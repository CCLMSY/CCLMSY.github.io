<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CCLMSY💫</title>
  
  
  <link href="https://www.cclmsy.cc/atom.xml" rel="self"/>
  
  <link href="https://www.cclmsy.cc/"/>
  <updated>2025-02-05T06:47:11.991Z</updated>
  <id>https://www.cclmsy.cc/</id>
  
  <author>
    <name>深翼💫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《计算机网络与通信 实验》课程笔记</title>
    <link href="https://www.cclmsy.cc/posts/Computer_Networks_and_Communications(Lab).html"/>
    <id>https://www.cclmsy.cc/posts/Computer_Networks_and_Communications(Lab).html</id>
    <published>2024-12-18T15:00:00.000Z</published>
    <updated>2025-02-05T06:47:11.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零-概述">零. 概述</h2><h3 id="0-1-网络分层OSI参考模型">0.1 网络分层OSI参考模型</h3><p>OSI参考模型是国际标准化组织(ISO)制定的一个用于计算机网络体系结构的标准框架。</p><p>OSI分为7层，自上而下分别是：</p><ul><li>7.应用层：应用软件</li><li>6.表示层：数据格式转换</li><li>5.会话层：决定采用哪种传输方式</li><li>4.传输层：提供端到端的通信，主机连接建立和断开，保证数据传输的可靠性</li><li>3.网络层：根据目标地址实现通信</li><li>2.数据链路层：根据物理地址实现数据的传输</li><li>1.物理层：传输介质</li></ul><h3 id="0-2-TCP-IP参考模型">0.2 TCP/IP参考模型</h3><p>TCP/IP参考模型是实际应用最广泛的网络协议体系结构，它只有4层，自上而下分别是：</p><ul><li>4.应用层(包含了OSI的应用层、表示层、会话层)<ul><li>数据</li><li>协议：HTTP、HTTPS、SSH、DNS、FTP、POP3、SMTP…</li></ul></li><li>3.传输层<ul><li>TCP首部+数据</li><li>TCP：面向连接的可靠传输协议，支持应用层所有协议</li><li>UDP：无连接的不可靠传输协议，支持DNS、DHCP、SMB等</li></ul></li><li>2.网络层<ul><li>IP首部+TCP首部+数据</li><li>IP：负责数据包的传输</li><li>ICMP：负责网络故障诊断</li><li>ARP：负责地址解析</li></ul></li><li>1.网络接口层(包含了OSI的数据链路层、物理层)<ul><li>数据链路层<ul><li>MAC首部+LLC首部+IP首部+TCP首部+数据+FCS(帧校验序列)</li><li>MAC子层协议：将数据包封装成帧，通过物理层传输</li></ul></li><li>物理层<ul><li>传输介质</li></ul></li></ul></li></ul><h3 id="0-3-网络层">0.3 网络层</h3><p>网络层关注的问题：如何找到合适的网络路径，将数据包从源主机传输到目的主机。</p><h4 id="0-3-1-数据包分组与封装">0.3.1 数据包分组与封装</h4><p>网络层主要协议：IP、ICMP、ARP</p><ul><li>分组交换：以分组为单位的<strong>存储转发</strong>的传输方式，将长的报文分割成若干短分组进行多次传输。</li><li>路由转发：源与目的主机之间可能存在多条相通的路径，网络层选择一条“最佳”路径完成数据转发。</li><li>拥塞控制：合理分配数据包的转发路径，提高转发效率。当产生网络拥塞时，及时更换传输路径。</li><li>异种网络的互连：当源主机和目标主机的网络不属于同一种网络类型时，为了解决不同网络在寻址、分组大小、协议等方面的差异，要求在不同种类网络交界处的路由器能够对分组进行处理，使得分组能够在不同网络上传输。不同的网络类型对分组大小要求不一样，需要重新分组。</li></ul><h4 id="0-3-2-网络层与数据链路层的关系">0.3.2 网络层与数据链路层的关系</h4><ul><li>通信双方：<ul><li>数据链路层实现在同一局域网内利用MAC地址进行通信</li><li>网络层实现在不同局域网内利用IP地址进行通信</li></ul></li><li>解决的问题：<ul><li>数据链路层实现的是保证两端链路的连通性，可以说数据链路层不能分辨异构的网络</li><li>网络层要解决异构网络互联的问题，按照不同网络协议的格式完成数据的重新封装</li></ul></li></ul><h4 id="0-3-3-IP地址、子网掩码（Subnet-Mask）、网关（Gateway）">0.3.3 IP地址、子网掩码（Subnet Mask）、网关（Gateway）</h4><p>IP地址：主机在Internet上的一个全世界范围内唯一32位标识符，用点分十进制表示，如192.168.0.1。</p><p>子网掩码：用来划分网络和主机的32位二进制数，用来指明一个IP地址的哪些位标识网络地址，哪些位标识主机地址。</p><p>表示方法：</p><ul><li>CIDR表示法：/子网掩码位数，如/24表示前24位是1，其余8位是0</li><li>点分十进制：<a href="http://xxx.xxx.xxx.xxx">xxx.xxx.xxx.xxx</a>，如255.255.255.0</li><li>转换例：255.255.254.0 -&gt; 11111111.11111111.11111110.00000000 -&gt; /23</li></ul><p>网关：一个网络的出口。当一个主机要将数据发送给其他网络的主机时，通常首先将数据发往网关。</p><h4 id="0-3-4-IP地址分类">0.3.4 IP地址分类</h4><p>IP地址分为A、B、C、D、E五类，每类地址的网络号和主机号的划分不同。</p><table><thead><tr><th>类别</th><th>前缀</th><th>网络号</th><th>主机号</th><th>第一字节范围</th><th>子网掩码</th><th>主机数</th><th>预留私有地址网段（RFC 1918）</th></tr></thead><tbody><tr><td>A类</td><td>0</td><td>7位</td><td>24位</td><td>0~127</td><td>/8</td><td>2^24-2=16777214</td><td>10.0.0.0~10.255.255.255</td></tr><tr><td>B类</td><td>10</td><td>14位</td><td>16位</td><td>128~191</td><td>/16</td><td>2^16-2=65534</td><td>172.16.0.0~172.31.255.255</td></tr><tr><td>C类</td><td>110</td><td>21位</td><td>8位</td><td>192~223</td><td>/24</td><td>2^8-2=254</td><td>192.168.0.0~192.168.255.255</td></tr><tr><td>D类</td><td>1110</td><td>多播地址28位</td><td>-</td><td>224~239</td><td>-</td><td>-</td><td>-</td></tr><tr><td>E类</td><td>1111</td><td>保留地址</td><td>-</td><td>240~255</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h4 id="0-3-5-子网划分">0.3.5 子网划分</h4><p>借位：从主机最高位开始借位变为新的子网位，剩余部分仍为主机位</p><p>例如192.168.1.0/24可划分为：</p><ul><li>2个子网：192.168.1.0/25、192.168.1.128/25</li><li>4个子网：192.168.1.0/26、192.168.1.64/26、192.168.1.128/26、192.168.1.192/26</li></ul><div STYLE="page-break-after: always;"></div><h2 id="一-传输介质">一. 传输介质</h2><h3 id="1-1-传输介质分类">1.1 传输介质分类</h3><h4 id="1-1-1-有线传输介质">1.1.1 有线传输介质</h4><p>有线传输介质是指在两个通信设备之间实现的物理连接部分，它能将信号从一方传输到另一方。</p><p>有线传输介质主要有<strong>双绞线</strong>、同轴电缆和光纤。双绞线和同轴电缆传输电信号，光纤传输光信号。</p><h4 id="1-1-2-无线传输介质">1.1.2 无线传输介质</h4><p>在自由空间传输的电磁波根据频谱可将其分为无线电波、微波、红外线、激光等，信息被加载在电磁波上进行传输。在局域网中，通常只使用无线电波和红外线作为传输介质。</p><h4 id="1-1-3-直连线和交叉线的区别">1.1.3 直连线和交叉线的区别</h4><p>直连线：两端的线序相同，用于连接不同设备。</p><ul><li>PC&lt;-&gt;Hub/Switch</li></ul><p>交叉线：两端的线序不同，用于连接相同设备。</p><h3 id="1-2-双绞线制作">1.2 双绞线制作</h3><h4 id="1-2-1-双绞线制作标准：EIA-TIA-568">1.2.1 双绞线制作标准：EIA/TIA 568</h4><ul><li>A：白绿/绿/白橙/蓝/白蓝/橙/白棕/棕</li><li>B：白橙/橙/白绿/蓝/白蓝/绿/白棕/棕</li></ul><h4 id="1-2-2-双绞线制作步骤">1.2.2 双绞线制作步骤</h4><ol><li>剥线：用压线钳将双绞线一端的外皮剥去3cm，露出8根线。</li><li>理线：将4对导线分别绕开，8根导线按EIA/TIA 568B标准顺序排列，将线芯撸直并拢。</li><li>剪线：将芯线放到压线钳切刀处，8根线芯要在同一平面上并拢，而且尽量直，留下一定的线芯长度约1.5CM处剪齐。</li><li>插线：将双绞线插入RJ45水晶头中，插入过程均衡力度直到插到尽头。检查8根线芯是否已经全部充分、整齐地排列在水晶头里面。</li><li>压线：用压线钳用力压紧水晶头，抽出即可。</li></ol><h4 id="1-2-3-双绞线测试">1.2.3 双绞线测试</h4><p>直连线(两端都是568B标准)：12345678</p><p>交叉线(一端是568A标准，一端是568B标准)：36145278</p><p>100Mbps以太网线实际使用的线：白绿/绿/白橙/橙</p><div STYLE="page-break-after: always;"></div><h2 id="二-DHCP">二. DHCP</h2><h3 id="2-1-DHCP工作原理">2.1 DHCP工作原理</h3><p>DHCP(Dynamic Host Configuration Protocol)是一种动态主机配置协议，它是一种自动分配IP地址的协议。</p><h4 id="DHCP工作原理">DHCP工作原理</h4><ol><li>DHCP Discover报文<ul><li>客户端启动时，客户主机-&gt;DHCP服务器：谁能给我一个IP地址？</li><li>源地址：0.0.0.0</li><li>源端口：UDP 68</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 67</li></ul></li><li>DHCP Offer报文<ul><li>服务器接收到广播数据包后，DHCP服务器-&gt;客户主机：我能给你分配IP地址192.168.1.2</li><li>源地址：服务器IP地址</li><li>源端口：UDP 67</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 68</li></ul></li><li>DHCP Request报文<ul><li>客户端接收到DHCP服务器分配的IP地址后，客户主机-&gt;DHCP服务器：好的，我接受你分配的IP地址192.168.1.2，请求确认</li><li>源地址：0.0.0.0</li><li>源端口：UDP 68</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 67</li></ul></li><li>DHCP ACK报文<ul><li>服务器接收到广播数据包后，DHCP服务器-&gt;客户主机：好的，我已经确认分配给你IP地址</li><li>源地址：服务器IP地址</li><li>源端口：UDP 67</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 68</li></ul></li></ol><p>DHCP端口号：UDP 67(服务器)和UDP 68(客户端)</p><h3 id="2-2-DHCP配置">2.2 DHCP配置</h3><ol><li>网络拓扑图<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/2_1.png" alt="网络拓扑图2"></li></ul></li><li>设置DHCP服务器和PC机的TCP/IP属性<ul><li>DHCP服务器：192.168.1.1/24</li><li>PC1/PC2：自动获取IP地址</li></ul></li><li>配置DHCP服务器<ul><li>设置IP池为192.168.1.10-20</li></ul></li></ol><h3 id="2-3-验证DHCP配置">2.3 验证DHCP配置</h3><ol><li>使用ipconfig /all命令查看各机器的TCP/IP配置<ul><li>PC1: 192.168.0.10</li><li>PC2: 192.168.0.11</li></ul></li><li>使用ping命令测试连通性<ul><li>PC1&lt;-&gt;PC2：连通</li></ul></li></ol><div STYLE="page-break-after: always;"></div><h2 id="三-DNS及Web服务">三. DNS及Web服务</h2><h3 id="3-1-DNS工作原理">3.1 DNS工作原理</h3><p>DNS(Domain Name System，域名系统)是一个分布式数据库，用于域名和IP地址之间的映射。</p><ul><li>IPv4：32位二进制数，可写作点分十进制</li><li>IPv6：128位二进制数，可写作冒号分隔的8组16进制数</li></ul><p>DNS工作流程：</p><ol><li>PC机-&gt;首选DNS服务器：<a href="http://xn--www-st5fu45oo2cory.baidu.com">我要访问www.baidu.com</a></li><li>首选DNS服务器-&gt;根域名’.'DNS服务器：www.baidu.com对应的IP地址是多少？</li><li>根域名’.'DNS服务器-&gt;首选DNS服务器：www.baidu.com归’com’DNS服务器管</li><li>首选DNS服务器-&gt;'com’DNS服务器：www.baidu.com对应的IP地址是多少？</li><li>'com’DNS服务器-&gt;首选DNS服务器：www.baidu.com归’<a href="http://baidu.com">baidu.com</a>’DNS服务器管</li><li>首选DNS服务器-&gt;'<a href="http://baidu.com">baidu.com</a>’DNS服务器：www.baidu.com对应的IP地址是多少？</li><li>'<a href="http://baidu.com">baidu.com</a>’DNS服务器-&gt;首选DNS服务器：<a href="http://www.baidu.xn--comIPXXX-xb7n6eu54cyshkv0aji6c.XXX.XXX.XXX">www.baidu.com对应的IP地址是XXX.XXX.XXX.XXX</a></li><li>首选DNS服务器-&gt;PC机：<a href="http://www.baidu.xn--comIPXXX-xb7n6eu54cyshkv0aji6c.XXX.XXX.XXX">www.baidu.com对应的IP地址是XXX.XXX.XXX.XXX</a></li><li>PC机-&gt;Web服务器：<a href="http://xn--XXX-st5fu45oo2cory.XXX.XXX.XXX">我要访问XXX.XXX.XXX.XXX</a></li><li>Web服务器-&gt;PC机：返回相关的数据</li></ol><ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/3_1.png" alt="DNS工作原理"></li></ul><p>递归查询：递归查询是一种DNS服务器的查询模式。在该模式下，DNS服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS服务器本地没有存储查询DNS信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p><p>迭代查询：DNS服务器会向客户机提供其他能够解析查询请求的DNS服务器地址。当客户机发送查询请求时，DNS服务器并不直接回复查询结果，而是告诉客户机另一台DNS服务器地址，客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。</p><p>DNS端口号：UDP 53</p><h3 id="3-2-HTTP工作原理">3.2 HTTP工作原理</h3><p>HTTP(HyperText Transfer Protocol，超文本传输协议)是一种用于传输超文本的协议。</p><p>HTTP工作流程：<br>1. 客户端浏览器解析URL<br>2. 客户端浏览器生产HTTP请求信息<br>3. 服务器发送响应HTTP页面<br>4. 客户端浏览器解析响应页面</p><h3 id="3-3-DNS配置">3.3 DNS配置</h3><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/3_2.png" alt="网络拓扑图3"></li></ul></li><li>配置DNS服务器<ul><li>jike.com配置Host IP：192.168.0.20(对应Web服务器)</li><li>ruanjian.com配置Host IP：192.168.0.70(没有对应的Web服务器)</li></ul></li></ol><h3 id="3-4-验证DNS配置">3.4 验证DNS配置</h3><ol><li>使用ipconfig /all命令查看各机器的TCP/IP配置</li><li>在客户端PC上使用ping命令测试连通性<ul><li><a href="http://jike.com">jike.com</a>：Reply from 192.168.0.20: bytes=32 time&lt;1ms TTL=128(来自192.168.0.20的回复：字节=32 时间&lt;1ms TTL=128)</li><li><a href="http://ruanjian.com">ruanjian.com</a>：Request timed out(来自192.168.0.10的回复：无法访问目标主机)</li><li><a href="http://anquan.com">anquan.com</a>：Unknown host &lt;<a href="http://www.anquan.com">www.anquan.com</a>(<a href="http://xn--Pinganquan-wj2piry83btt9cs3ox4ssg7j.com">Ping请求找不到主机anquan.com</a>。请检查该名称，然后重试)&gt;</li></ul></li></ol><h3 id="3-5-FTP服务配置">3.5 FTP服务配置</h3><ol><li>在控制面板中启用IIS(Internet Information Services，Internet信息服务)</li><li>打开IIS，网站名称改为jike，选择物理路径。在路径下新建index.html文件，用ANSI编码保存，并在默认文档中添加该文档。<a href="http://xn--jingke-2o2mv27a7m7e4jva.com/index.html%E5%BA%94%E8%AF%A5%E8%83%BD%E7%9C%8B%E5%88%B0index.html%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82">此时访问jingke.com/index.html应该能看到index.html的内容。</a></li><li>新建一个FTP站点，名称为jikeFTP，选择物理路径(在该位置新建几个文件夹测试)，绑定IP地址为192.168.0.20，选择无SSL，允许所有用户访问。此时使用FTP客户端连接，应该能看到FTP站点的内容。</li></ol><div STYLE="page-break-after: always;"></div><h2 id="四-交换机工作原理及基本配置">四. 交换机工作原理及基本配置</h2><h3 id="4-1-交换机">4.1 交换机</h3><p>交换机(Switch)是一种网络设备，用于在计算机网络中连接多个设备，实现设备之间的通信。</p><p>最常见的以太网交换机工作于OSI网络参考模型的第二层(即数据链路层)，是一种基于MAC地址识别、完成以太网数据帧转发的网络设备。</p><h4 id="4-1-1-MAC地址">4.1.1 MAC地址</h4><p>MAC地址(Media Access Control Address，介质访问控制地址)是一个用来识别网络设备的地址，又称物理地址。</p><p>由48位二进制数组成，通常以12位十六进制数表示，如00-0C-29-3D-2E-7C，也写作000C.293D.2E7C、00:0C:29:3D:2E:7C。</p><p>前24位是厂商识别码，后24位是设备识别码(供应商对网卡的唯一编号)。</p><ul><li>单播地址：MAC地址的第一个字节的最低位为0，可作为目的地址和源地址。</li><li>组播地址：MAC地址的第一个字节的最低位为1，仅能作为目的地址。</li><li>广播地址：MAC地址全为1，即FF-FF-FF-FF-FF-FF，用于向同一网络中的所有设备发送数据。</li></ul><h4 id="4-1-2-MAC地址表">4.1.2 MAC地址表</h4><p>交换机内部用于存放物理地址与交换机端口映射关系的数据库，交换机依靠MAC地址表实现数据帧的转发。<br>- Static MAC Address：静态MAC地址，由管理员手动配置。<br>- Dynamic MAC Address：动态MAC地址，由交换机自动学习。</p><p>动态MAC地址学习过程</p><ol><li>主机A-&gt;交换机：我要发送数据帧给主机B。 交换机：记录主机A的MAC地址和端口映射。</li><li>交换机-&gt;广播：主机A的数据帧发送给所有端口。</li><li>主机B-&gt;交换机：我收到数据帧了，回复。 交换机：记录主机B的MAC地址和端口映射。</li></ol><h4 id="4-1-3-数据帧">4.1.3 数据帧</h4><ul><li>数据帧(Data Frame)是数据链路层的协议数据单元，包括：帧头、数据、帧尾。</li><li>在以太网链路上的数据单元称为以太网帧，现在最常见的以太网帧是Ethernet II，包括：目的MAC地址(6B)、源MAC地址(6B)、类型/长度(2B)、数据(46-1500B)、FCS帧校验序列(4B)。</li></ul><p>帧转发/过滤：单播帧依靠MAC地址表进行转发/过滤，组播帧向指定端口转发，广播帧向所有端口转发</p><p>帧转发方式：</p><ul><li>直通转发：交换机收到帧头(通常只检查14个字节)后立刻察看目的MAC地址并进行转发。</li><li>存储转发：接收完整的帧，执行完校验后，转发正确的帧而丢弃错误的帧。</li><li>无碎片直通转发：交换机读取前64个字节后开始转发。</li></ul><h3 id="4-2-交换机本地配置-MAC地址绑定">4.2 交换机本地配置-MAC地址绑定</h3><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/4_1.png" alt="网络拓扑图4"></li></ul></li><li>计算机串口或USB口与交换机的Console端口连接；打开计算机Win系统的“超级终端”或其他串口通信客户端软件；Serial Port按交换机要求设置，一般默认<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/4_2.png" alt="终端配置"></li></ul></li><li>常用命令/模式切换命令<ul><li>Switch&gt;   //(初始)用户模式</li><li>Switch&gt;enable  //进入特权模式</li><li>Switch#configure terminal  //进入全局配置模式</li><li>Switch(config)#interface fa0/1  //进入接口fa0/1配置模式</li><li>Switch(config-if)#end //退出配置模式，返回特权模式</li><li>Switch#show clock  //查看交换机时间</li><li>Switch#show version  //查看交换机版本信息</li><li>修改交换机主机名<ul><li>Switch#configure terminal</li><li>Switch(config)#hostname jike</li><li>jike(config)#</li></ul></li></ul></li><li>MAC地址表管理命令<ul><li>Switch#show mac-address-table  //查看MAC地址表</li><li>Switch#show mac-address-table aging-time  //查看MAC地址表老化时间</li><li>交换机上添加MAC地址绑定<ul><li>Switch(config)#mac-address-table static aaaa.aaaa.aaaa vlan 1 interface fa0/1</li><li>Switch(config)#mac-address-table static aaaa.aaaa.aaab vlan 1 interface fa0/2</li><li>Switch(config)#mac-address-table static aaaa.aaaa.aaac vlan 1 interface fa0/3</li></ul></li><li>交换机上删除MAC地址绑定<ul><li>Switch(config)#no mac-address-table static aaaa.aaaa.aaac vlan 1 interface fa0/3</li></ul></li></ul></li></ol><h3 id="4-3-验证交换机配置">4.3 验证交换机配置</h3><p>以绑定了fa0/1、fa0/2的交换机为例，在以下端口连接情况下，使用ping命令测试连通性：</p><ol><li>PC1至1号端口，PC2至2号端口，PC3至3号端口<ul><li>PC1&lt;-&gt;PC2：连通</li><li>PC1&lt;-&gt;PC3：连通</li><li>PC2&lt;-&gt;PC3：连通</li><li>MAC地址表：fa0/1-PC1、fa0/2-PC2、fa0/3-PC3</li></ul></li><li>PC1至2号端口，PC2至1号端口，PC3至10号端口<ul><li>PC1&lt;-&gt;PC2：不连通</li><li>PC1&lt;-&gt;PC3：不连通</li><li>PC2&lt;-&gt;PC3：不连通</li><li>MAC地址表：fa0/1-PC2、fa0/2-PC1、fa0/10-PC3</li></ul></li><li>PC1至5号端口，PC2至2号端口，PC3至3号端口<ul><li>PC1&lt;-&gt;PC2：不连通</li><li>PC1&lt;-&gt;PC3：不连通</li><li>PC2&lt;-&gt;PC3：连通</li><li>MAC地址表：fa0/1-PC2、fa0/2-PC1、fa0/3-PC3</li></ul></li></ol><ul><li>总结：静态MAC地址绑定后，主机与端口连线必须一一对应才能传输数据；如果是动态MAC地址，主机连任意一个端口均可正常收发数据。</li></ul><div STYLE="page-break-after: always;"></div><h2 id="五-交换机VLAN">五. 交换机VLAN</h2><h3 id="5-1-VLAN">5.1 VLAN</h3><p>交换网络是平面网络结构，必须依赖广播，广播域过大会导致网络拥塞。</p><p>VLAN(Virtual Local Area Network，虚拟局域网)是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样。</p><p>VLAN的特点：</p><ul><li>基于逻辑的分组，不受物理位置限制。</li><li>在同一VLAN内和真实局域网相同。</li><li>不同VLAN内用户要通信需要借助三层设备。</li></ul><p>基于端口的VLAN：交换机端口可以划分到不同的VLAN中，不同VLAN之间的通信需要通过路由器。</p><h4 id="5-1-1-IEEE-802-1Q标准">5.1.1 IEEE 802.1Q标准</h4><p>定义了基于端口的VLAN模型，规定如何标识带有 VLAN 成员信息的以太帧，定义VLAN标签格式。</p><p>在以太网帧中增加了一个4字节的802.1Q帧头，用于标识VLAN信息：目的MAC地址(6B)、源MAC地址(6B)、802.1Q帧头(4B)、类型/长度(2B)、数据(46-1500B)、FCS帧校验序列(4B)。</p><p>802.1Q帧头格式：TPID(2B)+PCP(3b)+DEI(1b)+VID(12b)</p><ul><li>TPID：标识802.1Q帧头，取值0x8100</li><li>PCP：优先级，取值0-7，0最低，7最高</li><li>DEI：丢弃标志，用于QoS</li><li>VID：VLAN ID，取值1-4094</li></ul><h4 id="5-1-2-交换机端口类型">5.1.2 交换机端口类型</h4><table><thead><tr><th></th><th>Access端口</th><th>Trunk端口</th></tr></thead><tbody><tr><td>Tag</td><td>UnTagged端口（接入端口）</td><td>Tag Aware端口（干道端口）</td></tr><tr><td>VLAN</td><td>只能属于一个VLAN</td><td>可以允许多个VLAN通过</td></tr><tr><td>数据帧</td><td>发送的数据帧不带VLAN标签</td><td>发送的数据帧带有VLAN标签</td></tr><tr><td>用途</td><td>一般用于连接终端设备（PC机）</td><td>一般用于交换机之间的连接</td></tr><tr><td>默认</td><td>交换机上的默认端口</td><td>-</td></tr></tbody></table><h3 id="5-2-交换机VLAN配置">5.2 交换机VLAN配置</h3><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/5_1.png" alt="网络拓扑图5"></li></ul></li><li>创建VLAN<ul><li>Switch(config)#vlan 10</li><li>Switch(config-vlan)#exit</li><li>Switch(config)#vlan 20</li><li>Switch(config-vlan)#exit</li></ul></li><li>配置Access端口/划分VLAN<ul><li>Switch(config)#interface fa0/1-5</li><li>Switch(config-if-range)#switchport mode access</li><li>Switch(config-if-range)#switchport access vlan 10</li><li>Switch(config-if-range)#exit</li><li>Switch(config)#interface fa0/6-10</li><li>Switch(config-if-range)#switchport mode access</li><li>Switch(config-if-range)#switchport access vlan 20</li><li>Switch(config-if-range)#exit</li></ul></li><li>配置Trunk端口<ul><li>Switch(config)#interface fa0/24</li><li>Switch(config-if)#switchport mode trunk</li></ul></li></ol><h3 id="5-3-验证交换机VLAN配置">5.3 验证交换机VLAN配置</h3><ol><li>显示交换机VLAN配置<ul><li>Switch#show vlan brief</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/5_2.png" alt="交换机VLAN配置"></li></ul></li><li>连通性测试<ul><li>PC1&lt;-&gt;PC4：连通</li><li>PC2&lt;-&gt;PC3：连通</li><li>其余PC之间不连通</li></ul></li><li>总结：同一VLAN内可以直接相互通信，不同VLAN内不能直接相互通信。</li></ol><div STYLE="page-break-after: always;"></div><h2 id="六-VLAN间通信">六. VLAN间通信</h2><h3 id="6-1-路由">6.1 路由</h3><p>VLAN是广播域（二层概念），而两个广播域之间通常由路由器连接，广播域之间来往的数据包都是由路由（三层概念）转发的。路由的主要功能由路由器和三层交换机提供。</p><p>VLAN间通信一般有以下3种实施方案：</p><ol><li>路由器多端口方式</li><li>单臂路由方式</li><li>三层交换机方式</li></ol><h3 id="6-2-路由器多端口方式">6.2 路由器多端口方式</h3><p>与路由器连接不同子网通信的方法一样，为路由器端口设置一个IP地址作为对应VLAN的网关，有几个VLAN就需要在几个端口设置IP地址。</p><p>缺点：<br>一般中大型局域网，VLAN数量可以很多，而路由器端口数量较少，路由器会成为局域网性能瓶颈。<br>路由器采用软件对IP报文进行转发，占用CPU和内存资源，效率比较低，无法胜任通信数据量较大的局域网。</p><h4 id="6-2-1-配置">6.2.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_1_1.png" alt="网络拓扑图6_1"></li></ul></li><li>二层交换机配置<ul><li>创建VLAN10和VLAN20</li><li>配置Access端口/划分VLAN<ul><li>VLAN10: fa0/1,fa0/10</li><li>VLAN20: fa0/2,fa0/20</li></ul></li><li>查看VLAN配置: Switch#show vlan brief</li></ul></li><li>路由器配置<ul><li>Router(config)#interface fa0/0</li><li>Router(config-if)#no shutdown //激活接口</li><li>Router(config-if)#ip address 192.168.1.1 255.255.255.0 //设置接口IP地址</li><li>Router(config-if)#exit</li><li>Router(config)#interface fa0/1</li><li>Router(config-if)#no shutdown</li><li>Router(config-if)#ip address 192.168.2.1 255.255.255.0</li><li>Router(config-if)#exit</li></ul></li></ol><h4 id="6-2-2-验证路由器配置">6.2.2 验证路由器配置</h4><ol><li>显示路由表<ul><li>Router#show ip route</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_1_2.png" alt="路由表"></li></ul></li><li>显示IP接口信息<ul><li>Router#show ip interface brief</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_1_3.png" alt="IP接口"></li></ul></li><li>连通性测试<ul><li>PC1&lt;-&gt;PC2：连通</li></ul></li></ol><h3 id="6-3-单臂路由方式">6.3 单臂路由方式</h3><p>在路由器的一个物理接口上配置多个子接口，作为不同VLAN的默认网关，实现原来相互隔离的不同VLAN之间的通信。</p><p>缺点：<br>路由器转发速度有限，无法满足VLAN间通信数据量大的需求，并且容易造成单点故障。<br>数据在物理链路上往返传输，会有转发延迟，很可能成为局域网性能瓶颈。</p><h4 id="6-3-1-配置">6.3.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_2_1.png" alt="网络拓扑图6_2"></li></ul></li><li>二层交换机配置<ul><li>创建VLAN10和VLAN20</li><li>配置Access端口/划分VLAN<ul><li>VLAN10: fa0/1</li><li>VLAN20: fa0/2</li></ul></li><li>配置Trunk端口<ul><li>Switch(config)#interface fa0/24</li><li>Switch(config-if)#switchport mode trunk</li><li>Switch(config-if)#exit</li></ul></li><li>查看VLAN配置: Switch#show vlan brief</li></ul></li><li>路由器配置<ul><li>Router(config)#interface fa0/0</li><li>Router(config-if)#no shutdown //激活接口</li><li>Router(config-if)#exit</li><li>Router(config)#interface fa0/0.10 //创建虚拟子接口10</li><li>Router(config-subif)#encapsulation dot1Q 10 //封装VLAN协议（802.1Q）</li><li>Router(config-subif)#ip address 192.168.1.1 255.255.255.0 //设置子接口IP地址</li><li>Router(config-subif)#exit</li><li>Router(config)#interface fa0/0.20 //创建虚拟子接口20</li><li>Router(config-subif)#encapsulation dot1Q 20</li><li>Router(config-subif)#ip address 192.168.2.1 255.255.255.0</li><li>Router(config-subif)#exit</li></ul></li></ol><h4 id="6-3-2-验证路由器配置">6.3.2 验证路由器配置</h4><ol><li>显示路由表<ul><li>Router#show ip route</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_2_2.png" alt="路由表"></li></ul></li><li>显示IP接口信息<ul><li>Router#show ip interface brief</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_2_3.png" alt="IP接口"></li></ul></li><li>显示Trunk端口<ul><li>Switch#show interfaces trunk</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_2_4.png" alt="Trunk端口"></li></ul></li><li>连通性测试<ul><li>PC1&lt;-&gt;PC2：连通</li></ul></li></ol><h3 id="6-4-三层交换机虚拟接口SVI">6.4 三层交换机虚拟接口SVI</h3><p>三层交换机实现VLAN间通信的方法是在已有的VLAN上创建虚接口，它同样可以配置IP地址，借助虚接口三层交换机能够实现路由转发功能。</p><p>优点：<br>VLAN间流量不必经过路由器，网络延时和抖动都很小，同时也极大程度的减轻上层接入路由器的负载。<br>三层交换机的VLAN间路由由交换机的三层转发引擎完成，其性能取决于交换机的背板转发速率，可以在多个端口上轻松实现线速转发，可以获得很好的性能。</p><h4 id="6-4-1-配置">6.4.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_3_1.png" alt="网络拓扑图6_3"></li></ul></li><li>二层交换机配置<ul><li>创建VLAN10和VLAN20</li><li>配置Access端口/划分VLAN<ul><li>VLAN10: fa0/1</li><li>VLAN20: fa0/2</li></ul></li><li>配置Trunk端口：fa0/24</li><li>查看VLAN配置: Switch#show vlan brief</li><li>查看Trunk端口: Switch#show interfaces trunk</li></ul></li><li>三层交换机配置<ul><li>创建VLAN10和VLAN20</li><li>配置SVI的ip地址<ul><li>Switch(config)#interface vlan 10</li><li>Switch(config-if)#ip address 192.168.1.1 255.255.255.0</li><li>Switch(config-if)#exit</li><li>Switch(config)#interface vlan 20</li><li>Switch(config-if)#ip address 192.168.2.1 255.255.255.0</li><li>Switch(config-if)#exit</li></ul></li><li>开启路由功能<ul><li>Switch(config)#ip routing</li></ul></li></ul></li></ol><h4 id="6-4-2-验证三层交换机配置">6.4.2 验证三层交换机配置</h4><ol><li>显示路由表<ul><li>Switch#show ip route</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/6_3_2.png" alt="路由表"></li></ul></li><li>连通性测试：4台主机之间均可相互通信</li></ol><div STYLE="page-break-after: always;"></div><h2 id="七-静态路由">七. 静态路由</h2><h3 id="7-1-路由器">7.1 路由器</h3><p>路由器（Router）：连接两个或多个网络的硬件设备，在网络间起网关的作用，是读取每一个IP数据包中的地址然后决定如何传送的专用智能性的网络设备。</p><ul><li>直连网络（邻村）：直接连接在某个路由器上的网络，称为该路由器的直连网络。每个路由器接口的IP作为所连直连网络的网关（村口）。</li><li>非直连网络：不直接连接在某个路由器上的网络（通常间隔多个路由器）。</li></ul><h4 id="7-1-1-路由表">7.1.1 路由表</h4><p>路由器依靠路由表来选择转发路径。<br>路由表中包含有该路由器掌握的所有目的网络地址，以及通过此路由器到达这些网络中最佳路径，这个最佳路径指的是路由器的某个接口或下一条路由器的地址。</p><h4 id="7-1-2-静态路由">7.1.2 静态路由</h4><p>静态路由：由系统管理员事先设置好固定的路由信息。</p><ul><li>优点：简单、高效、可靠。优先级最高。</li><li>缺点：不能动态地适用网络状况的变化。</li></ul><h3 id="7-2-静态路由配置">7.2 静态路由配置</h3><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/7_1.png" alt="网络拓扑图7_1"></li></ul></li><li>路由器配置（Router1为例）<ul><li>Router1(config)#interface fa0/0</li><li>Router1(config-if)#no shutdown  //激活接口</li><li>Router1(config-if)#ip address 192.168.1.1 255.255.255.0 //设置接口IP地址为所在网络的网关</li><li>Router1(config-if)#exit</li><li>Router1(config)#interface fa0/1</li><li>Router1(config-if)#no shutdown</li><li>Router1(config-if)#ip address 192.168.2.1 255.255.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#ip route 192.168.3.0 255.255.255.0 192.168.2.2 //设置静态路由：ip route &lt;目的网络&gt; &lt;子网掩码&gt; &lt;下一跳地址&gt;</li></ul></li></ol><h3 id="7-3-验证静态路由配置">7.3 验证静态路由配置</h3><ol><li>显示路由表<ul><li>Router1#show ip route</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/7_2.png" alt="路由表"></li></ul></li><li>连通性测试：3台主机之间均可相互通信</li></ol><h3 id="7-4-静态路由配置补充">7.4 静态路由配置补充</h3><ul><li>通过192.168.0.1的端口，访问所有24位子网掩码的目的网络<ul><li>Router1(config)#ip route 0.0.0.0 255.255.255.0 192.168.0.1</li></ul></li><li>通过192.168.0.1的端口，访问所有网络<ul><li>Router1(config)#ip route 0.0.0.0 0.0.0.0 192.168.0.1</li></ul></li></ul><div STYLE="page-break-after: always;"></div><h2 id="八-动态路由RIP">八. 动态路由RIP</h2><h3 id="8-1-动态路由">8.1 动态路由</h3><p>动态路由：路由器根据网络系统的运行情况而自动调整的路由信息。路由器根据路由选择协议（Routing Protocol）提供的功能，自动学习和记忆网络运行情况，在需要时自动计算数据传输的最佳路径。</p><ul><li>优点：动态路由可以自动学习网络的拓朴结构，并更新路由表。</li><li>缺点：路由广播更新信息将占据大量的网络带宽。</li></ul><h4 id="8-1-1-动态路由分类">8.1.1 动态路由分类</h4><ul><li>按照使用的区域不同<ul><li>内部网关协议IGP（Interior Gateway Protocol）域内协议。如RIP、EIGRP、OSPF、ISIS</li><li>外部网关协议EGP（Exterior Gateway Protocol）域间协议。如BGP</li></ul></li><li>按照算法不同<ul><li>距离矢量协议（Distance Vector）。如RIPV1、RIPV2、BGP</li><li>链路状态路由协议（Link State）。如OSPF、ISIS</li></ul></li><li>按是否携带子网掩码<ul><li>有类路由协议。如RIPV1</li><li>无类路由协议。如RIPV2、OSPF、ISIS、BGP</li></ul></li></ul><h4 id="8-1-2-RIP协议">8.1.2 RIP协议</h4><p>RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。</p><p>在RIP网络中，缺省情况下，设备到与它直接相连网络的跳数为0，通过一个设备可达的网络的跳数为1，其余依此类推。也就是说，度量值等于从本网络到达目的网络间的设备数量。</p><p>为限制收敛时间，RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得RIP不可能在大型网络中得到应用。</p><p>RIP路由器工作流程：</p><ul><li>RIP路由器A,B初始的路由表中只有自己的直连路由。</li><li>每30秒，向相邻路由器发送自己的路由表。</li><li>收到相邻路由器的路由表后，更新自己的路由表：<ul><li>新增：如果收到的路由表中有自己没有的路由，则添加到自己的路由表中。</li><li>更新：如果收到的路由表中有自己已有的路由，且新的跳数更小，则更新自己的路由表的跳数。</li></ul></li><li>RIP计时器：<ul><li>更新计时器：每30秒左右发送一次路由表。</li><li>失效计时器：180秒（6倍更新时间）未更新，标记为不可达。</li><li>刷新计时器：无效路由240秒未更新，从路由表中删除。</li></ul></li></ul><p>路由毒化：当一个路由器发现一个网络不可达时，会向其他路由器发送一个度量值为16的路由，以传播路由失效的消息，这个过程称为路由毒化。</p><h4 id="8-1-3-RIP协议版本">8.1.3 RIP协议版本</h4><p>RIPv1</p><ul><li>使用广播的方式发送路由更新</li><li>路由更新信息中不携带子网掩码，为有类路由协议，不支持 VLSM 和 CIDR</li><li>不支持认证</li></ul><p>RIPv2</p><ul><li>发送更新报文的方式为组播，组播地址为224.0.0.9</li><li>路由信息中加入了子网掩码，为无类路由协议，支持 VLSM，支持路由聚合与 CIDR</li><li>支持明文认证和 MD5 密文认证</li></ul><p>VLSM：可变长子网掩码Variable Length Subnet Mask</p><p>CIDR：无类域间路由聚合Classless Inter-Domain Routing</p><h3 id="8-2-RIPV1">8.2 RIPV1</h3><h4 id="8-2-1-配置">8.2.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/8_1_1.png" alt="网络拓扑图8_1"></li></ul></li><li>路由器配置（以Router1为例）<ul><li>Router1(config)#interface lo0  //创建Loopback接口，用于模拟网络</li><li>Router1(config-if)#ip address 1.1.1.1 255.255.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#interface fa0/0</li><li>Router1(config-if)#no shutdown  //激活接口</li><li>Router1(config-if)#ip address 12.1.1.1 255.55.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#router rip  //进入RIP协议配置模式</li><li>Router1(config-router)#version 1  //设置RIP版本为1</li><li>Router1(config-router)#network 1.1.1.0 //设置RIP协议的网络地址</li><li>Router1(config-router)#network 12.1.1.0</li></ul></li></ol><h4 id="8-2-2-验证RIPV1配置">8.2.2 验证RIPV1配置</h4><ol><li>显示路由表<ul><li>Router1#show ip route</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/8_1_2.png" alt="路由表"></li></ul></li><li>连通性测试：Router1和Router3的lo0接口之间可以相互通信</li></ol><h3 id="8-3-RIPV2">8.3 RIPV2</h3><h4 id="8-3-1-配置">8.3.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/8_2_1.png" alt="网络拓扑图8_2"></li></ul></li><li>路由器配置（以Router1为例）<ul><li>Router1(config)#interface lo0</li><li>Router1(config-if)#ip address 10.1.1.1 255.255.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#interface fa0/0</li><li>Router1(config-if)#no shutdown</li><li>Router1(config-if)#ip address 12.1.1.1 255.255.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#router rip</li><li>Router1(config-router)#version 2 //设置RIP版本为2</li><li>Router1(config-router)#network 10.1.1.0</li><li>Router1(config-router)#network 12.1.1.0</li><li>Router1(config-router)#no auto-summary //关闭自动汇总</li></ul></li></ol><h4 id="8-3-2-验证RIPV2配置">8.3.2 验证RIPV2配置</h4><ol><li>显示路由表<ul><li>Router1#show ip route</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/8_2_2.png" alt="路由表"></li></ul></li><li>连通性测试：Router1和Router3的lo0接口之间可以相互通信</li></ol><div STYLE="page-break-after: always;"></div><h2 id="九-NAT">九. NAT</h2><h3 id="9-1-NAT">9.1 NAT</h3><p>NAT(Network Address Translation，网络地址转换)是一种将私有地址（RFC 1918）转换为公有地址的技术，用于解决IP地址不足的问题。</p><h4 id="9-1-1-NAT术语">9.1.1 NAT术语</h4><ul><li>内部本地IP地址：分配给内部网络中的主机的IP地址，通常这种地址来自RFC1918指定的私有地址空间。</li><li>内部全局IP地址：内部全局IP地址，对外代表一个或多个内部本地IP地址，通常这种地址来自全局惟一的地址空间，通常由ISP提供。</li><li>外部本地IP地址：在内部网络中看到的外部主机的IP地址，通常来自RFC 1918定义的私有地址空间。</li><li>外部全局IP地址：外部网络中的主机的IP地址，通常来自全局可路由的地址空间。</li></ul><h4 id="9-1-2-NAT分类">9.1.2 NAT分类</h4><ul><li>静态NAT：一对一映射，将一个内部IP地址映射到一个外部IP地址。</li><li>动态NAT：将内部IP地址动态转换为一组外部IP地址（IP地址池）中的一个。<ul><li>超载NAT：动态NAT的一种实现形式，利用不同端口号将多个内部IP地址转换为一个外部IP地址，也称为PAT、NAPT或端口复用NAT。</li></ul></li></ul><h3 id="9-2-NAT配置">9.2 NAT配置</h3><h4 id="9-2-1-网路拓扑图">9.2.1 网路拓扑图</h4><p><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/9_0.png" alt="网络拓扑图"></p><p>完成PC机和服务器的TCP/IP配置</p><h4 id="9-2-2-路由器基础配置">9.2.2 路由器基础配置</h4><ol><li>Router1配置<ul><li>Router1(config)#interface fa0/0</li><li>Router1(config-if)#no shutdown</li><li>Router1(config-if)#ip address 10.1.1.1 255.255.255.0</li><li>Router1(config-if)#ip nat inside //内网接口</li><li>Router1(config-if)#exit</li><li>Router1(config)#interface fa0/1</li><li>Router1(config-if)#no shutdown</li><li>Router1(config-if)#ip address 2.2.2.1 255.255.255.0</li><li>Router1(config-if)#ip nat outside //外网接口</li><li>Router1(config-if)#exit</li><li>Router1(config)#ip route 0.0.0.0 0.0.0.0 2.2.2.2 //设置静态路由：内网主机可以通过Router1访问外网</li></ul></li><li>Router2配置<ul><li>fa0/0: 2.2.2.2/24</li><li>fa0/1: 1.1.1.1/24</li><li>外网不允许访问内网，无需配置静态路由</li></ul></li></ol><h4 id="9-2-3-静态NAT">9.2.3 静态NAT</h4><p>在Router1上设置静态NAT，使外网PC可以使用外网地址2.2.2.10访问内部服务器Server0的Web服务（仅80端口）</p><h5 id="配置静态NAT">配置静态NAT</h5><ul><li>Router1(config)#ip nat inside source static tcp 10.1.1.20 80 2.2.2.10 80 //设置静态NAT：内网服务器的80端口映射到外网地址的80端口</li></ul><h5 id="验证静态NAT">验证静态NAT</h5><ol><li>外网PC使用外网地址2.2.2.10访问内部服务器Server0的Web服务<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/9_1_2.png" alt="访问Web服务"></li></ul></li><li>显示NAT转换表<ul><li>Router1#show ip nat translations</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/9_1_1.png" alt="NAT转换表"></li></ul></li></ol><h4 id="9-2-4-动态NAT">9.2.4 动态NAT</h4><p>在Router1上设置动态NAT，使内网PC可以通过外网地址2.2.2.11-2.2.2.12访问外网服务器Server1的Web服务（仅80端口）</p><h5 id="配置动态NAT">配置动态NAT</h5><ul><li>Router1(config)#access-list 1 permit any //创建访问控制列表 1</li><li>Router1(config)#ip nat pool pool1 2.2.2.11 2.2.2.12 netmask 255.255.255.0 //创建IP地址池：ip nat pool &lt;名称&gt; &lt;起始地址&gt; &lt;结束地址&gt; netmask &lt;子网掩码&gt;</li><li>Router1(config)#ip nat inside source list 1 pool pool1 //设置动态NAT：ip nat inside source list &lt;访问控制列表&gt; pool &lt;IP地址池&gt;</li></ul><h5 id="验证动态NAT">验证动态NAT</h5><ol><li>内网PC使用外网地址1.1.1.10访问外网服务器Server1的Web服务<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/9_2_1.png" alt="访问Web服务"></li><li>由于IP地址池中只有2个地址，第3个内网主机无法访问外网</li></ul></li><li>显示NAT转换表<ul><li>Router1#show ip nat translations</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/9_2_2.png" alt="NAT转换表"></li></ul></li></ol><h3 id="9-3-NAPT">9.3 NAPT</h3><p>在Router1上设置动态NAPT。使内网PC可以通过外网地址2.2.2.15访问外网服务器</p><h4 id="配置NAPT">配置NAPT</h4><ul><li>Router1(config)#ip nat pool pool2 2.2.2.15 2.2.2.15 netmask 255.255.255.0</li><li>Router1(config)#ip nat inside source list 1 pool pool2 overload //overload: 超载，即NAPT</li></ul><h4 id="验证NAPT">验证NAPT</h4><ol><li>内网PC使用外网地址1.1.1.10访问外网服务器Server1的Web服务<ul><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/9_3_1.png" alt="访问Web服务"></li></ul></li><li>显示NAT转换表<ul><li>Router1#show ip nat translations</li><li><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/9_3_2.png" alt="NAT转换表"></li></ul></li></ol><div STYLE="page-break-after: always;"></div><h2 id="十-ARP协议分析">十. ARP协议分析</h2><h3 id="10-1-ARP协议">10.1 ARP协议</h3><p>ARP（Address Resolution Protocol，地址解析协议）主要用于根据 IP 地址求出主机所对应的物理地址（MAC 地址）。</p><p>在网络通信中，主机和主机之间的通信需要根据 OSI 模型进行数据包的封装和解封装，这里面不仅需要封装源目的 IP 地址，也需要源目的 MAC 地址。</p><p>一般情况下，上层应用只知道 IP 地址，而并不关心 MAC 地址，所以就需要通过一个协议来获知目的 MAC 地址，完成数据的封装，这个协议就是 ARP 协议。</p><h4 id="ARP协议工作原理">ARP协议工作原理</h4><p>主机A已知目标主机B的IP地址，向主机B发送数据包时，需要知道目标主机B的MAC地址。</p><p>ARP协议工作原理如下：</p><ol><li>主机A在自己的ARP缓存表中查找目标主机B的MAC地址，如果找到则直接发送数据包。</li><li>如果ARP缓存表中没有目标主机B的MAC地址，则主机A向本地网络广播ARP请求报文，请求目标主机B的MAC地址。</li><li>目标主机B收到ARP请求报文后，向主机A发送ARP响应报文，包含自己的MAC地址。</li><li>主机A收到ARP响应报文后，将目标主机B的MAC地址存入ARP缓存表，并发送数据包。</li></ol><h3 id="10-2-ARP协议分析">10.2 ARP协议分析</h3><p>以管理员身份启动cmd：</p><ul><li>查看ARP缓存表：arp -a</li><li>清空ARP缓存表：arp -d</li><li>删除指定ARP缓存：arp -d &lt;IP地址&gt;</li></ul><ol><li>打开Wireshark，在捕获选项中设置过滤器为“arp”。</li><li>开始抓取数据。</li><li>以管理员身份启动cmd，清空ARP缓存表并等待一段时间。</li><li>结束抓取数据。</li><li>选择一对ARP请求和响应报文，进行分析。</li></ol><p>以ARP请求报文为例，具体数据包如下图：</p><p><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/10_1.png" alt="ARP请求报文"></p><p>数据链路层数据帧：</p><table><thead><tr><th>字段</th><th>长度(bit)</th><th>说明</th><th>ARP Request</th><th>ARP Reply</th></tr></thead><tbody><tr><td>Destination</td><td>48</td><td>目的MAC地址</td><td>ff:ff:ff:ff:ff:ff(广播地址)</td><td>08:xx:xx:xx:xx:ae(发送方MAC地址)</td></tr><tr><td>Source</td><td>48</td><td>源MAC地址</td><td>08:xx:xx:xx:xx:ae(发送方MAC地址)</td><td>d8:xx:xx:xx:xx:d5(目标MAC地址)</td></tr><tr><td>Type</td><td>16</td><td>类型</td><td>0x0806(ARP)</td><td>0x0806(ARP)</td></tr></tbody></table><p>ARP数据帧：</p><table><thead><tr><th>字段</th><th>长度(bit)</th><th>说明</th><th>ARP Request</th><th>ARP Reply</th></tr></thead><tbody><tr><td>Hardware Type</td><td>16</td><td>硬件类型，标识链路层协议</td><td>0x0001(以太网)</td><td>0x0001(以太网)</td></tr><tr><td>Protocol Type</td><td>16</td><td>协议类型，标识网络层协议</td><td>0x0800(IPv4)</td><td>0x0800(IPv4)</td></tr><tr><td>Hardware Size</td><td>8</td><td>硬件地址大小，标识MAC地址长度</td><td>0x06(6B=48bit)</td><td>0x06(6B=48bit)</td></tr><tr><td>Protocol Size</td><td>8</td><td>协议地址大小，标识IP地址长度</td><td>0x04(4B=32bit)</td><td>0x04(4B=32bit)</td></tr><tr><td>Opcode</td><td>16</td><td>操作码，标识ARP请求或响应</td><td>0x0001(ARP Request)</td><td>0x0002(ARP Reply)</td></tr><tr><td>Sender MAC Address</td><td>48</td><td>发送方MAC地址</td><td>08:xx:xx:xx:xx:ae</td><td>d8:xx:xx:xx:xx:d5(目标MAC地址)</td></tr><tr><td>Sender IP Address</td><td>32</td><td>发送方IP地址</td><td>10.234.172.214</td><td>10.234.0.1</td></tr><tr><td>Target MAC Address</td><td>48</td><td>目标MAC地址</td><td>00:00:00:00:00:00(待填充)</td><td>08:xx:xx:xx:xx:ae(发送方MAC地址)</td></tr><tr><td>Target IP Address</td><td>32</td><td>目标IP地址</td><td>10.234.0.1</td><td>10.234.172.214</td></tr></tbody></table><div STYLE="page-break-after: always;"></div><h2 id="十一-TCP协议分析">十一. TCP协议分析</h2><h3 id="11-1-TCP协议">11.1 TCP协议</h3><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>UDP（User Datagram Protocol，用户数据报协议）是一种无连接的、不可靠的、基于数据报的传输层通信协议。</p><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠传输，使用流量控制和拥塞控制</td><td>不可靠传输，不使用拥塞控制</td></tr><tr><td>连接对象个数</td><td>一对一</td><td>一对一、一对多、多对多</td></tr><tr><td>传输方式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>首部开销</td><td>20字节~60字节</td><td>8字节</td></tr><tr><td>适用场景</td><td>需要可靠传输的场景，例如文件传输</td><td>传输速度、实时性要求高的场景</td></tr></tbody></table><p>TCP协议工作流程：</p><ol><li>建立连接：三次握手<ol><li>发起方向接收方发送SYN报文，请求建立连接</li><li>接收方收到SYN报文后，回复SYN+ACK报文，表示同意建立连接</li><li>发起方收到SYN+ACK报文后，回复ACK报文，表示连接建立成功</li><li>三次握手完成，连接建立成功</li></ol></li><li>数据传输：数据传输阶段</li><li>断开连接：四次挥手<ol><li>发起方向接收方发送FIN报文，请求断开连接</li><li>接收方收到FIN报文后，回复ACK报文，表示收到断开请求</li><li>接收方向发起方发送FIN报文，请求断开连接</li><li>发起方收到FIN报文后，回复ACK报文，表示收到断开请求</li><li>四次挥手完成，连接断开成功</li></ol></li></ol><ul><li>谁想建立或断开连接，谁就是发起方。发起方可以是客户端，也可以是服务器端，</li></ul><h3 id="11-2-TCP协议分析">11.2 TCP协议分析</h3><p>以访问10.21.11.21为例，分析TCP协议的工作流程。</p><ol><li>打开Wireshark，在捕获选项中设置过滤器为“http and ip.addr==10.21.11.21”。</li><li>开始抓取数据。</li><li>打开浏览器，在地址栏中输入“10.21.11.21”，回车访问，等待加载完成后关闭浏览器。</li><li>结束抓取数据。</li><li>选中一条访问10.21.11.21的HTTP记录，右键，追踪TPC流。</li><li>观察TPC流是否包含完整的TPC访问过程（三次握手，四次挥手）。</li></ol><p>TCP数据包示例如下：</p><p><img src="https://source.cclmsy.cc/Images/Posts/Computer_Networks_and_Communications(Lab)/11_1.png" alt="TCP数据包"></p><h4 id="TCP报文格式">TCP报文格式</h4><table><thead><tr><th>字段</th><th>长度(bit)</th><th>说明</th></tr></thead><tbody><tr><td>Source Port</td><td>16</td><td>源端口号</td></tr><tr><td>Destination Port</td><td>16</td><td>目的端口号</td></tr><tr><td>Sequence Number</td><td>32</td><td>本报文段发送的数据组的第一个字节的序号</td></tr><tr><td>ACK Number</td><td>32</td><td>确认号，期望收到对方下一个报文段的第一个字节的序号，表明该序号之前的所有数据已经正确无误的收到</td></tr><tr><td>Header Length</td><td>4</td><td>报文头长度，指示TCP头部的长度，即数据区在报文段中的起始偏移值（字节）。偏移值=4*Header Length</td></tr><tr><td>Reserved</td><td>6</td><td>保留字段，未使用</td></tr><tr><td>Flags</td><td>6</td><td>标志位，按顺序为：URG、ACK、PSH、RST、SYN、FIN</td></tr><tr><td>Window Size</td><td>16</td><td>窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制</td></tr><tr><td>TCP Checksum</td><td>16</td><td>校验和，用于检验TCP头部和数据的完整性</td></tr><tr><td>Urgent Pointer</td><td>16</td><td>紧急指针，TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</td></tr><tr><td>Options</td><td>0-320</td><td>可选字段，用于扩展TCP头部。最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size）（在第一个TCP报文）。选项长度不一定是32位的整数倍，所以要加填充位</td></tr></tbody></table><h4 id="TCP三次握手">TCP三次握手</h4><table><thead><tr><th>字段</th><th>第一次握手[SYN]</th><th>第二次握手[SYN, ACK]</th><th>第三次握手[ACK]</th></tr></thead><tbody><tr><td>Source Port</td><td>0xcf75(53109)</td><td>0x0050(80)</td><td>0xcf75(53109)</td></tr><tr><td>Destination Port</td><td>0x0050(80)</td><td>0xcf75(53109)</td><td>0x0050(80)</td></tr><tr><td>Sequence Number</td><td>0xc01d24d3(0)</td><td>0xabbe9051(0)</td><td>0xc01d24d4(1)</td></tr><tr><td>ACK Number</td><td>0x00000000(0)</td><td>0xc01d24d4(1)</td><td>0xabbe9052(1)</td></tr><tr><td>Header Length</td><td>0x8(32)</td><td>0x8(32)</td><td>0x5(20)</td></tr><tr><td>Reserved</td><td>0x00</td><td>0x00</td><td>0x00</td></tr><tr><td>Flags</td><td>0x002(SYN)</td><td>0x012(SYN, ACK)</td><td>0x010(ACK)</td></tr><tr><td>Window Size</td><td>0xfaf0(64240)</td><td>0x4000(16384)</td><td>0x0201(513)</td></tr></tbody></table><h4 id="TCP四次挥手">TCP四次挥手</h4><table><thead><tr><th>字段</th><th>第一次挥手[FIN, ACK]</th><th>第二次挥手[ACK]</th><th>第三次挥手[FIN, ACK]</th><th>第四次挥手[ACK]</th></tr></thead><tbody><tr><td>Source Port</td><td>0x0050(80)</td><td>0xcf75(53109)</td><td>0x0050(80)</td><td>0xcf75(53109)</td></tr><tr><td>Destination Port</td><td>0xcf75(53109)</td><td>0x0050(80)</td><td>0xcf75(53109)</td><td>0x0050(80)</td></tr><tr><td>Sequence Number</td><td>0xabbe9194(323)</td><td>0xc01d26e6(531)</td><td>0xc01d26e6(531)</td><td>0xabbe9195(324)</td></tr><tr><td>ACK Number</td><td>0xc01d26e6(531)</td><td>0xabbe9195(324)</td><td>0xabbe9195(324)</td><td>0xc01d26e7(532)</td></tr><tr><td>Header Length</td><td>0x5(20)</td><td>0x5(20)</td><td>0x5(20)</td><td>0x5(20)</td></tr><tr><td>Reserved</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td></tr><tr><td>Flags</td><td>0x011(FIN, ACK)</td><td>0x010(ACK)</td><td>0x011(FIN, ACK)</td><td>0x010(ACK)</td></tr><tr><td>Window Size</td><td>0xfeed(65005)</td><td>0x0200(513)</td><td>0x0200(513)</td><td>0xfeed(65005)</td></tr></tbody></table><div STYLE="page-break-after: always;"></div><h2 id="附录-实验涉及命令行汇总">附录. 实验涉及命令行汇总</h2><h3 id="1-PC机-终端">1. PC机 终端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all # 查看IP配置</span><br><span class="line">ping &lt;IP地址&gt; # 测试连通性</span><br></pre></td></tr></table></figure><h3 id="2-交换机Switch-命令行">2. 交换机Switch 命令行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Switch&gt;enable # 进入特权模式</span><br><span class="line">Switch#configure terminal # 进入全局配置模式</span><br><span class="line">Switch(config)#hostname Switch # 设置交换机主机名</span><br><span class="line">Switch(config)#exit # 退回上一级模式</span><br><span class="line">Switch(config)#end # 退回特权模式</span><br><span class="line"></span><br><span class="line"># 显示</span><br><span class="line">Switch#show vlan brief # 显示VLAN信息</span><br><span class="line">Switch#show interfaces # 显示接口信息</span><br><span class="line">Switch#show interfaces trunk # 显示trunk接口信息</span><br><span class="line"></span><br><span class="line"># VLAN</span><br><span class="line">Switch(config)#vlan &lt;VLAN号&gt; # 创建VLAN并进入VLAN配置模式</span><br><span class="line">Switch(config)#interface vlan &lt;VLAN号&gt; # 进入VLAN配置模式</span><br><span class="line"></span><br><span class="line"># 接口</span><br><span class="line">Switch(config)#interface &lt;接口号&gt; # 进入接口配置模式</span><br><span class="line">Switch(config)#interface &lt;接口号&gt;-&lt;接口号&gt; # 进入接口范围配置模式</span><br><span class="line">Switch(config-if)#switchport mode access # 设置接口为access</span><br><span class="line">Switch(config-if)#switchport access vlan &lt;VLAN号&gt; # 设置access接口所属VLAN</span><br><span class="line">Switch(config-if)#switchport mode trunk # 设置接口为trunk</span><br><span class="line"></span><br><span class="line"># MAC地址绑定</span><br><span class="line">Switch#show mac-address-table # 查看MAC地址表</span><br><span class="line">Switch#show mac-address-table aging-time # 查看MAC地址表老化时间</span><br><span class="line">Switch(config-if)#mac-address-table static &lt;MAC地址&gt; vlan &lt;VLAN号&gt; interface &lt;接口号&gt; # 设置静态MAC地址绑定</span><br><span class="line">Switch(config-if)#no mac-address-table static &lt;MAC地址&gt; vlan &lt;VLAN号&gt; interface &lt;接口号&gt; # 删除静态MAC地址绑定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-路由器Router-命令行">3. 路由器Router 命令行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;enable # 进入特权模式</span><br><span class="line">Router#configure terminal # 进入全局配置模式</span><br><span class="line">Router(config)#hostname Router # 设置路由器主机名</span><br><span class="line">Router(config)#exit # 退回上一级模式</span><br><span class="line">Router(config)#end # 退回特权模式</span><br><span class="line"></span><br><span class="line"># 显示</span><br><span class="line">Router#show ip route # 显示路由表</span><br><span class="line">Router#show ip interface brief # 显示接口IP信息</span><br><span class="line">Router#show ip interface &lt;接口号&gt; # 显示指定接口信息</span><br><span class="line">Router#show ip nat translations # 显示NAT转换表</span><br><span class="line"></span><br><span class="line"># 接口</span><br><span class="line">Router(config)#interface &lt;接口号&gt; # 进入接口配置模式</span><br><span class="line">Router(config-if)#no shutdown # 激活接口</span><br><span class="line">Router(config-if)#ip address &lt;IP地址&gt; &lt;子网掩码&gt; # 设置接口IP地址</span><br><span class="line"></span><br><span class="line"># VLAN</span><br><span class="line">Router(config)#interface &lt;接口号&gt;.&lt;子接口号&gt; # 进入子接口配置模式（接口需激活）</span><br><span class="line">Router(config-subif)#encapsulation dot1Q &lt;VLAN号&gt; # 封装VLAN协议（802.1Q），设置子接口所属VLAN</span><br><span class="line">Router(config-subif)#ip address &lt;IP地址&gt; &lt;子网掩码&gt; # 设置子接口IP地址</span><br><span class="line"></span><br><span class="line"># 路由</span><br><span class="line">Router(config)#ip route &lt;目的网络&gt; &lt;子网掩码&gt; &lt;下一跳地址&gt; # 设置静态路由</span><br><span class="line"></span><br><span class="line">Router(config)#router rip # 进入RIP协议配置模式</span><br><span class="line">Router(config-router)#version &lt;版本号&gt; # 设置RIP版本</span><br><span class="line">Router(config-router)#network &lt;网络地址&gt; # 设置RIP协议的网络地址</span><br><span class="line"></span><br><span class="line"># NAT</span><br><span class="line">Router(config)#ip nat inside source static tcp &lt;内网IP地址&gt; &lt;内网端口&gt; &lt;外网IP地址&gt; &lt;外网端口&gt; # 设置静态NAT</span><br><span class="line"></span><br><span class="line">Router(config)#access-list &lt;访问控制列表号&gt; permit any # 创建访问控制列表</span><br><span class="line">Router(config)#ip nat pool &lt;IP地址池名称&gt; &lt;起始地址&gt; &lt;结束地址&gt; netmask &lt;子网掩码&gt; # 创建IP地址池</span><br><span class="line">Router(config)#ip nat inside source list &lt;访问控制列表号&gt; pool &lt;IP地址池名称&gt; # 设置动态NAT</span><br><span class="line">Router(config)#ip nat inside source list &lt;访问控制列表号&gt; pool &lt;IP地址池名称&gt; overload # 设置NAPT</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">交换机与路由器的爱恨情仇（？</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.cclmsy.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校10</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU10.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU10.html</id>
    <published>2024-08-17T16:00:00.000Z</published>
    <updated>2024-08-25T16:44:48.016Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A810%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（10）</a></p><h1>(1008)HDU7548.SunBian</h1><h2 id="题意">题意</h2><p>有排成环形的 $n$ 个横着的笋，Alice 和 Bob 轮流执行如下操作，Alice 先手：</p><ul><li>选择 [1,k] 个连续的横着的笋，把它们变成竖着的</li></ul><p>不能操作者输。</p><p>给定 $n,k$ ，求谁会赢。</p><h2 id="解题思路">解题思路</h2><ul><li>当 $k=1$ 时，根据奇偶性判断赢家</li><li>当 $k\ge n$ 时，先手直接将笋全部竖置，必胜</li><li>其余情况下，后手每次都可以尽可能保证剩余区域数为偶数，最终必胜</li></ul><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=k) cout &lt;&lt; <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">1</span>) cout &lt;&lt; (n%<span class="number">2</span>?<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1009)HDU7549.不基本子串结构</h1><h2 id="题意-2">题意</h2><p>给定2个字符串 $a,b$ ，找到一个最小长度的字符串 $c$ ，使得 $a$ 和 $b$ 在 $c$ 中出现的次数相等且不为0，输出最小长度。</p><h2 id="解题思路-2">解题思路</h2><p>分类讨论，不妨假设 $len(a)\le len(b)$</p><ul><li>若 $a$ 在 $b$ 中出现的次数大于 $1$ ，则不存在满足条件的 $c$</li><li>若 $a$ 在 $b$ 中出现的次数为 $1$ ，则 $c=b$ ，输出 $len(b)$</li><li>若 $a$ 在 $b$ 中没有出现：<ul><li>记 $l_1$ 为 最大满足 $a[0:l]=b[len(b)-l:len(b)]$ 的 $l$</li><li>记 $l_2$ 为 最大满足 $a[len(a)-l:len(a)]=b[0:l]$ 的 $l$</li><li>答案为 $len(a)+len(b)-max(l_1,l_2)$</li></ul></li></ul><p>可以用字符串哈希进行检查和计数。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">if</span>(s1.<span class="built_in">length</span>()&lt;s2.<span class="built_in">length</span>()) <span class="built_in">swap</span>(s1,s2);</span><br><span class="line">    <span class="function">strHash <span class="title">h1</span><span class="params">(s1)</span>,<span class="title">h2</span><span class="params">(s2)</span></span>;</span><br><span class="line">    ll n=s1.<span class="built_in">length</span>(),m=s2.<span class="built_in">length</span>();</span><br><span class="line">    ll cnt=h1.<span class="built_in">count</span>(h2);</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=m+n;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(len,m<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.<span class="built_in">findz</span>(n-len+<span class="number">1</span>,n)==h2.<span class="built_in">findz</span>(<span class="number">1</span>,len))&#123;</span><br><span class="line">            <span class="built_in">chmin</span>(ans,n+m-len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(len,m<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.<span class="built_in">findf</span>(<span class="number">1</span>,len)==h2.<span class="built_in">findf</span>(m-len+<span class="number">1</span>,m))&#123;</span><br><span class="line">            <span class="built_in">chmin</span>(ans,n+m-len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1011）HDU7551.NOI2024</h1><h2 id="题意-3">题意</h2><p>$m$ 名选手进行 $n$ 场比赛，排名定义为分数严格大于你的人数+1。<br>第 $i$ 场比赛的分数上限为 $b_i$ ，你的排名为 $a_i$ 。<br>最终按照每场比赛的总分排名，前 $k$ 名选手将获得金牌。<br>问在给定条件下不管怎么比赛，是否一定能获得金牌。</p><h2 id="解题思路-3">解题思路</h2><p>用最坏情况考虑：你始终为 $0$ 分，在你前面的选手都有分数。<br>最终最坏排名为 $\min(\sum_{i=1}^{n}a_i,m)$ 。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,n);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cnt+=<span class="built_in">max</span>(<span class="number">0ll</span>,a[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">chmin</span>(cnt,m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=k) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校10</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校09</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU09.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU09.html</id>
    <published>2024-08-15T16:00:00.000Z</published>
    <updated>2024-08-25T16:44:50.760Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A89%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（9）</a></p><h1>(1005)HDU7533.怪物猎人</h1><h2 id="题意">题意</h2><p>攻击生命值为 $k$ 的怪物，每回合可选择造成 $x$ 或 $y$ 点伤害。<br>分别回答是否有一种攻击序列，可以恰好在第奇数回合/第偶数回合击杀怪物。</p><h2 id="解题思路">解题思路</h2><p>最边缘的情况即为全用 $x$ 和 全用 $y$ ，分别需要 $\lceil \frac{k}{x}\rceil$ 和 $\lceil \frac{k}{y}\rceil$ 回合。</p><p>这两个回合数相等，只有一种可能，否则都可以。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,a,b;cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ta,tb;</span><br><span class="line">    ta=(n+a<span class="number">-1</span>)/a;</span><br><span class="line">    tb=(n+b<span class="number">-1</span>)/b;</span><br><span class="line">    <span class="keyword">if</span>(ta==tb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ta%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7535.小猫钓鱼</h1><h2 id="题意-2">题意</h2><p>有 $2n$ 张牌，点数 $1\sim n$ 各出现2次。<br>两人各分到 $n$ 张牌，已知每个人手中牌的点数。<br>两人轮流放牌到牌堆顶，若牌堆中此前已经有相同点数的牌，则将这两张牌以及中间的所有牌拿回手中。<br>先打完的人输。</p><h2 id="解题思路-2">解题思路</h2><p>称手牌中成对的牌为双牌，单独的牌为单牌。</p><p>当自己打出单牌时，对方必定能打出一样的单牌收回，且先后手不变，这样是不优的。<br>因此，贪心的打法是先手打双牌，后手打双牌，先手打上次打的双牌。<br>这样的结果是：后手失去一个双牌，交换先后手。</p><p>观察到两人手牌中的双牌的数量相同，因此有双牌的情况下，后手先失去所有双牌，先手获胜。<br>否则，后手可以稳定收取先手打出的牌，后手获胜。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mp[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">size</span>()&lt;n) cout &lt;&lt; <span class="string">&quot;shuishui&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;sha7dow&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校09</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校10</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD10.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD10.html</id>
    <published>2024-08-14T16:00:00.000Z</published>
    <updated>2024-08-25T05:52:02.196Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81605">2024牛客暑期多校训练营10</a></p><h1>A.Surrender to My Will</h1><h2 id="题意">题意</h2><p>给定一个长度为 $5$ 的字符串，<code>Y</code>代表投降，<code>N</code>代表不投降，<code>-</code>代表未投票。<br>投降人数不小于4人即可投降。<br>问字符串表示的投降结果。</p><h2 id="解题思路">解题思路</h2><p>计数判断</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) mp[c]++;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="string">&#x27;Y&#x27;</span>]&gt;=<span class="number">4</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="string">&#x27;N&#x27;</span>]&gt;=<span class="number">2</span>) &#123;cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.std::pair</h1><h2 id="题意-2">题意</h2><p>基础合法类型<code>int</code>和<code>double</code>。<br>对于任意2个合法类型<code>A</code>和<code>B</code>，<code>pair&lt;A,B&gt;</code>是合法的，可以通过<code>.first</code>和<code>.second</code>分别访问<code>A</code>和<code>B</code>成员。<br>声明变量的格式为<code>pair&lt;A,B&gt; 变量名;</code>。</p><p>给定 $n$ 个字符串表示变量声明，变量名不重复。<br>再给定 $q$ 个字符串表示访问变量，返回被查询的成员类型。</p><h2 id="解题思路-2">解题思路</h2><p>模拟题，对每个变量类型构建二叉树，查询在二叉树上进行。<br>具体实现方式可以参考代码。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">pll v[N]; <span class="comment">//pair的树，x表示左子树，y表示右子树</span></span><br><span class="line">map&lt;string,ll&gt; dict; <span class="comment">//变量二叉树的根所在下标</span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function">pll <span class="title">parse_type</span><span class="params">(string s)</span></span>&#123; <span class="comment">//解析类型，构建树</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">&quot;int&quot;</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">//int</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">&quot;double&quot;</span>) <span class="keyword">return</span> &#123;<span class="number">-2</span>,<span class="number">-2</span>&#125;; <span class="comment">//double</span></span><br><span class="line">    s=s.<span class="built_in">substr</span>(<span class="number">5</span>,s.<span class="built_in">length</span>()<span class="number">-6</span>); </span><br><span class="line">    ll cntp=<span class="number">0</span>,cntd=<span class="number">0</span>,pos;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123; <span class="comment">//找到当前pair对应的逗号位置pos</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;p&#x27;</span>) cntp++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cntp==cntd) &#123;pos=i;<span class="keyword">break</span>;&#125; </span><br><span class="line">            cntd++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ltype=s.<span class="built_in">substr</span>(<span class="number">0</span>,pos),rtype=s.<span class="built_in">substr</span>(pos+<span class="number">1</span>,s.<span class="built_in">length</span>()-pos<span class="number">-1</span>);</span><br><span class="line">    ll lidx=cnt++,ridx=cnt++;</span><br><span class="line">    v[lidx]=<span class="built_in">parse_type</span>(ltype);</span><br><span class="line">    v[ridx]=<span class="built_in">parse_type</span>(rtype);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(lidx,ridx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">get_type</span><span class="params">(ll idx)</span></span>&#123; <span class="comment">//重组类型字符串</span></span><br><span class="line">    <span class="keyword">if</span>(v[idx].x==<span class="number">-1</span>) <span class="keyword">return</span> <span class="string">&quot;int&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[idx].x==<span class="number">-2</span>) <span class="keyword">return</span> <span class="string">&quot;double&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pair&lt;&quot;</span>+<span class="built_in">get_type</span>(v[idx].x)+<span class="string">&quot;,&quot;</span>+<span class="built_in">get_type</span>(v[idx].y)+<span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,q;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string type,name;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; type &gt;&gt; name;</span><br><span class="line">        name.<span class="built_in">pop_back</span>();</span><br><span class="line">        dict[name]=cnt++;</span><br><span class="line">        v[dict[name]]=<span class="built_in">parse_type</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; name;</span><br><span class="line">        ll j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;name.<span class="built_in">length</span>()&amp;&amp;name[j]!=<span class="string">&#x27;.&#x27;</span>) j++;</span><br><span class="line">        string main_name=name.<span class="built_in">substr</span>(<span class="number">0</span>,j); j++;</span><br><span class="line">        ll idx=dict[main_name];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;name.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(name[j]==<span class="string">&#x27;f&#x27;</span>)&#123; <span class="comment">//first</span></span><br><span class="line">                idx=v[idx].x;</span><br><span class="line">                j+=<span class="number">6</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name[j]==<span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//second</span></span><br><span class="line">                idx=v[idx].y;</span><br><span class="line">                j+=<span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">get_type</span>(idx) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F.Collinear Exception</h1><h2 id="题意-3">题意</h2><p>有一 $n\times n$ 的点阵列，每个点的坐标为 $(i,j)$ ，$1\leq i,j\leq n$ 。<br>按给定序列对点进行标记，要求标记后不能存在三个被标记点共线，否则标记失败。<br>按给定序列顺序输出每个点是否标记成功。</p><h2 id="解题思路-3">解题思路</h2><p>每当加入一个新的点时，和已有的点连线，标记线上的所有点。<br>被标记的点不能再被加入。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vis</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    vector&lt;pll&gt; points;</span><br><span class="line">    ll ub=n*n,xx,yy,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; xx &gt;&gt; yy;</span><br><span class="line">        <span class="keyword">if</span>(vis[xx][yy])&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>[tx,ty]:points)&#123; <span class="comment">//标记线上的点</span></span><br><span class="line">            <span class="keyword">if</span>(xx==tx)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n) vis[xx][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ll dx=xx-tx,dy=yy-ty;</span><br><span class="line">                ll g=__gcd(dx,dy);</span><br><span class="line">                dx/=g;dy/=g;</span><br><span class="line">                ll ttx=tx,tty=ty;</span><br><span class="line">                <span class="keyword">while</span>(ttx&lt;=n&amp;&amp;ttx&gt;=<span class="number">1</span>&amp;&amp;tty&lt;=n&amp;&amp;tty&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    vis[ttx][tty]=<span class="number">1</span>;</span><br><span class="line">                    ttx+=dx; tty+=dy;</span><br><span class="line">                &#125;</span><br><span class="line">                ttx=tx; tty=ty;</span><br><span class="line">                <span class="keyword">while</span>(ttx&lt;=n&amp;&amp;ttx&gt;=<span class="number">1</span>&amp;&amp;tty&lt;=n&amp;&amp;tty&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    vis[ttx][tty]=<span class="number">1</span>;</span><br><span class="line">                    ttx-=dx; tty-=dy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        points.<span class="built_in">emplace_back</span>(xx,yy);</span><br><span class="line">        vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.All-in at the Pre-flop</h1><h2 id="题意-4">题意</h2><p>两名玩家初始分别有 $a,b$ 的筹码，每轮游戏各有 $\frac{1}{2}$ 的概率获胜。<br>假设当前轮两名玩家分别有 $x,y$ 的筹码，那么输家需要付给赢家 $\min(x,y)$ 的筹码。<br>问两名玩家获胜的概率。</p><h2 id="解题思路-4">解题思路</h2><p>打个表，观察到答案是 $\frac{a}{a+b},\frac{b}{a+b}$ 。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll c=<span class="built_in">inv</span>(<span class="built_in">add</span>(a,b));</span><br><span class="line">    cout &lt;&lt; <span class="built_in">mul</span>(a,c) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">mul</span>(b,c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校10</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校09</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD09.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD09.html</id>
    <published>2024-08-12T16:00:00.000Z</published>
    <updated>2024-08-25T05:52:02.195Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81604">2024牛客暑期多校训练营9</a></p><h1>A.Image Scaling</h1><h2 id="题意">题意</h2><p>给定由 <code>.</code> 和 <code>x</code> 组成的 $n\times m$ 的 $n\times m$ 矩阵，$x$ 部分是一个子矩阵。<br>提取并在长宽比不变的情况下，将子矩阵尽可能缩小并输出。</p><h2 id="解题思路">解题思路</h2><p>模拟，缩小到 $1/gcd$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll fl=<span class="number">0</span>,st=<span class="number">-1</span>;</span><br><span class="line">    ll nn=<span class="number">-1</span>,mm,idx;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(fl) <span class="keyword">if</span>(s[idx]!=<span class="string">&#x27;x&#x27;</span>) &#123;nn=i-st;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">                    fl=<span class="number">1</span>; st=i; idx=j;</span><br><span class="line">                    ll t=j;</span><br><span class="line">                    <span class="keyword">while</span>(t&lt;m&amp;&amp;s[t]==<span class="string">&#x27;x&#x27;</span>) t++;</span><br><span class="line">                    mm=t-j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nn==<span class="number">-1</span>) nn=n-st;</span><br><span class="line">    ll g=__gcd(nn,mm);</span><br><span class="line">    nn/=g; mm/=g;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,nn<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,mm<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        &#125;cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.Kill The Monsters</h1><h2 id="题意-2">题意</h2><p>$n$ 个怪兽，第 $i$ 个怪兽的体力为 $a_i$ 。</p><p>每次可以进行一种操作：</p><ol><li>所有怪兽体力 $-1$</li><li>选择一个怪兽 $i$ 使得 $a_i\leftarrow \lfloor \dfrac{a_i}{k} \rfloor$</li></ol><p>问最少多少次操作可以使所有怪兽的体力都为 $0$ 。</p><h2 id="解题思路-2">解题思路</h2><p>贪心的，先连续对最大体力的怪兽进行第二种操作，再进行第一种操作。<br>用优先队列维护最大体力。<br>记当前已经操作了 $cnt$ 次，用 $a_{max}+cnt$ 维护最小操作次数。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k,t;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    priority_queue&lt;ll&gt; pq;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) &#123;cin &gt;&gt; t;pq.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">    ll cur=<span class="number">0</span>,ans=pq.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) &#123;cout &lt;&lt; ans &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">top</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        t=pq.<span class="built_in">top</span>();pq.<span class="built_in">pop</span>();</span><br><span class="line">        t/=k; cur++;</span><br><span class="line">        pq.<span class="built_in">push</span>(t);</span><br><span class="line">        <span class="built_in">chmin</span>(ans,pq.<span class="built_in">top</span>()+cur);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校09</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校08</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU08.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU08.html</id>
    <published>2024-08-11T16:00:00.000Z</published>
    <updated>2024-08-25T16:44:50.779Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A88%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（8）</a></p><h1>(1004)HDU7520.cats 的重力拼图</h1><h2 id="题意">题意</h2><p>有一个 $n\times m$ 的方格阵列，物块初始位于 $(x,y),1\le x\le n,1\le y\le m$。<br>每次操作可以改变重力方向：向上、向下、向左、向右，物块会沿重力方向移动，直到碰到边界。<br>求任意操作下物块最多经过的格子数。</p><h2 id="解题思路">解题思路</h2><p>有2种最贪心的操作序列：</p><ol><li>向左、向右、再沿边缘一周</li><li>向上、向下、再沿边缘一周</li></ol><p>特判 $n=1$ 或 $m=1$ 或初始在边缘的情况。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b;cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>||m&lt;=<span class="number">2</span>)&#123; cout &lt;&lt; n*m &lt;&lt; endl; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    ll ans=<span class="number">2</span>*(n+m<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>||a==n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>||b==m) cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans+n<span class="number">-2</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">1</span>||b==m) cout &lt;&lt; ans+m<span class="number">-2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans+<span class="built_in">max</span>(&#123;<span class="number">0ll</span>,n<span class="number">-2</span>,m<span class="number">-2</span>&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1006）HDU7522.cats 的最小生成树</h1><h2 id="题意-2">题意</h2><p>给定一个有 $n$ 个节点，可能含重边的带权无向图， $m$ 条边按顺序给出，第 $i$ 条边的权值为 $i$。<br>每次删去当前图的最小生成树的所有边，直到图不连通。</p><p>求每条边是在第几次被删除去的。</p><h2 id="解题思路-2">解题思路</h2><p>根据Kruskal算法思想，最小生成树加边是从小到大加入的。<br>开若干个并查集，遍历边，每次二分查找当前边最早可以加入第几个并查集。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll ub=m/(n<span class="number">-1</span>);</span><br><span class="line">    <span class="function">vector&lt;DSU&gt; <span class="title">dsu</span><span class="params">(ub+<span class="number">2</span>,DSU(n))</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">cnt</span><span class="params">(ub+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        ll l=<span class="number">1</span>,r=ub+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            ll mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">bool</span> fl=(dsu[mid].<span class="built_in">find</span>(u)==dsu[mid].<span class="built_in">find</span>(v));</span><br><span class="line">            <span class="keyword">if</span>(fl) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll tar=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">1ll</span>,l<span class="number">-3</span>),<span class="built_in">min</span>(ub+<span class="number">1</span>,l+<span class="number">3</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(dsu[i].<span class="built_in">find</span>(u)!=dsu[i].<span class="built_in">find</span>(v))&#123;</span><br><span class="line">                tar=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tar==ub+<span class="number">1</span>) &#123; ans[i]=<span class="number">-1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        dsu[tar].<span class="built_in">merge</span>(u,v);</span><br><span class="line">        cnt[tar]++; ans[i]=tar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]!=<span class="number">-1</span>&amp;&amp;cnt[ans[i]]==n<span class="number">-1</span>) cout &lt;&lt; ans[i];</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">Presentation</span>(i,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7523.cats 的 k-xor</h1><h2 id="题意-3">题意</h2><p>给定2个十进制整数 $a,b,c$ ， $a,b$ 进行 $k(k\ge 2)$ 进制不进位加法后的结果是 $c$。<br>求 $k$ 有多少种可能。</p><h2 id="解题思路-3">解题思路</h2><p>不进位加法下，丢失的进位信息 $a+b-c$ 是 $k$ 的倍数。<br>枚举 $a+b-c$ 的因子作为 $k$ ，check是否满足条件。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll a,ll b,ll c,ll k)</span></span>&#123;</span><br><span class="line">    ll dif=a+b-c;</span><br><span class="line">    ll cur=<span class="number">1</span>,nxt=k,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a/cur||b/cur)&#123;</span><br><span class="line">        ll ta=a/cur%k,tb=b/cur%k;</span><br><span class="line">        s+=(ta+tb)/k*nxt;</span><br><span class="line">        cur*=k; nxt*=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s==dif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll dif=a+b-c;</span><br><span class="line">    <span class="keyword">if</span>(dif==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>,ub=<span class="built_in">sqrt</span>(dif)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,ub) <span class="keyword">if</span>(dif%i==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i*i&gt;dif) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(a,b,c,i)) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(i*i!=dif&amp;&amp;<span class="built_in">check</span>(a,b,c,dif/i)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(a,b,c,dif)) cnt++;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1012）HDU7528.cats 的电脑中毒</h1><h2 id="题意-4">题意</h2><p>给定 $3$ 个长度为 $n$ 的二进制串 $a,b,c$ ， 表示病毒的初始位置。<br>每过一秒，病毒会感染相邻的所有二进制编码。（当且仅当两个二进制编码仅有一个位置不同时，这两个编码为相邻）<br>问所有的 $2^n$ 个二进制编码都被感染需要多少时间。</p><h2 id="解题思路-4">解题思路</h2><p>考虑最后一秒被感染的二进制串，它的 距离三个初始位置的最小汉明距离 最大，找到这个串。<br>设这个串为 $s$ ，枚举每一位。若三个初始位置的这一位上，1的数量较多，则设为0；否则设为1。<br>然后进行微调，使得 $s$ 到三个初始位置的最小汉明距离 最大。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ll n;</span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cnt+=(s1[i]!=s2[i]);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s[<span class="number">3</span>],<span class="built_in">ns</span>(n,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">2</span>) cin &gt;&gt; s[i];</span><br><span class="line">    ll cnta=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> cnt1=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">if</span>(s[j][i]==<span class="string">&#x27;1&#x27;</span>) cnt1++;</span><br><span class="line">        ns[i]=(cnt1&gt;=<span class="number">2</span>)?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll dis0=<span class="built_in">dis</span>(s[<span class="number">0</span>],ns),dis1=<span class="built_in">dis</span>(s[<span class="number">1</span>],ns),dis2=<span class="built_in">dis</span>(s[<span class="number">2</span>],ns);</span><br><span class="line">    <span class="keyword">while</span>(dis0&lt;dis1<span class="number">-1</span>&amp;&amp;dis0&lt;dis2<span class="number">-1</span>)&#123; dis0++; dis1--; dis2--; &#125;</span><br><span class="line">    <span class="keyword">while</span>(dis1&lt;dis0<span class="number">-1</span>&amp;&amp;dis1&lt;dis2<span class="number">-1</span>)&#123; dis1++; dis0--; dis2--; &#125;</span><br><span class="line">    <span class="keyword">while</span>(dis2&lt;dis0<span class="number">-1</span>&amp;&amp;dis2&lt;dis1<span class="number">-1</span>)&#123; dis2++; dis0--; dis1--; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(&#123;dis0,dis1,dis2&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校08</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校07</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU07.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU07.html</id>
    <published>2024-08-08T16:00:00.000Z</published>
    <updated>2024-08-25T16:44:50.793Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A87%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（7）</a></p><h1>(1010)HDU7514.故障机器人想活下去</h1><h2 id="题意">题意</h2><p>故障机器人有 $x$ 点血量。<br>他将按顺序进行 $n$ 场战斗，第 $i$ 场战斗会受到 $a_i$ 点伤害。<br>故障机器人还有 $k$ 个烟雾弹，每个烟雾弹可以让他跳过一场战斗而不受伤害。</p><p>问故障机器人最多能活到第几场战斗结束。</p><h2 id="解题思路">解题思路</h2><p>维护当前最高的 $k$ 个伤害，作为被跳过的伤害。<br>统计受伤量，直到受伤量超过 $x$ 为止。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,k;cin &gt;&gt; n &gt;&gt; x &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;,less&lt;ll&gt;&gt; pq;</span><br><span class="line">    ll S=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        S+=v[i];</span><br><span class="line">        pq.<span class="built_in">push</span>(v[i]);</span><br><span class="line">        <span class="keyword">while</span>(S&gt;=x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=k)&#123;</span><br><span class="line">                cout &lt;&lt; pq.<span class="built_in">size</span>()+cnt<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            S-=pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7515.蛋糕上的草莓是蛋糕的灵魂</h1><h2 id="题意-2">题意</h2><p>有 $x$ 个相同的草莓和 $y$ 个相同的蛋糕。<br>每次可以将当前所有草莓或蛋糕放在一起切 $m$ 刀，即份数变为此前的 $2m$ 倍。<br>在满足条件的情况下切草莓的次数尽可能少。<br>求出最终草莓和蛋糕的数量。</p><h2 id="解题思路-2">解题思路</h2><p>贪心的，观察到蛋糕是不用切的，将草莓切到 $\gcd(x,y)$ 份即可。<br>若 $\gcd$ 是 $x$ 的奇数倍，需要多来一刀。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    ll g=__gcd(x,y);</span><br><span class="line">    <span class="keyword">if</span>(y/g&gt;<span class="number">1</span>&amp;&amp;(y/g)%<span class="number">2</span>) cout &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x/g*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x/g &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校07</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校08</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD08.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD08.html</id>
    <published>2024-08-07T16:00:00.000Z</published>
    <updated>2024-08-24T15:07:18.555Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81603">2024牛客暑期多校训练营8</a></p><h1>A.Haitang and Game</h1><h2 id="题意">题意</h2><p>给定一个包含 $n$ 个数的正整数集合 $S$ ，每次可以从中选择两个数 $x,y$ 满足 $x,y\in S,\gcd(x,y)\notin S$，将 $\gcd(x,y)$ 加入 $S$ 。<br>最多加入数的个数是奇数输出<code>dXqwq</code>，否则输出<code>Haitang</code>。</p><h2 id="解题思路">解题思路</h2><p>考虑最终集合中的数 $d$ ，一定满足原集合中，它的所有倍数的 $gcd$ 等于它。<br>从小到大枚举 $d$ ，如果 $d$ 满足上述条件且不在原集合中，计数。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;ll&gt; s;</span><br><span class="line">    ll mx=<span class="number">-1</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        s.<span class="built_in">insert</span>(t);</span><br><span class="line">        <span class="built_in">chmax</span>(mx,t);</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,mx)&#123;</span><br><span class="line">        ll fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=mx;j+=i)</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">count</span>(j)) fl=__gcd(fl,j);</span><br><span class="line">        <span class="keyword">if</span>(fl==i&amp;&amp;!s.<span class="built_in">count</span>(i)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;dXqwq\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Haitang\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.Haitang and Triangle</h1><h2 id="题意-2">题意</h2><p>构造一个长度为 $n$ 的排列，它恰有 $m$ 个长度为 $3$ 的子区间满足子区间的三个数能构成非退化三角形。</p><h2 id="解题思路-2">解题思路</h2><p>构造一个长度为 $n-m$ 的排列，它不含能够构成非退化三角形的长度为 $3$ 的子区间。<br>我使用的方法是把 $1\sim n-m$ 从大到小均分成三组，第1组降序，其他组升序，按321的顺序放置。<br>假设 $n-m=7$ ，分成 $[2,1],[3,4],[5,6,7]$ ，排列为 $5,3,2,\ 6,4,1,\ 7$ 。</p><p>剩下 $m$ 个数降序放在排列的前面，和上面的排列合并形成 $m$ 个合法区间。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll t = n-m;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;ll&gt; v[<span class="number">3</span>];</span><br><span class="line">    ll t1=t/<span class="number">3</span>,t2=t%<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,t1) v[<span class="number">0</span>].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,t1+<span class="number">1</span>,t1*<span class="number">2</span>+(t2&gt;<span class="number">1</span>)) v[<span class="number">1</span>].<span class="built_in">emplace_front</span>(i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,t1*<span class="number">2</span>+(t2&gt;<span class="number">1</span>)+<span class="number">1</span>,t) v[<span class="number">2</span>].<span class="built_in">emplace_front</span>(i);</span><br><span class="line">    <span class="comment">// FORLL(i,0,2) print_vec(v[i]);</span></span><br><span class="line">    vector&lt;ll&gt; ans;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">2</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">2</span>][i]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">1</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">1</span>][i]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">0</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,t+<span class="number">1</span>) cout &lt;&lt; i &lt;&lt; <span class="built_in">Presentation</span>(i,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t<span class="number">-1</span>) cout &lt;&lt; ans[i] &lt;&lt; <span class="built_in">Presentation</span>(i,t<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.Haitang and Ava</h1><h2 id="题意-3">题意</h2><p>判断给定字符串是否仅由若干个 <code>ava</code> 和 <code>avava</code> 组成。</p><h2 id="解题思路-3">解题思路</h2><p>从 $i=1$ 开始，对于当前位置开头，先检查长度为 $5$ 的子串是否是 <code>avava</code> ，再检查长度为 $3$ 的子串是否是 <code>ava</code> ，如果是，就跳过这个子串；否则输出<code>NO</code>。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pat1 = <span class="string">&#x27;ava&#x27;</span></span><br><span class="line">pat2 = <span class="string">&#x27;avava&#x27;</span></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">5</span>&lt;=<span class="built_in">len</span>(s) <span class="keyword">and</span> s[i:i+<span class="number">5</span>] == pat2:</span><br><span class="line">            i += <span class="number">5</span></span><br><span class="line">        <span class="keyword">elif</span> i+<span class="number">3</span>&lt;=<span class="built_in">len</span>(s) <span class="keyword">and</span> s[i:i+<span class="number">3</span>] == pat1:</span><br><span class="line">            i += <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校08</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校07</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD07.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD07.html</id>
    <published>2024-08-05T16:00:00.000Z</published>
    <updated>2024-08-25T05:52:02.196Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81702">2024牛客暑期多校训练营7</a></p><h1>I.Fight Against the Monster</h1><h2 id="题意">题意</h2><p>瓶子换水问题。 $m$ 个空瓶可以换 $k$ 瓶水， 求一共要喝 $h$ 瓶水，初始最少需要多少瓶水。</p><h2 id="解题思路">解题思路</h2><p>二分check。</p><p>设初始有 $x$ 瓶水，换水次数为 $\dfrac{x-m}{m-k}+1=\dfrac{x-k}{m-k}$。<br>每次换水产生 $k$ 瓶水，总共 $x+k\cdot \dfrac{x-k}{m-k}$ 瓶水。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(ll m,ll k,ll h,ll x)</span></span>&#123;</span><br><span class="line">    ll t=(x-k)/(m-k)*k+x;   </span><br><span class="line">    <span class="keyword">if</span>(t&gt;=h) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,k,h;cin &gt;&gt; m &gt;&gt; k &gt;&gt; h;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;=m)&#123;cout &lt;&lt; h &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//不用换</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=k)&#123;cout &lt;&lt; m &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//生生不息</span></span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        ll mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(m,k,h,mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">0ll</span>,l<span class="number">-10</span>),r+<span class="number">10</span>) <span class="keyword">if</span>(<span class="built_in">check</span>(m,k,h,i)) &#123;cout &lt;&lt; i &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.Ball</h1><h2 id="题意-2">题意</h2><p>给定一根左端点为 $(0,0)$ 垂直于y轴长度为 $l$ 的棍子。<br>在上面找一个支点使得棍子绕支点旋转可以碰到位于 $(x,y)$ 的小球。</p><h2 id="解题思路-2">解题思路</h2><p>支点位于两端时扫过的面积可覆盖所有情况。<br>判断小球到两端的距离。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,x,y;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    ll dis1,dis2;</span><br><span class="line">    dis1=x*x+y*y;</span><br><span class="line">    dis2=(l-x)*(l-x)+y*y;</span><br><span class="line">    <span class="keyword">if</span>(dis1&gt;l*l&amp;&amp;dis2&gt;l*l) &#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(dis1&lt;dis2) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校07</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校06</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU06.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU06.html</id>
    <published>2024-08-04T16:00:00.000Z</published>
    <updated>2024-08-05T17:09:48.637Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A86%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（6）</a></p><h1>(1001)HDU7494 造花（简单版）</h1><h2 id="题意">题意</h2><p>给定一棵 $n$ 个节点的树，问能否通过删去一个节点，使得剩下的节点组成2个连通块，且每个连通块都是一个菊花图。</p><p>菊花图是一棵树，且存在唯一中心点与其他所有节点之间有一条边。特殊的，只有一个节点的树也是菊花图。</p><h2 id="解题思路">解题思路</h2><p>一棵树删去一个点得到两个连通块，那么删去的点的度必定为2。</p><p>这个删去的点 $u$ 和得到的两个菊花图的中心点 $v_1,v_2$ 有三种情况：</p><ol><li>$u$ 和 $v_1,v_2$ 直接相连</li><li>$u$ 和 $v_1$ 直接相连，和 $v_2$ 的距离为2</li><li>$u$ 和 $v_1,v_2$ 的距离都为2</li></ol><p>记录度大于1的节点，这些点是关键节点，可能是中心点，也可能是删去的点。</p><p>度大于1的节点数最多的情况是第三种，最多有5个度大于1的节点，形如：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  8       9</span><br><span class="line">  |       |</span><br><span class="line">1<span class="string">-2</span><span class="string">-3</span><span class="string">-4</span><span class="string">-5</span><span class="string">-6</span><span class="string">-7</span></span><br><span class="line">  |       |</span><br><span class="line">  10      11</span><br></pre></td></tr></table></figure><p>删去点 $u$ 后，剩余度大于1的节点必定是中心点，个数不大于 $2-t$ 即满足。<br>其中， $t$ 是删点后仅由不多于$2$个点组成的连通块的个数。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; crit; <span class="comment">//关键点</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(G[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>) crit.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(crit.<span class="built_in">size</span>()&gt;<span class="number">5</span>) &#123;cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:crit) <span class="keyword">if</span>(G[u].<span class="built_in">size</span>()==<span class="number">2</span>)&#123; <span class="comment">//枚举删除的点</span></span><br><span class="line">        ll cnt2=<span class="number">0</span>,cnt1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])&#123; <span class="comment">//相邻的2个点</span></span><br><span class="line">            <span class="keyword">if</span>(G[v].<span class="built_in">size</span>()==<span class="number">2</span>)&#123; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> w:G[v])  <span class="comment">//w==u:这一端的连通块只有2个节点</span></span><br><span class="line">                <span class="keyword">if</span>(w!=u) <span class="keyword">if</span>(G[w].<span class="built_in">size</span>()&gt;<span class="number">1</span>) cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(G[v].<span class="built_in">size</span>()==<span class="number">1</span>) cnt1++; <span class="comment">//这一端的连通块只有1个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        ll t=crit.<span class="built_in">size</span>()<span class="number">-1</span>-cnt2;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=<span class="number">2</span>-cnt1) &#123; cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1003)HDU7496 飞车狂飙</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的字符串，包含：</p><ol><li><code>L</code> ：表示左转的方块</li><li><code>R</code> ：表示右转的方块</li><li><code>S</code> ：表示直行的方块</li></ol><p>从原点开始，按照字符串给定的顺序，先放置，再按照给定的方向移动。</p><p>合法的字符串满足：</p><ol><li>不在同一位置放置两个方块</li><li>所有方块形成一个环</li></ol><p>问给定的字符串是否合法。</p><h2 id="解题思路-2">解题思路</h2><p>模拟。<br>每走一步更新沿途放置了方块的坐标和当前方向。<br>中途检查是否有重复放置的方块，最后检查是否回到原点、方向是否回正。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        0 1 2 3</span></span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pll cur=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir=<span class="number">0</span>; <span class="comment">//0:up 1:left 2:down 3:right</span></span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    map&lt;pll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(cur))&#123;  cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        mp[cur]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;L&#x27;</span>) dir=(dir+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>) dir=(dir+<span class="number">3</span>)%<span class="number">4</span>;</span><br><span class="line">        cur.first+=dx[dir];</span><br><span class="line">        cur.second+=dy[dir];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.first==<span class="number">0</span>&amp;&amp;cur.second==<span class="number">0</span>&amp;&amp;dir==<span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1004)HDU7497 不醒人室</h1><h2 id="题意-3">题意</h2><p>给定 $n$ 个上课时间段， $m$ 个睡觉时间段。</p><p>初始状态是不清醒。<br>每个睡觉时间段 $[s,t]$ 能使接下来 $2(t-s)$ 的时间，也就是 $[t,t+2(t-s)]$ 时间段内保持清醒。<br>睡觉提供的清醒时间段不会叠加，以此前最后一个睡觉时间段为准。</p><p>问给定的时间段能否满足以下条件：</p><ol><li>上课时间保持清醒</li><li>上课时间不能睡觉</li></ol><h2 id="解题思路-3">解题思路</h2><p>将所有时间段排序，从左往右遍历：</p><ol><li>当前是上课时间段，检查：<ol><li>上课开始时间是否晚于最后一个睡觉时间段的结束时间</li><li>上课结束时间是否早于最后一次睡觉提供的清醒时间段的结束时间</li></ol></li><li>当前是睡觉时间段，检查睡觉时间是否晚于上一节课的结束时间</li></ol><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;pair&lt;pll,<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m+n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; v[i].first.first &gt;&gt; v[i].first.second;</span><br><span class="line">        v[i].second = <span class="number">0</span>; <span class="comment">//上课</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,n,n+m<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; v[i].first.first &gt;&gt; v[i].first.second;</span><br><span class="line">        v[i].second = <span class="number">1</span>; <span class="comment">//睡觉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll b,e,s,t; <span class="comment">//上次上课时间[b,e]，上次睡觉时间[s,t]</span></span><br><span class="line">    b=e=s=t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [tp,op]:v)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x,y] = tp;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>)&#123; <span class="comment">//上课</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;t)&#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//上课开始还在睡觉</span></span><br><span class="line">            <span class="keyword">if</span>(t+<span class="number">2</span>*(t-s)&lt;y) &#123;cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//上次没睡够支撑不到下课</span></span><br><span class="line">            b=x;e=y;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(x&lt;e)&#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//还没下课就睡觉</span></span><br><span class="line">            s=x;t=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1005)HDU7498 交通管控</h1><h2 id="题意-4">题意</h2><p>有 $k$ 盏红绿灯，每盏灯有三种状态：绿色<code>A</code>、黄色<code>B</code>、红色<code>C</code>。</p><p>一个操作用一个长度为 $k$ 的字符串表示，一个字符对应一盏灯。<br>字符串中包含：</p><ol><li><code>+</code>：红变绿、绿变黄、黄变红</li><li><code>-</code>：绿变红、黄变绿、红变黄</li><li><code>0</code>：不变</li></ol><p>交警有一个长度为 $n$ 的操作序列，他可以按顺序对每个操作选择执行或不执行。</p><p>问最后能达到哪些状态，以及每种状态对应的 操作序列种数。</p><h2 id="解题思路-4">解题思路</h2><p>状态压缩DP。</p><p>用一个 $k$ 位3进制数表示 $k$ 盏灯的状态，每一位表示一盏灯的状态：0绿、1黄、2红。<br>记：</p><ul><li>$dp[i][x]$ 表示前 $i$ 个操作，状态为 $x$ 的方案数。</li><li>$op(x,i)$ 表示状态 $x$ 经过第 $i$ 个操作后的状态。</li></ul><p>状态转移方程：$dp[i][x]=dp[i-1][x]+\sum\limits_{j}^{st\in stat[i-1],op(st,i)=j} dp[i-1][st]$<br>其中，$stat[i-1]$ 表示第 $i-1$ 个操作后的所有状态。</p><p>利用滚动数组可以实现空间优化。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; pow3;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pow3.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">20</span>) pow3.<span class="built_in">emplace_back</span>(pow3.<span class="built_in">back</span>()*<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">ll n,k;</span><br><span class="line"><span class="comment">//在x的3进制，第idx位，+d再对3取模</span></span><br><span class="line"><span class="function">ll <span class="title">opadd</span><span class="params">(ll x,ll idx,ll d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    ll t = x/pow3[idx]%<span class="number">3</span>;</span><br><span class="line">    t = (t+d+<span class="number">3</span>)%<span class="number">3</span>-t;</span><br><span class="line">    <span class="keyword">return</span> x + t*pow3[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0A1B2C</span></span><br><span class="line"><span class="function">string <span class="title">trans</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">        s += <span class="built_in">char</span>(<span class="string">&#x27;A&#x27;</span>+x%<span class="number">3</span>);</span><br><span class="line">        x /= <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cin &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:v) cin &gt;&gt; s;</span><br><span class="line">    map&lt;ll,ll&gt; dp[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">    dp[fl].<span class="built_in">insert</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;); fl^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:v)&#123;</span><br><span class="line">        dp[fl]=dp[fl^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,cnt]:dp[fl^<span class="number">1</span>])&#123;</span><br><span class="line">            ll t=v;</span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>) t=<span class="built_in">opadd</span>(t,i,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>) t=<span class="built_in">opadd</span>(t,i,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">addto</span>(dp[fl][t],cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        fl^=<span class="number">1</span>;</span><br><span class="line">    &#125;fl^=<span class="number">1</span>;</span><br><span class="line">    map&lt;string,ll&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,cnt]:dp[fl]) ans.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">trans</span>(v),(ll)cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [s,cnt]:ans) cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校06</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校05</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU05.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU05.html</id>
    <published>2024-08-01T16:00:00.000Z</published>
    <updated>2024-08-05T11:36:11.110Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A85%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（5）</a></p><h1>(1002)HDU7482 Array-Gift</h1><h2 id="题意">题意</h2><p>给定一个长度为 $n$ 的正整数数组 $a$ ，提供以下2种操作：</p><ol><li>选择两个不同的下标 $i,j$ ，$a_i\leftarrow a_i\ mod\ a_j$</li><li>选择一个下标 $i$ 和一个任意正整数 $x$ ，$a_i\leftarrow a_i+x$</li></ol><p>求使得数组仅有1个非0元素的最小操作次数。</p><h2 id="解题思路">解题思路</h2><p>add：做之前先对数组去重，因为重复的数可以在开始就通过操作1变为0。</p><p>考虑最坏情况的操作次数：<br>选定两个不同的下标 $i,j$ ，不妨设 $a_i&lt;=a_j$ 。（1次）<br>做操作2使得 $a_i=a_j+1$ ，再做操作1使得 $a_i=1$ 。（1次）<br>最后对每个 $k\neq i$ 做操作1：$a_k\leftarrow a_k\ mod\ a_i=0$ 。（$n-1$次）<br>最坏情况的操作次数为 $n+1$ 。</p><p>最好的情况：存在一个下标 $i$ 使得 $a_i$ 能够整除数组中所有元素。<br>满足这个条件的 $a_i$ 一定是数组中的最小值。<br>这种情况只需对每个 $k\neq i$ 做操作1：$a_k\leftarrow a_k\ mod\ a_i=0$ ，操作次数为 $n-1$ 。</p><p>由于最坏情况难以确定，考虑操作次数为 $n$ 的情况：</p><ol><li>数组 $a$ 中的最小值经过操作2 ，$\min(a)\leftarrow\min(a)+x$ ，能够整除数组中所有元素。</li><li>某个元素经过操作1，能够整除数组中所有元素。</li></ol><p>对于第二种情况，维护gcd前缀/后缀（似乎不维护也能过？）。<br>枚举被修改的数 $a_i$ 和模数 $a_j$ ，若 $a_i\ mod\ a_j=\gcd\limits_k^{k\neq i}a_k$ ，则最少操作次数为 $n$ 。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    vector&lt;ll&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)&#123;</span><br><span class="line">        <span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m:tmp) <span class="keyword">if</span>(x%m==<span class="number">0</span>) &#123;fl=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(fl) tmp.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ll on=n; v=tmp; n=v.<span class="built_in">size</span>(); <span class="comment">//on是原数组大小</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(),<span class="number">0</span>); v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(),<span class="number">0</span>); <span class="comment">//起始下标改为1</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; on<span class="number">-1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">preg</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span>,<span class="title">sufg</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>; </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) preg[i]=__gcd(preg[i<span class="number">-1</span>],v[i]);</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>) sufg[i]=__gcd(sufg[i+<span class="number">1</span>],v[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sufg[<span class="number">2</span>]&gt;v[<span class="number">1</span>]&amp;&amp;sufg[<span class="number">2</span>]&lt;=v[<span class="number">2</span>]) &#123;cout &lt;&lt; on &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//剩下的数模（v1+x）为0</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123; <span class="comment">//被修改的数</span></span><br><span class="line">        ll g=__gcd(preg[i<span class="number">-1</span>],sufg[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)&#123;<span class="comment">//模数</span></span><br><span class="line">            ll t=v[i]%v[j];</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g%t==<span class="number">0</span>) &#123;cout &lt;&lt; on &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; on+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1006)HDU7486 猫罐头游戏</h1><h2 id="题意-2">题意</h2><p>有三堆猫罐头，每堆猫罐头的数量分别为 $a,b,c$ 。<br>两只猫猫进行博弈，每次可以选择一堆猫罐头全部吃掉，然后再从剩下的两堆中选择一堆猫罐头分成两份（每份至少一罐）。<br>不能操作的猫猫输掉游戏。</p><p>问先手是否有必胜策略。</p><h2 id="解题思路-2">解题思路</h2><p>最终必败态是 $a=b=c=1$ 。</p><p>当开局有3个奇数时，不论怎么操作，结果都是2奇数1偶数；<br>当开局有1个或2个偶数时，可以控制结果为3个奇数。<br>三个奇数的尽头就是3个1必败，因此开局3奇数必败，开局1或2偶数必胜。</p><p>开局全偶数的情况，可以从lowbit的角度考虑。<br>当开局三个数lowbit位于同一位时，不论怎么操作都不能使lowbit相等。<br>当开局三个数lowbit位于不同位时，可以通过操作控制lowbit相等，整个过程lowbit减小。<br>lowbit相等的尽头是三个数的lowbit都等于$1$也就是三奇数的必败态。</p><p>因此，开局三个数lowbit相等必败。<br>观察到三个数不全是偶数的情况也可以归并到这个结论中，2行秒了。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lowbit</span>(a)==<span class="built_in">lowbit</span>(b)&amp;&amp;<span class="built_in">lowbit</span>(b)==<span class="built_in">lowbit</span>(c))  NO; <span class="keyword">else</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7491 开关灯</h1><h2 id="题意-3">题意</h2><p>有 $n$ 盏灯排成一排，编号为 $1\sim n$ ，初始状态为全灭。<br>每次操作可以选择一盏灯，反转这盏灯和与之相邻的灯的状态（开变关，关变开）。<br>求任意操作后，这排灯可以到达多少种不同的状态。</p><h2 id="解题思路-3">解题思路</h2><p>观察样例发现答案满足 $2^n$ 。<br>手玩发现只有 $n\equiv2(mod\ 3)$ 时达不到全亮状态，是 $2^{n-1}$ 。</p><p>如果发现力不够，还可以考虑以下方法：<br>对位置1,2分别做一次操作，可以单独反转3；再对4,5分别做一次操作，可以单独反转6。<br>以此类推，正着做可以单独反转所有 $i\equiv0(mod\ 3)$，反着做可以单独反转所有 $i\equiv n-2(mod\ 3)$ 。<br>如果可以单独任意反转连续2个灯，则与它们相邻的灯也可以单独任意反转，以达到所有 $2^n$ 种状态。</p><p>当且仅当 $n\equiv2(mod\ 3)$ 时，正着做和反着做反转的都是同一批灯，无法通过以上操作任意反转所有的灯。<br>由于无法到达全亮状态，答案少一半，为 $2^{n-1}$ 。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">2</span>) cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,n<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1013)HDU7493 飞行棋</h1><h2 id="题意-4">题意</h2><p>$0\sim n$ 号格子排成一排，棋子初始在 $0$ 号格，目标是精确到达第 $n$ 格。<br>每次随机从 $1\sim n$ 中均匀随机一个正整数 $x$ ，然后向前移动 $x$ 步，若移动到第 $n$ 格还有剩余步数，则会往回走。<br>如果随机到 $n$ 且最终没有精确到达第 $n$ 格，则可以再从 $1\sim n-1$ 中均匀随机一个正整数并行动。</p><p>求精确到达第 $n$ 格的期望步数。</p><h2 id="解题思路-4">解题思路</h2><p>从 $0$ 号格子一次到达第 $n$ 格的概率是 $\dfrac{1}{n}$ 。<br>从 $1\sim n-1$ 号格子一次到达第 $n$ 格的概率都是 $\dfrac{1}{n}(1+\dfrac{1}{n-1})=\dfrac{1}{n-1}$ ，期望为 $n-1$<br>如果没有到达终点，棋子只会落在 $1\sim n-1$ 号格子上。</p><p>因此答案为 $\dfrac{1}{n}+\dfrac{n-1}{n}\times ((n-1)+1)=n+1+\dfrac{1}{n}$ 。<br>（式子中 $(n-1)+1$ 是加上了从0开始的第一步）</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sub</span>(<span class="built_in">add</span>(<span class="built_in">inv</span>(n),n),<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校05</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校06</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD06.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD06.html</id>
    <published>2024-07-31T16:00:00.000Z</published>
    <updated>2024-08-03T15:09:15.812Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81601">2024牛客暑期多校训练营6</a></p><h1>A.Cake</h1><h2 id="题意">题意</h2><p>给定一棵 $n$ 个节点，以 $1$ 为根的树，每条边有一个权值 0 或 1。<br>棋子初始在节点 $1$ ，Alice先手，Bob后手。<br>每回合，玩家可以将棋子移动到当前节点的一个子节点。<br>直到棋子达到叶子节点，游戏结束。</p><p>棋子经过的路径的权值按顺序构成一个01序列，记它的长度为 $m$ 。<br>接下来，Bob可以把 $1$ 块蛋糕任意分成 $m$ 份（某份蛋糕可以为0//空盘子）。<br>然后根据01序列决定取蛋糕的次序：0代表Bob取，1代表Alice取。</p><p>问两人都以最优策略行动和切蛋糕，问Alice最多能拿到多少蛋糕。</p><h2 id="解题思路">解题思路</h2><p>先考虑在路径确定的情况下，Bob会怎么分蛋糕：<br>Bob会找到一个前缀pre，这个前缀的“0占比”是所有前缀中最大的。<br>pre的长度记为 $t$，0占比记为 $p$。<br>Bob会将蛋糕平均分为 $t$ 份，剩下 $m-t$ 份为空。<br>这样，Bob可以保证他拿到最多的，大小为 $p$ 的蛋糕。</p><p>对于每个节点 $i$ ，先DFS一次，处理出从 $1$ 到 $i$ 这条路径上所有前缀的最大0占比。<br>那么在每个结点处。</p><p>再DFS一次，假设根节点 $1$ 的深度是1，那么：<br>深度为奇数的节点是Alice的回合，Alice会希望前缀的“0的占比”最小化；<br>深度为偶数的节点是Bob的回合，Bob会希望前缀的“0的占比”最大化。</p><p>从叶子到根更新，得到最终0占比 $p$ ，按照上面的方法分蛋糕，最终答案为 $1-p$ 。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ll n;</span><br><span class="line">vector&lt;vector&lt;pll&gt;&gt; G;</span><br><span class="line">vector&lt;ld&gt; pref; <span class="comment">//前缀中0的最大占比</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u=<span class="number">1</span>,ll fa=<span class="number">0</span>,ll cnt0=<span class="number">0</span>,ll cnt1=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>) <span class="built_in">chmax</span>(pref[u],(ld)cnt0/(cnt0+cnt1));<span class="comment">//用当前节点的0占比更新前缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">            pref[v]=pref[u];<span class="comment">//继承父节点的pref</span></span><br><span class="line">            <span class="built_in">dfs</span>(v,u,cnt0+(w==<span class="number">0</span>),cnt1+(w==<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;ld&gt; dp; <span class="comment">//节点对执棋手的最优解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_dp</span><span class="params">(ll u=<span class="number">1</span>,ll fa=<span class="number">0</span>, ll dep=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    dp[u]=dep%<span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>&amp;&amp;G[u].<span class="built_in">size</span>()==<span class="number">1</span>) dp[u]=pref[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u]) <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">        <span class="built_in">dfs_dp</span>(v,u,dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dep%<span class="number">2</span>) <span class="built_in">chmin</span>(dp[u],dp[v]); <span class="comment">//先手求pref小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">chmax</span>(dp[u],dp[v]); <span class="comment">//后手求pref大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    pref.<span class="built_in">clear</span>(); pref.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dp.<span class="built_in">clear</span>(); dp.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v,w);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(); <span class="built_in">dfs_dp</span>();</span><br><span class="line">    <span class="built_in">print_float</span>(<span class="number">1.</span>-dp[<span class="number">1</span>],<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Cake2</h1><h2 id="题意-2">题意</h2><p>给定正整数 $n,k$ ，蛋糕的形状是正 $n$ 边形，顶点编号为 $0$ 到 $n-1$ 。<br>对于每个顶点 $i$ ，沿着由 顶点 $i$ 和 $(i+k)mod\ n$ 确定的直线切一刀。<br>求最后蛋糕的块数。</p><p>以$n=6,k=2$为例，蛋糕的形状如下：<br><img src="/images/ACM/2024Summer_NCD06_B.png" alt=""></p><h2 id="解题思路-2">解题思路</h2><p>手画几个图，发现当且仅当 $n=k\times2$ 时，蛋糕的块数为 $n$ 。<br>其余情况下，发现每个交点仅由2条直线，蛋糕的块数为 $n\times k+1$ 。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n/<span class="number">2</span>) k=n-k;</span><br><span class="line">    <span class="keyword">if</span>(k*<span class="number">2</span>!=n) cout &lt;&lt; k*n+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Genshin Impact’s Fault</h1><h2 id="题意-3">题意</h2><p>给定一个字符串，包含以下字符：</p><ul><li><code>3</code>：三星卡</li><li><code>4</code>：四星卡</li><li><code>5</code>：普通五星卡</li><li><code>U</code>：特殊五星卡</li></ul><p>满足以下条件的字符串是合法的：</p><ol><li>每10个连续的字符不能都是<code>3</code></li><li>每90个连续的字符至少有1个<code>U</code>或<code>5</code></li><li>相邻两张五星卡不能都是<code>5</code></li></ol><p>判断给定字符串是否合法。</p><h2 id="解题思路-3">解题思路</h2><p>按照题意模拟判断。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;3&#x27;</span>) cnt++;</span><br><span class="line">        <span class="keyword">else</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">10</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">&#x27;5&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;U&#x27;</span>) cnt++;</span><br><span class="line">        <span class="keyword">else</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">90</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> pre=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;5&#x27;</span>||c==<span class="string">&#x27;U&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="string">&#x27;0&#x27;</span>) pre=c;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pre==<span class="string">&#x27;5&#x27;</span>&amp;&amp;c==<span class="string">&#x27;5&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> pre=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check1</span>()&amp;&amp;<span class="built_in">check2</span>()&amp;&amp;<span class="built_in">check3</span>()) cout &lt;&lt; <span class="string">&quot;valid\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;invalid\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校06</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校05</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD05.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD05.html</id>
    <published>2024-07-29T16:00:00.000Z</published>
    <updated>2024-07-30T10:01:05.925Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81600">2024牛客暑期多校训练营5</a></p><blockquote><p>玲珑骰子安红豆，入骨相思知不知。  ——温庭筠</p></blockquote><h1>B.珑</h1><h2 id="题意">题意</h2><p>使用若干个 $1\times 2$ 的小矩形，恰好覆盖一个 $n\times m$ 的大矩形（即不允许重叠、不允许有部分超出大矩形范围）</p><p>对于任意两个小矩形，可能存在以下两种限制（中的0种、1种或2种）：</p><ol><li>边长为1的边不能相贴</li><li>边长为2的边不能相贴，即使相贴部分的长度仅为1</li></ol><p>问是否存在一种方案，在满足给定限制的条件下，恰好覆盖大矩形。</p><h2 id="解题思路">解题思路</h2><p>不妨令 $n&lt;m$ ：</p><ol><li>小矩形的面积是2，所以 $n\times m$ 必须是偶数</li><li>只有 $n=1$ 的情况满足条件2</li><li>只有 $n=1且m&gt;2$ 的情况不满足条件1</li></ol><p><img src="/images/ACM/2024Summer_NCD05_B.png" alt="image"></p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>&amp;&amp;m%<span class="number">2</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 面积是奇数</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">2</span>) &#123;YES;<span class="keyword">return</span> ;&#125; <span class="comment">// 1*2只需要一块</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>&amp;&amp;n!=<span class="number">1</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 只有1*m时能满足b</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;n==<span class="number">1</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 只有1*m时不能满足a</span></span><br><span class="line">    YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.安</h1><h2 id="题意-2">题意</h2><p>May和Ray各有 $n$ 个骑士，分别按顺序排成一排，编号为 $1\sim n$ 。<br>May的骑士的生命值为 $a_i$ ，Ray的骑士的生命值为 $b_i$ 。</p><p>玩家每次操作可以选择一个双方骑士都存活的序号 $i$ ，命自己的骑士 $i$ 攻击对方的骑士 $i$ （使对方的骑士 $i$ 的生命值减少 $1$ ）。</p><p>May先行，两人都执行最优策略，直到无法操作。</p><p>问May最终剩余多少个骑士。</p><h2 id="解题思路-2">解题思路</h2><p>考虑最优策略：</p><ol><li>$a_i&gt;b_i$ ：优势，在这个位置只需要在对方攻击后反击，就能保证消灭对方。</li><li>$a_i&lt;b_i$ ：根据上一条，这个位置的骑士无法存活。</li><li>$a_i=b_i$ ：先攻击的棋子存活，一半的棋子存活，先手可以向上取整。</li></ol><p>按照最优策略，答案为 $cnt(a_i&gt;b_i)+\lceil cnt(a_i=b_i)/2 \rceil$ 。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,n);</span><br><span class="line">    ll ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[i]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[i]) ans++;</span><br><span class="line">    &#125;cout &lt;&lt; ans+(cnt+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.入</h1><h2 id="题意-3">题意</h2><p>给定一个 $n$ 个点 $m$ 条边的无向图，每个点带唯一点权 $w_i$ 。</p><p>棋子初始被放在一个点上，每次会移动到相邻的点中点权最小的一个点。</p><p>现在点权和初始位置可以自己决定，问最多能经过多少个点。</p><h2 id="解题思路-3">解题思路</h2><p>若从点 $i$ 走到点 $j$ ，其他和 $i$ 相邻的点的权值一定大于点 $j$ 的权值，因此之后都不会再走到这些点。</p><p>换句话说，走到下一个点之后，就可以把上一步的点和它的相邻点删掉了。</p><p>建图，按照以上思路，从每个点出发各一次，DFS找到最长路径长度。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ll n,m;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">ll ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll cur=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">chmax</span>(ans,cur);</span><br><span class="line">    vector&lt;ll&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u]) <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">        tmp.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        vis[v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt+=tmp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n-cnt+cur&gt;=ans)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:tmp) <span class="built_in">dfs</span>(v,cur+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:tmp) vis[v]=<span class="number">0</span>;</span><br><span class="line">    cnt-=tmp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll u,v;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    vis.<span class="built_in">clear</span>(); vis.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        vis[i]=<span class="number">1</span>; cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>L.知</h1><h2 id="题意-4">题意</h2><p>给定一个长度为 $n$ 的序列 $a$ ，每次操作可以选择一个下标 $i&lt;n$ ，执行：$a_i=a_i+1,a_{i+1}=a_{i+1}-1$ 。</p><p>求任意次操作后，序列 $a$ 的积的最大值 $mod\ 998244353$ 。</p><h2 id="解题思路-4">解题思路</h2><p>小学老师教过我们，当和一定时，数越平均，积越大。</p><p>观察到操作的特性：后面的大数字可以匀到前面，但是前面的数字不能匀给后面。</p><p>从前往后处理，把第 $i$ 个数 $a_i$ 加入答案时，<br>从当前的 前 $i-1$ 个数中，从小到大依次选取尽可能多的数（记为 $b_1\sim b_k$ ），<br>满足：$max{b_1\cdots b_k}&lt; avg{b_1 \cdots b_k,a_i}$</p><p>然后可以将 ${b_1 \cdots b_k,a_i}$ 平均化，是最优的平均方法。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// ll n=5;</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span>,vans</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    vans.<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;vans[<span class="number">0</span>])&#123;</span><br><span class="line">            ll tsum=v[i],j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;i)&#123; <span class="comment">//取出需要被匀的数</span></span><br><span class="line">                <span class="keyword">if</span>(vans[j]&gt;=tsum/(j+<span class="number">1</span>)) <span class="keyword">break</span>;  </span><br><span class="line">                <span class="comment">//如果当前的数已经大于等于平均值，就不需要被平均了</span></span><br><span class="line">                tsum+=vans[j]; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;ll&gt; temp;</span><br><span class="line">            <span class="built_in">FORLL</span>(k,j,i<span class="number">-1</span>) temp.<span class="built_in">emplace_back</span>(vans[k]);</span><br><span class="line">            ll avg=tsum/(j+<span class="number">1</span>),tt=tsum%(j+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">insert</span>(temp.<span class="built_in">end</span>(),tt,avg+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">insert</span>(temp.<span class="built_in">end</span>(),j+<span class="number">1</span>-tt,avg);</span><br><span class="line">            vans=temp;</span><br><span class="line">        &#125;<span class="keyword">else</span> vans.<span class="built_in">emplace_back</span>(v[i]);</span><br><span class="line">        <span class="built_in">SORT</span>(vans);</span><br><span class="line">    &#125; <span class="comment">// print_vec(ans);</span></span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:vans) <span class="built_in">multo</span>(ans,x);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校05</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校04</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU04.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU04.html</id>
    <published>2024-07-28T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A84%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（4）</a></p><h1>1003</h1><p>//TODO</p><h1>(1005)HDU7473.多层血条</h1><h2 id="题意">题意</h2><p>Boss血条的尺寸为 $n$ 行 $m$ 列，外层有边框。<br>行数仅代表血条的高度，不代表血量。<br>每列代表 $1$ 点血量， $m$ 列代表了 $m$ 点血量，即一层血条。</p><p>血条自底向上、从左往右平铺，最底下没有血量的部分为空格。<br>第一层血量用 <code>A</code> 表示，第二层血量用 <code>B</code> 表示，…，第五层血量用 <code>E</code> 表示，第六层血量用 <code>A</code> 表示，五层一循环，以此类推。</p><p>$n=2,m=10$ 且血量为$12$时，血条如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">|BBAAAAAAAA|</span><br><span class="line"><span class="section">|BBAAAAAAAA|</span></span><br><span class="line"><span class="section">+----------+</span></span><br></pre></td></tr></table></figure><p>为了加强打击反馈，当Boss受到伤害时，即将扣减的血量将短暂显示为<code>.</code>，然后再显示为对应的血条。</p><p>如上面的血条，当受到 $3$ 点伤害时，血条将变为：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">|..AAAAAAA.|</span><br><span class="line"><span class="section">|..AAAAAAA.|</span></span><br><span class="line"><span class="section">+----------+</span></span><br></pre></td></tr></table></figure><p>给定 $n,m$ ，血量 $hp$，即将受到的伤害 $dmg$ ，求受到伤害时的血条。</p><h2 id="解题思路">解题思路</h2><p>计算血条层数决定填充当前层（和下一层）的字符。<br>计算当前最后一个血的位置，然后根据伤害对血条进行修改。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,hp,dmg;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; hp &gt;&gt; dmg;</span><br><span class="line">    string ul=<span class="string">&#x27;+&#x27;</span>+<span class="built_in">string</span>(m,<span class="string">&#x27;-&#x27;</span>)+<span class="string">&#x27;+&#x27;</span>; <span class="comment">//边框</span></span><br><span class="line">    cout &lt;&lt; ul &lt;&lt; endl;</span><br><span class="line">    string s=<span class="string">&quot;|&quot;</span>;</span><br><span class="line">    ll k=(hp+m<span class="number">-1</span>)/m; <span class="comment">//层数</span></span><br><span class="line">    <span class="type">char</span> c=(k+<span class="number">4</span>)%<span class="number">5</span>+<span class="string">&#x27;A&#x27;</span>; <span class="comment">//当前层字符</span></span><br><span class="line">    ll cur = (hp<span class="number">-1</span>)%m+<span class="number">1</span>; <span class="comment">//当前层血量位置</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,cur) s+=c;</span><br><span class="line">    <span class="type">char</span> c1=(k<span class="number">-1</span>)&gt;<span class="number">0</span>?(k<span class="number">-2</span>)%<span class="number">5</span>+<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27; &#x27;</span>; <span class="comment">//下一层字符</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,cur+<span class="number">1</span>,m) s+=c1;</span><br><span class="line">    s+=<span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    <span class="built_in">chmin</span>(dmg,m);</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,cur,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dmg==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dmg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,m,cur+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dmg==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dmg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ul &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>1007</h1><p>//TODO</p><h1>(1009)HDU7477.昵称检索</h1><h2 id="题意-2">题意</h2><p>给定 $n$ 个字符串表示名字。<br>一个昵称由两部分组成：一个给定的名字+4位数字。<br>其中，4位数字表示一个日期。</p><p>注：日期格式为 <code>MMDD</code> ，即月份和日期，0229也算。</p><p>给定一个长度为 $m$ 的字符串，计算所有子序列中能构成不同的昵称的个数。</p><h2 id="解题思路-2">解题思路</h2><p>昵称和日期分开考虑。</p><p>要求计不同的昵称的个数，因此每种名字、日期只需要考虑一次。</p><p>名字只需要选取最早完整出现的子序列，因为早出现一定比晚出现匹配的日期个数多。<br>日期只需要选取最晚完整出现的子序列，因为晚出现一定比早出现匹配的名字个数多。</p><p>记录每种字符出现的位置，先匹配日期。<br>用 $date_i$ 表示下标为 $i$ 的位置开头的不同日期数。<br>对 $date$ 做一个后缀和， $date_i$ 就表示到当前位置开始，往后的不同日期数。</p><p>再匹配名字。<br>找到名字 $name$ 的最早出现位置 $j$ ，它能组合出的最多不同昵称数为 $date_{j+1}$，加入答案。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; days = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">toint</span><span class="params">(<span class="type">char</span> c1,<span class="type">char</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c1-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+c2-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;string&gt; names;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        names.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">char</span>,vector&lt;ll&gt;&gt; posc,posint;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>) posc[s[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> posint[s[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">date</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> d2=<span class="string">&#x27;0&#x27;</span>;d2&lt;=<span class="string">&#x27;9&#x27;</span>;d2++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(posint[d2].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">        <span class="keyword">auto</span> posd2 = posint[d2].<span class="built_in">back</span>(); <span class="comment">//最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d1=<span class="string">&#x27;0&#x27;</span>;d1&lt;=<span class="string">&#x27;3&#x27;</span>;d1++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> day=<span class="built_in">toint</span>(d1,d2);</span><br><span class="line">            <span class="keyword">if</span>(day&gt;<span class="number">31</span>||day&lt;<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//不可能的天数</span></span><br><span class="line">            <span class="keyword">if</span>(posint[d1].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">            <span class="keyword">auto</span> itposd1 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[d1]),posd2); <span class="comment">//找比posd2小的最大的位置</span></span><br><span class="line">            <span class="keyword">if</span>(itposd1==posint[d1].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posd2小的</span></span><br><span class="line">            <span class="keyword">auto</span> posd1 = *(--itposd1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> m2=<span class="string">&#x27;0&#x27;</span>;m2&lt;=<span class="string">&#x27;9&#x27;</span>;m2++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(posint[m2].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">                <span class="keyword">auto</span> itposm2 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[m2]),posd1); <span class="comment">//找比posd1小的最大的位置</span></span><br><span class="line">                <span class="keyword">if</span>(itposm2==posint[m2].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posd1小的</span></span><br><span class="line">                <span class="keyword">auto</span> posm2 = *(--itposm2);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> m1=<span class="string">&#x27;0&#x27;</span>;m1&lt;=<span class="string">&#x27;1&#x27;</span>;m1++)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> month=<span class="built_in">toint</span>(m1,m2);</span><br><span class="line">                    <span class="keyword">if</span>(month&gt;<span class="number">12</span>||month&lt;<span class="number">1</span>) <span class="keyword">continue</span>;; <span class="comment">//不可能的月份</span></span><br><span class="line">                    <span class="keyword">if</span>(day&gt;days[month]) <span class="keyword">continue</span>;; <span class="comment">//不可能的日期</span></span><br><span class="line">                    <span class="keyword">if</span>(posint[m1].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">                    <span class="keyword">auto</span> itposm1 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[m1]),posm2); <span class="comment">//找比posm2小的最大的位置</span></span><br><span class="line">                    <span class="keyword">if</span>(itposm1==posint[m1].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posm2小的</span></span><br><span class="line">                    <span class="keyword">auto</span> posm1 = *(--itposm1);</span><br><span class="line">                    date[posm1]++;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; month &lt;&lt; &#x27; &#x27; &lt;&lt; day &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,m<span class="number">-1</span>,<span class="number">0</span>) date[i]+=date[i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// print_vec(date);</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;name:names)&#123;</span><br><span class="line">        ll curi=<span class="number">-1</span>,len=name.<span class="built_in">length</span>();</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> c=name[i];</span><br><span class="line">            <span class="keyword">auto</span> it=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(posc[c]),curi);</span><br><span class="line">            <span class="keyword">if</span>(it==posc[c].<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            curi=*it;</span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>) ans+=date[curi+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校04</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校03</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU03.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU03.html</id>
    <published>2024-07-25T16:00:00.000Z</published>
    <updated>2024-08-03T12:15:50.329Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A83%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（3）</a></p><h1>(1001)HDU7457.深度自同构</h1><h2 id="题意">题意</h2><p>求由 $n$ 个节点构成，且满足“深度相同的节点，度相同”的森林的方案数。</p><h2 id="解题思路">解题思路</h2><p>先考虑 $i$ 个节点的合法的树，这棵树每个节点的子树形态相同。<br>去掉根节点，每个部分的子树形态相同，那么每个子树的节点数是 $i-1$ 的约数。<br>设 $f(i)$ 表示 $i$ 个节点满足上述条件的树的方案数，那么有：$f(i)=\sum_{d|(i-1)} f(d)$</p><p>再考虑 $n$ 个节点的合法的森林，每个树的节点数是 $n$ 的约数。<br>设 $g(n)$ 表示 $n$ 个节点满足上述条件的森林的方案数，那么有：$g(n)=\sum_{d|n} f(d)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    ll n=<span class="number">1e6</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=n;j+=i)</span><br><span class="line">            <span class="built_in">addto</span>(f[j+<span class="number">1</span>],f[i]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=n;j+=i)</span><br><span class="line">            <span class="built_in">addto</span>(g[j],f[i]);</span><br><span class="line">    <span class="comment">//寄巧：对于从约数i到倍数j的转移，可以枚举倍数k，以调和级数复杂度求</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; g[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7463.单峰数列</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的数列 $a$ ，$q$ 次操作：</p><ol><li><code>1 l r x</code>：$a[l,r]$ 每个数加 $x$</li><li><code>2 l r</code>：判断 $a[l,r]$ 是否相同</li><li><code>3 l r</code>：判断 $a[l,r]$ 是否严格单调递增，$l=r$ 时也算</li><li><code>4 l r</code>：判断 $a[l,r]$ 是否严格单调递减，$l=r$ 时也算</li><li><code>5 l r</code>：判断 $a[l,r]$ 是否单峰数列</li></ol><p>长度为 $m$ 的数列 $b$ 被称为单峰数列，当且仅当存在唯一位置 $1\lt i\lt m$ ，使得 $b[1,i]$ 严格单调递增，$b[i,m]$ 严格单调递减。</p><h2 id="解题思路-2">解题思路</h2><p>暴力判断<br>维护差分序列更直观</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; v;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">range_add</span><span class="params">(ll l,ll r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l<span class="number">-1</span>,r<span class="number">-1</span>) v[i]+=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_same</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i]!=v[l<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_up</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;=v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_down</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i<span class="number">-1</span>]&lt;=v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_mountain</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>; <span class="comment">//up</span></span><br><span class="line">    <span class="keyword">if</span>(v[l<span class="number">-1</span>]&gt;v[l]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i<span class="number">-1</span>]==v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(fl==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;v[i]) fl=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fl==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i<span class="number">-1</span>]&lt;v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fl==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    v.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll q;cin &gt;&gt; q;</span><br><span class="line">    ll op,l,r,val;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">            <span class="built_in">range_add</span>(l,r,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_same</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_up</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_down</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_mountain</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1008)HDU7464.比特跳跃</h1><h2 id="题意-3">题意</h2><p>给定一个 $n$ 个点 $m$ 条边（不保证连通，可能有重边）的无向图。<br>每条边 $E(u,v)$ 有一个权值 $w$ ，表示从 $u$ 到 $v$ 的代价。<br>此外，对于任意两点 $u,v$ ，可以付出 $k\times(u|v)$ （按位或）的代价从 $u$ 跳到 $v$ 。<br>分别求从节点 $1$ 到所有其他点 $2$ ~ $n$ 的最小代价。</p><h2 id="解题思路-3">解题思路</h2><p>最暴力的想法肯定是把直接跳跃也看作边加入图中，然后跑单源最短路。<br>但是这样边的数量是 $n^2$ ，显然不可取。<br>因此考虑哪些边是有必要加的。</p><p>$1$ 直接跳到其他节点的方案是很优的：<br>若节点 $i$ 不在节点 $1$ 所在的连通块内，那么 $1$ 直接跳到 $i$ 的代价只可能是 $i$ （$i$ 为奇数）或 $i+1$ （$i$ 为偶数）。</p><p>但如果存在 $E(1,2,0)$ ，对于 $x=2,6,10…$ 这一类满足 $x%4=2$ 的节点， $1$ 直接跳到 $x$ 的代价为 $x+1$ ，但先走到 $2$ 再跳到 $x$ 的代价仅为 $x$ 。</p><p>因此，对于 $x%4=2$ 的节点，需要加入 $E(2,x,k(x|2))$ 。</p><p>同理，对于 $x%2^{i+1}=2^i$ 的节点，需要加入 $E(2,x,k(x|2^i))$ 。</p><p>最后，跑一遍单调队列优化的单源最短路，求出答案。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">pow2</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">60</span>;i++) pow2.<span class="built_in">emplace_back</span>(pow2.<span class="built_in">back</span>()*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="function">Dijkstra <span class="title">dij</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ll u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        dij.<span class="built_in">addedge</span>(u,v,w);</span><br><span class="line">        dij.<span class="built_in">addedge</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n) dij.<span class="built_in">addedge</span>(<span class="number">1</span>,i,k*(<span class="number">1</span>|i));</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">60</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pow2[i]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll j=pow2[i]*<span class="number">2</span>;j&lt;=n;j+=pow2[i]) <span class="keyword">if</span>(pow2[i]&amp;j)</span><br><span class="line">            dij.<span class="built_in">addedge</span>(pow2[i],j,k*(pow2[i]|j));</span><br><span class="line">    &#125;</span><br><span class="line">    dij.<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n) cout &lt;&lt; dij[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7467.抓拍</h1><h2 id="题意-4">题意</h2><p>$n$ 个人，第 $i$ 个人初始在 $(x_i,y_i)$ 。<br>每个人有一个行进方向：东（E,+x方向）、西（W,-x方向）、南（S,-y方向）、北（N,+y方向），每秒移动一个距离。<br>散步无限长时间、不改变方向、忽略碰撞。</p><p>求一个周长最小的矩形满足：</p><ol><li>上下边平行于 $x$ 轴，左右边平行于 $y$ 轴</li><li>存在一个时刻，所有人都在矩形内部</li></ol><h2 id="解题思路-4">解题思路</h2><p>每个时刻的最小周长矩形只由 最上面、最下面、最左边、最右边 的四个人决定，那么就考虑可能成为这四个人的人。</p><p>左右移动的人占据的y区间，上下移动的人占据的x区间，不会改变。<br>记录：左右走的人里最靠上、最靠下的人，上下走的人里最靠左、最靠右的人。</p><p>因为时间无限长，最后在最上面的人，一定是向上走的人中初始点最靠上的，其他方向同理。<br>记录：向上走的人里最靠上的、向下走的人里最靠下的，向左走的人里最靠左的、向右走的人里最靠右的。</p><p>开始最靠下的人如果是向左/右/下走的，已经记录了，只要在向上走的人中找到最靠下的，其他方向同理。<br>记录：向上走的人里最靠下的、向下走的人里最靠上的、向左走的人里最靠右的、向右走的人里最靠左的。</p><p>有了这12个值，就可以计算出任何一个时刻的 $x_{min},x_{max},y_{min},y_{max}$ ，从而计算出最小周长。</p><p>模拟可知，周长对时间的函数，要么是单调增的，要么是一个开口向上的二次函数（因为最后人一定越走越散）。因此可以三分找到极小值点，即为答案。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           E W S N</span></span><br><span class="line"><span class="comment">//           R L D U</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pll a,pll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">&#125;</span><br><span class="line">ll yLRmax,yLRmin,xUDmax,xUDmin;</span><br><span class="line">ll xLmin,xLmax,xRmin,xRmax,yUmin,yUmax,yDmin,yDmax;</span><br><span class="line"><span class="function">ll <span class="title">getC</span><span class="params">(ll t)</span></span>&#123;</span><br><span class="line">    ll xmin = <span class="built_in">min</span>(&#123;xLmin-t,xRmin+t,xUDmin&#125;);</span><br><span class="line">    ll xmax = <span class="built_in">max</span>(&#123;xLmax-t,xRmax+t,xUDmax&#125;);</span><br><span class="line">    ll ymin = <span class="built_in">min</span>(&#123;yDmin-t,yUmin+t,yLRmin&#125;);</span><br><span class="line">    ll ymax = <span class="built_in">max</span>(&#123;yDmax-t,yUmax+t,yLRmax&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*((xmax-xmin)+(ymax-ymin));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    vector&lt;pll&gt; L,R,U,D;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;E&#x27;</span>) R.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) L.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;N&#x27;</span>) U.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) D.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右移动的最上和最下两个人，上下移动的最左和最右两个人</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(L),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(R),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(U)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(D));</span><br><span class="line">    yLRmax = xUDmax = -INF;</span><br><span class="line">    yLRmin = xUDmin = INF;</span><br><span class="line">    <span class="keyword">if</span>(L.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(yLRmax,L.<span class="built_in">back</span>().second);<span class="built_in">chmin</span>(yLRmin,L.<span class="built_in">front</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(R.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(yLRmax,R.<span class="built_in">back</span>().second);<span class="built_in">chmin</span>(yLRmin,R.<span class="built_in">front</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(U.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(xUDmax,U.<span class="built_in">back</span>().first);<span class="built_in">chmin</span>(xUDmin,U.<span class="built_in">front</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(D.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(xUDmax,D.<span class="built_in">back</span>().first);<span class="built_in">chmin</span>(xUDmin,D.<span class="built_in">front</span>().first);&#125;</span><br><span class="line">    <span class="comment">//初始状态，向左的最左最右，向右的最左最右，向上的最上最下，向下的最上最下</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(L)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(R)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(U),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(D),cmp);</span><br><span class="line">    xLmin = xRmin = yUmin = yDmin = INF;</span><br><span class="line">    xLmax = xRmax = yUmax = yDmax = -INF;</span><br><span class="line">    <span class="keyword">if</span>(L.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(xLmin,L.<span class="built_in">front</span>().first);<span class="built_in">chmax</span>(xLmax,L.<span class="built_in">back</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(R.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(xRmin,R.<span class="built_in">front</span>().first);<span class="built_in">chmax</span>(xRmax,R.<span class="built_in">back</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(U.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(yUmin,U.<span class="built_in">front</span>().second);<span class="built_in">chmax</span>(yUmax,U.<span class="built_in">back</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(D.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(yDmin,D.<span class="built_in">front</span>().second);<span class="built_in">chmax</span>(yDmax,D.<span class="built_in">back</span>().second);&#125;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">2e9</span>;</span><br><span class="line">    <span class="comment">//三分找到getC最小的t</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        ll m1 = l+(r-l)/<span class="number">3</span>;</span><br><span class="line">        ll m2 = r-(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getC</span>(m1)&lt;<span class="built_in">getC</span>(m2)) r=m2;</span><br><span class="line">        <span class="keyword">else</span> l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mnans=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r) <span class="built_in">chmin</span>(mnans,<span class="built_in">getC</span>(i));</span><br><span class="line">    cout &lt;&lt; mnans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1012)HDU7468.死亡之组</h1><h2 id="题意-5">题意</h2><p>给定一个长度为 $n$ 的数组 $a$ （$n$ 是4的倍数），$a_i$ 表示第 $i$ 个队伍的实力。<br>每4个队伍一组，“死亡之组”至少符合以下条件之一：</p><ol><li>至少有2个队伍的实力 $&gt; L$</li><li>最大实力和最小实力之差 $\le D$</li></ol><p>问是否存在一种分组方案使得第 $1$ 组所在的小组不是“死亡之组”。</p><h2 id="解题思路-5">解题思路</h2><p>为了不满足条件1，存在至少3个队伍的实力 $\le L$ 即可。<br>然后把这3个队伍 $t_1,t_2,t_3$ 拿出来。<br>为了不满足条件2，所有队伍的实力中，最大值和最小值之差 $&gt; D$ 即可。<br>然后把实力最大的队伍 $t_4$ 拿出来。</p><p>对队伍1（$a_1$）进行讨论：</p><ul><li>如果 $a_1&gt;L$，替换 $t4$ ，重新判定</li><li>如果 $a_1\le L$，替换 $t3$</li></ul><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,l,d;cin &gt;&gt; n &gt;&gt; l &gt;&gt; d;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll t1 = v[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll cntll=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) <span class="keyword">if</span>(x&lt;l) cntll++;</span><br><span class="line">    <span class="keyword">if</span>(cntll&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t1&gt;=l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1-v.<span class="built_in">front</span>()&lt;=d) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">back</span>()-v.<span class="built_in">front</span>()&lt;=d) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校03</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校04</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD04.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD04.html</id>
    <published>2024-07-24T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.295Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81599">2024牛客暑期多校训练营4</a></p><h1>A.LCT</h1><h2 id="题意">题意</h2><p>给定一棵有根树，问按顺序给定的前 $i$ 条边组成的森林中，以 $c_i$ 为根的树的深度。</p><h2 id="解题思路">解题思路</h2><p>按步骤生成森林的过程，与并查集合并的过程一致。<br>因此用带权并查集，维护每个点的深度和答案，利用路径压缩降低时间复杂度。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">    vector&lt;ll&gt; parents, size, dep, ans;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DSU</span><span class="params">(ll n)</span> : parents(n + <span class="number">1</span>), size(n + <span class="number">1</span>, <span class="number">1</span>), dep(n + <span class="number">1</span>, <span class="number">0</span>), ans(n + <span class="number">1</span>, <span class="number">0</span>) &#123;</span> <span class="built_in">iota</span>(parents.<span class="built_in">begin</span>(), parents.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == parents[x]) <span class="keyword">return</span> x;</span><br><span class="line">        ll px = <span class="built_in">find</span>(parents[x]);</span><br><span class="line">        dep[x]+=dep[parents[x]]; </span><br><span class="line">        <span class="keyword">return</span> parents[x]=px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// merge b into a</span></span><br><span class="line">        ll pa = <span class="built_in">find</span>(a);</span><br><span class="line">        parents[b] = a;</span><br><span class="line">        dep[b] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="built_in">chmax</span>(ans[pa],ans[b]+dep[b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> ans[x];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll a,b,q;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(a,b);</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        cout &lt;&lt; dsu.<span class="built_in">query</span>(q) &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Sort4</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的排列 $p$ （即序列中 $1$ ~ $n$ 的每个数恰好出现一次）。<br>每次操作可以选择4个元素，并任意交换它们的位置。<br>求使得排列变为升序的最少操作次数。</p><h2 id="解题思路-2">解题思路</h2><p>把排列看作由 $i\rightarrow p_i$（下标从1开始） 构成的图，这个图中有若干个环，表示这个环中的元素可以通过交换回到原来的位置。</p><p>长度为 $3,4$ 的环，可以通过一次操作还原；<br>长度为 $2$ 的环，可以 $2$ 个环一组通过一次操作还原；<br>长度大于 $4$ 的环，每次操作可以让 $3$ 个元素回到原来的位置，使得环的长度减少 $3$，直到环的长度小于等于 $4$。</p><p>根据这个原则，计算最终答案。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    ll ans=<span class="number">0</span>,of=<span class="number">0</span>; <span class="comment">//of:最终长度为2的环的数量</span></span><br><span class="line">    map&lt;ll,ll&gt; mp;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        ll cnt=<span class="number">1</span>,cur=v[i];</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=i)&#123;</span><br><span class="line">            vis[cur]=<span class="number">1</span>;</span><br><span class="line">            cur = v[cur];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">1</span>) ans+=(cnt<span class="number">-1</span>)/<span class="number">3</span>; <span class="comment">//最终长度为4的环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">2</span>)&#123; <span class="comment">//最终长度为2的环</span></span><br><span class="line">            ans+=(cnt<span class="number">-2</span>)/<span class="number">3</span>;</span><br><span class="line">            of++;</span><br><span class="line">        &#125;<span class="keyword">else</span> ans+=cnt/<span class="number">3</span>; <span class="comment">//最终长度为3的环</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans+(of+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Yet Another Origami Problem</h1><h2 id="题意-3">题意</h2><p>给定一个长度为 $n$ 的序列 $a$，每次可以选择一个元素 $a_i$，执行以下操作之一：</p><ol><li>所有原来比 $a_i$ 小的数 $a_j$ ： $a_j=a_i+2(a_i-a_j)$ ，即原来 $a_j$ 比 $a_i$ 小多少，现在就比 $a_i$ 大多少。</li><li>所有原来比 $a_i$ 大的数 $a_j$ ： $a_j=a_i-2(a_j+a_i)$ ，即原来 $a_j$ 比 $a_i$ 大多少，现在就比 $a_i$ 小多少。</li></ol><p>问任意次操作后，序列 $a$ 中最大元素和最小元素之差 $max(a)-min(a)$ 的最小值。</p><h2 id="解题思路-3">解题思路</h2><p>每次操作：</p><ol><li>对序列 $a$ 排序去重，求出差分数组 $d$ 。</li><li>选定次小元素 $a_2$ ，执行操作 $1$ ，使得最小元素 $a_1 = a_2 - d_1$ 变成 $a_1’ = a_2 + d_1$ 。</li></ol><p>假设重新排序去重后，新的 $a_1’$ 相邻的两项为 $a_j,a_{j+1}$ ，步骤1中这两项的差分是 $d_j=a_{j+1}-a_j$ 。<br>那么当 $a_i’$ 插到中间时，新的差分数组的变化如下：</p><ol><li>第1项 $d_1$ 删去（因为 $a_1$ 变成了 $a_1’$ 后移）</li><li>原本的 $d_j$ 被替换为 $d_j’=d_1-\sum\limits_{k=2}^{j-1}d_k$ ，$d’_{j+1}=d_j-d_j’$ 。</li></ol><p>第2点变化可能比较难理解，给出如下例子：</p><ul><li>$a = [1,6,8,10,13,15]$ （原序列排序去重）</li><li>$d = [5,2,2,3,2]$ （差分数组）</li><li>$a_1=1,a_2=6,d_1=5$ （选定次小元素做操作1）</li><li>$a_1’=a_2+d_1=11$</li><li>$a’ = [6,8,10,11,13,15]$ （新序列排序去重，$a_1’$ 位于第4位）</li><li>$d’ = [2,2,1,2,2]$ （新差分数组）</li></ul><p>差分数组的变化：</p><ol><li>第1项 $d_1=5$ 删去</li><li>第4项 $3$ 变为：$d_1-d_2-d_3=1$ 和 $3-1=2$</li></ol><p>这个变化的意义就在于，它证明了任意次操作后的差分数组中的元素，是原差分数组中元素的线性组合，且随着操作次数增加，$\sum d_i$ 逐渐减小，直到 $a$ 仅剩2个元素。<br>线性组合能达到的最小值为 $\gcd\limits_{i=1}^{n-1}d_i$ 。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">        ans = __gcd(ans,v[i]-v[i<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.Horse Drink Water</h1><h2 id="题意-4">题意</h2><p>将军饮马问题，将军在第一象限的整点 $(x_0,y_0)$ ，河流由 $x$ 正半轴和 $y$ 正半轴组成。<br>问将军碰到河流再前往 $(x_1,y_1)$ 的最短路径长度。</p><h2 id="解题思路-4">解题思路</h2><p>将起点以 $x$ 轴、 $y$ 轴为对称轴，分别对称到第四、二象限，比较这两个点和终点的距离，取最小值。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ld xx1,xx2,yy1,yy2;</span><br><span class="line">    cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;</span><br><span class="line">    ld ans1,ans2;</span><br><span class="line">    ans1 = <span class="built_in">sqrt</span>((xx1-xx2)*(xx1-xx2)+(yy1+yy2)*(yy1+yy2));</span><br><span class="line">    ans2 = <span class="built_in">sqrt</span>((xx1+xx2)*(xx1+xx2)+(yy1-yy2)*(yy1-yy2));</span><br><span class="line">    <span class="built_in">print_float</span>(<span class="built_in">min</span>(ans1,ans2),<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I</h1><p>// TODO</p>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校04</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校03</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD03.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD03.html</id>
    <published>2024-07-22T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.295Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81598">2024牛客暑期多校训练营3</a></p><h1>A.Bridging the Gap 2</h1><h2 id="题意">题意</h2><p>$n$个人过河，第 $i$ 个人初始有 $h_i$ 点体力。<br>由于船的限制，每次过河（或返回）至少需要乘坐 $l$ 人（来划船），至多可以乘坐 $r$ 人，<strong>每个</strong>乘船的人都会消耗 $1$ 点体力。体力为 $0$ 的人无法乘船。<br>求对于给定的条件，是否能够使所有人过河。</p><h2 id="解题思路">解题思路</h2><p>假设初始所有人在左岸，考虑一种贪心模拟的做法：</p><ul><li>从在左岸的所有人中选取 $l$ 个体力最大的人划船，带 $r-l$ 个体力最小的人去右岸。</li><li>从在右岸的所有人中选取 $l$ 个体力最大的人划船返回左岸。</li><li>重复以上步骤，直到所有人都到达右岸，或者无法继续。</li></ul><p>这个过程中，除去最后一次划到右岸的 $r$ 个人，每次能运输的人数为 $r-l$ 。<br>最低<strong>往返</strong>的次数为 $turn = \lceil \dfrac{n-r}{r-l}\rceil$ ，且最优，因为往返越少对体力的要求越低。</p><p>对于个人，除自己前往右岸的1点体力，多余的体力可以用于划船带人，往返一次需要2点体力。<br>因此第 $i$ 个人能够参与的往返次数为 $\lfloor \dfrac{h_i-1}{2}\rfloor$ 。<br>由于只存在 $turn$ 次往返，因此第 $i$ 个人能够参与的往返次数为 $\min(\lfloor \dfrac{h_i-1}{2}\rfloor,turn)$ 。</p><p>计算所有人能够参与的往返次数之和，如果大于等于 $turn*l$ ，则按照上述贪心模拟的方法，可以使所有人过河。</p><h2 id="参考程序">参考程序</h2><blockquote><p>程序是副机长根据解题思路写的，居然A了()</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,l,r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll turn = (n-r)/(r-l) + ((n-r)%(r-l)!=<span class="number">0</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) sum += <span class="built_in">min</span>((x<span class="number">-1</span>)/<span class="number">2</span>,turn);</span><br><span class="line">    cout &lt;&lt; (sum&gt;=turn*l?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Crash Test</h1><h2 id="题意-2">题意</h2><p>初始距离墙壁的距离为 $d$ 。<br>每次前进有 $n$ 种长度可以选择：$h_1,h_2,\cdots,h_n$。每次前进的长度可以是任意一种长度。<br>如果选择的长度 $h_i$ 大于当前与墙壁的距离 $d’$ ，将会退后多余的距离，即新的距离为 $h_i - d’$ 。<br>求在任意次（包括0次）前进后，与墙壁的最小距离。</p><h2 id="解题思路-2">解题思路</h2><p><a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593">裴蜀定理</a>：对于非0整数 $a,b$ ，对任意整数 $x,y$ 有 $gcd(a,b)|ax+by$ 成立，即 $gcd(a,b)$ 是所有 $a,b$ 的线性组合中，绝对值最小的非0整数。</p><p>裴蜀定理扩展到多整数的情况仍然成立。</p><p>因此计算出 $g=\gcd\limits_{i=1}^n(h_i)$ ，$g$ 的意义是通过对 $h_i$ 的某种线性组合，能够得到的最小前进距离。</p><p>然后每一步视为走 $g$ ，以此求得不撞墙答案 $d%g$ 与撞墙答案 $g-d%g$ ，取较小值即可。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,d; cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll g = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) g = __gcd(g,x);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(d%g,g-d%g) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Dominoes!</h1><p>//TODO</p><h1>J.Rigged Games</h1><p>//TODO</p><h1>L.Sudoku and Minesweeper</h1><h2 id="题意-3">题意</h2><p>经典数独在 $9\times 9$ 大小的棋盘格内进行，每一行、每一列、$9$ 个 $3\times 3$ 的小方块内，数字 $1-9$ 恰好出现一次。</p><p>扫雷是一款在棋盘格内进行的游戏，中心数字表示周围 $8$ 格包含地雷的数量。</p><p>现给定一个 $9\times 9$ 数字矩阵表示一个已经完成的合法经典数独，可以将里面的数字替换成地雷，但必须保留至少 $1$ 个数字，求一个合法的扫雷游戏布局。</p><h2 id="解题思路-3">解题思路</h2><p>除了边缘之外，中间 $7\times 7$ 范围内必然出现数字 $8$ 。<br>这是一个特殊的数字，只需要把它保留，其余所有数字全部替换成地雷，就是一个合法的扫雷游戏布局。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">vs</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;s:vs) cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>,i8,i8;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">7</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vs[i][j]==<span class="string">&#x27;8&#x27;</span>)&#123;</span><br><span class="line">                i8=i; i8=j; fl=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(fl) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==i8&amp;&amp;j==i8) cout &lt;&lt; <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校03</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校02</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU02.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU02.html</id>
    <published>2024-07-21T16:00:00.000Z</published>
    <updated>2024-08-25T05:58:05.948Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A82%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（2）</a></p><h1>(1001)HDU7445.鸡爪</h1><p><strong>构造</strong></p><h2 id="题意">题意</h2><p>一个鸡爪由一个中心节点和3条（不含端点的）边构成。如下图中，三条边和节点 $1$ 构成一个鸡爪，节点 $2,3,4$ 不属于这个鸡爪。<br><img src="/images/ACM//2024Summer_HDU02_1001_1.png" alt="image"></p><p>给定正整数 $n$ ，允许使用 $n$ 条边和任意个节点。要求构造一张图，在包含尽可能最多的鸡爪的条件下，按顺序输出图的 $n$ 条边时的字典序最小。</p><h2 id="解题思路">解题思路</h2><p>不限制节点数的情况下，想要构造最多$n/3$（整除）个的鸡爪是很容易的，问题的关键是如何构造使得字典序最小。</p><p>先讨论 $n$ 是3的倍数的情况。<br>由于一个中心点只能被一个鸡爪使用，贪心的想法便是让节点 $1$~$n/3$ 成为中心点，且依次尽量让节点 $1,2,3$ 连接更多的点。</p><p>$4$~$n/3$ 这些点首先作为中心点和 $1,2,3$ 相连。<br>$1,2,3$ 三个点互相连接后，无法构成以 $1,2,3$ 为中心的鸡爪，因此需要借助 $n/3+1, n/3+2, n/3+3$ 这三个点进行构造。</p><p>连接图如下：<br><img src="/images/ACM/2024Summer_HDU02_1001_2.png" alt="image"></p><p>其他情况：<br>对于 $n$ 不是3的倍数的情况，将多余的1或2个点连接到节点1上。<br>$n\le 6$时，由于节点数太少，需要单独构造。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;pll&gt;&gt; ans=&#123;</span><br><span class="line">    &#123;&#125;, <span class="comment">// 0</span></span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;&#125;, <span class="comment">// 1</span></span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">6</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#125;, <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:ans[n])&#123;</span><br><span class="line">            cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pll&gt; edges;</span><br><span class="line">    ll cnt = n/<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,cnt+<span class="number">3</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">1</span>,i); </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">3</span>,cnt+<span class="number">2</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">2</span>,i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">4</span>,cnt+<span class="number">1</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">3</span>,i); </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n%<span class="number">3</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">1</span>,cnt+<span class="number">3</span>+i);</span><br><span class="line">    <span class="built_in">SORT</span>(edges);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:edges)&#123;</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Test:&quot; &lt;&lt; edges.size() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1003)HDU7447.绝对不模拟的简单魔方</h1><h2 id="题意-2">题意</h2><p>给定一个三阶魔方，用$1$~$6$表示6个面的颜色。<br>魔方从初始还原状态起，侧面被扭转了不超过3次，且有一个角上的两片颜色贴纸可能贴错。<br>确定魔方的贴纸是否被贴错。如果有贴错，输出贴错那个角的三个颜色。</p><h2 id="解题思路-2">解题思路</h2><p>扭转三次的操作对于魔方的角来说没有任何影响，只是虚晃一枪（题目中也提示了“绝对不模拟”）。</p><blockquote><p>但是赛时还是有神速度写模拟而且一遍过了%%%%</p></blockquote><p>只需要先把正常状态的魔方的8个角按同一顺序（如顺时针）记录下来，统一以$1,6$开头以唯一确定三元组。<br>再把输入的魔方的8个角按同一顺序（顺时针）记录下来，统一以$1,6$开头，然后在正常状态的记录中查找，找不到的就是被贴错贴纸的角。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cor</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">cor</span>(<span class="type">int</span> _a,<span class="type">int</span> _b,<span class="type">int</span> _c):<span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b),<span class="built_in">c</span>(_c)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(cor t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==t.a&amp;&amp;b==t.b&amp;&amp;c==t.c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">srt</span><span class="params">()</span></span>&#123; <span class="comment">//按大小排序</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(b&gt;c) <span class="built_in">swap</span>(b,c);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mkstd</span><span class="params">()</span></span>&#123; <span class="comment">//把三元组化为以1或6开头的形式</span></span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">6</span>)&#123;</span><br><span class="line">            t=a; a=b; b=c; c=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//原始魔方八个角，顺时针</span></span><br><span class="line">vector&lt;cor&gt; std_cor = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">mf</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:mf) cin &gt;&gt; s;</span><br><span class="line">    vector&lt;cor&gt; corners=&#123;<span class="comment">//给定魔方的八个角，顺时针</span></span><br><span class="line">        &#123;mf[<span class="number">0</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">11</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">8</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">11</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">8</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">9</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">0</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">5</span>][<span class="number">8</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">8</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">9</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">6</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">2</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">6</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">2</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cor:corners) cor.<span class="built_in">mkstd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cor:corners)&#123;</span><br><span class="line">        <span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; st:std_cor) <span class="keyword">if</span>(st==cor) &#123;fl=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(fl) <span class="keyword">continue</span>;</span><br><span class="line">        cor.<span class="built_in">srt</span>();</span><br><span class="line">        cout &lt;&lt; cor.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cor.b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cor.c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No problem&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1006)HDU7450.传奇勇士小凯</h1><h2 id="题意-3">题意</h2><p>一棵以 $1$ 为根， $n$ 个节点的树，在第 $i$ 个节点处，每天有 $\dfrac{p_i}{15}$ 的概率可以离开当前节点，并选择一个子节点走一步。<br>从根节点 $1$ 走到任意叶子节点的最大天数的期望。</p><h2 id="解题思路-3">解题思路</h2><p>在第 $i$ 个节点处，记停留在该节点的期望天数为 $x$ ，有 $\dfrac{p_i}{15}$ 的概率可以离开（停留 $1$ 天），有 $1-\dfrac{p_i}{15}$ 的概率停留在当前节点（停留 $x+1$ 天）。<br>有 $x = \dfrac{p_i}{15} + \dfrac{15-p_i}{15} \cdot (1+x)$ 成立，解得 $x = \dfrac{15}{p_i}$ 。</p><p>问题转换为选择一条以节点 $1$ 开头，以叶子节点结尾的路径，使得路径上的每个节点的期望天数 $\dfrac{15}{p_i}$ 之和最大。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">form</span><span class="params">(pll&amp; p)</span></span>&#123; <span class="comment">//化简</span></span><br><span class="line">    ll g = __gcd(p.first,p.second);</span><br><span class="line">    p.first/=g;</span><br><span class="line">    p.second/=g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">smaller</span><span class="params">(pll a,pll b)</span></span>&#123; <span class="comment">//a&lt;b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span>*a.first/a.second&lt;<span class="number">1.</span>*b.first/b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addto</span><span class="params">(pll&amp; a,pll b)</span></span>&#123; <span class="comment">//a+=b</span></span><br><span class="line">    a.first=a.first*b.second+a.second*b.first;</span><br><span class="line">    a.second*=b.second;</span><br><span class="line">    form(a);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;ll&gt; vdfs; <span class="comment">//dfs序列</span></span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;ll&gt; fa;</span><br><span class="line">vector&lt;pll&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x,ll f)</span></span>&#123;</span><br><span class="line">    fa[x]=f;</span><br><span class="line">    vdfs.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) <span class="keyword">if</span>(y!=f) <span class="built_in">dfs</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    fa.<span class="built_in">clear</span>(); fa.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    ans.<span class="built_in">clear</span>(); ans.<span class="built_in">resize</span>(n+<span class="number">1</span>,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    vdfs.<span class="built_in">clear</span>();</span><br><span class="line">    ll u,v,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125; <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ans[i]=&#123;<span class="number">15</span>,t&#125;; <span class="comment">//直接存入第i个节点的期望</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(vdfs));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> cur:vdfs)&#123; <span class="comment">//逆DFS序遍历</span></span><br><span class="line">        pll mx=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[cur]) <span class="keyword">if</span>(y!=fa[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">smaller</span>(mx,ans[y])) mx=ans[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ans[cur],mx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans[<span class="number">1</span>].first &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; ans[<span class="number">1</span>].second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7451.URL划分</h1><h2 id="题意-4">题意</h2><p>给定字符串URL，形如：<code>s3://hdu-oj-bucket/problem=1/type=data/</code><br>从中提取出：</p><ul><li>传输协议：<code>://</code>之前的内容，如<code>s3</code></li><li>网络位置：<code>://</code>之后，第一个<code>/</code>之前的内容，如<code>hdu-oj-bucket</code></li><li>环境变量：由<code>/</code>分割，形如<code>A=B</code>的内容，如<code>problem=1</code>，<code>type=data</code></li></ul><h2 id="解题思路-4">解题思路</h2><p>按题目要求提取即可</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    string protocol;</span><br><span class="line">    string location;</span><br><span class="line">    vector&lt;string&gt; var;</span><br><span class="line">    string varname,val;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>(),i=<span class="number">0</span>,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;:&#x27;</span>)&#123;</span><br><span class="line">            protocol = s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">    &#125; i+=<span class="number">3</span>;</span><br><span class="line">    ll j=i;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            location = s.<span class="built_in">substr</span>(j,i-j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; i++;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123; <span class="comment">//匹配varname=val，以/分隔</span></span><br><span class="line">        j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">&#x27;=&#x27;</span>&amp;&amp;s[j]!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">        <span class="keyword">if</span>(s[j]==<span class="string">&#x27;/&#x27;</span>)&#123; <span class="comment">//跳过</span></span><br><span class="line">            i=j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            varname=s.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            i=j+<span class="number">1</span>; j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">            val=s.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            var.<span class="built_in">emplace_back</span>(varname+<span class="string">&quot;=&quot;</span>+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; protocol &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; location &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:var) cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写完python才发现hduOJ不支持python…</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    url = <span class="built_in">input</span>()</span><br><span class="line">    protocol, location, *path = re.split(<span class="string">r&quot;://|/&quot;</span>, url)</span><br><span class="line">    variables = [p <span class="keyword">for</span> p <span class="keyword">in</span> path <span class="keyword">if</span> <span class="string">&quot;=&quot;</span> <span class="keyword">in</span> p]</span><br><span class="line">    <span class="built_in">print</span>(protocol)</span><br><span class="line">    <span class="built_in">print</span>(location)</span><br><span class="line">    <span class="keyword">for</span> variable <span class="keyword">in</span> variables:</span><br><span class="line">        <span class="built_in">print</span>(variable)</span><br></pre></td></tr></table></figure><h1>(1010)HDU7454.女神的睿智</h1><h2 id="题意-5">题意</h2><p>给定长度为$8$的字符串，由<code>R,G,B</code>三种字符组成。<br>进行以下三轮操作，每轮操作从左往右两两合并：</p><ol><li>颜色相同时，合并为该颜色；颜色不同时，合并为左侧颜色</li><li>颜色相同时，合并为该颜色；颜色不同时，合并为左侧颜色</li><li>颜色相同时，合并为该颜色；颜色不同时，比较两种颜色在初始字符串中的数量，合并为数量多的一种；数量相同时，合并为随机颜色</li></ol><p>求最终合并后的颜色：<code>R,G,B</code>或不确定颜色<code>N</code></p><h2 id="解题思路-5">解题思路</h2><p>按题目要求模拟即可</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,s2; cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) mp[c]++;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i+=<span class="number">2</span>) s2.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i+=<span class="number">2</span>) s.<span class="built_in">push_back</span>(s2[i]);</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==s[<span class="number">1</span>]) cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mp[s[<span class="number">0</span>]]!=mp[s[<span class="number">1</span>]]) cout &lt;&lt; s[mp[s[<span class="number">0</span>]]&lt;mp[s[<span class="number">1</span>]]] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;N&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7455.在 A 里面找有 C 的 B</h1><p>//TODO</p>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校02</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校01</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU01.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU01.html</id>
    <published>2024-07-18T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A81%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（1）</a></p><h1>(1001)HDU7433.循环位移</h1><p><strong>字符串</strong></p><h2 id="题意">题意</h2><p>给定两个字符串 $A,B$ 。<br>定义 $[A]$ 为字符串 $A$ 的循环位移任意次可以得到的所有字符串的集合。<br>求 $B$ 包含 $[A]$ 中元素的个数。</p><h2 id="解题思路">解题思路</h2><p>利用字符串Hash快速匹配。<br>将 $[A]$ 中所有元素的Hash记录到一个set：计算 $A+A$ 的Hash前缀和，以快速得到所有长度为 $|A|$ 的子串的Hash值，并加入set中。<br>枚举 $B$ 的所有长度为 $|A|$ 的子串，计算Hash值，判断是否在set中，计数。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll n=a.<span class="built_in">length</span>(),m=b.<span class="built_in">length</span>();</span><br><span class="line">    set&lt;pll&gt; st;</span><br><span class="line">    <span class="function">strHash <span class="title">sa</span><span class="params">(a+a)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        st.<span class="built_in">insert</span>(sa.<span class="built_in">findz</span>(i,i+n<span class="number">-1</span>));</span><br><span class="line">    <span class="function">strHash <span class="title">sb</span><span class="params">(b)</span></span>;</span><br><span class="line">    ll ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m-n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">count</span>(sb.<span class="built_in">findz</span>(i,i+n<span class="number">-1</span>))) ans++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1002)HDU7434.星星</h1><p><strong>背包DP</strong></p><h2 id="题意-2">题意</h2><p>小A要进行n次选择，每次可以选择一项：</p><ol><li>不执行操作</li><li>付出$a_i$点代价得到1颗星星</li><li>付出$b_i$点代价得到2颗星星</li><li>付出$c_i$点代价得到3颗星星</li><li>付出$d_i$点代价得到4颗星星</li></ol><p>求恰好得到$k$颗星星的最小代价。</p><h2 id="解题思路-2">解题思路</h2><p>一眼顶针鉴定为背包DP的分组背包问题。</p><p>$dp_x$表示选x个物品的最低cost。<br>在第$i$组时，从大到小遍历作出选择后有$j$个星星。<br>遍历这一步的选择（ $l$ 个星星），从 $dp_{j-l}$ 更新到 $dp_j$ ，这样更新保证了一次操作只生效一项。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;array&lt;ll,5&gt;&gt; <span class="built_in">cost</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(k+<span class="number">1</span>,INF)</span></span>; dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//选i个物品的最低cost</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; cost[i][<span class="number">1</span>] &gt;&gt; cost[i][<span class="number">2</span>] &gt;&gt; cost[i][<span class="number">3</span>] &gt;&gt; cost[i][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123; <span class="comment">//第i步</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,k,<span class="number">1</span>)&#123; <span class="comment">//选择后的个数</span></span><br><span class="line">            <span class="built_in">FORLL</span>(l,<span class="number">0</span>,<span class="number">4</span>)&#123; <span class="comment">//这一步选择l个</span></span><br><span class="line">                <span class="keyword">if</span>(j-l&gt;=<span class="number">0</span>) <span class="built_in">chmin</span>(dp[j],dp[j-l]+cost[i][l]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1008)HDU7440.位运算</h1><h2 id="题意-3">题意</h2><p>给定整数$n,k$，求满足 $((a\otimes b)\oplus c)\ominus d=n$ 的四元组 $(a,b,c,d)，0\le a,b,c,d\lt 2^k$ 的个数。</p><p>其中，$\otimes$ 表示按位与，$\oplus$ 表示按位异或，$\ominus$ 表示按位或。</p><h2 id="解题思路-3">解题思路</h2><p>转为二进制，按位考虑。</p><p>若 $n$ 的某一位上是 $0$ ， $d$ 在这一位上必须为 $0$ ，$c$ 在这一位上由 $a,b$ 决定（控制这一位为 $0$），$a,b$ 在这一位上任选，即 $1\times 1\times 2\times 2=4$ 种可能。</p><p>若 $n$ 的某一位上是 $1$ ：</p><ol><li>若 $d$ 在这一位上为 $0$ ，则 $c$ 在这一位上由 $a,b$ 决定（控制这一位为 $1$），$a,b$ 在这一位上任选，即 $1\times 1\times 2\times 2=4$ 种可能。</li><li>若 $d$ 在这一位上为 $1$ ，则 $a,b,c$ 在这一位上任选，即 $1\times 2\times 2\times 2=8$ 种可能。</li></ol><p>综上，$n$ 的一位上是 $1$ 时有 $12$ 种可能，是 $0$ 时有 $4$ 种可能。</p><p>答案为 $4^k\times 3^{cnt1}$ 。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll cnt1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) cnt1++;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,k*<span class="number">2</span>)*<span class="built_in">qcpow</span>(<span class="number">3</span>,cnt1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1012)HDU7444.并</h1><h2 id="题意-4">题意</h2><p>给定 $n$ 个矩形，对 $k=1\to n$ 分别求随机取 $k$ 个矩形的面积并的期望。</p><h2 id="解题思路-4">解题思路</h2><p>平面可以被矩形边界分割成若干个小区域，考虑每个区域对答案的贡献。</p><p>因为要求期望，被“相同数量矩形覆盖”的小区域 对答案的贡献是相同的，因此按照 覆盖矩形数量 将这些小区域分组，统计出恰好被 $i$ 个矩形覆盖的区域的面积 $S_i$。</p><p>我的求法就是从左到右扫描，在每条竖线的位置，更新 $i$ 个矩形覆盖的y轴长度 $yval_i$ ，到下一条竖线再乘经过的x轴长度，得到这一部分的面积（类似于积分？），加入 $S_i$</p><p>然后考虑贡献的权重。<br>从 $n$ 个矩形中随机选取 $k$ 个，对于被 $i$ 个矩形覆盖的区域，只要选取的 $k$ 个矩形中，存在这 $i$ 个矩形之一，那么这个面积就会被计入。<br>在上述条件下的贡献权重是 $val_{k,i}=\frac{C_{n}^{k}-C_{n-i}^{k}}{C_{n}^{k}}$ ，即从 $n$ 个矩形中选取 $k$ 个方案数，减去从 $n-i$ 个矩形中选取 $k$ 个方案数。</p><p>最后答案$ans_k$是 $\sum\limits_{i=1}^{n}val_{k,i}\times S_i$ 。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    MOD = <span class="number">998244353</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getval</span><span class="params">(ll n,ll i,ll j)</span></span>&#123;</span><br><span class="line">    ll ret=C[n][i],sb;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n-j) sb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> sb = C[n-j][i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(ret,sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll xx1,xx2,yy1,yy2;</span><br><span class="line">    vector&lt;tuple&lt;ll,ll,ll,ll&gt;&gt; xlines;</span><br><span class="line">    vector&lt;ll&gt; ylines;</span><br><span class="line">    <span class="comment">// xline:(y,x1,x2,flag) # 横线 flag:0上边界1下边界</span></span><br><span class="line">    <span class="comment">// yline:(x) # 竖线x坐标</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;</span><br><span class="line">        xlines.<span class="built_in">emplace_back</span>(yy1,xx1,xx2,<span class="number">0</span>);</span><br><span class="line">        xlines.<span class="built_in">emplace_back</span>(yy2,xx1,xx2,<span class="number">1</span>);</span><br><span class="line">        ylines.<span class="built_in">emplace_back</span>(xx1);</span><br><span class="line">        ylines.<span class="built_in">emplace_back</span>(xx2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(xlines); <span class="built_in">SORT</span>(ylines);</span><br><span class="line"></span><br><span class="line">    map&lt;ll,ll&gt; S,yval;</span><br><span class="line">    ll prex=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// S[i]:重叠i次部分的面积</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xx:ylines)</span><br><span class="line">    &#123;</span><br><span class="line">        ll difx = xx-prex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [pl,val]:yval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// S[pl]+=difx*val;</span></span><br><span class="line">            <span class="built_in">addto</span>(S[pl],<span class="built_in">mul</span>(difx,val));</span><br><span class="line">        &#125;</span><br><span class="line">        yval.<span class="built_in">clear</span>();</span><br><span class="line">        ll cur = <span class="number">0</span>, prey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [yy,xx1,xx2,flag]:xlines)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(xx1&lt;=xx&amp;&amp;xx&lt;xx2)</span><br><span class="line">            &#123;</span><br><span class="line">                yval[cur]+=yy-prey;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) cur++;</span><br><span class="line">                <span class="keyword">else</span> cur--;</span><br><span class="line">                prey=yy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prex = xx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(auto x:S) cout &lt;&lt; x.first &lt;&lt; &#x27; &#x27; &lt;&lt; x.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ll val = <span class="built_in">getval</span>(n,i,j);</span><br><span class="line">            ans = <span class="built_in">add</span>(ans,<span class="built_in">mul</span>(val,S[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">divto</span>(ans,C[n][i]);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校01</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校02</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD02.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD02.html</id>
    <published>2024-07-17T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.295Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81597">2024牛客暑期多校训练营2</a></p><h1>C.Red Walking on Grid</h1><h2 id="题意">题意</h2><p>一个2行 $n$ 列的网格上，有些格子是红色的，有些格子是白色的。<br>你可以最初选择一个红色的格子，然后每一步都可以选择上下左右相邻的红色格子。离开一个格子时，这个格子立即变成白色。问最多可以走多少步。<br>最初没有红色的格子，输出0。</p><h2 id="解题思路">解题思路</h2><p>总体思路就是找连通块，在每个连通块内部找到能走最多格的路径，然后所有连通块的答案取最大值。<br>由于无法走回头路，形如以下样式的连通块将无法走遍全部红色格子：</p><p><img src="/images/ACM/2024Summer_NCD02_C.png" alt="image"></p><p>先从头到尾扫一遍，有以上2种形式的连通块，将打×的部分预先涂成白色。这样就能保证每个红色格子都会被经过，计算到答案中。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 2&gt; s;</span><br><span class="line">ll n,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function">ll <span class="title">getstat</span><span class="params">(ll col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getcnt</span><span class="params">(ll col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preprocess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>,pre=<span class="number">0</span>,cur;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getcnt</span>(<span class="number">0</span>)==<span class="number">1</span>) pre=<span class="built_in">getstat</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur = <span class="built_in">getcnt</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">            cur=<span class="built_in">getstat</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(pre&amp;&amp;cur&amp;&amp;cnt)&#123;</span><br><span class="line">                <span class="keyword">if</span>((cnt%<span class="number">2</span>==<span class="number">0</span>)&amp;&amp;((pre&amp;cur)==<span class="number">0</span>)) s[cur<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>((cnt%<span class="number">2</span>)&amp;&amp;((pre&amp;cur))) s[cur<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="number">2</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cnt=<span class="number">0</span>; pre=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="built_in">getcnt</span>(<span class="number">0</span>),pre=<span class="built_in">getstat</span>(<span class="number">0</span>),cur;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur = <span class="built_in">getstat</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cur&amp;pre)&#123;</span><br><span class="line">            cnt+=<span class="built_in">getcnt</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">chmax</span>(ans,cnt);</span><br><span class="line">            cnt=<span class="built_in">getcnt</span>(i);</span><br><span class="line">        &#125;pre=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">chmax</span>(ans,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s[<span class="number">0</span>] &gt;&gt; s[<span class="number">1</span>];</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">preprocess</span>();</span><br><span class="line">    <span class="built_in">getans</span>();</span><br><span class="line">    cout &lt;&lt; ans<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.GCD VS XOR</h1><h2 id="题意-2">题意</h2><p>给定一个正整数 $x$ ，找到一个严格小于 $x$ 的正整数 $y$ ，使得 $gcd(x,y)=x\oplus y$ ，其中 $\oplus$ 表示按位异或。</p><h2 id="解题思路-2">解题思路</h2><p>首先观察到，对于一个正整数 $x$ ，$lowbit(x)$ 一定是 $x$ 的因子。<br>那么令 $y = x - lowbit(x)$ ，则 $gcd(x,y)=lowbit(x)$ ，$x\oplus y = lowbit(x)$ ，满足题意。</p><blockquote><p>有时候灵感就来源于一瞬间</p></blockquote><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll ans=n-<span class="built_in">lowbit</span>(n);</span><br><span class="line">    cout &lt;&lt; (ans?ans:<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Instructions Substring</h1><h2 id="题意-3">题意</h2><p>你初始位于原点 $(0,0)$ 。<br>给定一串动作指令，包含<code>W</code>、<code>A</code>、<code>S</code>、<code>D</code>，分别表示向上（$y+=1$）、向左（$x-=1$）、向下（$y-=1$）、向右（$x+=1$）。<br>你需要选择一个连续的子串，使得执行这个子串的指令后，你能经过给定得一点 $(x,y)$ 。<br>计算符合条件的子串的个数。</p><h2 id="解题思路-3">解题思路</h2><p>假设选择了子串 $s_{ij}$ ，恰好能到达 $(x,y)$ ，那么 $s_j$ 之后任意增加指令都已经满足了“经过 $(x,y)$”的条件。</p><p>最暴力的做法就是枚举开头指令 $i$ ，枚举恰好到达 $(x,y)$ 的最小结尾指令 $j$ ，以位置 $i$ 开头的方案数就是 $n-j+1$ 。时间复杂度 $O(n^2)$ ，包TLE的，需要优化搜索过程。</p><p>我们可以先从头到尾执行（即做一个前缀和），每一步都记录到达当前位置 $(x_i,y_i)$ 时执行的指令编号 $i$ 。<br>再重新从头到尾执行一边，对于每一步到达的位置 $(x_i,y_i)$ ，将它视作起点（即假设之前的步骤都没有执行），那么需要经过的点变为 $(x_i+x,y_i+y)$ 。二分找到在 $i$ 之后到达过 $(x_i+x,y_i+y)$ 的最小指令编号 $j$ ，以位置 $i$ 开头的方案数就是 $n-j+1$ 。</p><p>$x=0,y=0$ 的情况比较特殊，特判一下即可。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                W  S  D  A</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">conv</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;D&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; n*(n+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;pll,vector&lt;ll&gt;&gt; mp;</span><br><span class="line">    ll cx,cy,dir; cx=cy=<span class="number">0</span>;</span><br><span class="line">    mp[&#123;cx,cy&#125;].<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        dir = <span class="built_in">conv</span>(c);</span><br><span class="line">        cx += dx[dir];</span><br><span class="line">        cy += dy[dir];</span><br><span class="line">        mp[&#123;cx,cy&#125;].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cx=cy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = mp[&#123;cx+x,cy+y&#125;];</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),i);</span><br><span class="line">        <span class="keyword">if</span>(it!=v.<span class="built_in">end</span>()) ans+=n-(*it);</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        dir = <span class="built_in">conv</span>(c);</span><br><span class="line">        cx += dx[dir];</span><br><span class="line">        cy += dy[dir];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> v = mp[&#123;cx+x,cy+y&#125;];</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),n);</span><br><span class="line">    <span class="keyword">if</span>(it!=v.<span class="built_in">end</span>()) ans+=n-(*it);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校02</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
</feed>
