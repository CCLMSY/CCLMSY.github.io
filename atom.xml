<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CCLMSY💫</title>
  
  
  <link href="http://www.cclmsy.cc/atom.xml" rel="self"/>
  
  <link href="http://www.cclmsy.cc/"/>
  <updated>2023-11-14T09:32:48.474Z</updated>
  <id>http://www.cclmsy.cc/</id>
  
  <author>
    <name>深翼💫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>教程|本地化部署一个QQ机器人</title>
    <link href="http://www.cclmsy.cc/posts/11f0411.html"/>
    <id>http://www.cclmsy.cc/posts/11f0411.html</id>
    <published>2023-10-06T06:00:00.000Z</published>
    <updated>2023-11-14T09:32:48.474Z</updated>
    
    <content type="html"><![CDATA[<h1>0.序言</h1><ol><li>本教程主要面向<strong>Windows系统</strong>用户</li><li>教程从0开始全程详细指导，0基础萌新请放心食用🍕</li><li>如果你遇到了问题，请仔细检查是否哪一步有遗漏。</li><li>如果你确定自己的操作没问题，可以在评论区里提问。注意留言时请填写正确的邮箱以确保能收到站长的回复。</li></ol><h1>1.搭建前的准备工作：</h1><h2 id="1-1-需要用到的工具">1.1.需要用到的工具</h2><ul><li>一台24小时开机联网的服务器/计算机</li><li>操作系统：Windows10</li><li>文本编辑器（强烈推荐使用VSCode）</li><li>Python3.11.5</li><li>一个闲置的QQ账号</li></ul><h2 id="1-2-Python安装指南">1.2.Python安装指南</h2><p>参考我的这篇文章：<a href="/posts/c34e2ac0.html">Python安装指南</a></p><p>10月2日发布了Python3.12.0版本，站长在10月5日安装机器人框架依赖时会报以下错误：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR: </span>Could not build wheels for yarl, httptools, multidict, which is required to install pyproject.toml-based projects</span><br><span class="line">安装依赖失败! 请手动安装依赖.</span><br></pre></td></tr></table></figure><p>尝试了几种方法没有解决，故使用之前成功过的Python3.11.5版本。</p><p>Python 3.11.5官方下载链接：<a href="https://www.python.org/downloads/release/python-3115/">Python 3.11.5</a><br>国内下载速度可能会有点慢，有条件的可以通过国际网络访问。<br>站长这里提供Windows64位版本的下载：<a href="http://source.cclmsy.cc/Tools/python-3.11.5-amd64.exe">python-3.11.5-amd64</a></p><h2 id="1-3-VSCode安装指南">1.3.VSCode安装指南</h2><p>VSCode是一款轻量化的IDE，支持市面上绝大多数编程语言，具有良好的扩展性，且具有非常友好的代码补全功能。<s>是CC站长的最爱</s><br>下载完成后直接一路确定傻瓜式安装即可//部分自定义配置说明如下：<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_12.png" alt="VSCode"></p><p>VSCode官网：<a href="https://code.visualstudio.com/">Visual Studio Code</a><br>同样国内下载比较慢，站长这里提供Windows64位1.82.2版本的下载，VSCode支持软件内更新到最新版本：<a href="http://source.cclmsy.cc/Tools/VSCodeUserSetup-x64-1.82.2.exe">VSCodeUserSetup-x64-1.82.2</a></p><h1>2.安装Nonebot框架</h1><h2 id="2-1-创建文件夹">2.1.创建文件夹</h2><p>创建一个文件夹用于存放项目，然后用VSCode打开这个文件夹。<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_13.png" alt="InstallNonebot1"></p><h2 id="2-2-安装pipx">2.2.安装pipx</h2><p>点击“终端-新建终端”（或直接按住Ctrl+Shift+`）创建一个终端，在终端中输入以下命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --<span class="keyword">user</span> <span class="title">pipx</span></span><br><span class="line">python -m pipx ensurepath</span><br></pre></td></tr></table></figure><p>如果出现以下提示，请调整你的账户环境变量：<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_14.png" alt="InstallNonebot2"><br>调整账户的环境变量参考：<a href="/posts/c34e2ac0.html">Python安装指南</a></p><p><strong>安装完成后，关闭当前VSCode窗口，重启VSCode后才会生效。</strong></p><h2 id="2-3-安装Nonebot脚手架">2.3.安装Nonebot脚手架</h2><p>创建一个终端，在终端中输入以下命令：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx install nb-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p><img src="http://source.cclmsy.cc/Images/BOT/BOT_15.png" alt="InstallNonebot3"><br>如果出现无法找到<code>pipx</code>命令的情况（例如出现“Command not found”字样），请确认你在上一步中账户环境变量设置正确，且<strong>完全重启</strong>VSCode。<br>如果你确信自己的所有配置完全正确，请尝试重启你的计算机。</p><h1>3.创建项目</h1><p>在终端中输入以下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nb create</span></span><br></pre></td></tr></table></figure><p>选择“bootstrap (初学者或用户)”，回车。<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_16.png" alt="Create1"></p><p>等待资源加载，加载完成后进行如下配置：<br>(键盘上下键移动光标，空格选中，回车确认)</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[?]</span> 项目名称: <span class="comment">[为你的项目取个名字吧！]</span> (项目名称建议由英文字母和数字构成，因为部分插件可能不支持包含中文的路径)</span><br><span class="line"><span class="comment">[?]</span> 要使用哪些驱动器? FastAPI (FastAPI 驱动器) </span><br><span class="line"><span class="comment">[?]</span> 要使用哪些适配器? OneBot V11 (OneBot V11 协议) </span><br><span class="line"><span class="comment">[?]</span> 立即安装依赖? y</span><br><span class="line"><span class="comment">[?]</span> 创建虚拟环境? y</span><br></pre></td></tr></table></figure><p><img src="http://source.cclmsy.cc/Images/BOT/BOT_17.png" alt="Create2"><br>脚手架会自动创建并引入所需的依赖包。</p><p>最后选择安装内置插件<code>echo</code>，这是一个简单的复读回显插件，可以用于测试你的机器人是否正常运行：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[?]</span> 要使用哪些内置插件? echo</span><br></pre></td></tr></table></figure><p>请注意，如果你这一步没有安装<code>echo</code>，<strong>后续将无法进行补装</strong>。<br>如果你操作失误没有安装，请删除当前项目文件夹并返回第<code>3</code>节开头。</p><p>出现以下提示则项目创建成功<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_18.png" alt="Create3"></p><p>在终端中输入以下命令进入项目文件夹：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span><span class="meta"> [你的项目的名字]</span></span><br></pre></td></tr></table></figure><p><strong>请注意：后续的操作均需要你的终端处于项目文件夹中。</strong><br>如果你使用的是VSCode，方便起见，你可以直接选择打开项目文件夹作为VSCode工作文件夹：<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_22.png" alt="Create4"><br>这样后续VSCode新建终端就会默认处于项目文件夹中。</p><h1>4.编辑配置文件</h1><p>脚手架会在项目文件夹中自动创建一个配置文件<code>.env.prod</code>，但你仍然需要进行一些自定义配置。</p><p>打开项目文件夹下的<code>.env.prod</code>文件，编辑内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DRIVER</span>=~fastapi  <span class="comment"># 脚手架自动生成的配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">HOST</span>=<span class="number">127.0</span>.<span class="number">0.1</span>  <span class="comment"># 配置 NoneBot 监听的 IP / 主机名</span></span><br><span class="line"><span class="attr">PORT</span>=<span class="number">23333</span>  <span class="comment"># 配置 NoneBot 监听的端口</span></span><br></pre></td></tr></table></figure><p>其中<code>HOST</code><strong>必须</strong>设为<code>127.0.0.1</code>（即localhost）<br><code>PORT</code>可以选择你喜欢的数字，范围在0-65535之间。不设置默认为8080，但尽量在15000-50000之间选择，避免和已有的端口发生冲突。</p><p>此外，你可以选择设置超级用户<code>SUPERUSERS</code>、命令起始字符<code>COMMAND_START</code>和命令分割字符<code>COMMAND_SEP</code>，你可以在有需要使用这些设置的时候再行配置。<br>部分插件可能会区分普通用户和超级用户（管理员），可以在<code>SUPERUSERS</code>中设置超级用户<br>设置命令起始字符后，机器人只响应以起始字符开头的命令。<br>设置命令分割字符后，你可以用一个语句包含多个命令，机器人会先按分割字符将命令分开，再按顺序处理。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SUPERUSERS</span>=[<span class="string">&quot;1234567890&quot;</span>,<span class="string">&quot;2333333333&quot;</span>]  <span class="comment"># 配置 NoneBot 的超级用户，可以是多个（你的QQ号）（可选）</span></span><br><span class="line"><span class="attr">COMMAND_START</span>=[<span class="string">&quot;/&quot;</span>]  <span class="comment"># 配置命令起始字符（可选）</span></span><br><span class="line"><span class="attr">COMMAND_SEP</span>=[<span class="string">&quot;.&quot;</span>]  <span class="comment"># 配置命令分割字符（可选）</span></span><br></pre></td></tr></table></figure><h1>5.安装插件</h1><h2 id="5-1-管理插件的方法">5.1.管理插件的方法</h2><blockquote><p>本节旨在让读者了解操作管理插件的流程，选择自己喜欢的管理插件的方式。<br>你也可以选择先跳过本节，在后面的教程中会默认提供方法一的命令。</p></blockquote><p>Nonebot提供了三种管理插件的方法，请确保你的终端当前处于项目文件夹中。<br>其中使用<code>pip</code>安装（方法三）需要手动激活Python虚拟环境，方法一、二管理插件时会自动使用虚拟环境。</p><h3 id="5-1-1-方法一：命令行管理">5.1.1.方法一：命令行管理</h3><p>在终端输入以下命令：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nb plugin install <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 安装插件</span></span><br><span class="line">nb plugin uninstall <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 卸载插件</span></span><br><span class="line">nb plugin update <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 升级插件</span></span><br><span class="line">nb plugin list  <span class="comment"># 列出商店所有插件</span></span><br><span class="line">nb plugin search [关键词]  <span class="comment"># 搜索商店插件</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-方法二：交互式管理">5.1.2.方法二：交互式管理</h3><p>在终端输入以下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nb plugin</span></span><br></pre></td></tr></table></figure><p>将进入控制台交互模式，键盘上下键移动光标，空格选中，回车确认。<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_21.png" alt="Plugin1"><br>按照提示输入插件名称即可。</p><h3 id="5-1-3-方法三：使用pip安装">5.1.3.方法三：使用pip安装</h3><p>如果你在第3节中正确创建了项目，那么你的项目文件夹中会有一个<code>.venv</code>文件夹，这是项目的Python虚拟环境文件夹。</p><p>值得一提的是，虚拟环境是Python提供的一个非常实用的功能，它可以将项目环境和全局环境隔离。<br>你可以在虚拟环境中安装和管理项目特定的Python库和依赖项，而不会与全局Python环境相互影响。</p><p>在终端输入以下命令以激活虚拟环境：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\.venv\Scripts\<span class="built_in">activate</span></span><br></pre></td></tr></table></figure><p>如果遇到“禁止运行脚本”的报错，可以参考我的这篇文章来解决：<a href="/posts/28dedfa6.html">Windows系统无法激活Python虚拟环境的解决方案</a><br>如果命令行开头出现一个括号，内容为你的项目名称，则代表Python虚拟环境已经成功激活。</p><p>接下来你可以使用pip命令来管理你的插件：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 安装插件</span></span><br><span class="line">pip uninstall <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 卸载插件</span></span><br><span class="line">pip install --upgrade <span class="variable">&lt;插件名称&gt;</span>  <span class="comment"># 升级插件</span></span><br><span class="line">pip list  <span class="comment"># 列出当前已经安装的插件（包含Nonebot依赖包）</span></span><br></pre></td></tr></table></figure><p><code>pip</code>相比前两种方法，缺少了列出和搜索商店插件的功能，多了可以查询当前已经安装了的插件的功能。<br>在忘记已经安装的插件或插件名情况下查询比较方便（当然你也可以自己在<code>.\.venv\Lib\site-packages</code>里查看）。</p><h2 id="5-2-安装go-cqhttp">5.2.安装go-cqhttp</h2><p><code>go-cqhttp</code>框架提供了接收QQ事件与调用QQ的API的能力，是QQ机器人的核心组件。<br>NoneBot插件商店中提供了这个框架的插件，插件名称为：<code>nonebot-plugin-gocqhttp</code><br>在终端中输入以下命令安装插件：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb <span class="keyword">plugin</span> install nonebot-<span class="keyword">plugin</span>-gocqhttp</span><br></pre></td></tr></table></figure><p>安装完成后，在终端中输入以下命令运行机器人：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>出现以下提示则安装和运行成功：<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_23.png" alt="gocq1"><br>按住Ctrl单击链接进入<code>go-cqhttp</code>的WebUI界面<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_24.png" alt="gocq2"></p><h1>6.登录QQ机器人与检查</h1><h2 id="6-1-登录QQ机器人">6.1.登录QQ机器人</h2><p>点击左上角“添加账号”，输入要部署的QQ账号，密码留空，设备类型选择“Android Watch”：<br>（注：也可以选择账号密码登录，但可能出现账号被风控无法登录的情况，手表协议登录相对比较稳定。）<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_25.png" alt="QQLogin1"><br>添加完成后点击启动，待加载出二维码后点击“显示登录二维码”。<br>用你的手机登录要部署的QQ账号，扫描二维码登录。<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_26.png" alt="QQLogin2"><br>登陆完成后会有消息提示如下：<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_27.png" alt="QQLogin3"></p><h2 id="6-2-检查QQ机器人是否正常运行">6.2.检查QQ机器人是否正常运行</h2><p>登录你自己的QQ账号，添加机器人为QQ好友，然后按以下格式发送给机器人消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="built_in">echo</span> [自定义消息]</span><br></pre></td></tr></table></figure><p>请注意，不论你有没有配置命令起始字符，在这里echo的开头<strong>必须包含&quot;\&quot;字符</strong>。<br>如果机器人回复了和自定义消息相同的内容，那么恭喜你，你已经成功地完成了QQ机器人的部署。</p><div class="hide-block"><button type="button" class="hide-button" style="background-color:  --theme-color;">点我预览示例    </button><div class="hide-content"><img src="http://source.cclmsy.cc/Images/BOT/BOT_28.png" alt="image" style="zoom:67%;" /></div></div><p>这一步完成后，建议将项目文件夹复制一份作为备份。<br>这样后续重置机器人时，只需要将备份复制一份回来即可。</p><h1>7.为你的QQ机器人赋能</h1><p>完成了QQ机器人部署后，你就可以为你的机器人添加插件以实现各种各样的功能。插件的管理方式见<code>5.1</code>节。<br>你可以在官方插件商店找到你需要的插件，根据插件开发者提供的的文档进行安装与配置：<a href="https://nonebot.dev/store/plugins">插件商店</a>。<br>如果你有足够的能力和精力，可以学习NoneBot文档，编写开发自己的插件：<a href="https://nonebot.dev/docs/">NoneBot文档</a>。</p><h1>8.注意事项</h1><ol><li>机器人的运行进程由终端调起，在你运行机器人的过程中，请务必保证你原来的终端窗口一直保持开启状态。如果你使用的是VSCode之类的IDE，请不要关闭你终端所在的窗口。</li><li>机器人以你的计算机作为服务器端，BOT使用期间请务必保证你的服务器/计算机处于开机联网状态。</li><li>Windows系统时常会进行自动更新，必要时可以关闭自动更新。</li></ol>]]></content>
    
    
    <summary type="html">拥有一个自己的QQ机器人难道不是一件很酷的事情吗//</summary>
    
    
    
    <category term="教程" scheme="http://www.cclmsy.cc/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://www.cclmsy.cc/tags/Python/"/>
    
    <category term="机器人" scheme="http://www.cclmsy.cc/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="教程" scheme="http://www.cclmsy.cc/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统无法激活Python虚拟环境的解决方案</title>
    <link href="http://www.cclmsy.cc/posts/28dedfa6.html"/>
    <id>http://www.cclmsy.cc/posts/28dedfa6.html</id>
    <published>2023-10-05T13:00:00.000Z</published>
    <updated>2023-11-05T14:13:27.538Z</updated>
    
    <content type="html"><![CDATA[<h1>情况描述</h1><p>在Windows系统终端激活Python虚拟环境时可能出现以下报错（假设你的虚拟环境名为“.venv”）：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS (yourpath<span class="string">\yourProj)&gt;</span> .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">.<span class="string">\.venv\Scripts\activate</span> : 无法加载文件 (yourpath<span class="string">\yourProj)\.venv\Scripts\activate.ps1，因为在此系统上禁止运行脚本。</span></span><br><span class="line">有关详细信息，请参阅 https:<span class="regexp">/go.microsoft.com/fwlink/</span>?LinkID=<span class="number">135170</span> 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">+ ~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure><h1>报错原因</h1><p>Windows系统具有执行策略（Execution Policy），导致无法运行虚拟环境的激活脚本。<br>执行策略是Windows中的一种安全机制，它可以防止执行不信任的脚本。</p><h1>解决方案</h1><ol><li>点击屏幕左下角Windows徽标打开“开始”菜单栏，在搜索栏搜索“PowerShell”，然后单击 “以管理员身份运行”。<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_19.png" alt="Python_venv1"></li><li>在弹出的终端中输入以下命令，回车：</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span>-ExecutionPolicy <span class="comment">RemoteSigned</span></span><br></pre></td></tr></table></figure><ol start="3"><li>弹出询问时输入“y”，回车：<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_20.png" alt="Python_venv2"></li><li>没有消息提示，退出 PowerShell 终端，回到你激活Python虚拟环境的终端。此时可以正常激活Python虚拟环境：</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS (yourpath<span class="string">\yourProj)&gt;</span> .<span class="string">\.venv\Scripts\activate</span></span><br><span class="line">(yourProj) PS (yourpath<span class="string">\yourProj)&gt;</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Windows系统无法激活Python虚拟环境的解决方案</summary>
    
    
    
    <category term="教程" scheme="http://www.cclmsy.cc/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://www.cclmsy.cc/tags/Python/"/>
    
    <category term="教程" scheme="http://www.cclmsy.cc/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>教程|Python安装指南</title>
    <link href="http://www.cclmsy.cc/posts/c34e2ac0.html"/>
    <id>http://www.cclmsy.cc/posts/c34e2ac0.html</id>
    <published>2023-10-05T09:00:00.000Z</published>
    <updated>2023-11-05T14:13:27.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-选择正确的版本，下载安装包">1. 选择正确的版本，下载安装包</h2><p>根据你的实际需要选择Python发行版本。值得注意的是，编程语言包并不是越新越好的，不同版本的Python之间可能会产生兼容性问题。<br>如果你不确定你的项目需要哪个版本，请查阅您可能需要使用到的插件的文档或咨询有相关经验的前辈。</p><ul><li>注：Python于10月2日发布3.12.0版本，站长在10月5日安装项目依赖包时产生错误，故本教程采用先前成功过的Python3.11.5版本。</li></ul><p>Python 3.11.5官方下载链接：<a href="https://www.python.org/downloads/release/python-3115/">Python 3.11.5</a><br>拉到页面底部，<strong>根据你的系统选择对应的版本下载</strong>，站长使用的是64位Windows系统，国内大多数普通用户使用的一般也是这个版本。<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_01.png" alt="Download"></p><p>国内下载速度可能会有点慢，有条件的可以通过国际网络访问<br>站长这里提供Python 3.11.5 Windows64位版本的下载：<a href="http://source.cclmsy.cc/Tools/python-3.11.5-amd64.exe">python-3.11.5-amd64</a></p><h2 id="2-安装Python到计算机">2. 安装Python到计算机</h2><p>下载完成后，打开文件所在的文件夹，选中文件右键，以管理员身份运行，按下图所示的步骤安装<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_02.png" alt="Install1"><br><img src="http://source.cclmsy.cc/Images/BOT/BOT_03.png" alt="Install2"><br><img src="http://source.cclmsy.cc/Images/BOT/BOT_04.png" alt="Install3"><br><img src="http://source.cclmsy.cc/Images/BOT/BOT_05.png" alt="Install4"><br><img src="http://source.cclmsy.cc/Images/BOT/BOT_06.png" alt="Install5"></p><h2 id="3-检查环境变量">3. 检查环境变量</h2><ol><li>打开设置，搜索“环境变量”，点击“编辑账户的环境变量”<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_07.png" alt="Env1"></li><li>在弹出的页面单击选中“Path”，点击“编辑”<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_08.png" alt="Env2"></li><li>在弹出的页面查看是否包含这两项。若没有，则添加这两项。（如果你在上一步自定义了安装路径，则添加对应的路径）<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_09.png" alt="Env3"></li><li>依次点击上面两个弹窗的“确定”，才能正确保存PATH。如果不确定是否正确保存，可以回去看一下//</li></ol><h2 id="4-检查是否正确安装了Python">4. 检查是否正确安装了Python</h2><ol><li>键盘按Windows+R，输入cmd运行终端<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_10.png" alt="Check1"></li><li>输入python回车，若显示版本号则表示安装成功<br><img src="http://source.cclmsy.cc/Images/BOT/BOT_11.png" alt="Check2"></li></ol>]]></content>
    
    
    <summary type="html">安装Python、配置Python环境（附安装包）</summary>
    
    
    
    <category term="教程" scheme="http://www.cclmsy.cc/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://www.cclmsy.cc/tags/Python/"/>
    
    <category term="教程" scheme="http://www.cclmsy.cc/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Introduction</title>
    <link href="http://www.cclmsy.cc/posts/ed318fdc.html"/>
    <id>http://www.cclmsy.cc/posts/ed318fdc.html</id>
    <published>2023-09-25T12:00:00.000Z</published>
    <updated>2023-11-05T14:13:27.532Z</updated>
    
    <content type="html"><![CDATA[<h1>博客介绍</h1><p>欢迎来到CCLMSY的Blog！<br>本博客自2023/9/26开始建设，于2023/10/4正式发布。<br>博客不定期更新算法竞赛题解、学习心得、模板笔记等等内容//<br><s>也可能会日常发疯（毕竟带学生哪有不疯的）</s><br>网站已开启邮件提醒功能。正确输入邮箱后，评论收到回复将有邮件提醒。</p><p>已知问题：</p><ul><li>由于书写时使用的MarkDown版本不同，部分内容的MarkDown格式或Katex公式渲染可能会不正确。如有发现请在评论区指正！非常感谢！（鞠躬）</li><li>使用国际网络访问可能导致无法正常使用自定义美化功能，目前尚未查明原因。</li></ul><p>关于网站、关于站长：见<a href="/about">关于</a>栏目<br>维护日志：见<a href="/site/time">旧时光</a>栏目</p>]]></content>
    
    
    <summary type="html">This is an introduction</summary>
    
    
    
    <category term="其他" scheme="http://www.cclmsy.cc/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划-背包DP</title>
    <link href="http://www.cclmsy.cc/posts/Infinity.html"/>
    <id>http://www.cclmsy.cc/posts/Infinity.html</id>
    <published>2023-09-22T12:00:00.000Z</published>
    <updated>2023-10-22T06:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1.01背包</h1><h2 id="1-1-DFS记忆化搜索">1.1.DFS记忆化搜索</h2><p>$O(mn)$ <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 105</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;z</span><br><span class="line">ll mem[W][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll maxw,n;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll i,ll curw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mem[i][curw]) <span class="keyword">return</span> mem[i][curw];</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="keyword">return</span> mem[i][curw]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(curw&gt;=w[i])</span><br><span class="line">        <span class="keyword">return</span> mem[i][curw]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw-w[i])+v[i],<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> mem[i][curw]=<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>,maxw) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-二维数组">1.2.二维数组</h2><p>$O(wn) M(wn)$ <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 105</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[N][W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,maxw)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i]) dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-w[i]]+v[i],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-一维滚动数组">1.3.一维滚动数组</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P2871">洛谷P2871</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123;<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.完全背包</h1><h2 id="2-1-一维滚动数组">2.1.一维滚动数组</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616</a><br>和01背包唯一区别在剩余容量从小到大遍历，每个物品能取多次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL</span>(j,w[i],maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-贪心优化">2.2.贪心优化</h2><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616</a><br>贪心思想：对于两件物品 $i,j$ ，如果 $w_i \le w_j \And v_i \ge v_j$ ，则只需保留 $i$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">vector&lt;pll&gt; objs,tv;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw,w,v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    tv.<span class="built_in">resize</span>(n);<span class="comment">//物品：&lt;weight,value&gt;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv) cin &gt;&gt; x.first &gt;&gt; x.second;</span><br><span class="line">    <span class="built_in">SORT</span>(tv);ll maxv=<span class="number">-1</span>;<span class="comment">//物品序列按主w次v排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:tv)</span><br><span class="line">        <span class="keyword">if</span>(x.second&gt;maxv)<span class="comment">//O(n)筛去多余物品</span></span><br><span class="line">            &#123;objs.<span class="built_in">emplace_back</span>(x);maxv=x.second;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:objs)&#123;</span><br><span class="line">        w=x.first;v=x.second;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,w,maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w]+v,dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3.多重背包</h1><h2 id="3-1-朴素方法">3.1.朴素方法</h2><p>$O(w\sum cnt_i)$<br>朴素方法：按有 $cnt_i$ 个的物品 $i$ ，进行01背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; tn &gt;&gt; maxw;</span><br><span class="line">    ll tv,tw,cnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">            v[++n]=tv;</span><br><span class="line">            w[n]=tw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-二进制分组">3.2.二进制分组</h2><p>$O(w\sum\lg{cnt_i})$<br>二进制分组优化：对于每个物品，将其按二进制分组，捆绑一个物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; tn &gt;&gt; maxw;</span><br><span class="line">    ll tv,tw,cnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; cnt;</span><br><span class="line">        ll b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;b)&#123;</span><br><span class="line">            v[++n]=tv*b;</span><br><span class="line">            w[n]=tw*b;</span><br><span class="line">            cnt-=b;b*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt) &#123;v[++n]=tv*cnt;w[n]=tw*cnt;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.混合背包</h1><p>$O(wn)$ <a href="https://www.luogu.com.cn/problem/P1833">洛谷P1833</a><br>01背包、多重背包和完全背包的缝合怪//</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll h1,m1,h2,m2;<span class="type">char</span> tc;</span><br><span class="line">    cin &gt;&gt; h1 &gt;&gt; tc &gt;&gt; m1 &gt;&gt; h2 &gt;&gt; tc &gt;&gt; m2 &gt;&gt; tn;</span><br><span class="line">    maxw=<span class="built_in">abs</span>((h2*<span class="number">60</span>+m2)-(h1*<span class="number">60</span>+m1));</span><br><span class="line">    ll tv,tw,tcnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tv &gt;&gt; tcnt;</span><br><span class="line">        <span class="keyword">if</span>(tcnt)&#123;</span><br><span class="line">            ll b=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tcnt&gt;b)&#123;</span><br><span class="line">                v[++n]=tv*b;</span><br><span class="line">                w[n]=tw*b;</span><br><span class="line">                cnt[n]=b;</span><br><span class="line">                tcnt-=b;b*=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="comment">//多重背包二进制分组</span></span><br><span class="line">            <span class="keyword">if</span>(tcnt) &#123;v[++n]=tv*tcnt;w[n]=tw*tcnt;cnt[n]=<span class="number">1</span>;&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            v[++n]=tv;</span><br><span class="line">            w[n]=tw;</span><br><span class="line">            cnt[n]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i])&#123;<span class="comment">//01背包</span></span><br><span class="line">            <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//完全背包</span></span><br><span class="line">            <span class="built_in">FORLL</span>(j,w[i],maxw)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5.二维费用背包</h1><p>$O(nw_1w_2)$ <a href="https://www.luogu.com.cn/problem/P1855">洛谷P1855</a><br>具有两种费用属性的背包问题，以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 205</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w1[N]=&#123;<span class="number">0</span>&#125;,w2[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W][W]=&#123;<span class="number">0</span>&#125;;<span class="comment">//二维滚动数组</span></span><br><span class="line">ll n,maxw1,maxw2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw1 &gt;&gt; maxw2;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; w1[i] &gt;&gt; w2[i];</span><br><span class="line">        v[i]=<span class="number">1</span>;<span class="comment">//本题中价值均为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j1,maxw1,w1[i])</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j2,maxw2,w2[i])</span><br><span class="line">            dp[j1][j2]=<span class="built_in">max</span>(dp[j1-w1[i]][j2-w2[i]]+v[i],dp[j1][j2]);</span><br><span class="line">    cout &lt;&lt; dp[maxw1][maxw2] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>6.分组背包</h1><p>$O(nw)$ <a href="https://www.luogu.com.cn/problem/P1757">洛谷P1757</a><br>01背包的进化体，每个组中最多能取1个物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 65536</span></span><br><span class="line">ll maxw,n;</span><br><span class="line">ll v[<span class="number">105</span>][N]=&#123;<span class="number">0</span>&#125;,w[<span class="number">105</span>][N]=&#123;<span class="number">0</span>&#125;,dp[<span class="number">1000</span>*N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll cnt[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;,mxid=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    ll tv,tw,id;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tv &gt;&gt; id;</span><br><span class="line">        cnt[id]++;</span><br><span class="line">        v[id][cnt[id]]=tv;</span><br><span class="line">        w[id][cnt[id]]=tw;</span><br><span class="line">        mxid=<span class="built_in">max</span>(mxid,id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,mxid)<span class="comment">//对于每一组物品</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,<span class="number">0</span>)<span class="comment">//对于每一种容量（从后往前遍历，保证同组两种物品不同时取到）</span></span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">1</span>,cnt[k]) <span class="keyword">if</span>(j&gt;=w[k][i])<span class="comment">//放入该组每种物品时可达到的最大值</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[k][i]]+v[k][i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>7.有依赖的背包</h1><p>$O(nw)$ <a href="https://www.luogu.com.cn/problem/P1064">洛谷P1064</a><br>分组背包的进化体，将所有主副件组合方案作为一组进行分组背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> W 32005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 61</span></span><br><span class="line">ll maxw,n;</span><br><span class="line">ll w[N][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,v[N][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,dp[W]=&#123;<span class="number">0</span>&#125;,cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; id_list;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    ll tw,tp,id;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tp &gt;&gt; id;</span><br><span class="line">        <span class="keyword">if</span>(id==<span class="number">0</span>)&#123;<span class="comment">//0：纯主件</span></span><br><span class="line">            id=i;w[id][<span class="number">0</span>]=tw;v[id][<span class="number">0</span>]=tw*tp;</span><br><span class="line">            id_list.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[id]==<span class="number">0</span>)&#123;<span class="comment">//1：主件+配件1</span></span><br><span class="line">            cnt[id]++;</span><br><span class="line">            w[id][<span class="number">1</span>]=tw+w[id][<span class="number">0</span>];</span><br><span class="line">            v[id][<span class="number">1</span>]=tw*tp+v[id][<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[id]==<span class="number">1</span>)&#123;<span class="comment">//2：主件+配件2//3：主件+配件1+配件2</span></span><br><span class="line">            cnt[id]++;</span><br><span class="line">            w[id][<span class="number">2</span>]=tw+w[id][<span class="number">0</span>];</span><br><span class="line">            v[id][<span class="number">2</span>]=tw*tp+v[id][<span class="number">0</span>];</span><br><span class="line">            w[id][<span class="number">3</span>]=tw+w[id][<span class="number">1</span>];</span><br><span class="line">            v[id][<span class="number">3</span>]=tw*tp+v[id][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> k:id_list)&#123;<span class="comment">//对于每一组物品</span></span><br><span class="line">        ll t=<span class="number">0</span>; <span class="keyword">if</span>(cnt[k]==<span class="number">1</span>) t=<span class="number">1</span>; <span class="keyword">if</span>(cnt[k]==<span class="number">2</span>) t=<span class="number">3</span>; </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,<span class="number">0</span>)<span class="comment">//对于每一种容量（从后往前遍历，保证同组两种方案不同时取到）</span></span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t) <span class="keyword">if</span>(j&gt;=w[k][i])<span class="comment">//采取该组每种方案时可达到的最大值</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[k][i]]+v[k][i],dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>8.进阶问题</h1><h2 id="1-求具体方案">1.求具体方案</h2><p>$O(wn)$<br>以完全背包为例，在转移时记录容量j下选择的物品编号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;,cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;,g[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL</span>(j,w[i],maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+v[i]&gt;dp[j])&#123;</span><br><span class="line">                dp[j]=dp[j-w[i]]+v[i];</span><br><span class="line">                g[j]=i;<span class="comment">//记录在容量j下选择了物品i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">    ll curw=maxw;</span><br><span class="line">    <span class="keyword">while</span>(g[curw])&#123;</span><br><span class="line">        cnt[g[curw]]++;</span><br><span class="line">        curw-=w[g[curw]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) ;<span class="comment">//输出方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-装满方案计数">2.装满方案计数</h2><p>对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。</p><h3 id="2-1-不考虑顺序">2.1.不考虑顺序</h3><p>$O(wn)$<br>不同的选择顺序看作相同方案。以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//dp[0]即不选，方案数为1</span></span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="comment">//先遍历物品</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123;<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            dp[j]=dp[j]+dp[j-w[i]];<span class="comment">//不选+选</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-考虑顺序">2.2.考虑顺序</h3><p>$O(wn)$ ZJNU C1299_B<br>不同的选择顺序看作不同方案。以完全背包为例</p><blockquote><p>从 $0$ 到 $n$ ，每次可以前进 {1,2,4} ，求方案数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> W 205</span></span><br><span class="line">ll w[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">ll maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(j,<span class="number">1</span>,maxw) <span class="comment">//先遍历容量</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">            dp[j]=dp[j]+dp[j-w[i]];</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-最优方案计数">3.最优方案计数</h2><p>$O(wn)$<br>求最优背包方案数，以01背包为例，g[j]代表容量j下最优方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;,g[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//g[0]即不选，方案数为1</span></span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+v[i]&gt;dp[j])&#123;<span class="comment">//取 最优</span></span><br><span class="line">                dp[j]=dp[j-w[i]]+v[i];</span><br><span class="line">                g[j]=g[j-w[i]];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j-w[i]]+v[i]==dp[j]) g[j]+=g[j-w[i]]; <span class="comment">//取或不取都最优</span></span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; g[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-求第k优解">4.求第k优解</h2><p>$O(wnk)$ <a href="https://vjudge.net/problem/HDU-2639">HDU2639</a><br>求背包的第k优解，以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 1005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll dp[W][<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//dp[j][k]表示容量j下第k优解</span></span><br><span class="line">    ll a[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll n,maxw,tark;</span><br><span class="line">    ll x,y,z;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw &gt;&gt; tark;</span><br><span class="line">    a[tark+<span class="number">1</span>]=b[tark+<span class="number">1</span>]=<span class="number">-1</span>;<span class="comment">//哨兵</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="comment">//考虑前i个物品时</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123; <span class="comment">//容量为j下</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">1</span>,tark)&#123;</span><br><span class="line">                a[k]=dp[j-w[i]][k]+v[i];<span class="comment">//第k优解，选</span></span><br><span class="line">                b[k]=dp[j][k];<span class="comment">//第k优解，不选</span></span><br><span class="line">            &#125;<span class="comment">//dp数组不升保证a,b数组不升</span></span><br><span class="line">            x=y=z=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(z&lt;=tark&amp;&amp;!(a[x]==<span class="number">-1</span>&amp;&amp;b[y]==<span class="number">-1</span>))&#123;<span class="comment">//循环直到找到全部前k解，或两指针都到末尾</span></span><br><span class="line">                <span class="keyword">if</span>(a[x]&gt;b[y]) dp[j][z]=a[x++];</span><br><span class="line">                <span class="keyword">else</span> dp[j][z]=b[y++];</span><br><span class="line">                <span class="keyword">if</span>(dp[j][z]!=dp[j][z<span class="number">-1</span>]) z++;<span class="comment">//非严格比较则删去if条件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw][tark] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference：<a href="https://oi-wiki.org/dp/">OI-Wiki</a></p>]]></content>
    
    
    <summary type="html">动态规划-背包DP部分例题、板子代码</summary>
    
    
    
    <category term="笔记模板" scheme="http://www.cclmsy.cc/categories/%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="动态规划" scheme="http://www.cclmsy.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="背包DP" scheme="http://www.cclmsy.cc/tags/%E8%83%8C%E5%8C%85DP/"/>
    
    <category term="笔记" scheme="http://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-其他</title>
    <link href="http://www.cclmsy.cc/posts/4014d4be.html"/>
    <id>http://www.cclmsy.cc/posts/4014d4be.html</id>
    <published>2023-09-22T12:00:00.000Z</published>
    <updated>2023-10-22T06:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一.子序列问题</h1><h2 id="1-最长公共子序列-LCS">1.最长公共子序列(LCS)</h2><p>O(mn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;,dp[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-最长上升子序列">2.最长上升子序列</h2><h3 id="2-1-DP">2.1.DP</h3><p>$O(n^2)$ 洛谷B3637</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        ll mx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j]) mx=<span class="built_in">max</span>(mx,dp[j]);</span><br><span class="line">        dp[i]=mx+<span class="number">1</span>;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-贪心">2.2.贪心</h3><p>$O(n\log n)$ 洛谷B3637<br>贪心：维护当前子序列d，替换序列中不小于a[i]的第一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; d;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    d.<span class="built_in">emplace_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.<span class="built_in">back</span>()&lt;a[i]) d.<span class="built_in">emplace_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(d),a[i])=a[i];</span><br><span class="line">    &#125;<span class="comment">//最长不降子序列改成upper_bound</span></span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二.区间DP</h1><p>$O(n^3)$ NOI1995/LOJ10147<br>分治：父问题的答案由子问题集中最优解转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 205</span></span><br><span class="line">ll v[N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,S[N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dpmx[N*<span class="number">2</span>][N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,dpmn[N*<span class="number">2</span>][N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        v[i+n]=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n*<span class="number">2</span>) dpmn[i][j]=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) dpmn[i][i]=<span class="number">0</span>;<span class="comment">//Init</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) S[i]=S[i<span class="number">-1</span>]+v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(len,<span class="number">1</span>,n)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>-len+<span class="number">1</span>)&#123;</span><br><span class="line">            ll j=i+len<span class="number">-1</span>;<span class="comment">//根据长度和i算出j</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,i,j<span class="number">-1</span>)&#123;<span class="comment">//枚举分界点</span></span><br><span class="line">                dpmx[i][j]=<span class="built_in">max</span>(dpmx[i][j],dpmx[i][k]+dpmx[k+<span class="number">1</span>][j]+S[j]-S[i<span class="number">-1</span>]);</span><br><span class="line">                dpmn[i][j]=<span class="built_in">min</span>(dpmn[i][j],dpmn[i][k]+dpmn[k+<span class="number">1</span>][j]+S[j]-S[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;<span class="comment">//转移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mx=<span class="number">0</span>,mn=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) mx=<span class="built_in">max</span>(mx,dpmx[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) mn=<span class="built_in">min</span>(mn,dpmn[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; mn &lt;&lt; endl &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>三.期望DP</h1><p>ATC-abc323_e<br>某点的期望从此前的一段区间内转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X 10004</span></span><br><span class="line">ll dp[X]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//歌曲在t时刻切换的概率</span></span><br><span class="line">ll t[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x;cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; t[i];</span><br><span class="line">    ll invn=<span class="built_in">inv</span>(n);<span class="comment">//1/n</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,x)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(i&gt;=t[j])</span><br><span class="line">            <span class="built_in">addto</span>(dp[i],dp[i-t[j]]);</span><br><span class="line">        <span class="built_in">multo</span>(dp[i],invn);</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">0ll</span>,x-t[<span class="number">1</span>]+<span class="number">1</span>),x) <span class="built_in">addto</span>(re,dp[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multo</span>(re,invn) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四.DP优化</h1><h2 id="1-单调队列优化DP">1. 单调队列优化DP</h2><p>O(mn) M(m) CF372C<br>利用单调队列将每次区间DP均摊复杂度降至O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 150005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;,t[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[<span class="number">2</span>][M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,m,d;<span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">ll que[M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i];</span><br><span class="line">    fl=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ll l=<span class="number">1</span>,r=<span class="number">0</span>,k=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;k&lt;=<span class="built_in">min</span>(n,j+(t[i]-t[i<span class="number">-1</span>])*d);k++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(r&gt;=l&amp;&amp;dp[fl^<span class="number">1</span>][que[r]]&lt;dp[fl^<span class="number">1</span>][k]) r--;</span><br><span class="line">                que[++r]=k;<span class="comment">//单调队列优化DP：维护上一状态的有效区间内的最大值的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r&gt;=l&amp;&amp;que[l]&lt;<span class="built_in">max</span>(<span class="number">1ll</span>,j-(t[i]-t[i<span class="number">-1</span>])*d)) l++;</span><br><span class="line">            dp[fl][j]=dp[fl^<span class="number">1</span>][que[l]]+b[i]-<span class="built_in">abs</span>(a[i]-j);</span><br><span class="line">        &#125;fl^=<span class="number">1</span>;<span class="comment">//状态转换</span></span><br><span class="line">    &#125;fl^=<span class="number">1</span>;<span class="comment">//回到最终状态</span></span><br><span class="line">    ll ans=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">max</span>(ans,dp[fl][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference：<a href="https://oi-wiki.org/dp/">OI-Wiki</a></p>]]></content>
    
    
    <summary type="html">动态规划-其他//其他类型的题目篇幅较小，故整合到一起</summary>
    
    
    
    <category term="笔记模板" scheme="http://www.cclmsy.cc/categories/%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="动态规划" scheme="http://www.cclmsy.cc/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="笔记" scheme="http://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校10</title>
    <link href="http://www.cclmsy.cc/posts/f6ff419e.html"/>
    <id>http://www.cclmsy.cc/posts/f6ff419e.html</id>
    <published>2023-08-17T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>K.First Last</h1><p><strong>签到题</strong></p><h2 id="题目大意">题目大意</h2><p>$n$ 个人参加 $m$ 场比赛，每场比赛中获得名次得概率均等<br>问针对某一人，他在所有场次比赛中都获得第一或倒数第一的概率</p><h2 id="解题思路">解题思路</h2><p>如果人数 $n&gt;1$ ，每场比赛的概率是 $p=\dfrac{2}{n}$ ；人数为 $1$ 时 $p=1$</p><p>输出 $p^m$ 即可</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">double</span> p=<span class="number">2.</span>/n,re=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) p=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) re*=p;</span><br><span class="line">    <span class="built_in">print_float</span>(re,<span class="number">15</span>);cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>M.Fair Equation</h1><p><strong>模拟</strong></p><h2 id="题目大意-2">题目大意</h2><p>给定一个式子 $A+B=C$ ，其中正整数 $A,B,C\le 10^6$<br>问能否在 $A,B,C$ 其中一个数的某一位置（可以是开头和结尾）插入一个数字，使得等式成立；或原式自然成立。<br>若成立，输出成立的等式</p><h2 id="解题思路-2">解题思路</h2><p>如题如题目所述，取出等式中的数字，逐位模拟即可。具体实现可参考代码</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_equal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">    cout &lt;&lt; num[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; num[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; num[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;<span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="built_in">get_nums</span>(s);ll t;<span class="comment">//分离出数字</span></span><br><span class="line">    <span class="keyword">if</span>(num[<span class="number">0</span>]+num[<span class="number">1</span>]==num[<span class="number">2</span>]) &#123;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;<span class="comment">//原式成立</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">0</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">0</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">0</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(t+num[<span class="number">1</span>]==num[<span class="number">2</span>]) &#123;num[<span class="number">0</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;<span class="comment">//在A的第k位插入i，判断是否符合条件，下面同理</span></span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">1</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">1</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">1</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>]+t==num[<span class="number">2</span>]) &#123;num[<span class="number">1</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">0</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">2</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">2</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>]+num[<span class="number">1</span>]==t) &#123;num[<span class="number">2</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校10</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校10</title>
    <link href="http://www.cclmsy.cc/posts/8239c814.html"/>
    <id>http://www.cclmsy.cc/posts/8239c814.html</id>
    <published>2023-08-16T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="http://1004.Do">1004.Do</a> You Like Interactive Problems?</h1><p><strong>概率论-数学期望</strong></p><h2 id="题目大意">题目大意</h2><p>给定一个正整数 $n$ ，在 $1$ ~ $n$ 范围内有一个正整数 $x$<br>进行若干轮猜测，每次猜测在 $1$ ~ $n$ 范围内等概率随机选择一个正整数 $y$ ，可以得到如下信息中的一个： $y&gt;x,y=x,y&lt;x$<br><strong>每次猜测后，下一次猜测仍在原范围内随机选择</strong>。当得到的信息能够唯一确定 $x$ 时，游戏结束<br>求猜测轮数的数学期望</p><h2 id="解题思路">解题思路</h2><p>由题意可知，当且仅当出现以下情况时，可以唯一确定 $x$ ：</p><ol><li>选到 $x$</li><li>$x$ 的相邻元素都被选到</li></ol><p>每次选择后，下一次选择的范围是不变的，因此其他元素的信息对唯一确定 $x$ 是没有作用的</p><p>对于给定 $n$ ，根据以下情况展开讨论：</p><ol><li>不论 $x$ 的位置，直接选到 $x$ ，轮数为 $1$ ，概率为 $\dfrac{1}{n}$</li><li>已经选到一个相邻点（或 $x$ 在两端），轮数期望记为 $E_2$<ol><li>选另一相邻点（或唯一相邻点），轮数为 $1$ ，概率为 $\dfrac{1}{n}$</li><li>选其他点没有贡献，概率为 $\dfrac{n-2}{n}$</li></ol></li><li>$x$ 在中间，没有选到过相邻点，轮数期望记为 $E_3$<ol><li>选到两个相邻点之一，转移到情况 $2$ ，概率为 $\dfrac{2}{n}$</li><li>选到其他点没有贡献，概率为 $\dfrac{n-3}{n}$</li></ol></li></ol><p>综上可得：</p><p>$E_2=\dfrac{1}{n}+\dfrac{1}{n}+\dfrac{n-2}{n}(1+E_2)$</p><p>$E_3=\dfrac{1}{n}+\dfrac{2}{n}(1+E_2)+\dfrac{n-3}{n}(1+E_3)$</p><p>解得 $E_2=\dfrac{n}{2},E_3=\dfrac{2n}{3}$<br>得到最终期望为：$E=\dfrac{2}{n}E_2+\dfrac{n-2}{n}E_3=\dfrac{2n-1}{3}$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    ll t=<span class="built_in">mul</span>(<span class="built_in">Get_Mod</span>(<span class="number">2</span>*(n<span class="number">-2</span>)+<span class="number">3</span>),<span class="built_in">inv</span>(<span class="number">3</span>));</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.Equalize the Array</h1><p><strong>签到</strong></p><h2 id="题目大意-2">题目大意</h2><p>定义一个数组的 $mode$ 是其中出现次数最多的数字（可不唯一）<br>给定一个数组 $a$ ，每次操作可以选定其一个 $mode$ 并使数组中所有与之相等的元素 $+1$<br>问任意次操作后能否使数组中全部元素相等</p><h2 id="解题思路-2">解题思路</h2><p>如果数组中最小的元素是 $mode$ ，连续操作最小元素即可实现//<br>元素计数，判断最小元素出现次数是否最多即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n\log n)$</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    map&lt;ll,ll&gt; mp;ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;mp[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mxcnt=<span class="number">0</span>,mxi=<span class="number">0</span>,mn=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t=mp[i];<span class="keyword">if</span>(!mn&amp;&amp;t) mn=i;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;mxcnt) &#123;mxcnt=t;mxi=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mxi&lt;=mn) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校10</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校09</title>
    <link href="http://www.cclmsy.cc/posts/e80ac002.html"/>
    <id>http://www.cclmsy.cc/posts/e80ac002.html</id>
    <published>2023-08-14T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1002.Shortest path</h1><p><strong><s>签到题</s></strong> <strong>DFS记忆化搜索</strong></p><h2 id="题目大意">题目大意</h2><p>给定一个正整数 $n$ ，可以对其进行以下操作：</p><ol><li>如果 $n$ 能被 $3$ 整除，则可以使 $n=n/3$ ;</li><li>如果 $n$ 能被 $2$ 整除，则可以使 $n=n/2$ ;</li><li>使 $n=n-1$</li></ol><p>求使得 $n$ 变成 $1$ 的最少操作次数</p><h2 id="解题思路">解题思路</h2><p><s>将样例Output输出即可</s></p><blockquote><p>这题不难，但确实精彩()//毕竟……<br>《钉耙编程”中国大学生算法设计超级联赛》是由hdu自主研发的一款全新开放世界冒险竞赛。竞赛发生在一个被称作“hdu”的幻想世界，在这里，被编译器选中的人将被授予“C++”，导引代码之力。你将扮演一位名为“acmer”的神秘角色，在自由的打题中邂逅性格各异能力独特的STL容器，和他们一起击败强题，找回AC的代码</p></blockquote><p>不闹了，解题吧</p><p>不难看出操作 $3$ 的收益最低，是不满足操作 $1,2$ 的时候凑条件用的。<br>而由于只允许整除，操作 $1,2$ 的优劣性不好评估（因为要夹杂操作 $3$ 而不单纯是减少的量的区别），因此每次对本次进行的两种操作方案进行比较。</p><p>按以下操作递归处理 $n$ ：</p><ol><li>如果 $n=1$ ，则返回 $0$ ；</li><li>进行若干次（可能0次）操作 $3$ 使得 $n$ 能被 $2$ 整除，执行操作 $2$</li><li>进行若干次（可能0次）操作 $3$ 使得 $n$ 能被 $3$ 整除，执行操作 $1$</li></ol><p>由于数据范围的关系，传统的DFS会超时，因此需要使用记忆化搜索<br>即每次计算完某个数（记为 $x$ ）的结果，将其保存下来，后续搜索 $x$ 时就无需继续搜索到底部，直接输出这个数的结果即可<br>记忆化搜索可以用 map 实现，频繁读取而不考虑元素顺序的可以使用 unordered_map ，有效降低时间空间复杂度</p><p><img src="/images/ACM/2023Summer_HDU09_1002.png" alt="Img"></p><p>第2、3行的提交使用了 map ，代码完全一致；第1行的提交仅仅将 map 改为了 unordered_map</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(t\log^2n)$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;ll,ll&gt; mp;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>-n;</span><br><span class="line">    <span class="keyword">if</span>(mp[n]) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll t1,t2;</span><br><span class="line">    t1=n%<span class="number">2</span>+<span class="number">1</span>+<span class="built_in">dfs</span>(n/<span class="number">2</span>);</span><br><span class="line">    t2=n%<span class="number">3</span>+<span class="number">1</span>+<span class="built_in">dfs</span>(n/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> mp[n]=<span class="built_in">min</span>(t1,t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1005.List Reshape</h1><p><strong>签到题、模拟</strong></p><h2 id="题目大意-2">题目大意</h2><p>按一定格式给定一个纯数字一维数组，按给定格式输出成二维数组。</p><h2 id="解题思路-2">解题思路</h2><p>读入初始数组字符串，将每个数字分离，按要求输出即可</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">char</span> s[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;string&gt; nums;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnums</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ts;ll len=<span class="built_in">strlen</span>(s);<span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,len)&#123;</span><br><span class="line">        c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) ts.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ts.<span class="built_in">size</span>())&#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">            ts.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="built_in">gets</span>(s);</span><br><span class="line">    ll n,m;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    nums.<span class="built_in">clear</span>();<span class="built_in">getnums</span>();</span><br><span class="line">    <span class="comment">//print_vec(nums);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; nums[i*m+j];</span><br><span class="line">            <span class="keyword">if</span>(m<span class="number">-1</span>-j) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n<span class="number">-1</span>-i) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; <span class="string">&#x27;]&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1008.Coins</h1><p><strong>概率论</strong></p><h2 id="题目大意-3">题目大意</h2><p>$n$ 个人进行游戏，每个人初始有 $a_i$ 个硬币，每次随机选择一个人给另一个人一枚硬币<br>若某人给出硬币后没有剩余，则退出游戏。直到有人拿到所有硬币游戏结束<br>求游戏轮数的数学期望</p><h2 id="解题思路-3">解题思路</h2><p>概率论还没学（）官方题解的鞅论看不懂（躺）//<br>等学完回来给严格推导（手搓大饼ing）<br>ACMer三大美德：暴力、打表、猜结论//下面给出道德解法（）</p><p>假设现在只有两个人，那么每个人给对方硬币的概率都为50%，直到其中一人没有硬币为止。<br>设这两个人的硬币数分别为 $m,n$ ，则游戏轮数期望为：<br>$f(m,n)=1+\dfrac{1}{2}f(m+1,n-1)+\dfrac{1}{2}f(m-1,n+1)$</p><p>可以发现越往后对期望的贡献越低，限制递归深度，利用如下程序暴力打表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(ll m,ll n,ll rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rnd&gt;<span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归上限40层（已经要跑很久了）</span></span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="number">0.5</span>*<span class="built_in">f</span>(m+<span class="number">1</span>,n<span class="number">-1</span>,rnd+<span class="number">1</span>)+<span class="number">0.5</span>*<span class="built_in">f</span>(m<span class="number">-1</span>,n+<span class="number">1</span>,rnd+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(m,n,<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到以下打表结果（不得不说跑的是真慢）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>:<span class="number">1</span> <span class="number">3</span> out:<span class="number">3</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">1</span> <span class="number">5</span> out:<span class="number">4</span>.<span class="number">98732</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">2</span> <span class="number">3</span> out:<span class="number">5</span>.<span class="number">99897</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">2</span> <span class="number">5</span> out:<span class="number">9</span>.<span class="number">8626</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">3</span> <span class="number">4</span> out:<span class="number">11</span>.<span class="number">8287</span></span><br></pre></td></tr></table></figure><p>暴力打完表可以猜结论了： $f(m,n)=mn$ ，即对于两个人，答案是他们硬币数的乘积；<br>那么对于三个人，利用样例<code>in:1 1 1 out:3</code>盲猜是 $a_1a_2+a_1a_3+a_2a_3$<br>推广到 $n$ 个人，两两相乘再相加即可</p><p>由于数据较大，答案需要开int128才能放得下<br>另外结合数据范围，利用前缀和算出结果即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>前缀和&amp;求和：$O(n)$</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int128 res;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        sum[i]=v[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        res=res+sum[i<span class="number">-1</span>]*v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">print</span>();<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校09</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校09</title>
    <link href="http://www.cclmsy.cc/posts/3f9284b7.html"/>
    <id>http://www.cclmsy.cc/posts/3f9284b7.html</id>
    <published>2023-08-13T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>E.Puzzle: Square Jam</h1><p><strong>几何</strong></p><h2 id="题目大意">题目大意</h2><p>给定一个 $n$ 行 $m$ 列的矩形，将其切割为若干个边长为正整数的正方形部分<br>要求矩形内每个整点都不能同时在四个正方形的边界上</p><h2 id="解题思路">解题思路</h2><p>每次在矩形中取最大的正方形，剩余部分递归处理即可。如此取，每个点最多在三个正方形的边界上</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;pll,ll&gt;&gt; ans;</span><br><span class="line">pair&lt;pll,ll&gt; tp;<span class="comment">//&lt;坐标,边长&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_sqr</span><span class="params">(ll x,ll y,ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//处理坐标在(x,y)，n行m列的矩形</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=m)&#123;</span><br><span class="line">        tp.first.first=x;tp.first.second=y;tp.second=m;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        <span class="built_in">solve_sqr</span>(x+m,y,n-m,m);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tp.first.first=x;tp.first.second=y;tp.second=n;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        <span class="built_in">solve_sqr</span>(x,y+n,n,m-n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">solve_sqr</span>(<span class="number">0</span>,<span class="number">0</span>,n,m);</span><br><span class="line">    cout &lt;&lt; YES ;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)&#123;</span><br><span class="line">        cout &lt;&lt; x.first.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.first.second &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校09</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校08</title>
    <link href="http://www.cclmsy.cc/posts/b57662bf.html"/>
    <id>http://www.cclmsy.cc/posts/b57662bf.html</id>
    <published>2023-08-10T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>A.Alive Fossils</h1><p><strong>签到</strong></p><h2 id="题目大意">题目大意</h2><p>给定 $n$ 个字符串集，求它们的交集，按字典序输出</p><h2 id="解题思路">解题思路</h2><p>逐一处理字符串集，开个 map 记录此前的交集，从当前集合中选走元素即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll tn;cin &gt;&gt; tn;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; mp;string ts;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; ts;</span><br><span class="line">        mp[ts]++;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        cin &gt;&gt; tn;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,tn)&#123;</span><br><span class="line">            cin &gt;&gt; ts;</span><br><span class="line">            <span class="keyword">if</span>(mp[ts]) v.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">        &#125;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:v) mp[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s:v) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>J.Permutation and Primes</h1><p><strong>构造</strong></p><h2 id="题目大意-2">题目大意</h2><p>给定一个正整数 $n$ ，构造一个 $n$ 的排列，使得每对相邻元素的和或差的绝对值为一奇素数</p><h2 id="解题思路-2">解题思路</h2><p>两个数的和或差是奇数，那么它们的奇偶性一定是不同的，因此所求排列中，奇数和偶数是交错分布的</p><p>对于排列的构造，首先考虑能不能通过自然排列转化而成//</p><p>赛时首先想到奇偶分开后，将全体偶数向左或向右循环移动 $2$ ~ $3$ 位，这样可以保证绝大部分位置和左右两边之差为 $3$ 或 $5$ //当时以为要切了，结果剩余的数字考虑了两年半还是没有找到符合题意而不失一般性的构造方法</p><p>然后考虑分段调整。在上面思想的基础上，发现如果元素个数为 $8$ 个，那么全体偶数左移 $2$ 位和右移 $2$ 位的结果都为： $1,6,3,8,5,2,7,4$ 。并且如果下一段长度为 $8$ 的序列也按照这种规则变换顺序，那么 $4$ 和下一段长度为 $8$ 的序列的开头 $9$ 之差为 $5$ ，符合题意，从而解决了边界问题</p><p>将 $n$ 模 $8$ 取余，记 $n=8k+r$ 。解决前 $r$ 个数的排列后，之后每 $8$ 个数按 $1,6,3,8,5,2,7,4$ 的顺序变换即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ll rem[<span class="number">8</span>][<span class="number">8</span>]=&#123;&#123;&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">ll pl[<span class="number">9</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll r=n%<span class="number">8</span>,d=n/<span class="number">8</span>;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,r<span class="number">-1</span>) v.<span class="built_in">emplace_back</span>(rem[r][i]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,d<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            v.<span class="built_in">emplace_back</span>(<span class="number">8</span>*i+pl[j]+r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; v[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校08</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校08</title>
    <link href="http://www.cclmsy.cc/posts/a4f57cd6.html"/>
    <id>http://www.cclmsy.cc/posts/a4f57cd6.html</id>
    <published>2023-08-09T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1005.0 vs 1</h1><p><strong>博弈，模拟</strong></p><h2 id="题目大意">题目大意</h2><p>两人名为零和壹，在给定的 $01$ 串上进行博弈<br>零只能取走两端的某一个 $0$ ，壹只能取走两端的某一个 $1$ ，零执先<br>先不能取的人判负，若取完则判平局</p><h2 id="解题思路">解题思路</h2><p>模拟博弈过程，当前操作者 $x$ 可以可以遵循以下策略：</p><ol><li>两端不同，只能取 $x$ 的一端，交替操作权</li><li>两端相同<ol><li>两端都不是 $x$ ，无法操作，失败</li><li>两端都是 $x$ ，假设取了某端<ol><li>这端的下一个数字是 $x$ ，则两端都是 $x$ ，对方无法操作，获胜</li><li>这端的下一个数字是 $!x$ ，则对方只能取这一端</li></ol></li><li>如果离任一端最近的连续两个相同的数都为 $x$ ，则根据上 $2$ 一直取到 $x$ 获胜</li><li>如果离两端最近的连续两个相同的数都为 $!x$ ，则不论选哪端，最终都会到达两端都为 $!x$ 的情况，失败<ol><li>特判：如果整个串有且仅有 $1$ 段连续两个相同的 $!x$ ，则从两端向中间将各会取掉一个，达成平局</li></ol></li></ol></li></ol><p>可以结合代码注释理解这一过程</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_s</span><span class="params">(deque&lt;<span class="type">int</span>&gt; s,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    ll n=s.<span class="built_in">size</span>(),i,j;;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//取完平局</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">front</span>()!=s.<span class="built_in">back</span>())&#123;<span class="comment">//前后不同，无法自由选择，交替操作权</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">front</span>()==now)&#123;<span class="comment">//取前</span></span><br><span class="line">            s.<span class="built_in">pop_front</span>();<span class="built_in">solve_s</span>(s,(now?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//取后</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>(); <span class="built_in">solve_s</span>(s,(now?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//前后相同</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">front</span>()!=now) &#123;cout &lt;&lt; (now?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;1&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//两端不可取，失败</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) <span class="keyword">break</span>;<span class="comment">//从前往后找第一个连续</span></span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//无连续，取完平局</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==now) &#123;cout &lt;&lt; (now?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;0&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有己方连续，胜利</span></span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--) <span class="keyword">if</span>(s[j]==s[j<span class="number">-1</span>]) <span class="keyword">break</span>;<span class="comment">//从后往前找最后一个连续</span></span><br><span class="line">        <span class="keyword">if</span>(s[j]==now) &#123;cout &lt;&lt; (now?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;0&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有己方连续，胜利</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>==j) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有且仅有一对对方连续，取完平局</span></span><br><span class="line">        &#123;cout &lt;&lt; (now?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;1&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//两对以上对方连续，失去主动权，判负</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    string ts;cin &gt;&gt; ts;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;<span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) s[i]=ts[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">solve_s</span>(s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Solubility</h1><p><strong>并查集/DFS</strong></p><h2 id="题目大意-2">题目大意</h2><p>给定 $n$ 个元素之间的 $m$ 对等价关系，问指定 $k$ 个元素是否属于同一等价类</p><h2 id="解题思路-2">解题思路</h2><p>这里给出两种解题思路：</p><ol><li>DFS：建无向图，DFS判断指定元素是否在同一个连通分量里</li><li>并查集：标准并查集板子题，裸套即可</li></ol><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><ol><li>DFS</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> visited[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    visited[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    G.<span class="built_in">clear</span>();G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) visited[i]=<span class="number">0</span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k;cin &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">s</span><span class="params">(k)</span></span>;<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s) cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">DFS</span>(s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s) <span class="keyword">if</span>(!visited[x]) &#123;cout &lt;&lt; NO;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>并查集</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k;cin &gt;&gt; k &gt;&gt; a;a=dsu.<span class="built_in">find</span>(a);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,k)&#123;</span><br><span class="line">        cin &gt;&gt; b;b=dsu.<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(b!=a) &#123;cout &lt;&lt; NO;<span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,k) cin &gt;&gt; n;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    &#125;cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1008.Expectation of Rank</h1><p><strong>线性代数-矩阵与向量空间、期望、动态规划</strong></p><h2 id="题目大意-3">题目大意</h2><p>给定两个正整数 $n,p$ ，其中 $p$ 是质数<br>$n$ 阶矩阵 $\bf A$ 中的所有元素随机在 $p$ 的有限域 $\mathbb{F}_p$ 中产生，求矩阵 $\bf A$ 的秩的期望 $\mathbb{E}(rank(\bf A))$ ，答案取模</p><h3 id="前置知识点">前置知识点</h3><ol><li><a href="https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E5%9F%9F/4273049">有限域</a> $\mathbb{F}_p$ ：在本题中可以粗略的理解为 $[0,p-1]$ 的整数集</li><li>线性代数-矩阵与向量空间基础知识：多维向量与向量组、线性相关、矩阵的秩与向量之间的关系、向量组张成向量空间的概念等</li></ol><p>建议在学习过《线性代数》课程后再解决本题。</p><h2 id="解题思路-3">解题思路</h2><p>一个含 $k$ 个向量的极大无关组可以张成一个 $k$ 维向量空间</p><p>在 $p$ 的有限域 $\mathbb{F}_p$ 下，每一维度上的坐标有 $p$ 种选择，故以该极大无关组为基，通过线性组合可以产生 $p^k$ 种不同的 $k$ 维向量（高维包含低维）<br>顺带一提，这并不意味着这 $p^k$ 种向量仅有 $k$ 位坐标非 $0$</p><p>矩阵 $\bf A$ 的每一行可以视为一个 $n$ 维向量，前 $i$ 行的秩表示了前 $i$ 个向量组成的向量组，其极大无关组中有多少个向量。这也意味着前 $i$ 行已经张成了一个多少维度的向量空间</p><p>构造DP数组， $dp_{i,k}$ 用以表示矩阵 $\bf A$ 前 $i$ 行的秩为 $k$ 的方案数</p><p>假设前 $i-1$ 行的秩为 $k$ ，那么其张成的向量空间为 $k$ 维，考虑状态转移：</p><ol><li>第 $i$ 行中可以构造出 $p^k$ 个向量落在这个向量空间中，并不改变秩（或者说维数）</li><li>余下 $p^n-p^k$ 个向量将与前 $i-1$ 个向量线性无关，并使张成的空间增大一维，秩 $+1$</li></ol><p>综上所述，构造出以下状态转移方程：<br>$$dp_{i,k}=<br>\begin{cases}<br>0 \qquad,k&gt;i\quad(rank_i\le i恒成立) \newline<br>1 \qquad,k=0\quad(当且仅当全为 \bf{0} \text{向量}) \newline<br>\sum\limits_{j=1}^{i-1} dp_{i-1,j}\times p^j + dp_{i-1,j-1}\times (p^n-p^j) &amp;,Otherwise<br>\end{cases}<br>$$</p><p>总方案数为 $(p^n)^n=p^{n^2}$ ，最终期望为 $\dfrac{1}{p^{n^2}}\sum\limits_{j=1}^{n} j\times dp_{n,j}$</p><h3 id="时间复杂度-2">时间复杂度</h3><p>DP：$O(n^2)$</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line">ll n,p;</span><br><span class="line">ll dp[N][N],powp[N];<span class="comment">//dp_i,k表示矩阵前i行秩为k的方案数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n)</span><br><span class="line">            dp[i][j]=<span class="number">0</span>;</span><br><span class="line">    powp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) powp[i]=<span class="built_in">mul</span>(powp[i<span class="number">-1</span>],p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="built_in">Init</span>(n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">1</span>,i)&#123;<span class="comment">//每行看作一个向量，有p^n种构造法。确定前i行的秩为k的总向量方案数</span></span><br><span class="line">            <span class="built_in">addto</span>(dp[i][k],<span class="built_in">mul</span>(dp[i<span class="number">-1</span>][k],powp[k]));</span><br><span class="line">            <span class="comment">//对于前i-1行秩为k的某方案，其向量空间为k维，故在p的有限集下有且仅有p^k个向量落在该向量空间</span></span><br><span class="line">            <span class="built_in">addto</span>(dp[i][k],<span class="built_in">mul</span>(dp[i<span class="number">-1</span>][k<span class="number">-1</span>],<span class="built_in">sub</span>(powp[n],powp[k<span class="number">-1</span>])));</span><br><span class="line">            <span class="comment">//对于前i-1行秩为k-1的某方案，有p^(k-1)个向量落在其张成的向量空间，剩余向量与前i-1行线性无关</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>,ninv=<span class="built_in">inv</span>(<span class="built_in">qcpow</span>(powp[n],n));<span class="comment">//ninv:总方案数(p^n)^n的倒数</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">addto</span>(re,<span class="built_in">mul</span>(<span class="built_in">mul</span>(i,dp[n][i]),ninv));</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1010.Rikka with Square Numbers</h1><p><strong>数学、贪心</strong></p><h2 id="题目大意-4">题目大意</h2><p>给定两个正整数 $a,b$ ，每次操作可以使 $a$ 增大或减小一个平方数 $x$ ，求把 $a$ 变成 $b$ 的最小操作次数</p><h2 id="解题思路-4">解题思路</h2><p>即求 $a,b$ 之差最少可以用多少个平方数的和差表示。以下是一些思路：</p><ol><li>$a=b$ ， $0$</li><li>$n^2$ ，平方数本身， $1$</li><li>$n^2-(n-1)^2=2n-1$ ，用两个相邻平方数之差即可表示任意奇数</li><li>$n^2-(n-2)^2=4(n-1)$ ，用两个距离为 $2$ 的平方数之差可以表示任意 $4$ 的倍数</li><li>结合以上两条可以归纳证明两个平方数之差一定为奇数或 $4$ 的倍数，$2$</li><li>模 $4$ 余 $2$ 的情况可能为两平方数加和，可以枚举判断， $2$</li><li>其余的数可以用第 $3$ 点得到任意奇数后加减 $1$ ， $3$</li></ol><p>综上判定即可</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(\sqrt n)$</p><h2 id="参考代码-4">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Is_Sqr</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(t*t==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b); ll dif=a-b;</span><br><span class="line">    <span class="keyword">if</span>(a==b) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Is_Sqr</span>(dif)) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(dif%<span class="number">2</span>||(dif%<span class="number">4</span>==<span class="number">0</span>)) &#123;cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=dif;i++) <span class="keyword">if</span>(<span class="built_in">Is_Sqr</span>(dif-i*i)) &#123;cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校08</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校07</title>
    <link href="http://www.cclmsy.cc/posts/adbd05a4.html"/>
    <id>http://www.cclmsy.cc/posts/adbd05a4.html</id>
    <published>2023-08-07T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1002.Random Nim Game</h1><p><strong>诈骗博弈题</strong></p><h2 id="题目大意">题目大意</h2><p>Nim是一种双人数学策略游戏，玩家轮流从不同的堆中移除棋子。在每一轮游戏中，玩家必须至少取出一个棋子，并且可以取出任意数量的棋子，条件是这些棋子都来自同一个棋子堆。走最后一步棋（即取出最后一块棋子）的人获胜。</p><p>现在更改游戏规则，在每个回合中，棋手必须选择一个棋子堆。假设他选择的堆包含 $x$ 个棋子，将从 $[1,x]$ 中随机一个整数 $y$ ，并从堆中移除 $y$ 个棋子</p><p>求先手获胜的概率，答案取模</p><h2 id="解题思路">解题思路</h2><p>看起来很吓人的一道题（谁被吓退了我不说）//</p><p>考虑只有一个堆的情况<br>若只有 $1$ 个棋子，先手必胜<br>如果有 $2$ 个棋子，有 $\dfrac{1}{2}$ 的概率拿完获胜，有 $\dfrac{1}{2}$ 的概率余 $1$ 失败，综合胜率 $\dfrac{1}{2}$<br>$\vdots$<br>如果有 $x\ (x&gt;1)$ 个棋子，有 $\dfrac{n-2}{n}$ 的概率转移到 剩余个数 $&gt;1$ 的状态，有 $\dfrac{1}{n}$ 的概率拿完获胜，有 $\dfrac{1}{n}$ 的概率余 $1$ 失败。递归得到 $x&gt;1$ 的状态下的综合胜率为 $\dfrac{1}{2}$</p><p>再考虑多堆的情况<br>如果所有堆的棋子数量均为 $1$ ，则当堆数 $n$ 为奇数时先手必胜<br>如果有某堆的数量多于 $1$ 个，那么必胜态将以 $\dfrac{1}{2}$ 的概率流转</p><p>综上所述，如果所有堆的棋子数量均为 $1$ ，则当堆数 $n$ 为奇数时先手必胜， $n$ 为偶数时先手必败，其余情况综合胜率 $\dfrac{1}{2}$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll mx=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,t);</span><br><span class="line">    &#125;<span class="keyword">if</span>(mx&gt;<span class="number">1</span>) cout &lt;&lt; <span class="built_in">inv</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">2</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1004.Medians Strike Back</h1><p><strong>构造</strong></p><h2 id="题目大意-2">题目大意</h2><p>定义长度为 $n$ 的整数序列的中位数：</p><ol><li>如果 $n$ 为奇数，则中位数是将序列排序后正中间的数</li><li>如果 $n$ 为偶数，则中位数是将序列排序后中间两个数中，出现次数较多的那个数，如果出现次数相同则取较小的那个数</li></ol><p>定义序列的 $shikness$ ：该序列中位数出现的次数<br>定义序列的 $nitness$ ：该序列的所有连续子串的 $shikness$ 的最大值</p><p>给定一个正整数 $n$ ，构造长度为 $n$ 且仅含元素 $1,2,3$ 的序列，并使 $nitness$ 最小化，求出最小值</p><h2 id="解题思路-2">解题思路</h2><p>构造找规律<br>$nitness_{min}=1$ 时，构造出最长序列为： $123$<br>$nitness_{min}=2$ 时，构造出最长序列为： $1313221313$<br>$nitness_{min}=3$ 时，构造出最长序列为： $131313222131313$<br>$nitness_{min}=4$ 时，构造出最长序列为： $1313131322131313132213131313$</p><p>如果序列中存在两个及以上的 $2$ ，那么 $2$ 是稳定作为中位数的，因此可以考虑以下构造方法：<br>连续 $n$ 对 $13$ 为一个单位子串//每个单位子串利用两个或三个连续的 $2$ 隔开，将得到以下格式的序列：$1313(n对)\cdots22\ 1313(n对)\cdots22\ 1313(n对)$</p><p>下面阐释这种构造方法的合法性</p><ol><li>对于整个序列， $nitness=cnt_2=n$</li><li>对于含多个 $2$ 的子串， $2$ 稳定做中位数， $nitness&lt;cnt_2=n$</li><li>对于仅含一个 $2$ 的子串，这个 $2$ 一定在单位子串的左边或右边，而单位子串的长度为 $2n$ ，因此加上 $2$ 后的长度为奇数，$2$ 稳定做中位数，$nitness=1$</li><li>对于不含 $2$ 的子串，其一定也是单位子串的子串，而单位子串中 $cnt_1=cnt3=n$ ，因此 $nitness\le n$</li></ol><p>计数得到最长长度的通项公式： $len_i=2i(\lfloor \dfrac{i}{2} \rfloor+1)+i$</p><p>初始化长度数组，二分查找即可</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 500000</span></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),n)-v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------Initialize----------*/</span></span><br><span class="line">    v[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">        v[i]=(i/<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>*i+i;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;<span class="number">1e11</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"><span class="comment">/*----------Initialize----------*/</span></span><br></pre></td></tr></table></figure><hr><h1>1011.Three Operations</h1><p><strong>签到题</strong></p><h2 id="题目大意-3">题目大意</h2><p>给定正整数 $x,a,b$ 可以进行以下操作：</p><ol><li>$x\leftarrow x-1$</li><li>$x\leftarrow \lfloor \dfrac{x+a}{2} \rfloor$</li><li>$x\leftarrow \lfloor \sqrt{x+b} \rfloor$</li></ol><p>求使得 $x$ 变为 $0$ 的最少操作次数</p><h2 id="解题思路-3">解题思路</h2><p>每次比较三种操作后的 $x$ 最小即可</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,a,b,t,re=<span class="number">0</span>;cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        t=<span class="built_in">min</span>((x+a)/<span class="number">2</span>,(ll)<span class="built_in">sqrt</span>(x+b));</span><br><span class="line">        <span class="keyword">if</span>(t&lt;x<span class="number">-1</span>) &#123;re++;x=t;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;re+=x;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1013.Minimal and Maximal XOR Sum</h1><p><strong>归并排序、贪心</strong></p><h2 id="题目大意-4">题目大意</h2><p>给定一个长度为 $n$ 的排列 $p$ ，每次操作可以选定一段连续子序列 $p_{i,j}$ ，花费等同于元素个数的代价 $c=j-i+1$ ，使得这一段顺序反转<br>记使得排序变成自然排序（ $p_i=i$ ）所经过的一系列操作中，每一次的代价的异或和为 $x=c_1 \oplus c_2 \oplus \cdots \oplus c_i$<br>求 $x$ 的最大值和最小值</p><h2 id="解题思路-4">解题思路</h2><p>排列的奇偶性定义为其所具有的逆序对数的奇偶性。任意一个n阶排列，可经过一系列对换转变为标准排列，且所做对换的次数与排列具有相同的奇偶性。</p><p>观察操作的特点可以得出，选定单一元素操作时，排列本身不发生改变，但产生 $1$ 点代价//这意味着所得结果 $x$ 的最后一个二进制位可以任意调整（和 $1$ 做异或）</p><p>考虑使得 $x$ 最小的操作方法<br>每次花费 $2$ 代价做对换，最小值 $x_{min}$ 一定会落在 $0$ 或 $2$ 上。根据对换次数与排列奇偶性的关系，判断排列逆序对数的奇偶性即可，可以使用归并排序进行逆序对计数</p><p>接下来考虑使得 $x$ 最大的操作方法<br>在排列 $p$ 已经有序的情况下，考虑如何操作花费代价可以使得异或和 $x$ 产生高位 $1$ ：先花费高代价 $c$ 反转某个长子序列，再连续花费 $2$ 代价做对换将序列恢复为有序</p><p>可以发现 $x$ 的最大可能二进制位数与 $n$ 相同，逐位考虑转 $1$ 记某位上的权重为 $2^m &lt;n$ ，则反转 $2^m$ 个数后，恢复有序需要连续做对换的次数为 $2^m(2^m-1)/2$ ， $m\ge 2$ 时对换次数为偶数，即对最终的异或和 $x$ 无影响，这意味着按照上述策略可以将 $x$ 倒数第3位（权重为4）及以前的数位全部置1//</p><p>$m=1$ 时对换次数为 $1$ ，和反转 $2^1$ 个数的代价 $2$ 抵消，因此无法变更倒数第二位的值</p><p>综上所述，只需将 $x$ 调整为与 $n$ 具有相同二进制数的最大值，再判断倒数第二位即可//</p><h3 id="时间复杂度">时间复杂度</h3><p>归并排序： $O(n\log n)$</p><h2 id="参考代码-4">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll mn,mx;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll cntinv=<span class="built_in">mergeSortAndCount</span>(v,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cntinv%<span class="number">2</span>) mn=<span class="number">2</span>;<span class="keyword">else</span> mn=<span class="number">0</span>;</span><br><span class="line">    ll t=n,dig=<span class="number">0</span>;<span class="keyword">while</span>(t) &#123;dig++;t/=<span class="number">2</span>;&#125;</span><br><span class="line">    mx=(<span class="number">1</span>&lt;&lt;dig)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mn==<span class="number">0</span>) mx-=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;0 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; mn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校07</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校07</title>
    <link href="http://www.cclmsy.cc/posts/179d3b5a.html"/>
    <id>http://www.cclmsy.cc/posts/179d3b5a.html</id>
    <published>2023-08-06T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>M.Writing Books</h1><p><strong>签到</strong></p><h2 id="题目大意">题目大意</h2><p>给定一个正整数 $n$ ，求 $1$ ~ $n$ 共有多少位数字</p><h2 id="解题思路">解题思路</h2><p>$1$ ~ $9$ 共 $9\times 10^0 \times 1$ 位；<br>$10$ ~ $99$ 共 $9\times 10^1 \times 2$ 位；<br>以此类推，求和即可</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a=<span class="number">1</span>,x=<span class="number">9</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=x) &#123;n-=x;cnt+=a*x;x*=<span class="number">10</span>;a++;&#125;</span><br><span class="line">    cnt+=a*n;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校07</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校06</title>
    <link href="http://www.cclmsy.cc/posts/d9c7e69f.html"/>
    <id>http://www.cclmsy.cc/posts/d9c7e69f.html</id>
    <published>2023-08-03T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>A.Tree</h1><p><strong>图论-Kruskal、动态规划</strong></p><h2 id="题目大意">题目大意</h2><p>给定一棵 $n$ 个节点带点权和边权的无根树</p><p>节点具有颜色白（$0$）和黑（$1$），颜色可反转，所需代价 $cost_i$ 为该点点权</p><p>整棵树的 $earning$ 为 $\sum\limits_{u\in V_0}\sum\limits_{v\in V_1} val(u,v)$ 。其中， $val(u,v)$ 为节点 $u\rightarrow v$的最短路径上的最大边权， $V_0$ 为白色点集， $V_2$ 为黑色点集</p><p>可以操作反转节点颜色任意次，求最大 $earning-\sum cost$ （以下简称 $score$ ）</p><h2 id="解题思路">解题思路</h2><p>注意到对于每对黑白点对，其贡献为最短路径上的最大边权。考虑利用Kruskal算法对树进行重构，即按边权从小到大的顺序进行加边</p><p>可以发现，在加入某条边 $e_i$ 时，原本在同一连通分量中的黑白点对的 $score$ 不受影响。由于加边顺序，新加的边一定具有目前最大的边权，因此只有经过新加的这条边的点对才对 $score$ 具有贡献，每个点对的贡献值为 $w_i$ ，点对数量为：$左白\times右黑+左黑\times右白$</p><p>构造dp数组：定义 $dp_{i,j}$ 为连通分量 $i$ （以并查集中连通分量的根节点标识）中具有 $j$ 个白色节点时的最大 $score$ 。初始对于点 $i$ ，$dp_{i,color_i}=0$ （不变）；$dp_{i,color_i\oplus 1}=-cost_i$ （反转）</p><p>在合并 $A、B$ 两个连通分量到 $C$ 时具有以下转移方程：<br>$$<br>dp_{C,i}=\max\limits_{0\le k \le |A| \And 0\le i-k\le |B|}{dp_{A,k}+dp_{B,i-k}+w(k(|B|-(i-k))+(i-k)(|A|-k))}<br>$$<br>（两边原有的 $score$ 加上过新加边的 $score$ ）</p><p>可以结合代码注释进行理解</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n^2\log n)$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;ll w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">edge</span>():<span class="built_in">u</span>(<span class="number">0</span>),<span class="built_in">v</span>(<span class="number">0</span>),<span class="built_in">w</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> _u,<span class="type">int</span> _v,ll _w): <span class="built_in">u</span>(_u),<span class="built_in">v</span>(_v),<span class="built_in">w</span>(_w) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//手写edge类，自定义比较方式</span></span><br><span class="line"><span class="comment">//下面的注释中也添加了不用手写的代码，优点是少写一段代码，缺点是表述较为冗杂不直观</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"><span class="type">int</span> dsu[N]=&#123;<span class="number">0</span>&#125;,sz[N]=&#123;<span class="number">0</span>&#125;,color[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; dp[N];<span class="comment">//dp_i,j:集合i有j个白色点时的score</span></span><br><span class="line">vector&lt;edge&gt; Edge;</span><br><span class="line"><span class="comment">//vector&lt;pair&lt;ll,pll&gt;&gt; Edge;//&lt;w,&lt;u,v&gt;&gt;;</span></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">cost</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">find_dsu</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dsu[x]==x?x:dsu[x]=<span class="built_in">find_dsu</span>(dsu[x]);</span><br><span class="line">&#125;<span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_dsu</span><span class="params">(ll a,ll b,ll w)</span></span>&#123;</span><br><span class="line">    a=<span class="built_in">find_dsu</span>(a);b=<span class="built_in">find_dsu</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(sz[a]&gt;sz[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    ll n=sz[a]+sz[b],rt;</span><br><span class="line">    <span class="comment">//n:a,b点集体积之和，即白点数量上限</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">tmp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        rt=-INF;</span><br><span class="line">        <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=sz[a];k++) <span class="keyword">if</span>(k&lt;=i&amp;&amp;i-k&lt;=sz[b])&#123;<span class="comment">//k:a中白点数量</span></span><br><span class="line">            ll cnt0=i-k,cnt1=sz[b]-(i-k);<span class="comment">//cnt0:b中白点数量 cnt1:b中黑点数量</span></span><br><span class="line">            rt=<span class="built_in">max</span>(rt,dp[a][k]+dp[b][i-k]+w*(k*cnt1+cnt0*(sz[a]-k)));</span><br><span class="line">            <span class="comment">//dp=max(两点集已经具有的最大earning-cost+经过这条边的点对数*边权)</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp[i]=rt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[b]=tmp;</span><br><span class="line"></span><br><span class="line">    sz[b]+=sz[a];</span><br><span class="line">    dsu[a]=b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    Edge.<span class="built_in">resize</span>(n<span class="number">-1</span>);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        dp[i].<span class="built_in">resize</span>(<span class="number">2</span>);<span class="comment">//接下来有需求会扩容</span></span><br><span class="line">        dsu[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; color[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">        dp[i][color[i]]=(ll)<span class="number">0</span>;</span><br><span class="line">        dp[i][color[i]^<span class="number">1</span>]=(ll)-cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:Edge)&#123;</span><br><span class="line">        cin &gt;&gt; e.u &gt;&gt; e.v &gt;&gt; e.w;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">        <span class="comment">//e.second.first=u;e.second.second=v;e.first=w;</span></span><br><span class="line">    &#125;<span class="comment">//存边</span></span><br><span class="line">    <span class="built_in">SORT</span>(Edge);<span class="comment">//按边权从小到大重构树</span></span><br><span class="line">    edge e;</span><br><span class="line">    <span class="comment">//pair&lt;ll,pll&gt; e;</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">        e=Edge[i];</span><br><span class="line">        u=e.u;v=e.v;w=e.w;</span><br><span class="line">        <span class="comment">//u=e.second.first;v=e.second.second;w=e.first;</span></span><br><span class="line">        <span class="built_in">merge_dsu</span>(u,v,w);</span><br><span class="line">    &#125;<span class="keyword">auto</span> tmp=dp[<span class="built_in">find_dsu</span>(<span class="number">1</span>)];</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(<span class="built_in">ALL</span>(tmp)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B.Distance</h1><p><strong>数学、贪心(?)</strong></p><h2 id="题目大意-2">题目大意</h2><p>对于两个大小相同的多重集 $\mathbb{A},\mathbb{B}$ ，可以选择其中任一元素 $x$ 执行操作 $x=x+1$  任意次数，最少的使得 $\mathbb{A},\mathbb{B}$ 相同的操作次数记为 $C(\mathbb{A},\mathbb{B})$<br>不同大小的 $\mathbb{A},\mathbb{B}$ 视为 $C(\mathbb{A},\mathbb{B})=0$</p><p>现在，给定两个大小为 $n$ 的多重集 $\mathbb{S},\mathbb{T}$ ，求对于 $\mathbb{S},\mathbb{T}$ 的所有子集 $\mathbb{A},\mathbb{B}$ ，最少操作次数之和 $\sum\limits_{\mathbb{A} \subseteq \mathbb{S}}\sum\limits_{\mathbb{B} \subseteq \mathbb{T}} C(\mathbb{A},\mathbb{B})$ 的值<br>具有相同值的两个元素视为不同元素，答案取模</p><h2 id="解题思路-2">解题思路</h2><p>对于某对子集 $\mathbb{A},\mathbb{B}$ ，为了使他们相同的操作次数最少，我们会将他们排序的元素后一一对应，使每一对中较小的数变成较大的数//假设 $a_i$ 与 $b_i$ 对应，他们在这次变化中贡献的操作次数显然是 $|a_i-b_i|$</p><p>那么换一种角度考虑，对于原多重集 $\mathbb{S},\mathbb{T}$ ，任取一对数 $a_i,b_j$ ，考虑它们俩对应的方案数 $cnt_{i,j}$ ，那么它们在全部方案中贡献的总操作次数即为 $|a_i-b_i|\times cnt_{i,j}$</p><p>由于我们的操作策略是排序后对应，因此先对 $\mathbb{S},\mathbb{T}$ 进行排序//<br>选定两个数 $a_i,b_j$ 后，它们在 $\mathbb{S},\mathbb{T}$ 中的位置前面选 $k$ 对数的方案数为 $\sum\limits_{k=0}^{min(i-1,j-1)}C_{i-1}^kC_{j-1}^k=C_{i+j-2}^k$ （<a href="https://oi-wiki.org/math/combinatorics/vandermonde-convolution/">范德蒙德卷积</a>）</p><p>同理，它们在 $\mathbb{S},\mathbb{T}$ 中的位置后面选 $k$ 对数的方案数为 $C_{2<em>n-i-j}^k$<br>总方案数为 $cnt_{i,j}=C_{i+j-2}^kC_{2</em>n-i-j}^k$ ，乘以两数之差的绝对值即为它们对答案的总贡献//</p><p>预处理组合数，枚举 $i,j$ 求和即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n^2)$</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:b) cin &gt;&gt; x;</span><br><span class="line">    ll re=<span class="number">0</span>;<span class="built_in">SORT</span>(a);<span class="built_in">SORT</span>(b);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">addto</span>(re,<span class="built_in">mul</span>(<span class="built_in">abs</span>(a[i]-b[j]),<span class="built_in">mul</span>(<span class="built_in">Get_Combination</span>(i+j,i),<span class="built_in">Get_Combination</span>((n-i<span class="number">-1</span>)+(n-j<span class="number">-1</span>),(n-i<span class="number">-1</span>)))));</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>C.idol!!</h1><p><strong>数学</strong></p><h2 id="题目大意-3">题目大意</h2><p>正整数 $n$ 的双阶乘 $n!!$ 表示不超过 $n$ 且与 $n$ 有相同奇偶性的所有正整数乘积<br>求对于给定 $n$ ，$\prod\limits_{i=1}^n i!!$ 的后缀 $0$ 个数</p><h2 id="解题思路-3">解题思路</h2><p>根据双阶乘的性质，可以得到： $(n-1)!!\times n!!=n!$<br>因此对于给定的 $n$ ，原式可化为：<br>$$\prod\limits_{i=1}^n i!!=\begin{cases}<br>\prod\limits_{i=1}^\frac{n}{2} (2i)! &amp;,n为偶数 \newline<br>\prod\limits_{i=1}^\frac{n+1}{2} (2i-1)! &amp;,n为奇数<br>\end{cases}$$<br>显而易见的，阶乘中因子 $2$ 的个数一定多于因子 $5$ 的个数，因此题目等价于求上式中因子 $5$ 的个数//</p><p>考虑某单一阶乘 $n!$ 中所含因子 $5$ 的个数。<br>可以发现，每个 $5$ 的倍数项会提供 $1$ 个因子 $5$ ，共有 $\lfloor \dfrac{n}{5} \rfloor$ 项<br>除此之外每个 $25=5^2$ 的倍数项会额外提供一个因子 $5$ ，共有 $\lfloor \dfrac{n}{5^2} \rfloor$ 项<br>再除此之外每个 $125=5^3$ 的倍数项会额外提供一个因子 $5$ ，共有 $\lfloor \dfrac{n}{5^3} \rfloor$ 项……<br>因此对于单一阶乘 $n!$ ，其提供因子 $5$ 的数量 $cnt_5=\sum\limits_{i=1}^N \lfloor \dfrac{n}{5^i} \rfloor (5^N&gt;n)$</p><p>接着考虑连乘积中因子 $5$ 个数的总和。<br>$$<br>ans=\begin{cases}<br>\sum\limits_{i=1}^\frac{n}{2} \sum\limits_{j=1}^N \lfloor \dfrac{2i}{5^j} \rfloor=\sum\limits_{i=1}^N \sum\limits_{j=1}^\frac{n}{2} \lfloor \dfrac{2j}{5^i} \rfloor &amp;,n为偶数 \newline<br>\sum\limits_{i=1}^\frac{n+1}{2} \sum\limits_{j=1}^N \lfloor \dfrac{2i-1}{5^j} \rfloor=\sum\limits_{i=1}^N \sum\limits_{j=1}^\frac{n+1}{2} \lfloor \dfrac{2j-1}{5^i} \rfloor &amp;,n为奇数<br>\end{cases} \newline<br>$$</p><p>对于某一 $i$ ，发现不论 $n$ 的奇偶， $j=1$ 开始的每 $5^i$ 项之和构成公差为 $2\times5^i$ 的等差数列//<br>例：$i=1$ ，$n$ 为偶数且足够大时，$\lfloor \dfrac{2j}{5^i} \rfloor$ 的前 $15$ 项如下，其中每 $5$ 项之和构成公差为 $5\times 2$ 的等差数列： $0,0,1,1,2||2,2,3,3,4||4,4,5,5,6……$</p><p>经计算，对于某一 $i$ ，等差数列的首项为<br>$$<br>a_1=\begin{cases}<br>\lfloor \dfrac{5^i}{2} \rfloor+2 &amp;,n为偶数 \newline<br>\lfloor \dfrac{5^i}{2} \rfloor+1 &amp;,n为奇数<br>\end{cases}<br>$$</p><p>完整的段用等差数列求和，非完整的段手算一下//<br>​<br>若此前完整段的数量记为 $m$ ，则非完整段：<br>前 $\lfloor \dfrac{5^i}{2} \rfloor$ 项的值为 $2m$ ，<br>第 $\lfloor \dfrac{5^i}{2} \rfloor+1$ 至 $2\times\lfloor \dfrac{5^i}{2} \rfloor $ 项的值为 $2m+1$（手搓一下就知道了）</p><p>求和即可</p><p>令 $N=\lfloor \log_5n \rfloor+1$ ，对 $i\in[1,N]$ 遍历求和得到答案</p><p>由于答案数据极其庞大，超出了C++ %lld(64bits)的范围，因此需要使用更高位数的整数类型（如int128）//或者直接转战Python</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(\log n)$</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># while 1:</span></span><br><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">N=<span class="built_in">int</span>(math.log(n,<span class="number">5</span>)+<span class="number">1</span>)</span><br><span class="line">re=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>) :</span><br><span class="line">        <span class="comment">#print(&quot;i=&quot;+str(i))</span></span><br><span class="line">        a1=(<span class="number">5</span>**i)//<span class="number">2</span>+<span class="number">2</span> <span class="comment">#首项</span></span><br><span class="line">        <span class="comment">#print(&quot;a1=&quot;+str(a1))</span></span><br><span class="line">        d=(<span class="number">5</span>**i)*<span class="number">2</span> <span class="comment">#公差</span></span><br><span class="line">        <span class="comment">#print(&quot;d=&quot;+str(d))</span></span><br><span class="line">        m=(n//<span class="number">2</span>)//(<span class="number">5</span>**i) <span class="comment">#完整段数</span></span><br><span class="line">        <span class="comment">#print(&quot;m=&quot;+str(m))</span></span><br><span class="line">        re+=(<span class="number">2</span>*a1+(m-<span class="number">1</span>)*d)*m//<span class="number">2</span> <span class="comment">#完整段等差数列求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re1:&quot; + str(re))</span></span><br><span class="line">        re+=(n//<span class="number">2</span>-m*(<span class="number">5</span>**i))*<span class="number">2</span>*m <span class="comment">#最后一段余项求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re2:&quot; + str(re))</span></span><br><span class="line">        <span class="comment">#print(&quot;pl1=&quot; + str((n//2-m*(5**i))*2*m))</span></span><br><span class="line">        <span class="keyword">if</span> n//<span class="number">2</span>-m*(<span class="number">5</span>**i)&gt;(<span class="number">5</span>**i)//<span class="number">2</span> :</span><br><span class="line">            re+=n//<span class="number">2</span>-m*(<span class="number">5</span>**i)-(<span class="number">5</span>**i)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#print(&quot;pl2=&quot; + str(n//2-m*(5**i)-(5**i)//2))</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>) :</span><br><span class="line">        <span class="comment">#print(&quot;i=&quot;+str(i))</span></span><br><span class="line">        a1=(<span class="number">5</span>**i)//<span class="number">2</span>+<span class="number">1</span> <span class="comment">#首项</span></span><br><span class="line">        <span class="comment">#print(&quot;a1=&quot;+str(a1))</span></span><br><span class="line">        d=(<span class="number">5</span>**i)*<span class="number">2</span> <span class="comment">#公差</span></span><br><span class="line">        <span class="comment">#print(&quot;d=&quot;+str(d))</span></span><br><span class="line">        m=((n+<span class="number">1</span>)//<span class="number">2</span>)//(<span class="number">5</span>**i) <span class="comment">#完整段数</span></span><br><span class="line">        <span class="comment">#print(&quot;m=&quot;+str(m))</span></span><br><span class="line">        re+=(<span class="number">2</span>*a1+(m-<span class="number">1</span>)*d)*m//<span class="number">2</span> <span class="comment">#完整段等差数列求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re1:&quot; + str(re))</span></span><br><span class="line">        re+=((n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i))*<span class="number">2</span>*m <span class="comment">#最后一段余项求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re2:&quot; + str(re)) </span></span><br><span class="line">        <span class="comment">#print(&quot;pl1=&quot; + str(((n+1)//2-m*(5**i))*2*m))</span></span><br><span class="line">        <span class="keyword">if</span> (n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i)&gt;(<span class="number">5</span>**i)//<span class="number">2</span> :</span><br><span class="line">            re+=(n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i)-(<span class="number">5</span>**i)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#print(&quot;pl2=&quot; + str((n+1)//2-m*(5**i)-(5**i)//2))</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(re)</span><br></pre></td></tr></table></figure><hr><h1>E.Sequence</h1><p><strong>思维题</strong></p><h2 id="题目大意-4">题目大意</h2><p>给定一个长度为 $n$ 的正整数序列，并进行 $q$ 次询问<br>每次询问给定一个范围 $[l,r]$ 和一个正整数 $k$<br>问能否将序列中给定范围内的子序列划分为 $k$ 段非空区间，且每段区间之和为偶数</p><h2 id="解题思路-4">解题思路</h2><p>首先对于给定区间：</p><ol><li>给定区间内总元素个数不足 $k$ ，则无法划分</li><li>给定区间内奇数元素个数为奇数，则给定区间的和为奇数，无法划分为 $k$ 个和为偶数的区间</li><li>给定区间内奇数元素个数为偶数，则最优划分为：从前往后奇数两两匹配形成区间，余下的偶数自成一个区间</li></ol><p>因此本题的关键就在于区间内奇数的处理</p><p>输入的记录奇数所在的位置，每次询问对于给定的区间，二分查找第一次出现奇数的位置和最后一次出现的位置，判断奇数个数<br>符合要求再进行区间计数判断，具体实现和解释可以参考代码注释</p><h3 id="时间复杂度-4">时间复杂度</h3><p>2023/8/5：纠正：最坏时间复杂度为 $O(qn)$ ，卡一下平均能过qwq</p><h2 id="参考代码-4">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,q,t;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    vector&lt;ll&gt; v,odd;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;v.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) odd.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;<span class="comment">//奇数下标存入odd,O(n)</span></span><br><span class="line">    ll l,r,k;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span>(r-l&lt;k<span class="number">-1</span>) &#123;cout &lt;&lt; NO;<span class="keyword">continue</span>;&#125;<span class="comment">//元素数量小于k</span></span><br><span class="line">        <span class="keyword">if</span>(odd.<span class="built_in">empty</span>()) &#123;cout &lt;&lt; YES;<span class="keyword">continue</span>;&#125;<span class="comment">//整个序列无奇数</span></span><br><span class="line">        <span class="keyword">auto</span> ol=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(odd),l);<span class="comment">//找到区间左端点右边最近的奇数的位置</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(odd),r)-ol)&amp;<span class="number">1</span>) &#123;cout &lt;&lt; NO;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//如果区间内奇数个数为奇数个，一定会残留一个区间和为奇数的区间</span></span><br><span class="line">        ll cnt=<span class="number">0</span>;<span class="comment">//最多区间计数</span></span><br><span class="line">        <span class="keyword">while</span>(ol!=odd.<span class="built_in">end</span>()&amp;&amp;*ol&lt;=r)&#123;<span class="comment">//下一个奇数在区间内</span></span><br><span class="line">            cnt+=*ol-l;ol++;<span class="comment">//奇数左边的偶数一个记一段</span></span><br><span class="line">            <span class="keyword">if</span>(*ol&lt;=r) cnt++;<span class="comment">//两个奇数之间记一段</span></span><br><span class="line">            l=*ol+<span class="number">1</span>;ol++;<span class="comment">//更新左端点</span></span><br><span class="line">        &#125;<span class="keyword">if</span>(ol==odd.<span class="built_in">begin</span>()) &#123;cout &lt;&lt; YES;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        ol--;cnt+=r-*ol;<span class="comment">//加上区间右边剩余偶数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=k) cout &lt;&lt; YES;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>G.Gcd</h1><p><strong>数论</strong></p><h2 id="题目大意-5">题目大意</h2><p>给定一个包含两个非负数的初始集合 $S={x,y}$<br>每次操作可以选定其中不相等的两个数 $a,b$ ，并将 $a-b$ 或 $gcd(a,b)$ 置入集合 $S$ ，其中 $gcd(0,a)=a$<br>可以操作任意次，问能否使得集合 $S$ 包含非负数 $z$</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://oi-wiki.org/math/number-theory/bezouts/">裴蜀定理</a></p><h2 id="解题思路-5">解题思路</h2><p>根据裴蜀定理，两个正整数辗转相减只能得到他们最大公约数的倍数//<br>因此对于 $z$ ，判断其是否是 $g=gcd(x,y)$ 的倍数即可。<br>如果 $z$ 是 $g$ 的倍数，则可以通过以下操作得到 $z$ ：</p><ol><li>将 $g=gcd(x,y)$ 置入集合</li><li>$x$ 作为 $g$ 的倍数，其加减任意次 $g$ 便可得到任意 $g$ 的倍数。<br>只能减不能加怎么办呢//先把 $x$ 减到 $-g$ 就好了</li></ol><p>值得注意的是，本题的数据约束为<strong>非负数</strong>，这意味着需要对 $0$ 的情况进行特判//</p><ol><li>对于 $z=0$ ，仅当 $x,y$ 有 $0$ 时有解</li><li>对于 $x=0$ 或 $y=0$ ，仅当 $z$ 为非 $0$ 项的倍数时有解（实际上这条也满足裴蜀定理，直接归入一般情况即可）</li></ol><p>参考样例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>: <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="attribute">out</span>: YES</span><br></pre></td></tr></table></figure><h2 id="参考代码-5">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y,z;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;&amp;y&amp;&amp;z==<span class="number">0</span>) &#123;cout &lt;&lt; NO;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll g=<span class="built_in">gcd</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(z%g) cout &lt;&lt; NO;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校06</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校06</title>
    <link href="http://www.cclmsy.cc/posts/93944a48.html"/>
    <id>http://www.cclmsy.cc/posts/93944a48.html</id>
    <published>2023-08-02T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1001.Count</h1><p><strong>构造</strong></p><h2 id="题目大意">题目大意</h2><p>给定 $n,m,k$ ，构造长度为 $n$ 的整数序列，元素大小范围为 $a_i\in [1,m]$ ，并且需要保证前 $k$ 个元素和后 $k$ 个元素对应相同<br>求可以构造出的序列数量</p><h2 id="解题思路">解题思路</h2><p>模拟一下即可<br>对于 $k\le \dfrac{n}{2}$ ，最后 $k$ 个元素由前 $k$ 个元素确定，只需决定前 $n-k$ 个元素<br>对于 $\dfrac{n}{2}\le k \lt n$ ，确定了前 $n-k$ 个元素，可以递归向后确定更多元素<br>对于 $k=n$ ，序列本身自然相同，即可以随意确定 $n$ 个元素</p><p>确定 $x$ 个元素的方案总数为 $m^{x}$ ，快速幂取模即可<br>(P.S.):快速幂前先对底数取模//</p><h3 id="时间复杂度">时间复杂度</h3><p>快速幂： $O(\log n)$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n==k) cout &lt;&lt; <span class="built_in">qcpow</span>(m,n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qcpow</span>(m,n-k) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校06</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校05</title>
    <link href="http://www.cclmsy.cc/posts/f4d5a717.html"/>
    <id>http://www.cclmsy.cc/posts/f4d5a717.html</id>
    <published>2023-07-31T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1001.Typhoon</h1><p><strong>计算几何</strong></p><h2 id="题目大意">题目大意</h2><p>依次给定 $n$ 个坐标 $P$ ，预测的台风路线为按顺序两两连接给定坐标所得的折线<br>现在有 $m$ 个庇护所的坐标 $S$ ，求每个庇护所到台风路线的最短距离<br><img src="/images/ACM/2023Summer_HDU05_1001.jpg" alt="Img"></p><h2 id="解题思路">解题思路</h2><p>对于每个庇护所坐标，求它到每个路线线段的距离，再取最短即可<br>常见的错误为计算了点到线段所在直线的距离，而非到线段的距离（<s>别问我怎么知道的</s>）</p><p>问题转移到如何计算点到线段的距离<br>可以考虑将线段表示为向量，记为 $vec$ ;点到线段两端的向量记为 $vec1,vec2$<br>如果 $vec1,vec2$ 与 $vec$ 的点积同时大于 $0$ 或同时小于 $0$ ，则距离在端点取到，否则距离为点到直线的距离//<br>具体说明可以参考代码注释</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(nm)$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pll&gt; typh,shel;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; frac,dist;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cal_dist</span><span class="params">(pll s,pll t1,pll t2)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    ll x,y,x1,y1,x2,y2,p1,p2;</span><br><span class="line">    pll vec,vec1,vec2;<span class="type">double</span> re;</span><br><span class="line">    x=s.first;y=s.second;<span class="comment">//庇护所坐标</span></span><br><span class="line">    x1=t1.first;y1=t1.second;<span class="comment">//端点1</span></span><br><span class="line">    x2=t2.first;y2=t2.second;<span class="comment">//端点2</span></span><br><span class="line">    vec=&#123;x2-x1,y2-y1&#125;;vec1=&#123;x-x1,y-y1&#125;;vec2=&#123;x-x2,y-y2&#125;;</span><br><span class="line">    <span class="comment">//线段向量、点到两个端点的向量</span></span><br><span class="line">    p1=vec.first*vec1.first+vec.second*vec1.second;<span class="comment">//点积1</span></span><br><span class="line">    p2=vec.first*vec2.first+vec.second*vec2.second;<span class="comment">//点积2</span></span><br><span class="line">    <span class="keyword">if</span>(p1&lt;=<span class="number">0</span>&amp;&amp;p2&gt;<span class="number">0</span>||p1&gt;<span class="number">0</span>&amp;&amp;p2&lt;=<span class="number">0</span>)&#123;<span class="comment">//点到直线距离</span></span><br><span class="line">        <span class="type">double</span> frac=(<span class="type">double</span>)<span class="built_in">sqrt</span>((y2-y1)*(y2-y1)+(x1-x2)*(x1-x2));</span><br><span class="line">        re=(<span class="type">double</span>)<span class="built_in">fabs</span>((y2-y1)*x+(x1-x2)*y-y2*x1+x2*y1)/frac;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//点到端点距离</span></span><br><span class="line">        <span class="type">double</span> dist1=(<span class="type">double</span>)<span class="built_in">sqrt</span>(vec1.first*vec1.first+vec1.second*vec1.second);</span><br><span class="line">        <span class="type">double</span> dist2=(<span class="type">double</span>)<span class="built_in">sqrt</span>(vec2.first*vec2.first+vec2.second*vec2.second);</span><br><span class="line">        re=<span class="built_in">min</span>(dist1,dist2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    typh.<span class="built_in">resize</span>(n);shel.<span class="built_in">resize</span>(m);dist.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:typh) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:shel) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;dist[i]=INF;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-2</span>)</span><br><span class="line">            dist[i]=<span class="built_in">min</span>(dist[i],<span class="built_in">cal_dist</span>(shel[i],typh[j],typh[j+<span class="number">1</span>]));&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> i:dist) &#123;<span class="built_in">print_float</span>(i,<span class="number">4</span>);cout &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1006.Touhou Red Red Blue</h1><p><strong>贪心/DP</strong></p><h2 id="题目大意-2">题目大意</h2><p>你将依次收到 $n$ 个物品，他们具有颜色红、绿或蓝，记为 $R,G,B$</p><p>你有一个大小为 $2$ 的物品栏。每当你收到一个物品，你可以考虑将其放入物品栏<strong>或直接丢弃</strong><br>物品栏是一个栈，这意味着如果你决定放入物品但物品栏是满的，你将丢弃更早放入的那个物品，并将手上的物品放入</p><p>下面是物品的得分和消除规则：</p><ol><li>如果手上和物品栏中共 $3$ 个物品颜色相同，则消除这 $3$ 个物品，得到 $1$ 分（这是唯一的得分方式），并在物品栏得到 $1$ 个颜色由你决定的新物品</li><li>如果手上和物品栏中共 $3$ 个物品颜色各不相同，则消除这 $3$ 个物品，并在物品栏得到 $2$ 个颜色由你决定的新物品</li></ol><p>求对于给定的物品序列，可以得到的最高分是多少</p><h2 id="解题思路-2">解题思路</h2><p>官方给出的做法是DP，但是考虑所有的状态转移略显繁琐，难以不重复、不遗漏<br>相比起来我还是更喜欢直接贪心的方法//</p><p>决定一种游戏策略前，先掌握游戏核心机制<br>首先，在贪心的思想下，物品栏的栈特性可以不考虑//因为如果需要被迫丢弃物品，大可以在拿到这个物品时就直接丢弃//<br>其次，注意到颜色任选的物品可以不立刻考虑，作为<code>任意物品</code>即可<br>考虑消除过程中的特点：</p><ol><li>规则 $2$ 消除后得到 $2$ 个<code>任意物品</code>，可以配合规则 $1$ ，直接和下一个物品（若有）合成得分</li><li>规则 $1$ 消除后留下 $1$ 个<code>任意物品</code>。这意味着如果有得分，最后一定会留下 $1$ 个<code>任意物品</code></li></ol><p>借助上面两个特点，单独考虑第一次消除，后续消除借助前面得到的<code>任意物品</code>，具体可以参考代码注释<br>计数直到满足条件消除，即视为取需要的物品，并直接丢弃无帮助的物品，重新计数即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGB</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>(),res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>,cnt[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur=<span class="built_in">RGB</span>(s[i]);cnt[cur]++;</span><br><span class="line">        <span class="keyword">if</span>(res)&#123;<span class="comment">//消除过，前面必定有一个自选</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]||cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">3</span>]||cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>])&#123;</span><br><span class="line">                <span class="comment">//已有两种不同颜色+自选：选不同颜色，消3得2</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>==n) <span class="keyword">break</span>;<span class="comment">//没有下一个就结束</span></span><br><span class="line">                i++;res++;<span class="comment">//再用2个自选和下一个出现的颜色消除</span></span><br><span class="line">                cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">1</span>]==<span class="number">2</span>||cnt[<span class="number">2</span>]==<span class="number">2</span>||cnt[<span class="number">3</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//已有两个相同颜色+自选：选相同颜色，消3得1</span></span><br><span class="line">                res++;cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//还没有消除过</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>])&#123;<span class="comment">//兼有三色：消3得2</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>==n) <span class="keyword">break</span>;</span><br><span class="line">                i++;res++;<span class="comment">//再用2个自选和下一个出现的颜色消除</span></span><br><span class="line">                cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">1</span>]==<span class="number">3</span>||cnt[<span class="number">2</span>]==<span class="number">3</span>||cnt[<span class="number">3</span>]==<span class="number">3</span>)&#123;<span class="comment">//有三个同色：消3得1</span></span><br><span class="line">                res++;cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Expectation (Easy Version)</h1><p><strong>数学期望</strong></p><h2 id="题目大意-3">题目大意</h2><p>玩 $n$ 次游戏，每次游戏胜利的概率为 $\dfrac{a}{b}$<br>对于给定的 $m$ ，每次游戏胜利将获得 $k^m$ 分，其中 $k$ 是当前总胜利局数，失败得 $0$ 分<br>最终得分为 $n$ 次游戏的得分之和，求最终得分的期望</p><h2 id="解题思路-3">解题思路</h2><p>从全局角度考虑得分情况，游戏输赢概率满足二项分布，记获胜概率为 $p=\dfrac{a}{b}$<br>在 $n$ 局游戏中赢 $k$ 局的概率为： $C_n^k\cdot p^k(1-p)^{n-k}$<br>赢 $k$ 局游戏可以获得的最终得分记为 $score(k)$ ： $score(k)=\sum\limits_{i=1}^k i^m$<br>故最终得分期望为： $E=\sum\limits_{i=1}^n C_n^k\cdot p^k(1-p)^{n-k}\cdot score(k)$</p><p>分别预处理阶乘、乘方、得分数组，求和取模即可</p><h3 id="时间复杂度-3">时间复杂度</h3><p>乘方、阶乘、求和取模： $O(n)$<br>得分（快速幂+前缀和）： $O(n\log m)$<br>总时间复杂度： $O(n\log m)$</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中功能请读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; powp,pownp,score;<span class="comment">//p的n次、q的n次、赢n局的得分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b,re=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll p=<span class="built_in">mul</span>(a,<span class="built_in">inv</span>(b));<span class="comment">//获胜的概率</span></span><br><span class="line">    ll np=<span class="built_in">Get_Mod</span>(<span class="number">1</span>-p);<span class="comment">//失败的概率</span></span><br><span class="line">    powp.<span class="built_in">clear</span>();pownp.<span class="built_in">clear</span>();score.<span class="built_in">clear</span>();</span><br><span class="line">    powp.<span class="built_in">resize</span>(n+<span class="number">1</span>);pownp.<span class="built_in">resize</span>(n+<span class="number">1</span>);score.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    powp[<span class="number">0</span>]=pownp[<span class="number">0</span>]=<span class="number">1</span>;score[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        powp[i]=<span class="built_in">mul</span>(powp[i<span class="number">-1</span>],p);</span><br><span class="line">        pownp[i]=<span class="built_in">mul</span>(pownp[i<span class="number">-1</span>],np);</span><br><span class="line">        score[i]=<span class="built_in">add</span>(score[i<span class="number">-1</span>],<span class="built_in">qcpow</span>(i,m));&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        re=<span class="built_in">add</span>(re,<span class="built_in">mul</span>(score[i],<span class="built_in">mul</span>(<span class="built_in">Get_Combination</span>(n,i),<span class="built_in">mul</span>(powp[i],pownp[n-i]))));</span><br><span class="line">        <span class="comment">//Ex(i)=C(n,i)*p^i*(1-p)^(n-i)*score(i)</span></span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.Counting Stars</h1><p><strong>计数</strong></p><h2 id="题目大意-4">题目大意</h2><p>定义 $k$ 星状图：一个 $k+1$ 个节点， $k$ 条边的无向图，中心节点与其他 $k$ 个节点之间各有一条边，其他节点之间没有边<br>给定一个无向图 $G=(V,E),|V|=n,|E|=m$ ，记其中不同的 $k$ 星状图的数量为 $cnt_k$<br>求对于 $2\le k\le n-1$ ，所有 $cnt_k$ 的异或和： $cnt_2\oplus cnt_3\oplus \cdots \oplus cnt_{n-1}$</p><h2 id="解题思路-4">解题思路</h2><p>对于某个节点 $i$ ，记它的度为 $deg_i$ ，考虑以它作为中心节点的情况<br>简单的组合问题，以 $i$ 为中心节点的 $k$ 星图数量即 $C_n^k$<br>遍历 $n$ 个节点，在每个节点处对 $2\le k\le deg_i$ 的 $k$ 星图计数取模<br>最终把所有结果做异或和即可</p><h3 id="时间复杂度-4">时间复杂度</h3><p>预处理阶乘（计算组合数）： $O(n)$<br>遍历节点：$O(n+m)$<br>异或和：$O(n)$<br>总时间复杂度：$O(n+m)$</p><h2 id="参考代码-4">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; deg,cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deg.<span class="built_in">clear</span>();deg.<span class="built_in">resize</span>(n+<span class="number">1</span>);cnt.<span class="built_in">clear</span>();cnt.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        deg[u]++;deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">2</span>,deg[i])</span><br><span class="line">            cnt[j]=<span class="built_in">Get_Mod</span>(cnt[j]+<span class="built_in">Get_Combination</span>(deg[i],j));</span><br><span class="line">    ll re=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n<span class="number">-1</span>) re^=cnt[i];</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校05</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校05</title>
    <link href="http://www.cclmsy.cc/posts/185a5ce3.html"/>
    <id>http://www.cclmsy.cc/posts/185a5ce3.html</id>
    <published>2023-07-30T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>C.Cheeeeen the Cute Cat</h1><p><strong>二部图最大匹配</strong></p><h2 id="题目大意">题目大意</h2><p>给定一个具有 $2n$ 个节点的二部图，前 $n$ 个节点和后 $n$ 个节点各成一部<br>对于每对 $(i,j),i\ne j$ ，保证在 $i,j+n$ 和 $j,i+n$ 之间有且仅有一条边，整幅图的边数共 $C_n^2$ 条<br>求这个二部图的最大匹配</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://oi-wiki.org/graph/bi-graph/">二分图</a><br><a href="https://oi-wiki.org/graph/graph-matching/bigraph-match/">二分图最大匹配</a></p><h2 id="解题思路">解题思路</h2><p>题解和讨论区谈及竞赛图以及相关特点，稍微了解了一下但是赛事确实没发现可以把这个图转化成一个竞赛图//<br>当时一眼看去就像一道朴实无华的板子题，队友直接交了一发板子就过了//<br>跑一遍增广路求出最大匹配即可，具体的实现原理在OI-Wiki上有非常详细的推导与说明//<br>本蒟蒻就是看它学的qwq这里就不过多赘述了</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">augment_path <span class="title">G</span><span class="params">(n,n*<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span>(t) G.<span class="built_in">add</span>(i,j+n);</span><br><span class="line">        &#125;cout &lt;&lt; G.<span class="built_in">solve</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>D.Cirno’s Perfect Equation Class</h1><p><strong>签到</strong></p><h2 id="题目大意-2">题目大意</h2><p>给定三个整数 $k,c,n$<br>求满足以下条件的有序对 $(a,b)$ 的个数： $ka+b=c$ ， $b|c$ ， $gcd(a,b)&gt;n$</p><h2 id="解题思路-2">解题思路</h2><p>注意到第二个约束条件： $b$ 是 $c$ 的因子<br>因此对 $b$ 枚举，判断计数即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(qc^\frac{1}{2})$</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll k,c,n,a,tb;</span><br><span class="line">cin &gt;&gt; k &gt;&gt; c &gt;&gt; n;</span><br><span class="line">ll r=<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(c)),cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll b=<span class="number">1</span>;b*b&lt;=c;b++)&#123;</span><br><span class="line"><span class="keyword">if</span>(c%b==<span class="number">0</span>&amp;&amp;(c-b)%k==<span class="number">0</span>)&#123;</span><br><span class="line">a=(c-b)/k;</span><br><span class="line"><span class="keyword">if</span>(a&amp;&amp;b&amp;&amp;<span class="built_in">gcd</span>(a,b)&gt;=n) cnt++;</span><br><span class="line">&#125;</span><br><span class="line">tb=c/b;</span><br><span class="line"><span class="keyword">if</span>(tb!=b&amp;&amp;c%tb==<span class="number">0</span>&amp;&amp;(c-tb)%k==<span class="number">0</span>)&#123;</span><br><span class="line">a=(c-tb)/k;</span><br><span class="line"><span class="keyword">if</span>(a&amp;&amp;tb&amp;&amp;<span class="built_in">gcd</span>(a,tb)&gt;=n) cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>G.Go to Play Maimai DX</h1><p><strong>签到</strong></p><h2 id="题目大意-3">题目大意</h2><p>给定一个长度为 $n$ 仅含有 $1,2,3,4$ 四种数字的序列<br>求最短的包含 $1,2,3$ 和 $k$ 个 $4$ 的区间的长度</p><h2 id="解题思路-3">解题思路</h2><p>用快慢指针确定区间<br>快指针每次记录元素，直到满足条件；<br>慢指针每次移除元素，直到不满足条件<br>即可得到每个满足条件的最小区间，比较长度即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考程序">参考程序</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">0</span>,cnt[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;,re=n;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>]&amp;&amp;cnt[<span class="number">4</span>]&gt;=k))&#123;</span><br><span class="line">            r++;cnt[v[r]]++;<span class="keyword">if</span>(r&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>]&amp;&amp;cnt[<span class="number">4</span>]&gt;=k)&#123;</span><br><span class="line">            l++;cnt[v[l]]--;<span class="keyword">if</span>(l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;re=<span class="built_in">min</span>(re,r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Nazrin the Greeeeeedy Mouse</h1><p><strong>动态规划</strong></p><h2 id="题目大意-4">题目大意</h2><p>给定一组 $n$ 个奶酪，第 $i$ 个奶酪具有重量 $w_i$ 和价值 $val_i$<br>将前来取 $m$ 次奶酪，每次会携带一个大小为 $sz$ 的背包，并保证每一次携带背包的大小不小于前一次，并从第一个奶酪出发<br>对于每一个奶酪，可以选择装入背包（如果背包剩余空间足够）或挖洞通过（被挖洞的奶酪无法带走），并且仅当上一块奶酪被带走或挖洞，才能到达下一块<br>每次出发的过程不独立，问 $m$ 次可以获得最大价值为多少//</p><h2 id="解题思路-4">解题思路</h2><p>由于每次携带的背包大小都不小于前一次，因此如果取的次数 $m$ 多于奶酪个数 $n$ ，只需要考虑最后 $n$ 个背包即可//感性证明一下：如果倒数 $n$ 背包内某次装不下任何一块奶酪，那么之前的背包也不可能装下//</p><p>对于奶酪，只有取和不取两种状态（为不影响后续操作，没取的奶酪直接视为挖洞）<br>对于某一轮行动，假设最优解下它取的第一个奶酪和最后一个奶酪之间的区间为 $[l,r]$ ，那么可以视为这一轮行动是携带空间为 $sz_i$ ，第 $[l,r]$ 个奶酪上的01背包问题</p><p>由于不确定每轮取的范围以及对应背包大小，因此每个区间的每个重量都需要一个01背包DP值<br>用 $dp_{i,j,k}$ 表示在区间 $[i,j]$ 内，取重量为 $k$ 的物品可以获得的最大价值，可以得到以下状态转移方程：<br>$$<br>dp_{i,j,k}=\begin{cases}<br>dp_{i,j-1,k} &amp;,dp_{i,j-1,k-w[j]}+val_j&lt;dp_{i,j-1,k}或 k&lt;w_j\newline<br>dp_{i,j-1,k-w[j]}+val_j &amp;,dp_{i,j-1,k-w[j]}+val_j&gt;dp_{i,j-1,k}<br>\end{cases}<br>$$</p><p>在计算完 $[i,j]$ 内的 $dp$ 值后，前缀维护每一个 $k$ 的 $dp_{i,j,k}$ ，使得对于该区间， $dp$ 值随 $k$ 增加不递减</p><p>最后对全部 $m$ 轮行动进行DP，记 $g_{i,j}$ 为第 $i$ 次行动携带背包的容量为 $sz$ ，到达的最后一个位置为 $j$ 所得到的最大价值，可以得到以下状态转移方程：<br>$$<br>g_{i,j}=max{g_{i-1,k}+dp_{k+1,j,sz}},k\in[1,j-1]<br>$$</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(n^2w)$</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 205</span></span><br><span class="line">ll dp[N][N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll w[N]=&#123;<span class="number">0</span>&#125;,val[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll g[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RESET</span>(dp);</span><br><span class="line">    ll n,m,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; val[i];</span><br><span class="line">    <span class="comment">//规划[i,j]区间内取体积为k的最优解</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//从第i个开始考虑</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,i,n)&#123;<span class="comment">//目前考虑第j个取/不取</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">0</span>,w[j]<span class="number">-1</span>) dp[i][j][k]=dp[i][j<span class="number">-1</span>][k];</span><br><span class="line">            <span class="comment">//对于无法装下第j个的情况，用j-1之前的维护</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,w[j],N) dp[i][j][k]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>][k],dp[i][j<span class="number">-1</span>][k-w[j]]+val[j]);</span><br><span class="line">            <span class="comment">//可以装下的情况，更新较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)</span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)</span><br><span class="line">                dp[i][j][k]=<span class="built_in">max</span>(dp[i][j][k],dp[i][j][k<span class="number">-1</span>]);</span><br><span class="line">                <span class="comment">//对于区间[i,j]，前缀维护最优解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)&#123;<span class="built_in">FORLL</span>(i,<span class="number">1</span>,m-n) cin &gt;&gt; t; m=n;&#125;ll sz,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;cin &gt;&gt; sz;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">0</span>,j<span class="number">-1</span>) g[i][j]=<span class="built_in">max</span>(g[i][j],g[i<span class="number">-1</span>][k]+dp[k+<span class="number">1</span>][j][sz]);</span><br><span class="line">            <span class="comment">//第二项：前i个背包最远拿到第k项+第i个背包拿[k+1,j]内</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校05</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期牛客多校04</title>
    <link href="http://www.cclmsy.cc/posts/6e0e8bd8.html"/>
    <id>http://www.cclmsy.cc/posts/6e0e8bd8.html</id>
    <published>2023-07-27T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>A.Bobo String Construction</h1><p><strong>构造</strong></p><h2 id="题目大意">题目大意</h2><p>给定一个标识01串 $t$ ，构造一个长度为 $n$ 的信息01串 $s$ ，使得串 $m=t+s+t$ 中，串$t$ 仅在开头和结尾各出现过一次。（其中 $+$ 表示字符串连接运算）</p><h2 id="解题思路">解题思路</h2><p>考虑构造 $s$ 全为 $0$ 或 $1$</p><p>对于特殊情况， $t$ 全为 $0$ 或 $1$ ，则使 $s$ 全为 $1$ 或 $0$ 即可</p><p>如果 $t$ 中兼有 $0$ 和 $1$ ，则 显然 $s$ 中不可能有子串 $t$<br>但对于 $m=t+s+t$ ，可能有 $t的后缀+s+t的前缀=t$ 的情况出现，导致不满足题设条件//</p><p>那么下面感性证明一下两种方案至少有一种成立。<br>假设对于兼有 $0$ 和 $1$ 的 $t$ ，在 $s$ 全为 $0$ 的情况下出现：<br>$t的后缀+s+t的前缀=t$<br>那么构造 $s$ 全为 $1$ 即可，反之亦然</p><p>于是问题就转化为在 $s$ 全为 $1$ 或 $0$ 的方案中选择一种使得串$t$ 仅在开头和结尾各出现过一次<br>先使 $s$ 全为 $1$ 将 $m=t+s+t$ 去掉首尾一个字符，判断中间有无字串 $t$ 即可<br>归纳发现特殊情况也可以用这种方法构造</p><h3 id="时间复杂度">时间复杂度</h3><p>数据范围小（ $n\le 1000,|t|\le 1000$ ），BF即可</p><h2 id="参考程序">参考程序</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t;ll n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    string s;<span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) s.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    string m=t+s+t;m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());m.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">find</span>(t)!=string::npos) <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>F.Election of the King</h1><p><strong>签到、模拟</strong></p><h2 id="题目大意-2">题目大意</h2><p>$n$ 个人竞选国王，每个人的从政理念用 $a_i$ 量化表示<br>每人每轮可以进行投票，对于个人而言，他会将票投给和他自己的政治理念相差最大的人<br>票数最多的人将被淘汰。如果票数相同，则淘汰值最大的；如果最大值有多个，则淘汰序号最大的人。<br>重复直到剩余一人成为国王，问最后谁会竞选上国王</p><h2 id="解题思路-2">解题思路</h2><p>对于其中某一个人，和他相差最大的，一定是最大值与最小值之一<br>那么每次一定淘汰最大值或最小值<br>因此对所有人进行排序，每轮投票处于中间位置的人代表着多数人的意志<br>因此每轮看中间的人投最大值还是最小值，踢到只剩一人即可</p><h2 id="参考程序-2">参考程序</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    deque&lt;pll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(t,i);</span><br><span class="line">    &#125;<span class="built_in">SORT</span>(v);</span><br><span class="line">    <span class="type">float</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        mid=<span class="number">1.</span>*(v.<span class="built_in">front</span>().first+v.<span class="built_in">back</span>().first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(v[(n+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>].first&lt;=mid) v.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">else</span> v.<span class="built_in">pop_front</span>();</span><br><span class="line">        n--;</span><br><span class="line">    &#125;cout &lt;&lt; v.<span class="built_in">front</span>().second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Merge the squares!</h1><p><strong>几何、分治</strong></p><h2 id="题目大意-3">题目大意</h2><p>给定一个 $n\times n$ 的矩阵，它由 $n\times n$ 个小正方形组成<br>每次操作可以选择 $2\le x\le50$ 个正方形并把它们组合成一个更大的正方形（组合后的形状也必须为正方形）<br>求合并到整个边长为 $n$ 大小的正方形的操作过程</p><h2 id="解题思路-3">解题思路</h2><p>这道题可以采用分治的思想</p><p>对于边长不大于 $7$ 的正方形，它的面积不大于 $49$ ，可以直接合并<br>对于边长较大的正方形，可以考虑将其分解为更小的正方形，递归处理</p><p>接下来考虑一种通用可行的分解方法如下图<br><img src="/images/ACM/2023Summer_NCD04_H.png" alt="Img"><br>这种分法将大正方形分解成两个小正方形和两个矩形<br>假设小正方形在递归处理中合并完成，占用块数为 $2$ ，那么每个长方形部分允许占用的块数为 $(50-2)/2=24$ 块</p><p>对于每个长方形，按照宽分割成一个正方形和一个矩形，对两部分分别递归处理</p><p>代码中预处理了一个切割方案，用于决定在大正方形边长为 $i$ 的情况下，满足矩形 $(i-j)\times j$ 即长方形的部分，占用分割块数不超过 $24$ 时，左上角的正方形边长，以此保证每次递归处理大正方形都满足条件</p><h1>参考代码</h1><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">ll len[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_len</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">            ll cnt=<span class="number">0</span>;</span><br><span class="line">            ll a=j,b=i-j;<span class="comment">//先减去一个j*j大小的方形</span></span><br><span class="line">            <span class="keyword">while</span>(b)&#123;</span><br><span class="line">                cnt+=a/b;</span><br><span class="line">                a%=b;</span><br><span class="line">                <span class="built_in">swap</span>(a,b);</span><br><span class="line">            &#125;<span class="comment">//辗转相减得到(i-j)*j下分块数量</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= <span class="number">24</span>)&#123;</span><br><span class="line">                len[i]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//得到长i下的可用宽j</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node_op</span>&#123;</span><br><span class="line">    ll x,y,n;</span><br><span class="line">&#125;top;</span><br><span class="line">vector&lt;node_op&gt; op;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x1,ll y1,ll x2,ll y2)</span><span class="comment">//递归处理(x1,y1):(x2,y2)区域的矩形</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll difx=x2-x1+<span class="number">1</span>,dify=y2-y1+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(difx==<span class="number">1</span>||dify==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(difx&gt;dify)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1,x1+dify<span class="number">-1</span>,y2);</span><br><span class="line">        <span class="built_in">dfs</span>(x1+dify,y1,x2,y2);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(difx&lt;dify)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1,x2,y1+difx<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1+difx,x2,y2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//difx==dify</span></span><br><span class="line">        <span class="keyword">if</span>(difx==<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//边长为1无需merge</span></span><br><span class="line">        <span class="keyword">if</span>(difx&gt;<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x1,y1,x1+len[dify]<span class="number">-1</span>,y1+len[difx]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(x1+len[dify],y1+len[difx],x2,y2);</span><br><span class="line">            <span class="built_in">dfs</span>(x1+len[dify],y1,x2,y1+len[difx]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(x1,y1+len[difx],x1+len[dify]<span class="number">-1</span>,y2);</span><br><span class="line">        &#125;</span><br><span class="line">        top.x=x1;top.y=y1;top.n=difx;</span><br><span class="line">        op.<span class="built_in">emplace_back</span>(top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op.<span class="built_in">clear</span>();</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">pre_len</span>(n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,n,n);</span><br><span class="line">    cout &lt;&lt; op.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:op)&#123;</span><br><span class="line">        cout &lt;&lt; i.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i.n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>J.Qu’est-ce Que C’est?</h1><p><strong>动态规划</strong></p><h2 id="题目大意-4">题目大意</h2><p>给定两个正整数 $n,m$ ，要求构造长度为 $n$ 的整数序列 $a$ ，满足：</p><ol><li>$\forall i\in [1,n],-m\le a_i\le m$</li><li>任意长度大于 $1$ 的连续子段之和不小于 $0$</li></ol><p>求满足以上条件的整数序列的个数，结果取模</p><h2 id="解题思路-4">解题思路</h2><p>计数取模，比起DP我会首先考虑猜通项<br>赛时根据样例1：$n=3,m=3\Rightarrow130$ 以及手算的 $n=2,m=3\Rightarrow28$ ，结合题目特征，拟出了一个满足上面两个情况的很奇怪的式子//然后样例2过不了，<s>开摆</s></p><p>DP的思想是先计算出第 $i$ 个位置前已经满足题设条件，且最小后缀和为 $j$ 的方案数量（ $j$ 可以是负数，因为最后一个数可以单独为负数）<br>考虑如何进行状态转移</p><p>对每个位置从大到小遍历当前位置填数后的最小后缀和 $j$ ，记当前遍历到 $i$ ，填入的数为 $x$</p><ol><li>对于非负整数 $j$ ，填入 $x$ 时的方案数为 $dp_{i-1,j-x}$<br>其中 $j-x\in[-m,m],x\in[-m,m],j\ge 0 \Rightarrow x\in [j-m,m]$，此时 $dp_{i,j}=\sum\limits_{x=j-m}^m dp_{i-1,x}$</li><li>对于负整数 $j$ ，此时 $x=j$ ，其方案数为允许 $x$ 填入的所有方案数之和，即 $dp_{i,j}=\sum\limits_{x=-j}^m dp_{i-1,x}$</li></ol><p>由于每次计算都用到了前一个位置的以 $m$ 为上界的区间和，因此可以对每个位置的dp数组从 $m$ 到 $-m$ 维护一个前缀和，以降低时间复杂度</p><h2 id="复杂度">复杂度</h2><p>时间复杂度： $O(n^2)$<br>空间复杂度： $M(Cn^2)$ ， $C$ 是常数，开LL可能会导致MLE<br>7/30：开L都MLE了//进行了空间优化，只保留 $dpsum$ 数组</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O 5000 <span class="comment">//记为0</span></span></span><br><span class="line"><span class="type">long</span> dp[<span class="number">5005</span>][<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//表示前i-1个数的最小后缀和为j+5000时，满足条件的可行方案数</span></span><br><span class="line"><span class="type">long</span> dpsum[<span class="number">5005</span>][<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//表示dp[i][m]到dp[i][j]可行方案数的区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--) &#123;dp[<span class="number">1</span>][j+O]=<span class="number">1</span>;dpsum[<span class="number">1</span>][j+O]=dpsum[<span class="number">1</span>][j+<span class="number">1</span>+O]+dp[<span class="number">1</span>][j+O];&#125;</span><br><span class="line">    <span class="comment">//预处理前0位</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) dp[i][j+O]=dpsum[i<span class="number">-1</span>][j-m+O];</span><br><span class="line">            <span class="comment">//下界x+m=j =&gt; x=j-m</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j+O]=dpsum[i<span class="number">-1</span>][-j+O];</span><br><span class="line">            <span class="comment">//j&lt;0 下界-j</span></span><br><span class="line">            dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dp[i][j+O]);</span><br><span class="line">            <span class="comment">//计数取模</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; dpsum[n][-m+O] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7/30：空间优化后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O 5000 <span class="comment">//记为0</span></span></span><br><span class="line"><span class="comment">//long dp[5001][10001]=&#123;0&#125;;//表示前i-1个数最小后缀和为j+5000，满足条件的可行方案数</span></span><br><span class="line"><span class="type">long</span> dpsum[<span class="number">5001</span>][<span class="number">10001</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//表示dp[i][m]到dp[i][j]可行方案数的区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">        <span class="comment">//dp[1][j+O]=1;</span></span><br><span class="line">        <span class="comment">//dpsum[1][j+O]=dpsum[1][j+1+O]+dp[1][j+O];</span></span><br><span class="line">        dpsum[<span class="number">1</span>][j+O]=dpsum[<span class="number">1</span>][j+<span class="number">1</span>+O]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">            <span class="comment">//if(j&gt;=0) dp[i][j+O]=dpsum[i-1][j-m+O];//下界x+m=j =&gt; x=j-m</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dpsum[i<span class="number">-1</span>][j-m+O]);</span><br><span class="line">            <span class="comment">//else dp[i][j+O]=dpsum[i-1][-j+O];//j&lt;0 下界-j</span></span><br><span class="line">            <span class="keyword">else</span> dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dpsum[i<span class="number">-1</span>][-j+O]);</span><br><span class="line">            <span class="comment">//dpsum[i][j+O]=Get_Mod(dpsum[i][j+1+O]+dp[i][j+O]);</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; dpsum[n][-m+O] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>L.We are the Lights</h1><p><strong>思维题</strong></p><h2 id="题目大意-5">题目大意</h2><p>有 $n\times m$ 的电灯矩阵，初始全为关闭状态</p><p>每次操作会打开或关闭某一行/列的所有灯</p><p>问在给定的 $q$ 次操作后，共有多少盏灯亮着</p><h2 id="解题思路-5">解题思路</h2><p>这道题和某刷墙小游戏类似（）玩过的话应该不难想到做法<br><img src="/images/ACM/2023Summer_NCD04_L.jpg" alt="Img"><br>后面的行动会覆盖前面的行动，用数组记录当前行/列是否已被覆盖</p><p>从后往前遍历操作即可</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> rc[N]=&#123;<span class="number">0</span>&#125;,op[N]=&#123;<span class="number">0</span>&#125;,rowvd[N]=&#123;<span class="number">0</span>&#125;,colvd[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll x[N]=&#123;<span class="number">0</span>&#125;,cnt=<span class="number">0</span>,cntr=<span class="number">0</span>,cntc=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    string trc,top;ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; trc &gt;&gt; t &gt;&gt; top;</span><br><span class="line">        <span class="keyword">if</span>(trc==<span class="string">&quot;row&quot;</span>) rc[i]=<span class="number">1</span>;<span class="keyword">else</span> rc[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(top==<span class="string">&quot;on&quot;</span>) op[i]=<span class="number">1</span>;<span class="keyword">else</span> op[i]=<span class="number">0</span>;</span><br><span class="line">        x[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=q;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rc[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(rowvd[x[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                rowvd[x[i]]=<span class="number">1</span>;cntr++;</span><br><span class="line">                <span class="keyword">if</span>(op[i]==<span class="number">1</span>) cnt+=m-cntc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(colvd[x[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                colvd[x[i]]=<span class="number">1</span>;cntc++;</span><br><span class="line">                <span class="keyword">if</span>(op[i]==<span class="number">1</span>) cnt+=n-cntr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期牛客多校04</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期牛客多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2023暑期杭电多校04</title>
    <link href="http://www.cclmsy.cc/posts/803f0ea0.html"/>
    <id>http://www.cclmsy.cc/posts/803f0ea0.html</id>
    <published>2023-07-26T16:00:00.000Z</published>
    <updated>2023-11-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1003.Simple Set Problem</h1><p><strong>思维</strong></p><h2 id="题目大意">题目大意</h2><p>给定 $k$ 个非空集合，在每一个集合里选择一个数 $a_i$ ，使得这些数之中最大值与最小值之差 $d=max(a_i)-min(a_i)$ 最小，输出 $d$ 的最小值</p><h2 id="解题思路">解题思路</h2><p>不论哪一种选法，最小值一定是在全体元素中取到的<br>不妨从小到大遍历全体元素作为下界，记当前遍历元素为 $a_i$<br>在每一个集合中二分查找恰好大于等于 $a_i$ 的元素选入(遍历到 $a_i$ 所在集合的时候，一定会选入 $a_i$ )<br>找到选定元素的最大值，做差<br>直到某个集合中没有大于等于 $a_i$ 的元素为止（此时该集合最大的元素选入的情况已全部考虑过），最终在得到的值中取最小即可</p><h3 id="时间复杂度">时间复杂度</h3><p>读入： $O(n)$ ；排序： $O(n\log n)$ ；遍历二分查找： $O(n\log n)$<br>综合时间复杂度：  $O(n\log n)$<br>其中 $n$ 表示全体元素个数， $n\le 4e6$</p><h2 id="参考代码">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">sets</span>(n+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    vector&lt;ll&gt;::iterator it;</span><br><span class="line">    ll tn,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tn;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,tn) &#123;cin &gt;&gt; t;sets[i].<span class="built_in">emplace_back</span>(t);v.<span class="built_in">emplace_back</span>(t);&#125;</span><br><span class="line">        <span class="built_in">SORT</span>(sets[i]);</span><br><span class="line">    &#125;<span class="built_in">SORT</span>(v);</span><br><span class="line">    ll re=INF,tre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)&#123;</span><br><span class="line">        tre=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            it=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(sets[i]),x);</span><br><span class="line">            <span class="keyword">if</span>(it==sets[i].<span class="built_in">end</span>()) &#123;tre=<span class="number">-1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tre=<span class="built_in">max</span>(tre,*it-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tre==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        re=<span class="built_in">min</span>(re,tre);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1006.PSO</h1><p><strong>数学题、概率论</strong></p><h2 id="题目大意-2">题目大意</h2><p>给定一个星状图（中心节点与每个其他节点之间各有一条边，其他节点之间没有边），任选两个点，求它们之间的距离的数学期望以及最大距离的长度</p><h2 id="解题思路-2">解题思路</h2><p>任选两个点的方案总数为 $C_n^2=n(n-1)/2$<br>其中一个点是中心点的方案数为 $n-1$ ，距离是 $1$<br>其余方案数为 $n(n-1)/2-(n-1)$ ，距离是 $2$<br>因此任选两个点的距离期望为：<br>$$\begin{align}<br>E&amp;={[n(n-1)/2-(n-1)]\times2+(n-1)\times1}/C_n^2 \newline<br>&amp;=[n(n-1)-(n-1)\times2+(n-1)]/C_n^2 \newline<br>&amp;=(n-1)^2/C_n^2 \newline<br>&amp;=2(n-1)/n<br>\end{align}<br>$$<br>注意控制精度</p><h2 id="参考程序">参考程序</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf&quot;</span>,<span class="number">2.</span>*(n<span class="number">-1</span>)/n);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot; 2.000000000\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; 1.000000000\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Guess</h1><p><strong>莫比乌斯函数</strong></p><h2 id="题目大意-3">题目大意</h2><p>给定一个正整数 $n\le1e18$ ，求 $e^{S(n)}$</p><p>其中，$S(n)=\sum\limits_{d|n} \mu(\dfrac{n}{d})\ln(d)$ ，$e$ 是自然对数 $\ln$ 的底数，$\mu(x)$ 是莫比乌斯函数，答案取模</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://baike.baidu.com/item/%E9%BB%98%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/16625781">莫比乌斯函数</a>：<br>$$<br>\mu(n)=\begin{cases}<br>1 &amp;,n=1; \newline<br>0 &amp;,n含有大于1的完全平方因子; \newline<br>(-1)^k &amp;,n为k个质数的乘积 \newline<br>\end{cases}<br>$$</p><h2 id="解题思路-3">解题思路</h2><p>对于 $n$ 的因数 $d$ ，根据 $\dfrac{n}{d}$ 与 $d$ 的轮换对称性可知：<br>$S(n)=\sum\limits_{d|n} \mu(\dfrac{n}{d})\ln(d)=\sum\limits_{d|n} \mu(d)\ln(\dfrac{n}{d})$</p><p>对 $S(n)$ 做一次莫比乌斯变换（第一形式）可得：$\ln(n)=\sum\limits_{d|n} S(d)$</p><p>两边以 $e$ 做底数得 $e^{ln(n)}={e}^{\sum\limits_{d|n} S(d)}\Rightarrow n=\prod\limits_{d|n} e^{S(d)}$</p><p>右式是一个连乘积，其连乘长度为 $n$ 的全体因数个数<br>记 $F(x)=e^{S(x)}$ ，那么答案也就是在求 $F(n)$</p><p>根据上式：</p><ol><li>$1=F(1)\Rightarrow F(1)=1$</li><li>对于任意质数 $x$ ，$x=F(1)F(x)\Rightarrow F(x)=x$</li><li>对于任意合数 $x$ ，借助 $1,2$ 递归计算出 $F(x)$</li></ol><p>经过较长时间的感性理解，想到了一种遍历求 $F(x)$ 方法的伪代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F<span class="selector-attr">[]</span>=&#123;<span class="number">0</span>&#125;</span><br><span class="line">FOR <span class="selector-tag">i</span> <span class="keyword">in</span> &#123;<span class="number">1</span>..+∞&#125;</span><br><span class="line">    FOR <span class="selector-tag">p</span> <span class="keyword">in</span> Primes</span><br><span class="line">        <span class="keyword">if</span> F<span class="selector-attr">[i*p]</span>==<span class="number">0</span> then F<span class="selector-attr">[i*p]</span>=p</span><br></pre></td></tr></table></figure><p>（其实打表也挺好的，想个一般性的方法好难qwq）</p><p>可以得到以下 $F(x)$ 的正整数序列：<br>$1,2,3,2,5,1,7,2,3,1,11,1,13,1,1,2,17,1,19,1,1,1,23\cdots$</p><p>这个序列的意义是 $x$ 对乘积 $n$ 的贡献，回到上面看那个连乘积的长度和表达形式就非常合理了</p><p>通项公式为：<br>$$\begin{align}<br>F(n)&amp;=lcm{1…n}/lcm{1…n-1} \newline<br>&amp;=\begin{cases}<br>n&amp;,n=p^i,p是素数,i\in \N_+ \newline<br>1&amp;,Otherwise<br>\end{cases}<br>\end{align}<br>$$<br>即为最终答案</p><p>面对 $n\le 1e18$ 的庞大数据，问题就落到了如何快速求出 $F(n)$ 上了。根据通项公式，只需要判断 $n$ 是否有且只有一个素数非平凡因子 $p$ 即可</p><p>Pollard-Rho算法是一种用于因数分解整数的快速随机算法，它可以实现在 $n^{\frac{1}{4}}$ 的时间下随机找到一个 $n$ 的非平凡因子<br>其中用到了Miller-Rabin 素性测试算法，是一种测试素数的快速随机算法</p><p>Pollard-Rho算法的具体实现可以参考这篇博文：<a href="https://blog.csdn.net/maxichu/article/details/45459533">大数因数分解Pollard_rho 算法详解</a></p><p>最终根据查找结果，结合通项公式判断输出即可</p><h2 id="参考代码-2">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><p>（Pollard_Rho算法及Miller_Rabin算法部分略）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ll fac=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prop</span><span class="params">(ll n)</span></span>&#123;<span class="comment">//判断n==p^i</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n))&#123;</span><br><span class="line">        <span class="keyword">if</span>(fac==<span class="number">0</span>) fac=n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fac!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=n;</span><br><span class="line">    <span class="keyword">while</span>(p==n) p=<span class="built_in">Pollard_Rho</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prop</span>(p)&amp;&amp;<span class="built_in">prop</span>(n/p)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    fac=<span class="number">0</span>;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n)) &#123;cout &lt;&lt; <span class="built_in">Get_Mod</span>(n) &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prop</span>(n)) cout &lt;&lt; <span class="built_in">Get_Mod</span>(fac) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-3.png" alt="Alt text"></p><hr><h1>1010.Kong Ming Qi</h1><p><strong><s>猜结论题</s> 找规律题</strong></p><h2 id="题目大意-4">题目大意</h2><p>如题，游戏规则和孔明棋相似<br>在一个 $(n+2)\times(m+2)$ 大小的棋盘的中间 $n\times m$ 的格子里放置着一些棋子<br>每次行动可以选择一个有四面相邻的棋子，使其跳过相邻的棋子，并使被跳过的棋子从棋盘上被移除<br>问对于给定的 $n,m$ ，剩余棋子个数最少是多少</p><h2 id="解题思路-4">解题思路</h2><p>首先考虑只有一行/一列的情况，每次只能选择倒数第二个跳出。假设 $n=1$ ，连续模拟几次可知一定剩余 $\lceil m/2 \rceil$ 颗棋子<br><img src="/images/ACM/2023Summer_HDU04_1010_1.png" alt="Img"></p><p>对于多行多列的情况，可以考虑以下两个基础操作：</p><ol><li>每次消去 $1\times 3$ 区域的棋子(需要左下方有棋子，中间操作)<br><img src="/images/ACM/2023Summer_HDU04_1010_2.png" alt="Img"></li><li>每次消去 $2\times 3$ 区域的棋子(最终操作)<br><img src="/images/ACM/2023Summer_HDU04_1010_3.png" alt="Img"></li></ol><p>连续操作 $1$ 后操作 $2$ ，即可在行数/列数大于 $3$ 的情况下任意消除 $3$ 行/列</p><p>考虑小情况 $2\times 2,2\times 3,3\times 3,2\times 4,3\times 4$ 等，借助上述基础操作以及模拟可得，当 $m,n$ 中有一个为3时，最少剩余 $2$ 颗棋子，其他情况最少剩余 $1$ 颗棋子，依此打表</p><h2 id="参考程序-2">参考程序</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(m,n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; (m+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(n%<span class="number">3</span>&amp;&amp;m%<span class="number">3</span>)) cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1011.Circuit</h1><p><strong>图论-最短路-Floyd</strong></p><h2 id="题目大意-5">题目大意</h2><p>给定一个无重边、无自循环的带权有向图 $G=(V,E),|V|=n,|E|=m$<br>求 $G$ 的所有回路中最短回路的长度以及个数，个数取模</p><h2 id="解题思路-5">解题思路</h2><p>全图范围的最短路计数，考虑使用弗洛伊德算法//</p><p>为了不重不漏的计数，考虑每个最短回路仅在其最大标号处计数<br>对于一条有向回路，可以将其最大编号到下一点的有向边单独分割出来，剩余部分即为从起点到回路上最大编号点的最短路//</p><p>借助Floyd算法，在 $O(n^3)$ 的时间内，计算最短路的同时，可以进行最短路方案数的计数，这里详细阐述一下计数过程</p><p>原图 $G$ 存在有向边 $u\rightarrow v$ ，则 $u\rightarrow v$ 的初始方案数置为 $1$ ，没有边则置为 $0$</p><p>加入点 $k$ 时，过点 $k$ 的 $i\rightarrow j$ 的最短路的方案数为： $i\rightarrow k$ 的最短方案数 $\times$ $k\rightarrow j$ 的最短路方案数<br>如果发生最短路更新，则方案数一并更新//另判断如果长度一致，则方案数需相加</p><p>每次完成更新后，假设 $k$ 已经是以 $i$ 为起点的最短回路上的最大编号点了，此时原图 $G$ 中如果有 $k\rightarrow i$ 的有向边，则可以构成回路，比较计数即可//</p><p>更加具体的内容可以参考代码注释</p><p>温馨提示： $INF$ 的值需要设置到 $1e18$ ，因为两段方案数乘积最大可以为 $MOD^2 \approx 1e18$ ，补题时因为 $INF$ 的值不够大卡了两个小时左右</p><h3 id="时间复杂度-2">时间复杂度</h3><p>Floyd算法：$O(n^3)$</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 505</span></span><br><span class="line">ll dist[N][N]=&#123;<span class="number">0</span>&#125;,cnt[N][N]=&#123;<span class="number">0</span>&#125;,ori[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll mindist=INF,cntmin=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RESET_G</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ori[i][j]=<span class="number">0</span>;</span><br><span class="line">        dist[i][j]=(i==j?<span class="number">0</span>:INF);</span><br><span class="line">        cnt[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    mindist=INF,cntmin=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//重置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;<span class="comment">//Floyd</span></span><br><span class="line">                <span class="keyword">if</span>(dist[i][j]&gt;dist[i][k]+dist[k][j])&#123;</span><br><span class="line">                    dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">                    cnt[i][j]=<span class="built_in">mul</span>(cnt[i][k],cnt[k][j]);<span class="comment">//cnt[i][j]=cnt[i][k]*cnt[k][j]</span></span><br><span class="line">                    <span class="comment">//方案数为两段方案数的乘积，更新同步</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dist[i][j]==dist[i][k]+dist[k][j])&#123;</span><br><span class="line">                    <span class="built_in">addto</span>(cnt[i][j],<span class="built_in">mul</span>(cnt[i][k],cnt[k][j]));<span class="comment">//cnt[i][j]+=cnt[i][k]*cnt[k][j]</span></span><br><span class="line">                    <span class="comment">//相等则方案数相加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k&amp;&amp;ori[k][i])&#123;<span class="comment">//假设到k为以i为起点的单向环上最大点</span></span><br><span class="line">                <span class="keyword">if</span>(ori[k][i]+dist[i][k]&lt;mindist) &#123;mindist=ori[k][i]+dist[i][k];cntmin=cnt[i][k];&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ori[k][i]+dist[i][k]==mindist) <span class="built_in">addto</span>(cntmin,cnt[i][k]);<span class="comment">//cntmin+=cnt[i][k]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">RESET_G</span>(n);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ori[u][v]=w;</span><br><span class="line">        dist[u][v]=w;</span><br><span class="line">        cnt[u][v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Floyd</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(cntmin) cout &lt;&lt; mindist &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cntmin &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.a-b Problem</h1><p><strong>贪心</strong></p><h2 id="题目大意-6">题目大意</h2><p>给定一堆 $n$ 个石子，每个石子有非负值 $a_i,b_i$ ，分别代表Alice和Bob取该石子可以得到的分数<br>两人都希望自己的得分最大化，Alice执先，求最终Alice和Bob的分数差</p><h2 id="解题思路-6">解题思路</h2><p>取某石子的价值不仅在于自身得分，也在于让对手失去他那部分的分值。因此根据每颗石子的分数之和排序，从大到小依次取即可</p><h2 id="参考代码-4">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中部分功能需读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;ll,pll&gt;&gt; v;</span><br><span class="line">    pair&lt;ll,pll&gt; t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t.second.first &gt;&gt; t.second.second;</span><br><span class="line">        t.first=t.second.first+t.second.second;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll A,B;A=B=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n<span class="number">-1</span>-i)&amp;<span class="number">1</span>) B+=v[i].second.second;</span><br><span class="line">        <span class="keyword">else</span> A+=v[i].second.first;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=A-B;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2023暑期杭电多校04</summary>
    
    
    
    <category term="算法竞赛" scheme="http://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2023暑期杭电多校" scheme="http://www.cclmsy.cc/tags/2023%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
</feed>
