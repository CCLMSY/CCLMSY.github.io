<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CCLMSY💫</title>
  
  
  <link href="https://www.cclmsy.cc/atom.xml" rel="self"/>
  
  <link href="https://www.cclmsy.cc/"/>
  <updated>2024-08-02T07:53:02.495Z</updated>
  <id>https://www.cclmsy.cc/</id>
  
  <author>
    <name>深翼💫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>题解|2024暑期杭电多校05</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU05.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU05.html</id>
    <published>2024-08-01T16:00:00.000Z</published>
    <updated>2024-08-02T07:53:02.495Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A85%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（5）</a></p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校05</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校06</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD06.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD06.html</id>
    <published>2024-07-31T16:00:00.000Z</published>
    <updated>2024-08-03T13:46:41.338Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81601">2024牛客暑期多校训练营6</a></p><h1 id="A-Cake"><a href="#A-Cake" class="headerlink" title="A.Cake"></a>A.Cake</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵 $n$ 个节点，以 $1$ 为根的树，每条边有一个权值 0 或 1。<br>棋子初始在节点 $1$ ，Alice先手，Bob后手。<br>每回合，玩家可以将棋子移动到当前节点的一个子节点。<br>直到棋子达到叶子节点，游戏结束。</p><p>棋子经过的路径的权值按顺序构成一个01序列，记它的长度为 $m$ 。<br>接下来，Bob可以把 $1$ 块蛋糕任意分成 $m$ 份（某份蛋糕可以为0//空盘子）。<br>然后根据01序列决定取蛋糕的次序：0代表Bob取，1代表Alice取。</p><p>问两人都以最优策略行动和切蛋糕，问Alice最多能拿到多少蛋糕。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先考虑在路径确定的情况下，Bob会怎么分蛋糕：<br>Bob会找到一个前缀pre，这个前缀的“0占比”是所有前缀中最大的。<br>pre的长度记为 $t$，0占比记为 $p$。<br>Bob会将蛋糕平均分为 $t$ 份，剩下 $m-t$ 份为空。<br>这样，Bob可以保证他拿到最多的，大小为 $p$ 的蛋糕。</p><p>对于每个节点 $i$ ，先DFS一次，处理出从 $1$ 到 $i$ 这条路径上所有前缀的最大0占比。<br>那么在每个结点处。</p><p>再DFS一次，假设根节点 $1$ 的深度是1，那么：<br>深度为奇数的节点是Alice的回合，Alice会希望前缀的“0的占比”最小化；<br>深度为偶数的节点是Bob的回合，Bob会希望前缀的“0的占比”最大化。</p><p>从叶子到根更新，得到最终0占比 $p$ ，按照上面的方法分蛋糕，最终答案为 $1-p$ 。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ll n;</span><br><span class="line">vector&lt;vector&lt;pll&gt;&gt; G;</span><br><span class="line">vector&lt;ld&gt; pref; <span class="comment">//前缀中0的最大占比</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u=<span class="number">1</span>,ll fa=<span class="number">0</span>,ll cnt0=<span class="number">0</span>,ll cnt1=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>) <span class="built_in">chmax</span>(pref[u],(ld)cnt0/(cnt0+cnt1));<span class="comment">//用当前节点的0占比更新前缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">            pref[v]=pref[u];<span class="comment">//继承父节点的pref</span></span><br><span class="line">            <span class="built_in">dfs</span>(v,u,cnt0+(w==<span class="number">0</span>),cnt1+(w==<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;ld&gt; dp; <span class="comment">//节点对执棋手的最优解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_dp</span><span class="params">(ll u=<span class="number">1</span>,ll fa=<span class="number">0</span>, ll dep=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    dp[u]=dep%<span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>&amp;&amp;G[u].<span class="built_in">size</span>()==<span class="number">1</span>) dp[u]=pref[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u]) <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">        <span class="built_in">dfs_dp</span>(v,u,dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dep%<span class="number">2</span>) <span class="built_in">chmin</span>(dp[u],dp[v]); <span class="comment">//先手求pref小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">chmax</span>(dp[u],dp[v]); <span class="comment">//后手求pref大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    pref.<span class="built_in">clear</span>(); pref.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dp.<span class="built_in">clear</span>(); dp.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v,w);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(); <span class="built_in">dfs_dp</span>();</span><br><span class="line">    <span class="built_in">print_float</span>(<span class="number">1.</span>-dp[<span class="number">1</span>],<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Cake2"><a href="#B-Cake2" class="headerlink" title="B.Cake2"></a>B.Cake2</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定正整数 $n,k$ ，蛋糕的形状是正 $n$ 边形，顶点编号为 $0$ 到 $n-1$ 。<br>对于每个顶点 $i$ ，沿着由 顶点 $i$ 和 $(i+k)mod\ n$ 确定的直线切一刀。<br>求最后蛋糕的块数。</p><p><img src="/images/ACM/2024Summer_NCD06_B.png" alt=""></p>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校06</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校05</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD05.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD05.html</id>
    <published>2024-07-29T16:00:00.000Z</published>
    <updated>2024-07-30T10:01:05.925Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81600">2024牛客暑期多校训练营5</a></p><blockquote><p>玲珑骰子安红豆，入骨相思知不知。  ——温庭筠</p></blockquote><h1 id="B-珑"><a href="#B-珑" class="headerlink" title="B.珑"></a>B.珑</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>使用若干个 $1\times 2$ 的小矩形，恰好覆盖一个 $n\times m$ 的大矩形（即不允许重叠、不允许有部分超出大矩形范围）</p><p>对于任意两个小矩形，可能存在以下两种限制（中的0种、1种或2种）：</p><ol><li>边长为1的边不能相贴</li><li>边长为2的边不能相贴，即使相贴部分的长度仅为1</li></ol><p>问是否存在一种方案，在满足给定限制的条件下，恰好覆盖大矩形。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>不妨令 $n&lt;m$ ：</p><ol><li>小矩形的面积是2，所以 $n\times m$ 必须是偶数</li><li>只有 $n=1$ 的情况满足条件2</li><li>只有 $n=1且m&gt;2$ 的情况不满足条件1</li></ol><p><img src="/images/ACM/2024Summer_NCD05_B.png" alt="image"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>&amp;&amp;m%<span class="number">2</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 面积是奇数</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">2</span>) &#123;YES;<span class="keyword">return</span> ;&#125; <span class="comment">// 1*2只需要一块</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>&amp;&amp;n!=<span class="number">1</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 只有1*m时能满足b</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;n==<span class="number">1</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 只有1*m时不能满足a</span></span><br><span class="line">    YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-安"><a href="#E-安" class="headerlink" title="E.安"></a>E.安</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>May和Ray各有 $n$ 个骑士，分别按顺序排成一排，编号为 $1\sim n$ 。<br>May的骑士的生命值为 $a_i$ ，Ray的骑士的生命值为 $b_i$ 。</p><p>玩家每次操作可以选择一个双方骑士都存活的序号 $i$ ，命自己的骑士 $i$ 攻击对方的骑士 $i$ （使对方的骑士 $i$ 的生命值减少 $1$ ）。</p><p>May先行，两人都执行最优策略，直到无法操作。</p><p>问May最终剩余多少个骑士。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑最优策略：</p><ol><li>$a_i&gt;b_i$ ：优势，在这个位置只需要在对方攻击后反击，就能保证消灭对方。</li><li>$a_i&lt;b_i$ ：根据上一条，这个位置的骑士无法存活。</li><li>$a_i=b_i$ ：先攻击的棋子存活，一半的棋子存活，先手可以向上取整。</li></ol><p>按照最优策略，答案为 $cnt(a_i&gt;b_i)+\lceil cnt(a_i=b_i)/2 \rceil$ 。</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,n);</span><br><span class="line">    ll ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[i]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[i]) ans++;</span><br><span class="line">    &#125;cout &lt;&lt; ans+(cnt+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-入"><a href="#H-入" class="headerlink" title="H.入"></a>H.入</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $n$ 个点 $m$ 条边的无向图，每个点带唯一点权 $w_i$ 。</p><p>棋子初始被放在一个点上，每次会移动到相邻的点中点权最小的一个点。</p><p>现在点权和初始位置可以自己决定，问最多能经过多少个点。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>若从点 $i$ 走到点 $j$ ，其他和 $i$ 相邻的点的权值一定大于点 $j$ 的权值，因此之后都不会再走到这些点。</p><p>换句话说，走到下一个点之后，就可以把上一步的点和它的相邻点删掉了。</p><p>建图，按照以上思路，从每个点出发各一次，DFS找到最长路径长度。</p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ll n,m;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">ll ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll cur=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">chmax</span>(ans,cur);</span><br><span class="line">    vector&lt;ll&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u]) <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">        tmp.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        vis[v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt+=tmp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n-cnt+cur&gt;=ans)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:tmp) <span class="built_in">dfs</span>(v,cur+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:tmp) vis[v]=<span class="number">0</span>;</span><br><span class="line">    cnt-=tmp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll u,v;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    vis.<span class="built_in">clear</span>(); vis.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        vis[i]=<span class="number">1</span>; cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="L-知"><a href="#L-知" class="headerlink" title="L.知"></a>L.知</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的序列 $a$ ，每次操作可以选择一个下标 $i&lt;n$ ，执行：$a<em>i=a_i+1,a</em>{i+1}=a_{i+1}-1$ 。</p><p>求任意次操作后，序列 $a$ 的积的最大值 $mod\ 998244353$ 。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>小学老师教过我们，当和一定时，数越平均，积越大。</p><p>观察到操作的特性：后面的大数字可以匀到前面，但是前面的数字不能匀给后面。</p><p>从前往后处理，把第 $i$ 个数 $a_i$ 加入答案时，<br>从当前的 前 $i-1$ 个数中，从小到大依次选取尽可能多的数（记为 $b_1\sim b_k$ ），<br>满足：$max{b_1\cdots b_k}&lt; avg{b_1 \cdots b_k,a_i}$</p><p>然后可以将 ${b_1 \cdots b_k,a_i}$ 平均化，是最优的平均方法。</p><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// ll n=5;</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span>,vans</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    vans.<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;vans[<span class="number">0</span>])&#123;</span><br><span class="line">            ll tsum=v[i],j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;i)&#123; <span class="comment">//取出需要被匀的数</span></span><br><span class="line">                <span class="keyword">if</span>(vans[j]&gt;=tsum/(j+<span class="number">1</span>)) <span class="keyword">break</span>;  </span><br><span class="line">                <span class="comment">//如果当前的数已经大于等于平均值，就不需要被平均了</span></span><br><span class="line">                tsum+=vans[j]; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;ll&gt; temp;</span><br><span class="line">            <span class="built_in">FORLL</span>(k,j,i<span class="number">-1</span>) temp.<span class="built_in">emplace_back</span>(vans[k]);</span><br><span class="line">            ll avg=tsum/(j+<span class="number">1</span>),tt=tsum%(j+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">insert</span>(temp.<span class="built_in">end</span>(),tt,avg+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">insert</span>(temp.<span class="built_in">end</span>(),j+<span class="number">1</span>-tt,avg);</span><br><span class="line">            vans=temp;</span><br><span class="line">        &#125;<span class="keyword">else</span> vans.<span class="built_in">emplace_back</span>(v[i]);</span><br><span class="line">        <span class="built_in">SORT</span>(vans);</span><br><span class="line">    &#125; <span class="comment">// print_vec(ans);</span></span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:vans) <span class="built_in">multo</span>(ans,x);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校05</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校04</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU04.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU04.html</id>
    <published>2024-07-28T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A84%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（4）</a></p><h1 id="1003"><a href="#1003" class="headerlink" title="1003"></a>1003</h1><p>//TODO</p><h1 id="1005-HDU7473-多层血条"><a href="#1005-HDU7473-多层血条" class="headerlink" title="(1005)HDU7473.多层血条"></a>(1005)HDU7473.多层血条</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Boss血条的尺寸为 $n$ 行 $m$ 列，外层有边框。<br>行数仅代表血条的高度，不代表血量。<br>每列代表 $1$ 点血量， $m$ 列代表了 $m$ 点血量，即一层血条。</p><p>血条自底向上、从左往右平铺，最底下没有血量的部分为空格。<br>第一层血量用 <code>A</code> 表示，第二层血量用 <code>B</code> 表示，…，第五层血量用 <code>E</code> 表示，第六层血量用 <code>A</code> 表示，五层一循环，以此类推。</p><p>$n=2,m=10$ 且血量为$12$时，血条如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">|BBAAAAAAAA|</span><br><span class="line"><span class="section">|BBAAAAAAAA|</span></span><br><span class="line"><span class="section">+----------+</span></span><br></pre></td></tr></table></figure></p><p>为了加强打击反馈，当Boss受到伤害时，即将扣减的血量将短暂显示为<code>.</code>，然后再显示为对应的血条。</p><p>如上面的血条，当受到 $3$ 点伤害时，血条将变为：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">|..AAAAAAA.|</span><br><span class="line"><span class="section">|..AAAAAAA.|</span></span><br><span class="line"><span class="section">+----------+</span></span><br></pre></td></tr></table></figure></p><p>给定 $n,m$ ，血量 $hp$，即将受到的伤害 $dmg$ ，求受到伤害时的血条。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>计算血条层数决定填充当前层（和下一层）的字符。<br>计算当前最后一个血的位置，然后根据伤害对血条进行修改。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,hp,dmg;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; hp &gt;&gt; dmg;</span><br><span class="line">    string ul=<span class="string">&#x27;+&#x27;</span>+<span class="built_in">string</span>(m,<span class="string">&#x27;-&#x27;</span>)+<span class="string">&#x27;+&#x27;</span>; <span class="comment">//边框</span></span><br><span class="line">    cout &lt;&lt; ul &lt;&lt; endl;</span><br><span class="line">    string s=<span class="string">&quot;|&quot;</span>;</span><br><span class="line">    ll k=(hp+m<span class="number">-1</span>)/m; <span class="comment">//层数</span></span><br><span class="line">    <span class="type">char</span> c=(k+<span class="number">4</span>)%<span class="number">5</span>+<span class="string">&#x27;A&#x27;</span>; <span class="comment">//当前层字符</span></span><br><span class="line">    ll cur = (hp<span class="number">-1</span>)%m+<span class="number">1</span>; <span class="comment">//当前层血量位置</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,cur) s+=c;</span><br><span class="line">    <span class="type">char</span> c1=(k<span class="number">-1</span>)&gt;<span class="number">0</span>?(k<span class="number">-2</span>)%<span class="number">5</span>+<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27; &#x27;</span>; <span class="comment">//下一层字符</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,cur+<span class="number">1</span>,m) s+=c1;</span><br><span class="line">    s+=<span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    <span class="built_in">chmin</span>(dmg,m);</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,cur,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dmg==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dmg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,m,cur+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dmg==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dmg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ul &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h1><p>//TODO</p><h1 id="1009-HDU7477-昵称检索"><a href="#1009-HDU7477-昵称检索" class="headerlink" title="(1009)HDU7477.昵称检索"></a>(1009)HDU7477.昵称检索</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个字符串表示名字。<br>一个昵称由两部分组成：一个给定的名字+4位数字。<br>其中，4位数字表示一个日期。</p><p>注：日期格式为 <code>MMDD</code> ，即月份和日期，0229也算。</p><p>给定一个长度为 $m$ 的字符串，计算所有子序列中能构成不同的昵称的个数。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>昵称和日期分开考虑。</p><p>要求计不同的昵称的个数，因此每种名字、日期只需要考虑一次。</p><p>名字只需要选取最早完整出现的子序列，因为早出现一定比晚出现匹配的日期个数多。<br>日期只需要选取最晚完整出现的子序列，因为晚出现一定比早出现匹配的名字个数多。</p><p>记录每种字符出现的位置，先匹配日期。<br>用 $date_i$ 表示下标为 $i$ 的位置开头的不同日期数。<br>对 $date$ 做一个后缀和， $date_i$ 就表示到当前位置开始，往后的不同日期数。</p><p>再匹配名字。<br>找到名字 $name$ 的最早出现位置 $j$ ，它能组合出的最多不同昵称数为 $date_{j+1}$，加入答案。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; days = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">toint</span><span class="params">(<span class="type">char</span> c1,<span class="type">char</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c1-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+c2-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;string&gt; names;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        names.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">char</span>,vector&lt;ll&gt;&gt; posc,posint;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>) posc[s[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> posint[s[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">date</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> d2=<span class="string">&#x27;0&#x27;</span>;d2&lt;=<span class="string">&#x27;9&#x27;</span>;d2++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(posint[d2].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">        <span class="keyword">auto</span> posd2 = posint[d2].<span class="built_in">back</span>(); <span class="comment">//最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d1=<span class="string">&#x27;0&#x27;</span>;d1&lt;=<span class="string">&#x27;3&#x27;</span>;d1++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> day=<span class="built_in">toint</span>(d1,d2);</span><br><span class="line">            <span class="keyword">if</span>(day&gt;<span class="number">31</span>||day&lt;<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//不可能的天数</span></span><br><span class="line">            <span class="keyword">if</span>(posint[d1].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">            <span class="keyword">auto</span> itposd1 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[d1]),posd2); <span class="comment">//找比posd2小的最大的位置</span></span><br><span class="line">            <span class="keyword">if</span>(itposd1==posint[d1].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posd2小的</span></span><br><span class="line">            <span class="keyword">auto</span> posd1 = *(--itposd1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> m2=<span class="string">&#x27;0&#x27;</span>;m2&lt;=<span class="string">&#x27;9&#x27;</span>;m2++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(posint[m2].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">                <span class="keyword">auto</span> itposm2 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[m2]),posd1); <span class="comment">//找比posd1小的最大的位置</span></span><br><span class="line">                <span class="keyword">if</span>(itposm2==posint[m2].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posd1小的</span></span><br><span class="line">                <span class="keyword">auto</span> posm2 = *(--itposm2);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> m1=<span class="string">&#x27;0&#x27;</span>;m1&lt;=<span class="string">&#x27;1&#x27;</span>;m1++)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> month=<span class="built_in">toint</span>(m1,m2);</span><br><span class="line">                    <span class="keyword">if</span>(month&gt;<span class="number">12</span>||month&lt;<span class="number">1</span>) <span class="keyword">continue</span>;; <span class="comment">//不可能的月份</span></span><br><span class="line">                    <span class="keyword">if</span>(day&gt;days[month]) <span class="keyword">continue</span>;; <span class="comment">//不可能的日期</span></span><br><span class="line">                    <span class="keyword">if</span>(posint[m1].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">                    <span class="keyword">auto</span> itposm1 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[m1]),posm2); <span class="comment">//找比posm2小的最大的位置</span></span><br><span class="line">                    <span class="keyword">if</span>(itposm1==posint[m1].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posm2小的</span></span><br><span class="line">                    <span class="keyword">auto</span> posm1 = *(--itposm1);</span><br><span class="line">                    date[posm1]++;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; month &lt;&lt; &#x27; &#x27; &lt;&lt; day &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,m<span class="number">-1</span>,<span class="number">0</span>) date[i]+=date[i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// print_vec(date);</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;name:names)&#123;</span><br><span class="line">        ll curi=<span class="number">-1</span>,len=name.<span class="built_in">length</span>();</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> c=name[i];</span><br><span class="line">            <span class="keyword">auto</span> it=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(posc[c]),curi);</span><br><span class="line">            <span class="keyword">if</span>(it==posc[c].<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            curi=*it;</span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>) ans+=date[curi+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校04</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校03</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU03.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU03.html</id>
    <published>2024-07-25T16:00:00.000Z</published>
    <updated>2024-08-03T12:15:50.329Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A83%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（3）</a></p><h1 id="1001-HDU7457-深度自同构"><a href="#1001-HDU7457-深度自同构" class="headerlink" title="(1001)HDU7457.深度自同构"></a>(1001)HDU7457.深度自同构</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求由 $n$ 个节点构成，且满足“深度相同的节点，度相同”的森林的方案数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先考虑 $i$ 个节点的合法的树，这棵树每个节点的子树形态相同。<br>去掉根节点，每个部分的子树形态相同，那么每个子树的节点数是 $i-1$ 的约数。<br>设 $f(i)$ 表示 $i$ 个节点满足上述条件的树的方案数，那么有：$f(i)=\sum_{d|(i-1)} f(d)$</p><p>再考虑 $n$ 个节点的合法的森林，每个树的节点数是 $n$ 的约数。<br>设 $g(n)$ 表示 $n$ 个节点满足上述条件的森林的方案数，那么有：$g(n)=\sum_{d|n} f(d)$</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    ll n=<span class="number">1e6</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=n;j+=i)</span><br><span class="line">            <span class="built_in">addto</span>(f[j+<span class="number">1</span>],f[i]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=n;j+=i)</span><br><span class="line">            <span class="built_in">addto</span>(g[j],f[i]);</span><br><span class="line">    <span class="comment">//寄巧：对于从约数i到倍数j的转移，可以枚举倍数k，以调和级数复杂度求</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; g[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1007-HDU7463-单峰数列"><a href="#1007-HDU7463-单峰数列" class="headerlink" title="(1007)HDU7463.单峰数列"></a>(1007)HDU7463.单峰数列</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的数列 $a$ ，$q$ 次操作：</p><ol><li><code>1 l r x</code>：$a[l,r]$ 每个数加 $x$</li><li><code>2 l r</code>：判断 $a[l,r]$ 是否相同</li><li><code>3 l r</code>：判断 $a[l,r]$ 是否严格单调递增，$l=r$ 时也算</li><li><code>4 l r</code>：判断 $a[l,r]$ 是否严格单调递减，$l=r$ 时也算</li><li><code>5 l r</code>：判断 $a[l,r]$ 是否单峰数列</li></ol><p>长度为 $m$ 的数列 $b$ 被称为单峰数列，当且仅当存在唯一位置 $1\lt i\lt m$ ，使得 $b[1,i]$ 严格单调递增，$b[i,m]$ 严格单调递减。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>暴力判断<br>维护差分序列更直观</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; v;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">range_add</span><span class="params">(ll l,ll r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l<span class="number">-1</span>,r<span class="number">-1</span>) v[i]+=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_same</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i]!=v[l<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_up</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;=v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_down</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i<span class="number">-1</span>]&lt;=v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_mountain</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>; <span class="comment">//up</span></span><br><span class="line">    <span class="keyword">if</span>(v[l<span class="number">-1</span>]&gt;v[l]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i<span class="number">-1</span>]==v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(fl==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;v[i]) fl=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fl==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i<span class="number">-1</span>]&lt;v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fl==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    v.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll q;cin &gt;&gt; q;</span><br><span class="line">    ll op,l,r,val;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">            <span class="built_in">range_add</span>(l,r,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_same</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_up</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_down</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_mountain</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1008-HDU7464-比特跳跃"><a href="#1008-HDU7464-比特跳跃" class="headerlink" title="(1008)HDU7464.比特跳跃"></a>(1008)HDU7464.比特跳跃</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $n$ 个点 $m$ 条边（不保证连通，可能有重边）的无向图。<br>每条边 $E(u,v)$ 有一个权值 $w$ ，表示从 $u$ 到 $v$ 的代价。<br>此外，对于任意两点 $u,v$ ，可以付出 $k\times(u|v)$ （按位或）的代价从 $u$ 跳到 $v$ 。<br>分别求从节点 $1$ 到所有其他点 $2$ ~ $n$ 的最小代价。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>最暴力的想法肯定是把直接跳跃也看作边加入图中，然后跑单源最短路。<br>但是这样边的数量是 $n^2$ ，显然不可取。<br>因此考虑哪些边是有必要加的。</p><p>$1$ 直接跳到其他节点的方案是很优的：<br>若节点 $i$ 不在节点 $1$ 所在的连通块内，那么 $1$ 直接跳到 $i$ 的代价只可能是 $i$ （$i$ 为奇数）或 $i+1$ （$i$ 为偶数）。</p><p>但如果存在 $E(1,2,0)$ ，对于 $x=2,6,10…$ 这一类满足 $x\%4=2$ 的节点， $1$ 直接跳到 $x$ 的代价为 $x+1$ ，但先走到 $2$ 再跳到 $x$ 的代价仅为 $x$ 。</p><p>因此，对于 $x\%4=2$ 的节点，需要加入 $E(2,x,k(x|2))$ 。</p><p>同理，对于 $x\%2^{i+1}=2^i$ 的节点，需要加入 $E(2,x,k(x|2^i))$ 。</p><p>最后，跑一遍单调队列优化的单源最短路，求出答案。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">pow2</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">60</span>;i++) pow2.<span class="built_in">emplace_back</span>(pow2.<span class="built_in">back</span>()*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="function">Dijkstra <span class="title">dij</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ll u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        dij.<span class="built_in">addedge</span>(u,v,w);</span><br><span class="line">        dij.<span class="built_in">addedge</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n) dij.<span class="built_in">addedge</span>(<span class="number">1</span>,i,k*(<span class="number">1</span>|i));</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">60</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pow2[i]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll j=pow2[i]*<span class="number">2</span>;j&lt;=n;j+=pow2[i]) <span class="keyword">if</span>(pow2[i]&amp;j)</span><br><span class="line">            dij.<span class="built_in">addedge</span>(pow2[i],j,k*(pow2[i]|j));</span><br><span class="line">    &#125;</span><br><span class="line">    dij.<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n) cout &lt;&lt; dij[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1011-HDU7467-抓拍"><a href="#1011-HDU7467-抓拍" class="headerlink" title="(1011)HDU7467.抓拍"></a>(1011)HDU7467.抓拍</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>$n$ 个人，第 $i$ 个人初始在 $(x_i,y_i)$ 。<br>每个人有一个行进方向：东（E,+x方向）、西（W,-x方向）、南（S,-y方向）、北（N,+y方向），每秒移动一个距离。<br>散步无限长时间、不改变方向、忽略碰撞。</p><p>求一个周长最小的矩形满足：</p><ol><li>上下边平行于 $x$ 轴，左右边平行于 $y$ 轴</li><li>存在一个时刻，所有人都在矩形内部</li></ol><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>每个时刻的最小周长矩形只由 最上面、最下面、最左边、最右边 的四个人决定，那么就考虑可能成为这四个人的人。</p><p>左右移动的人占据的y区间，上下移动的人占据的x区间，不会改变。<br>记录：左右走的人里最靠上、最靠下的人，上下走的人里最靠左、最靠右的人。</p><p>因为时间无限长，最后在最上面的人，一定是向上走的人中初始点最靠上的，其他方向同理。<br>记录：向上走的人里最靠上的、向下走的人里最靠下的，向左走的人里最靠左的、向右走的人里最靠右的。</p><p>开始最靠下的人如果是向左/右/下走的，已经记录了，只要在向上走的人中找到最靠下的，其他方向同理。<br>记录：向上走的人里最靠下的、向下走的人里最靠上的、向左走的人里最靠右的、向右走的人里最靠左的。</p><p>有了这12个值，就可以计算出任何一个时刻的 $x<em>{min},x</em>{max},y<em>{min},y</em>{max}$ ，从而计算出最小周长。</p><p>模拟可知，周长对时间的函数，要么是单调增的，要么是一个开口向上的二次函数（因为最后人一定越走越散）。因此可以三分找到极小值点，即为答案。</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           E W S N</span></span><br><span class="line"><span class="comment">//           R L D U</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pll a,pll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">&#125;</span><br><span class="line">ll yLRmax,yLRmin,xUDmax,xUDmin;</span><br><span class="line">ll xLmin,xLmax,xRmin,xRmax,yUmin,yUmax,yDmin,yDmax;</span><br><span class="line"><span class="function">ll <span class="title">getC</span><span class="params">(ll t)</span></span>&#123;</span><br><span class="line">    ll xmin = <span class="built_in">min</span>(&#123;xLmin-t,xRmin+t,xUDmin&#125;);</span><br><span class="line">    ll xmax = <span class="built_in">max</span>(&#123;xLmax-t,xRmax+t,xUDmax&#125;);</span><br><span class="line">    ll ymin = <span class="built_in">min</span>(&#123;yDmin-t,yUmin+t,yLRmin&#125;);</span><br><span class="line">    ll ymax = <span class="built_in">max</span>(&#123;yDmax-t,yUmax+t,yLRmax&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*((xmax-xmin)+(ymax-ymin));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    vector&lt;pll&gt; L,R,U,D;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;E&#x27;</span>) R.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) L.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;N&#x27;</span>) U.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) D.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右移动的最上和最下两个人，上下移动的最左和最右两个人</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(L),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(R),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(U)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(D));</span><br><span class="line">    yLRmax = xUDmax = -INF;</span><br><span class="line">    yLRmin = xUDmin = INF;</span><br><span class="line">    <span class="keyword">if</span>(L.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(yLRmax,L.<span class="built_in">back</span>().second);<span class="built_in">chmin</span>(yLRmin,L.<span class="built_in">front</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(R.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(yLRmax,R.<span class="built_in">back</span>().second);<span class="built_in">chmin</span>(yLRmin,R.<span class="built_in">front</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(U.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(xUDmax,U.<span class="built_in">back</span>().first);<span class="built_in">chmin</span>(xUDmin,U.<span class="built_in">front</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(D.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(xUDmax,D.<span class="built_in">back</span>().first);<span class="built_in">chmin</span>(xUDmin,D.<span class="built_in">front</span>().first);&#125;</span><br><span class="line">    <span class="comment">//初始状态，向左的最左最右，向右的最左最右，向上的最上最下，向下的最上最下</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(L)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(R)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(U),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(D),cmp);</span><br><span class="line">    xLmin = xRmin = yUmin = yDmin = INF;</span><br><span class="line">    xLmax = xRmax = yUmax = yDmax = -INF;</span><br><span class="line">    <span class="keyword">if</span>(L.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(xLmin,L.<span class="built_in">front</span>().first);<span class="built_in">chmax</span>(xLmax,L.<span class="built_in">back</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(R.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(xRmin,R.<span class="built_in">front</span>().first);<span class="built_in">chmax</span>(xRmax,R.<span class="built_in">back</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(U.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(yUmin,U.<span class="built_in">front</span>().second);<span class="built_in">chmax</span>(yUmax,U.<span class="built_in">back</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(D.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(yDmin,D.<span class="built_in">front</span>().second);<span class="built_in">chmax</span>(yDmax,D.<span class="built_in">back</span>().second);&#125;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">2e9</span>;</span><br><span class="line">    <span class="comment">//三分找到getC最小的t</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        ll m1 = l+(r-l)/<span class="number">3</span>;</span><br><span class="line">        ll m2 = r-(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getC</span>(m1)&lt;<span class="built_in">getC</span>(m2)) r=m2;</span><br><span class="line">        <span class="keyword">else</span> l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mnans=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r) <span class="built_in">chmin</span>(mnans,<span class="built_in">getC</span>(i));</span><br><span class="line">    cout &lt;&lt; mnans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1012-HDU7468-死亡之组"><a href="#1012-HDU7468-死亡之组" class="headerlink" title="(1012)HDU7468.死亡之组"></a>(1012)HDU7468.死亡之组</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的数组 $a$ （$n$ 是4的倍数），$a_i$ 表示第 $i$ 个队伍的实力。<br>每4个队伍一组，“死亡之组”至少符合以下条件之一：</p><ol><li>至少有2个队伍的实力 $&gt; L$</li><li>最大实力和最小实力之差 $\le D$</li></ol><p>问是否存在一种分组方案使得第 $1$ 组所在的小组不是“死亡之组”。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>为了不满足条件1，存在至少3个队伍的实力 $\le L$ 即可。<br>然后把这3个队伍 $t_1,t_2,t_3$ 拿出来。<br>为了不满足条件2，所有队伍的实力中，最大值和最小值之差 $&gt; D$ 即可。<br>然后把实力最大的队伍 $t_4$ 拿出来。</p><p>对队伍1（$a_1$）进行讨论：</p><ul><li>如果 $a_1&gt;L$，替换 $t4$ ，重新判定</li><li>如果 $a_1\le L$，替换 $t3$</li></ul><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,l,d;cin &gt;&gt; n &gt;&gt; l &gt;&gt; d;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll t1 = v[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll cntll=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) <span class="keyword">if</span>(x&lt;l) cntll++;</span><br><span class="line">    <span class="keyword">if</span>(cntll&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t1&gt;=l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1-v.<span class="built_in">front</span>()&lt;=d) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">back</span>()-v.<span class="built_in">front</span>()&lt;=d) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校03</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校04</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD04.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD04.html</id>
    <published>2024-07-24T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.295Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81599">2024牛客暑期多校训练营4</a></p><h1 id="A-LCT"><a href="#A-LCT" class="headerlink" title="A.LCT"></a>A.LCT</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵有根树，问按顺序给定的前 $i$ 条边组成的森林中，以 $c_i$ 为根的树的深度。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>按步骤生成森林的过程，与并查集合并的过程一致。<br>因此用带权并查集，维护每个点的深度和答案，利用路径压缩降低时间复杂度。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">    vector&lt;ll&gt; parents, size, dep, ans;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DSU</span><span class="params">(ll n)</span> : parents(n + <span class="number">1</span>), size(n + <span class="number">1</span>, <span class="number">1</span>), dep(n + <span class="number">1</span>, <span class="number">0</span>), ans(n + <span class="number">1</span>, <span class="number">0</span>) &#123;</span> <span class="built_in">iota</span>(parents.<span class="built_in">begin</span>(), parents.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == parents[x]) <span class="keyword">return</span> x;</span><br><span class="line">        ll px = <span class="built_in">find</span>(parents[x]);</span><br><span class="line">        dep[x]+=dep[parents[x]]; </span><br><span class="line">        <span class="keyword">return</span> parents[x]=px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// merge b into a</span></span><br><span class="line">        ll pa = <span class="built_in">find</span>(a);</span><br><span class="line">        parents[b] = a;</span><br><span class="line">        dep[b] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="built_in">chmax</span>(ans[pa],ans[b]+dep[b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> ans[x];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll a,b,q;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(a,b);</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        cout &lt;&lt; dsu.<span class="built_in">query</span>(q) &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Sort4"><a href="#C-Sort4" class="headerlink" title="C.Sort4"></a>C.Sort4</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的排列 $p$ （即序列中 $1$ ~ $n$ 的每个数恰好出现一次）。<br>每次操作可以选择4个元素，并任意交换它们的位置。<br>求使得排列变为升序的最少操作次数。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>把排列看作由 $i\rightarrow p_i$（下标从1开始） 构成的图，这个图中有若干个环，表示这个环中的元素可以通过交换回到原来的位置。</p><p>长度为 $3,4$ 的环，可以通过一次操作还原；<br>长度为 $2$ 的环，可以 $2$ 个环一组通过一次操作还原；<br>长度大于 $4$ 的环，每次操作可以让 $3$ 个元素回到原来的位置，使得环的长度减少 $3$，直到环的长度小于等于 $4$。</p><p>根据这个原则，计算最终答案。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    ll ans=<span class="number">0</span>,of=<span class="number">0</span>; <span class="comment">//of:最终长度为2的环的数量</span></span><br><span class="line">    map&lt;ll,ll&gt; mp;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        ll cnt=<span class="number">1</span>,cur=v[i];</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=i)&#123;</span><br><span class="line">            vis[cur]=<span class="number">1</span>;</span><br><span class="line">            cur = v[cur];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">1</span>) ans+=(cnt<span class="number">-1</span>)/<span class="number">3</span>; <span class="comment">//最终长度为4的环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">2</span>)&#123; <span class="comment">//最终长度为2的环</span></span><br><span class="line">            ans+=(cnt<span class="number">-2</span>)/<span class="number">3</span>;</span><br><span class="line">            of++;</span><br><span class="line">        &#125;<span class="keyword">else</span> ans+=cnt/<span class="number">3</span>; <span class="comment">//最终长度为3的环</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans+(of+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-Yet-Another-Origami-Problem"><a href="#H-Yet-Another-Origami-Problem" class="headerlink" title="H.Yet Another Origami Problem"></a>H.Yet Another Origami Problem</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $n$ 的序列 $a$，每次可以选择一个元素 $a_i$，执行以下操作之一：</p><ol><li>所有原来比 $a_i$ 小的数 $a_j$ ： $a_j=a_i+2(a_i-a_j)$ ，即原来 $a_j$ 比 $a_i$ 小多少，现在就比 $a_i$ 大多少。</li><li>所有原来比 $a_i$ 大的数 $a_j$ ： $a_j=a_i-2(a_j+a_i)$ ，即原来 $a_j$ 比 $a_i$ 大多少，现在就比 $a_i$ 小多少。</li></ol><p>问任意次操作后，序列 $a$ 中最大元素和最小元素之差 $max(a)-min(a)$ 的最小值。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>每次操作：</p><ol><li>对序列 $a$ 排序去重，求出差分数组 $d$ 。</li><li>选定次小元素 $a_2$ ，执行操作 $1$ ，使得最小元素 $a_1 = a_2 - d_1$ 变成 $a_1’ = a_2 + d_1$ 。</li></ol><p>假设重新排序去重后，新的 $a<em>1’$ 相邻的两项为 $a_j,a</em>{j+1}$ ，步骤1中这两项的差分是 $d<em>j=a</em>{j+1}-a_j$ 。<br>那么当 $a_i’$ 插到中间时，新的差分数组的变化如下：</p><ol><li>第1项 $d_1$ 删去（因为 $a_1$ 变成了 $a_1’$ 后移）</li><li>原本的 $d<em>j$ 被替换为 $d_j’=d_1-\sum\limits</em>{k=2}^{j-1}d<em>k$ ，$d’</em>{j+1}=d_j-d_j’$ 。</li></ol><p>第2点变化可能比较难理解，给出如下例子：</p><ul><li>$a = [1,6,8,10,13,15]$ （原序列排序去重）</li><li>$d = [5,2,2,3,2]$ （差分数组）</li><li>$a_1=1,a_2=6,d_1=5$ （选定次小元素做操作1）</li><li>$a_1’=a_2+d_1=11$</li><li>$a’ = [6,8,10,11,13,15]$ （新序列排序去重，$a_1’$ 位于第4位）</li><li>$d’ = [2,2,1,2,2]$ （新差分数组）</li></ul><p>差分数组的变化：</p><ol><li>第1项 $d_1=5$ 删去</li><li>第4项 $3$ 变为：$d_1-d_2-d_3=1$ 和 $3-1=2$</li></ol><p>这个变化的意义就在于，它证明了任意次操作后的差分数组中的元素，是原差分数组中元素的线性组合，且随着操作次数增加，$\sum d<em>i$ 逐渐减小，直到 $a$ 仅剩2个元素。<br>线性组合能达到的最小值为 $\gcd\limits</em>{i=1}^{n-1}d_i$ 。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">        ans = __gcd(ans,v[i]-v[i<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-Horse-Drink-Water"><a href="#G-Horse-Drink-Water" class="headerlink" title="G.Horse Drink Water"></a>G.Horse Drink Water</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>将军饮马问题，将军在第一象限的整点 $(x_0,y_0)$ ，河流由 $x$ 正半轴和 $y$ 正半轴组成。<br>问将军碰到河流再前往 $(x_1,y_1)$ 的最短路径长度。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>将起点以 $x$ 轴、 $y$ 轴为对称轴，分别对称到第四、二象限，比较这两个点和终点的距离，取最小值。</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ld xx1,xx2,yy1,yy2;</span><br><span class="line">    cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;</span><br><span class="line">    ld ans1,ans2;</span><br><span class="line">    ans1 = <span class="built_in">sqrt</span>((xx1-xx2)*(xx1-xx2)+(yy1+yy2)*(yy1+yy2));</span><br><span class="line">    ans2 = <span class="built_in">sqrt</span>((xx1+xx2)*(xx1+xx2)+(yy1-yy2)*(yy1-yy2));</span><br><span class="line">    <span class="built_in">print_float</span>(<span class="built_in">min</span>(ans1,ans2),<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>// TODO</p>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校04</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校03</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD03.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD03.html</id>
    <published>2024-07-22T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.295Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81598">2024牛客暑期多校训练营3</a></p><h1 id="A-Bridging-the-Gap-2"><a href="#A-Bridging-the-Gap-2" class="headerlink" title="A.Bridging the Gap 2"></a>A.Bridging the Gap 2</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$n$个人过河，第 $i$ 个人初始有 $h_i$ 点体力。<br>由于船的限制，每次过河（或返回）至少需要乘坐 $l$ 人（来划船），至多可以乘坐 $r$ 人，<strong>每个</strong>乘船的人都会消耗 $1$ 点体力。体力为 $0$ 的人无法乘船。<br>求对于给定的条件，是否能够使所有人过河。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设初始所有人在左岸，考虑一种贪心模拟的做法：</p><ul><li>从在左岸的所有人中选取 $l$ 个体力最大的人划船，带 $r-l$ 个体力最小的人去右岸。</li><li>从在右岸的所有人中选取 $l$ 个体力最大的人划船返回左岸。</li><li>重复以上步骤，直到所有人都到达右岸，或者无法继续。</li></ul><p>这个过程中，除去最后一次划到右岸的 $r$ 个人，每次能运输的人数为 $r-l$ 。<br>最低<strong>往返</strong>的次数为 $turn = \lceil \dfrac{n-r}{r-l}\rceil$ ，且最优，因为往返越少对体力的要求越低。</p><p>对于个人，除自己前往右岸的1点体力，多余的体力可以用于划船带人，往返一次需要2点体力。<br>因此第 $i$ 个人能够参与的往返次数为 $\lfloor \dfrac{h_i-1}{2}\rfloor$ 。<br>由于只存在 $turn$ 次往返，因此第 $i$ 个人能够参与的往返次数为 $\min(\lfloor \dfrac{h_i-1}{2}\rfloor,turn)$ 。</p><p>计算所有人能够参与的往返次数之和，如果大于等于 $turn*l$ ，则按照上述贪心模拟的方法，可以使所有人过河。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><blockquote><p>程序是副机长根据解题思路写的，居然A了()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,l,r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll turn = (n-r)/(r-l) + ((n-r)%(r-l)!=<span class="number">0</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) sum += <span class="built_in">min</span>((x<span class="number">-1</span>)/<span class="number">2</span>,turn);</span><br><span class="line">    cout &lt;&lt; (sum&gt;=turn*l?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="B-Crash-Test"><a href="#B-Crash-Test" class="headerlink" title="B.Crash Test"></a>B.Crash Test</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>初始距离墙壁的距离为 $d$ 。<br>每次前进有 $n$ 种长度可以选择：$h_1,h_2,\cdots,h_n$。每次前进的长度可以是任意一种长度。<br>如果选择的长度 $h_i$ 大于当前与墙壁的距离 $d’$ ，将会退后多余的距离，即新的距离为 $h_i - d’$ 。<br>求在任意次（包括0次）前进后，与墙壁的最小距离。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593">裴蜀定理</a>：对于非0整数 $a,b$ ，对任意整数 $x,y$ 有 $gcd(a,b)|ax+by$ 成立，即 $gcd(a,b)$ 是所有 $a,b$ 的线性组合中，绝对值最小的非0整数。</p><p>裴蜀定理扩展到多整数的情况仍然成立。</p><p>因此计算出 $g=\gcd\limits_{i=1}^n(h_i)$ ，$g$ 的意义是通过对 $h_i$ 的某种线性组合，能够得到的最小前进距离。</p><p>然后每一步视为走 $g$ ，以此求得不撞墙答案 $d\%g$ 与撞墙答案 $g-d\%g$ ，取较小值即可。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,d; cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll g = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) g = __gcd(g,x);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(d%g,g-d%g) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Dominoes"><a href="#D-Dominoes" class="headerlink" title="D.Dominoes!"></a>D.Dominoes!</h1><p>//TODO</p><h1 id="J-Rigged-Games"><a href="#J-Rigged-Games" class="headerlink" title="J.Rigged Games"></a>J.Rigged Games</h1><p>//TODO</p><h1 id="L-Sudoku-and-Minesweeper"><a href="#L-Sudoku-and-Minesweeper" class="headerlink" title="L.Sudoku and Minesweeper"></a>L.Sudoku and Minesweeper</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>经典数独在 $9\times 9$ 大小的棋盘格内进行，每一行、每一列、$9$ 个 $3\times 3$ 的小方块内，数字 $1-9$ 恰好出现一次。</p><p>扫雷是一款在棋盘格内进行的游戏，中心数字表示周围 $8$ 格包含地雷的数量。</p><p>现给定一个 $9\times 9$ 数字矩阵表示一个已经完成的合法经典数独，可以将里面的数字替换成地雷，但必须保留至少 $1$ 个数字，求一个合法的扫雷游戏布局。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>除了边缘之外，中间 $7\times 7$ 范围内必然出现数字 $8$ 。<br>这是一个特殊的数字，只需要把它保留，其余所有数字全部替换成地雷，就是一个合法的扫雷游戏布局。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">vs</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;s:vs) cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>,i8,i8;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">7</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vs[i][j]==<span class="string">&#x27;8&#x27;</span>)&#123;</span><br><span class="line">                i8=i; i8=j; fl=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(fl) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==i8&amp;&amp;j==i8) cout &lt;&lt; <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校03</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校02</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU02.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU02.html</id>
    <published>2024-07-21T16:00:00.000Z</published>
    <updated>2024-08-03T12:15:50.329Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A82%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（2）</a></p><h1 id="1001-HDU7445-鸡爪"><a href="#1001-HDU7445-鸡爪" class="headerlink" title="(1001)HDU7445.鸡爪"></a>(1001)HDU7445.鸡爪</h1><p><strong>构造</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个鸡爪由一个中心节点和3条（不含端点的）边构成。如下图中，三条边和节点 $1$ 构成一个鸡爪，节点 $2,3,4$ 不属于这个鸡爪。<br><img src="/images/ACM//2024Summer_HDU02_1001_1.png" alt="image"></p><p>给定正整数 $n$ ，允许使用 $n$ 条边和任意个节点。要求构造一张图，在包含尽可能最多的鸡爪的条件下，按顺序输出图的 $n$ 条边时的字典序最小。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>不限制节点数的情况下，想要构造最多$n/3$（整除）个的鸡爪是很容易的，问题的关键是如何构造使得字典序最小。</p><p>先讨论 $n$ 是3的倍数的情况。<br>由于一个中心点只能被一个鸡爪使用，贪心的想法便是让节点 $1$~$n/3$ 成为中心点，且依次尽量让节点 $1,2,3$ 连接更多的点。</p><p>$4$~$n/3$ 这些点首先作为中心点和 $1,2,3$ 相连。<br>$1,2,3$ 三个点互相连接后，无法构成以 $1,2,3$ 为中心的鸡爪，因此需要借助 $n/3+1, n/3+2, n/3+3$ 这三个点进行构造。</p><p>连接图如下：<br><img src="/images/ACM//2024Summer_HDU02_1001_2.png" alt="image"></p><p>其他情况：<br>对于 $n$ 不是3的倍数的情况，将多余的1或2个点连接到节点1上。<br>$n\le 6$时，由于节点数太少，需要单独构造。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;pll&gt;&gt; ans=&#123;</span><br><span class="line">    &#123;&#125;, <span class="comment">// 0</span></span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;&#125;, <span class="comment">// 1</span></span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">6</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#125;, <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:ans[n])&#123;</span><br><span class="line">            cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pll&gt; edges;</span><br><span class="line">    ll cnt = n/<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,cnt+<span class="number">3</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">1</span>,i); </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">3</span>,cnt+<span class="number">2</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">2</span>,i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">4</span>,cnt+<span class="number">1</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">3</span>,i); </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n%<span class="number">3</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">1</span>,cnt+<span class="number">3</span>+i);</span><br><span class="line">    <span class="built_in">SORT</span>(edges);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:edges)&#123;</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Test:&quot; &lt;&lt; edges.size() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1003-HDU7447-绝对不模拟的简单魔方"><a href="#1003-HDU7447-绝对不模拟的简单魔方" class="headerlink" title="(1003)HDU7447.绝对不模拟的简单魔方"></a>(1003)HDU7447.绝对不模拟的简单魔方</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个三阶魔方，用$1$~$6$表示6个面的颜色。<br>魔方从初始还原状态起，侧面被扭转了不超过3次，且有一个角上的两片颜色贴纸可能贴错。<br>确定魔方的贴纸是否被贴错。如果有贴错，输出贴错那个角的三个颜色。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>扭转三次的操作对于魔方的角来说没有任何影响，只是虚晃一枪（题目中也提示了“绝对不模拟”）。</p><blockquote><p>但是赛时还是有神速度写模拟而且一遍过了%%%%</p></blockquote><p>只需要先把正常状态的魔方的8个角按同一顺序（如顺时针）记录下来，统一以$1,6$开头以唯一确定三元组。<br>再把输入的魔方的8个角按同一顺序（顺时针）记录下来，统一以$1,6$开头，然后在正常状态的记录中查找，找不到的就是被贴错贴纸的角。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cor</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">cor</span>(<span class="type">int</span> _a,<span class="type">int</span> _b,<span class="type">int</span> _c):<span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b),<span class="built_in">c</span>(_c)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(cor t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==t.a&amp;&amp;b==t.b&amp;&amp;c==t.c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">srt</span><span class="params">()</span></span>&#123; <span class="comment">//按大小排序</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(b&gt;c) <span class="built_in">swap</span>(b,c);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mkstd</span><span class="params">()</span></span>&#123; <span class="comment">//把三元组化为以1或6开头的形式</span></span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">6</span>)&#123;</span><br><span class="line">            t=a; a=b; b=c; c=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//原始魔方八个角，顺时针</span></span><br><span class="line">vector&lt;cor&gt; std_cor = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">mf</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:mf) cin &gt;&gt; s;</span><br><span class="line">    vector&lt;cor&gt; corners=&#123;<span class="comment">//给定魔方的八个角，顺时针</span></span><br><span class="line">        &#123;mf[<span class="number">0</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">11</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">8</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">11</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">8</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">9</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">0</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">5</span>][<span class="number">8</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">8</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">9</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">6</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">2</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">6</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">2</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cor:corners) cor.<span class="built_in">mkstd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cor:corners)&#123;</span><br><span class="line">        <span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; st:std_cor) <span class="keyword">if</span>(st==cor) &#123;fl=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(fl) <span class="keyword">continue</span>;</span><br><span class="line">        cor.<span class="built_in">srt</span>();</span><br><span class="line">        cout &lt;&lt; cor.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cor.b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cor.c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No problem&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1006-HDU7450-传奇勇士小凯"><a href="#1006-HDU7450-传奇勇士小凯" class="headerlink" title="(1006)HDU7450.传奇勇士小凯"></a>(1006)HDU7450.传奇勇士小凯</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>一棵以 $1$ 为根， $n$ 个节点的树，在第 $i$ 个节点处，每天有 $\dfrac{p_i}{15}$ 的概率可以离开当前节点，并选择一个子节点走一步。<br>从根节点 $1$ 走到任意叶子节点的最大天数的期望。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>在第 $i$ 个节点处，记停留在该节点的期望天数为 $x$ ，有 $\dfrac{p_i}{15}$ 的概率可以离开（停留 $1$ 天），有 $1-\dfrac{p_i}{15}$ 的概率停留在当前节点（停留 $x+1$ 天）。<br>有 $x = \dfrac{p_i}{15} + \dfrac{15-p_i}{15} \cdot (1+x)$ 成立，解得 $x = \dfrac{15}{p_i}$ 。</p><p>问题转换为选择一条以节点 $1$ 开头，以叶子节点结尾的路径，使得路径上的每个节点的期望天数 $\dfrac{15}{p_i}$ 之和最大。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">form</span><span class="params">(pll&amp; p)</span></span>&#123; <span class="comment">//化简</span></span><br><span class="line">    ll g = __gcd(p.first,p.second);</span><br><span class="line">    p.first/=g;</span><br><span class="line">    p.second/=g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">smaller</span><span class="params">(pll a,pll b)</span></span>&#123; <span class="comment">//a&lt;b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span>*a.first/a.second&lt;<span class="number">1.</span>*b.first/b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addto</span><span class="params">(pll&amp; a,pll b)</span></span>&#123; <span class="comment">//a+=b</span></span><br><span class="line">    a.first=a.first*b.second+a.second*b.first;</span><br><span class="line">    a.second*=b.second;</span><br><span class="line">    form(a);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;ll&gt; vdfs; <span class="comment">//dfs序列</span></span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;ll&gt; fa;</span><br><span class="line">vector&lt;pll&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x,ll f)</span></span>&#123;</span><br><span class="line">    fa[x]=f;</span><br><span class="line">    vdfs.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) <span class="keyword">if</span>(y!=f) <span class="built_in">dfs</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    fa.<span class="built_in">clear</span>(); fa.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    ans.<span class="built_in">clear</span>(); ans.<span class="built_in">resize</span>(n+<span class="number">1</span>,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    vdfs.<span class="built_in">clear</span>();</span><br><span class="line">    ll u,v,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125; <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ans[i]=&#123;<span class="number">15</span>,t&#125;; <span class="comment">//直接存入第i个节点的期望</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(vdfs));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> cur:vdfs)&#123; <span class="comment">//逆DFS序遍历</span></span><br><span class="line">        pll mx=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[cur]) <span class="keyword">if</span>(y!=fa[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">smaller</span>(mx,ans[y])) mx=ans[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ans[cur],mx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans[<span class="number">1</span>].first &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; ans[<span class="number">1</span>].second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1007-HDU7451-URL划分"><a href="#1007-HDU7451-URL划分" class="headerlink" title="(1007)HDU7451.URL划分"></a>(1007)HDU7451.URL划分</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定字符串URL，形如：<code>s3://hdu-oj-bucket/problem=1/type=data/</code><br>从中提取出：</p><ul><li>传输协议：<code>://</code>之前的内容，如<code>s3</code></li><li>网络位置：<code>://</code>之后，第一个<code>/</code>之前的内容，如<code>hdu-oj-bucket</code></li><li>环境变量：由<code>/</code>分割，形如<code>A=B</code>的内容，如<code>problem=1</code>，<code>type=data</code></li></ul><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>按题目要求提取即可</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    string protocol;</span><br><span class="line">    string location;</span><br><span class="line">    vector&lt;string&gt; var;</span><br><span class="line">    string varname,val;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>(),i=<span class="number">0</span>,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;:&#x27;</span>)&#123;</span><br><span class="line">            protocol = s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">    &#125; i+=<span class="number">3</span>;</span><br><span class="line">    ll j=i;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            location = s.<span class="built_in">substr</span>(j,i-j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; i++;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123; <span class="comment">//匹配varname=val，以/分隔</span></span><br><span class="line">        j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">&#x27;=&#x27;</span>&amp;&amp;s[j]!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">        <span class="keyword">if</span>(s[j]==<span class="string">&#x27;/&#x27;</span>)&#123; <span class="comment">//跳过</span></span><br><span class="line">            i=j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            varname=s.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            i=j+<span class="number">1</span>; j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">            val=s.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            var.<span class="built_in">emplace_back</span>(varname+<span class="string">&quot;=&quot;</span>+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; protocol &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; location &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:var) cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写完python才发现hduOJ不支持python…<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    url = <span class="built_in">input</span>()</span><br><span class="line">    protocol, location, *path = re.split(<span class="string">r&quot;://|/&quot;</span>, url)</span><br><span class="line">    variables = [p <span class="keyword">for</span> p <span class="keyword">in</span> path <span class="keyword">if</span> <span class="string">&quot;=&quot;</span> <span class="keyword">in</span> p]</span><br><span class="line">    <span class="built_in">print</span>(protocol)</span><br><span class="line">    <span class="built_in">print</span>(location)</span><br><span class="line">    <span class="keyword">for</span> variable <span class="keyword">in</span> variables:</span><br><span class="line">        <span class="built_in">print</span>(variable)</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="1010-HDU7454-女神的睿智"><a href="#1010-HDU7454-女神的睿智" class="headerlink" title="(1010)HDU7454.女神的睿智"></a>(1010)HDU7454.女神的睿智</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定长度为$8$的字符串，由<code>R,G,B</code>三种字符组成。<br>进行以下三轮操作，每轮操作从左往右两两合并：</p><ol><li>颜色相同时，合并为该颜色；颜色不同时，合并为左侧颜色</li><li>颜色相同时，合并为该颜色；颜色不同时，合并为左侧颜色</li><li>颜色相同时，合并为该颜色；颜色不同时，比较两种颜色在初始字符串中的数量，合并为数量多的一种；数量相同时，合并为随机颜色</li></ol><p>求最终合并后的颜色：<code>R,G,B</code>或不确定颜色<code>N</code></p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>按题目要求模拟即可</p><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,s2; cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) mp[c]++;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i+=<span class="number">2</span>) s2.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i+=<span class="number">2</span>) s.<span class="built_in">push_back</span>(s2[i]);</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==s[<span class="number">1</span>]) cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mp[s[<span class="number">0</span>]]!=mp[s[<span class="number">1</span>]]) cout &lt;&lt; s[mp[s[<span class="number">0</span>]]&lt;mp[s[<span class="number">1</span>]]] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;N&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1011-HDU7455-在-A-里面找有-C-的-B"><a href="#1011-HDU7455-在-A-里面找有-C-的-B" class="headerlink" title="(1011)HDU7455.在 A 里面找有 C 的 B"></a>(1011)HDU7455.在 A 里面找有 C 的 B</h1><p>//TODO</p>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校02</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期杭电多校01</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_HDU01.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_HDU01.html</id>
    <published>2024-07-18T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A81%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（1）</a></p><h1 id="1001-HDU7433-循环位移"><a href="#1001-HDU7433-循环位移" class="headerlink" title="(1001)HDU7433.循环位移"></a>(1001)HDU7433.循环位移</h1><p><strong>字符串</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个字符串 $A,B$ 。<br>定义 $[A]$ 为字符串 $A$ 的循环位移任意次可以得到的所有字符串的集合。<br>求 $B$ 包含 $[A]$ 中元素的个数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用字符串Hash快速匹配。<br>将 $[A]$ 中所有元素的Hash记录到一个set：计算 $A+A$ 的Hash前缀和，以快速得到所有长度为 $|A|$ 的子串的Hash值，并加入set中。<br>枚举 $B$ 的所有长度为 $|A|$ 的子串，计算Hash值，判断是否在set中，计数。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll n=a.<span class="built_in">length</span>(),m=b.<span class="built_in">length</span>();</span><br><span class="line">    set&lt;pll&gt; st;</span><br><span class="line">    <span class="function">strHash <span class="title">sa</span><span class="params">(a+a)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        st.<span class="built_in">insert</span>(sa.<span class="built_in">findz</span>(i,i+n<span class="number">-1</span>));</span><br><span class="line">    <span class="function">strHash <span class="title">sb</span><span class="params">(b)</span></span>;</span><br><span class="line">    ll ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m-n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">count</span>(sb.<span class="built_in">findz</span>(i,i+n<span class="number">-1</span>))) ans++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1002-HDU7434-星星"><a href="#1002-HDU7434-星星" class="headerlink" title="(1002)HDU7434.星星"></a>(1002)HDU7434.星星</h1><p><strong>背包DP</strong></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>小A要进行n次选择，每次可以选择一项：</p><ol><li>不执行操作</li><li>付出$a_i$点代价得到1颗星星</li><li>付出$b_i$点代价得到2颗星星</li><li>付出$c_i$点代价得到3颗星星</li><li>付出$d_i$点代价得到4颗星星</li></ol><p>求恰好得到$k$颗星星的最小代价。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>一眼顶针鉴定为背包DP的分组背包问题。</p><p>$dp<em>x$表示选x个物品的最低cost。<br>在第$i$组时，从大到小遍历作出选择后有$j$个星星。<br>遍历这一步的选择（ $l$ 个星星），从 $dp</em>{j-l}$ 更新到 $dp_j$ ，这样更新保证了一次操作只生效一项。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;array&lt;ll,5&gt;&gt; <span class="built_in">cost</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(k+<span class="number">1</span>,INF)</span></span>; dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//选i个物品的最低cost</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; cost[i][<span class="number">1</span>] &gt;&gt; cost[i][<span class="number">2</span>] &gt;&gt; cost[i][<span class="number">3</span>] &gt;&gt; cost[i][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123; <span class="comment">//第i步</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,k,<span class="number">1</span>)&#123; <span class="comment">//选择后的个数</span></span><br><span class="line">            <span class="built_in">FORLL</span>(l,<span class="number">0</span>,<span class="number">4</span>)&#123; <span class="comment">//这一步选择l个</span></span><br><span class="line">                <span class="keyword">if</span>(j-l&gt;=<span class="number">0</span>) <span class="built_in">chmin</span>(dp[j],dp[j-l]+cost[i][l]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1008-HDU7440-位运算"><a href="#1008-HDU7440-位运算" class="headerlink" title="(1008)HDU7440.位运算"></a>(1008)HDU7440.位运算</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定整数$n,k$，求满足 $((a\otimes b)\oplus c)\ominus d=n$ 的四元组 $(a,b,c,d)，0\le a,b,c,d\lt 2^k$ 的个数。</p><p>其中，$\otimes$ 表示按位与，$\oplus$ 表示按位异或，$\ominus$ 表示按位或。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>转为二进制，按位考虑。</p><p>若 $n$ 的某一位上是 $0$ ， $d$ 在这一位上必须为 $0$ ，$c$ 在这一位上由 $a,b$ 决定（控制这一位为 $0$），$a,b$ 在这一位上任选，即 $1\times 1\times 2\times 2=4$ 种可能。</p><p>若 $n$ 的某一位上是 $1$ ：</p><ol><li>若 $d$ 在这一位上为 $0$ ，则 $c$ 在这一位上由 $a,b$ 决定（控制这一位为 $1$），$a,b$ 在这一位上任选，即 $1\times 1\times 2\times 2=4$ 种可能。</li><li>若 $d$ 在这一位上为 $1$ ，则 $a,b,c$ 在这一位上任选，即 $1\times 2\times 2\times 2=8$ 种可能。</li></ol><p>综上，$n$ 的一位上是 $1$ 时有 $12$ 种可能，是 $0$ 时有 $4$ 种可能。</p><p>答案为 $4^k\times 3^{cnt1}$ 。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll cnt1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) cnt1++;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,k*<span class="number">2</span>)*<span class="built_in">qcpow</span>(<span class="number">3</span>,cnt1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1012-HDU7444-并"><a href="#1012-HDU7444-并" class="headerlink" title="(1012)HDU7444.并"></a>(1012)HDU7444.并</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个矩形，对 $k=1\to n$ 分别求随机取 $k$ 个矩形的面积并的期望。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>平面可以被矩形边界分割成若干个小区域，考虑每个区域对答案的贡献。</p><p>因为要求期望，被“相同数量矩形覆盖”的小区域 对答案的贡献是相同的，因此按照 覆盖矩形数量 将这些小区域分组，统计出恰好被 $i$ 个矩形覆盖的区域的面积 $S_i$。</p><p>我的求法就是从左到右扫描，在每条竖线的位置，更新 $i$ 个矩形覆盖的y轴长度 $yval_i$ ，到下一条竖线再乘经过的x轴长度，得到这一部分的面积（类似于积分？），加入 $S_i$ </p><p>然后考虑贡献的权重。<br>从 $n$ 个矩形中随机选取 $k$ 个，对于被 $i$ 个矩形覆盖的区域，只要选取的 $k$ 个矩形中，存在这 $i$ 个矩形之一，那么这个面积就会被计入。<br>在上述条件下的贡献权重是 $val<em>{k,i}=\frac{C</em>{n}^{k}-C<em>{n-i}^{k}}{C</em>{n}^{k}}$ ，即从 $n$ 个矩形中选取 $k$ 个方案数，减去从 $n-i$ 个矩形中选取 $k$ 个方案数。</p><p>最后答案$ans<em>k$是 $\sum\limits</em>{i=1}^{n}val_{k,i}\times S_i$ 。</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    MOD = <span class="number">998244353</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getval</span><span class="params">(ll n,ll i,ll j)</span></span>&#123;</span><br><span class="line">    ll ret=C[n][i],sb;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n-j) sb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> sb = C[n-j][i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(ret,sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll xx1,xx2,yy1,yy2;</span><br><span class="line">    vector&lt;tuple&lt;ll,ll,ll,ll&gt;&gt; xlines;</span><br><span class="line">    vector&lt;ll&gt; ylines;</span><br><span class="line">    <span class="comment">// xline:(y,x1,x2,flag) # 横线 flag:0上边界1下边界</span></span><br><span class="line">    <span class="comment">// yline:(x) # 竖线x坐标</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;</span><br><span class="line">        xlines.<span class="built_in">emplace_back</span>(yy1,xx1,xx2,<span class="number">0</span>);</span><br><span class="line">        xlines.<span class="built_in">emplace_back</span>(yy2,xx1,xx2,<span class="number">1</span>);</span><br><span class="line">        ylines.<span class="built_in">emplace_back</span>(xx1);</span><br><span class="line">        ylines.<span class="built_in">emplace_back</span>(xx2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(xlines); <span class="built_in">SORT</span>(ylines);</span><br><span class="line"></span><br><span class="line">    map&lt;ll,ll&gt; S,yval;</span><br><span class="line">    ll prex=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// S[i]:重叠i次部分的面积</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xx:ylines)</span><br><span class="line">    &#123;</span><br><span class="line">        ll difx = xx-prex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [pl,val]:yval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// S[pl]+=difx*val;</span></span><br><span class="line">            <span class="built_in">addto</span>(S[pl],<span class="built_in">mul</span>(difx,val));</span><br><span class="line">        &#125;</span><br><span class="line">        yval.<span class="built_in">clear</span>();</span><br><span class="line">        ll cur = <span class="number">0</span>, prey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [yy,xx1,xx2,flag]:xlines)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(xx1&lt;=xx&amp;&amp;xx&lt;xx2)</span><br><span class="line">            &#123;</span><br><span class="line">                yval[cur]+=yy-prey;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) cur++;</span><br><span class="line">                <span class="keyword">else</span> cur--;</span><br><span class="line">                prey=yy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prex = xx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(auto x:S) cout &lt;&lt; x.first &lt;&lt; &#x27; &#x27; &lt;&lt; x.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ll val = <span class="built_in">getval</span>(n,i,j);</span><br><span class="line">            ans = <span class="built_in">add</span>(ans,<span class="built_in">mul</span>(val,S[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">divto</span>(ans,C[n][i]);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期杭电多校01</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期杭电多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校02</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD02.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD02.html</id>
    <published>2024-07-17T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.295Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81597">2024牛客暑期多校训练营2</a></p><h1 id="C-Red-Walking-on-Grid"><a href="#C-Red-Walking-on-Grid" class="headerlink" title="C.Red Walking on Grid"></a>C.Red Walking on Grid</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个2行 $n$ 列的网格上，有些格子是红色的，有些格子是白色的。<br>你可以最初选择一个红色的格子，然后每一步都可以选择上下左右相邻的红色格子。离开一个格子时，这个格子立即变成白色。问最多可以走多少步。<br>最初没有红色的格子，输出0。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>总体思路就是找连通块，在每个连通块内部找到能走最多格的路径，然后所有连通块的答案取最大值。<br>由于无法走回头路，形如以下样式的连通块将无法走遍全部红色格子：</p><p><img src="/images/ACM/2024Summer_NCD02_C.png" alt="image"></p><p>先从头到尾扫一遍，有以上2种形式的连通块，将打×的部分预先涂成白色。这样就能保证每个红色格子都会被经过，计算到答案中。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 2&gt; s;</span><br><span class="line">ll n,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function">ll <span class="title">getstat</span><span class="params">(ll col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getcnt</span><span class="params">(ll col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preprocess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>,pre=<span class="number">0</span>,cur;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getcnt</span>(<span class="number">0</span>)==<span class="number">1</span>) pre=<span class="built_in">getstat</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur = <span class="built_in">getcnt</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">            cur=<span class="built_in">getstat</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(pre&amp;&amp;cur&amp;&amp;cnt)&#123;</span><br><span class="line">                <span class="keyword">if</span>((cnt%<span class="number">2</span>==<span class="number">0</span>)&amp;&amp;((pre&amp;cur)==<span class="number">0</span>)) s[cur<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>((cnt%<span class="number">2</span>)&amp;&amp;((pre&amp;cur))) s[cur<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="number">2</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cnt=<span class="number">0</span>; pre=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="built_in">getcnt</span>(<span class="number">0</span>),pre=<span class="built_in">getstat</span>(<span class="number">0</span>),cur;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur = <span class="built_in">getstat</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cur&amp;pre)&#123;</span><br><span class="line">            cnt+=<span class="built_in">getcnt</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">chmax</span>(ans,cnt);</span><br><span class="line">            cnt=<span class="built_in">getcnt</span>(i);</span><br><span class="line">        &#125;pre=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">chmax</span>(ans,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s[<span class="number">0</span>] &gt;&gt; s[<span class="number">1</span>];</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">preprocess</span>();</span><br><span class="line">    <span class="built_in">getans</span>();</span><br><span class="line">    cout &lt;&lt; ans<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-GCD-VS-XOR"><a href="#E-GCD-VS-XOR" class="headerlink" title="E.GCD VS XOR"></a>E.GCD VS XOR</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个正整数 $x$ ，找到一个严格小于 $x$ 的正整数 $y$ ，使得 $gcd(x,y)=x\oplus y$ ，其中 $\oplus$ 表示按位异或。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先观察到，对于一个正整数 $x$ ，$lowbit(x)$ 一定是 $x$ 的因子。<br>那么令 $y = x - lowbit(x)$ ，则 $gcd(x,y)=lowbit(x)$ ，$x\oplus y = lowbit(x)$ ，满足题意。</p><blockquote><p>有时候灵感就来源于一瞬间</p></blockquote><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll ans=n-<span class="built_in">lowbit</span>(n);</span><br><span class="line">    cout &lt;&lt; (ans?ans:<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-Instructions-Substring"><a href="#H-Instructions-Substring" class="headerlink" title="H.Instructions Substring"></a>H.Instructions Substring</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>你初始位于原点 $(0,0)$ 。<br>给定一串动作指令，包含<code>W</code>、<code>A</code>、<code>S</code>、<code>D</code>，分别表示向上（$y+=1$）、向左（$x-=1$）、向下（$y-=1$）、向右（$x+=1$）。<br>你需要选择一个连续的子串，使得执行这个子串的指令后，你能经过给定得一点 $(x,y)$ 。<br>计算符合条件的子串的个数。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设选择了子串 $s_{ij}$ ，恰好能到达 $(x,y)$ ，那么 $s_j$ 之后任意增加指令都已经满足了“经过 $(x,y)$”的条件。</p><p>最暴力的做法就是枚举开头指令 $i$ ，枚举恰好到达 $(x,y)$ 的最小结尾指令 $j$ ，以位置 $i$ 开头的方案数就是 $n-j+1$ 。时间复杂度 $O(n^2)$ ，包TLE的，需要优化搜索过程。</p><p>我们可以先从头到尾执行（即做一个前缀和），每一步都记录到达当前位置 $(x_i,y_i)$ 时执行的指令编号 $i$ 。<br>再重新从头到尾执行一边，对于每一步到达的位置 $(x_i,y_i)$ ，将它视作起点（即假设之前的步骤都没有执行），那么需要经过的点变为 $(x_i+x,y_i+y)$ 。二分找到在 $i$ 之后到达过 $(x_i+x,y_i+y)$ 的最小指令编号 $j$ ，以位置 $i$ 开头的方案数就是 $n-j+1$ 。</p><p>$x=0,y=0$ 的情况比较特殊，特判一下即可。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                W  S  D  A</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">conv</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;D&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; n*(n+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;pll,vector&lt;ll&gt;&gt; mp;</span><br><span class="line">    ll cx,cy,dir; cx=cy=<span class="number">0</span>;</span><br><span class="line">    mp[&#123;cx,cy&#125;].<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        dir = <span class="built_in">conv</span>(c);</span><br><span class="line">        cx += dx[dir];</span><br><span class="line">        cy += dy[dir];</span><br><span class="line">        mp[&#123;cx,cy&#125;].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cx=cy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = mp[&#123;cx+x,cy+y&#125;];</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),i);</span><br><span class="line">        <span class="keyword">if</span>(it!=v.<span class="built_in">end</span>()) ans+=n-(*it);</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        dir = <span class="built_in">conv</span>(c);</span><br><span class="line">        cx += dx[dir];</span><br><span class="line">        cy += dy[dir];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> v = mp[&#123;cx+x,cy+y&#125;];</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),n);</span><br><span class="line">    <span class="keyword">if</span>(it!=v.<span class="built_in">end</span>()) ans+=n-(*it);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校02</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024暑期牛客多校01</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Summer_NCD01.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Summer_NCD01.html</id>
    <published>2024-07-15T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.294Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81596">2024牛客暑期多校训练营1</a></p><h1 id="A-A-Bit-Common"><a href="#A-A-Bit-Common" class="headerlink" title="A.A Bit Common"></a>A.A Bit Common</h1><p><strong>组合数学</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><strong>题目概括：</strong><br>给定两个整数 $n$ 和 $m$，我们需要计算所有包含 $n$ 个非负整数且每个整数都小于 $2^m$ 的序列中，满足<strong>存在一个</strong>非空子序列使得这些整数的按位与（bitwise AND）为 1 的序列的数量。</p><p>注意：一个序列的非空子序列是指从序列中删除零个或多个元素后得到的子序列，并保持剩余元素的原始顺序。</p><p>由于结果可能非常大，请输出结果对一个正整数 $q$ 取模后的值。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>序列 $A$ 中的每个整数可以看作一个 $m$ 位的二进制数。</p><p>符合条件的序列中，所有末位为 1 的元素的&amp;和一定为 1（因为剩余的元素末位都是0，&amp;入答案会消灭末位1）。</p><p>枚举序列包含的 末位为 1 的元素个数 $k$ ，把这些数一行一个写成二进制，按位对齐。</p><p>对于这 $k$ 个元素，要满足除末位外每一个二进制位不全为 1 ，这 $k$ 个数每个二进制位（按列看）上的方案数为 $2^{k}-1$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $a=(2^{k}-1)^{m-1}$ 。 </p><p>对于剩余的 $n-k$ 个元素，只需要保证末位为 0 ，其他位不加限制，因此这 $n-k$ 个数每个二进制位（按列看）上的方案数为 $2^{n-k}$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $b=(2^{n-k})^{m-1}$ 。</p><p>综合两部分，方案数为 $a\times b\times C_n^k$ 。<br>$C_n^k$ 表示序列的 $n$ 个位置中选取 $k$ 个用于顺序放置末位为 1 的 $k$ 个数。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    ll tmp,a,b,ans1=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)&#123;</span><br><span class="line">        a = <span class="built_in">qcpow</span>(<span class="built_in">qcpow</span>(<span class="number">2</span>,k)<span class="number">-1</span>,m<span class="number">-1</span>); <span class="comment">// a = (2^k-1)^(m-1)</span></span><br><span class="line">        b = <span class="built_in">qcpow</span>(<span class="number">2</span>,<span class="built_in">mul</span>(n-k,m<span class="number">-1</span>)); <span class="comment">// b = 2^(n-k)^(m-1)</span></span><br><span class="line">        tmp = <span class="built_in">mul</span>(C[n][k],<span class="built_in">mul</span>(a,b)); <span class="comment">// tmp = C(n,k)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans1,tmp); <span class="comment">// 加入答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; <span class="built_in">Get_Mod</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-A-Bit-More-Common"><a href="#B-A-Bit-More-Common" class="headerlink" title="B.A Bit More Common"></a>B.A Bit More Common</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定两个整数 $n$ 和 $m$，我们需要计算所有包含 $n$ 个非负整数且每个整数都小于 $2^m$ 的序列中，满足<strong>存在两个</strong>非空子序列使得这些整数的按位与（bitwise AND）为 1 的序列的数量。</p><p>注意：一个序列的非空子序列是指从序列中删除零个或多个元素后得到的子序列，并保持剩余元素的原始顺序。</p><p>由于结果可能非常大，请输出结果对一个正整数 $q$ 取模后的值。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>和A题的区别在于，需要满足存在两个非空子序列。</p><p>因此除A题中 “由所有末位为1的元素” 构成的&amp;和为1的子序列外，还要另考虑一个。<br>贪心的想法就是从上述子序列中删去某个元素，剩下的元素的&amp;和仍然为1。</p><p>枚举序列包含的 末位为 1 的元素个数 $k$ ，把这些数一行一个写成二进制，按位对齐。</p><p>正向考虑难以枚举，可以从反面考虑，即：从 这$k$个&amp;和为1的元素 中，删去任一元素，剩下的元素的&amp;和都不能为1。<br>要满足这一特性，每个元素都至少要有一位“特殊位0” 。</p><p>“特殊位0” ：即有且仅有唯一元素，在这个二进制位（按列看）上是 0 ，其他元素的这个二进制位上都为 1 。<br>这样，当删去这个元素后，其他元素这一位上的&amp;和将变成1，从而不满足条件。</p><p>记$dp(k,j)$： $k$ 个末位为 1 的数，每个数至少有 1 个“特殊位0” ，且它们共有 $j$ “特殊位0” 的方案数。<br>如果从这 $k$ 个数中选取 1 个，去掉它的 1 个特殊位，则有可能会导致一个数没有特殊位。<br>转移到： </p><ul><li>$k$ 个数，每个数至少有 1 个“特殊位0” ，且它们共有 $j-1$ 个“特殊位0”</li><li>$k-1$ 个数，每个数至少有 1 个“特殊位0” ，且它们共有 $j-1$ “特殊位0” </li></ul><p>得到转移方程： $dp(k,j)=k\times(dp(k,j-1)+dp(k-1,j-1))$ ，预处理dp数组。</p><p>对于这 $k$ 个元素，要满足除末位1外每一个二进制位不全为 1 ，且每个元素至少有 1 个“特殊位0” 。<br>对于每个 $k$ ，枚举特殊位个数 $j:k\rightarrow m-1$ :</p><ul><li>末位为1但没有特殊位的元素，每个 非“特殊位0” 二进制位（按列看）上的方案数为 $2^{k}-1-k$ （除：全1的1种和“特殊位0”k种），除末位外有 $m-1-j$ 个 非“特殊位0” 二进制位，（有序）方案数为 $t=(2^{k}-1)^{m-1}$ 。</li><li>特殊位：方案数 $dp(k,j)$</li></ul><p>综上，这 $k$ 个末位为1的元素的（有序）方案数为 $a = \sum\limits_{j=k}^{m-1} t\times dp(k,j)\times C(m-1,j)$</p><p>对于剩余的 $n-k$ 个元素，只需要保证末位为 0 ，其他位不加限制，因此这 $n-k$ 个数每个二进制位（按列看）上的方案数为 $2^{n-k}$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $b=(2^{n-k})^{m-1}$ 。</p><p>综合两部分，方案数为 $a\times b\times C_n^k$ 。</p><p>用A题的答案减去得到的数字，则为本题所求的答案。</p><p>本题复杂度较高，常规的取模操作做的多的，可能会因为常数太大TLE。<br>可以通过预处理乘方数组、逐步求乘方数、减少取模次数、优化取模等方法解决。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    vector&lt;ll&gt; pow2;</span><br><span class="line">    pow2.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*m) pow2.<span class="built_in">emplace_back</span>(<span class="built_in">mul</span>(pow2.<span class="built_in">back</span>(),<span class="number">2</span>));</span><br><span class="line">    ll t,tt,powt,a,b,ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        a = pow2[<span class="built_in">mul</span>(m<span class="number">-1</span>,n-i)]; <span class="comment">// a = 2^(m-1)^(n-i)</span></span><br><span class="line">        b = <span class="built_in">qcpow</span>(pow2[i]<span class="number">-1</span>,m<span class="number">-1</span>); <span class="comment">// b = (2^i-1)^(m-1)</span></span><br><span class="line">        t = <span class="built_in">mul</span>(C[n][i],<span class="built_in">mul</span>(a,b)); <span class="comment">// t = C(n,i)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans1,t);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(m+<span class="number">1</span>,<span class="number">0</span>)); <span class="comment">//dp_i,j表示j个特殊位覆盖了i个数的方案数</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m<span class="number">-1</span>)&#123; </span><br><span class="line">            dp[i][j] = <span class="built_in">mul</span>(<span class="built_in">add</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]),i); <span class="comment">// i*(dp[i][j-1]+dp[i-1][j-1])</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">2</span>,n)&#123; <span class="comment">// 末位为1的数的个数</span></span><br><span class="line">        t = <span class="built_in">sub</span>(pow2[k],k+<span class="number">1</span>); <span class="comment">// 2^k-k-1</span></span><br><span class="line">        powt = <span class="number">1</span>;</span><br><span class="line">        a = pow2[<span class="built_in">mul</span>(n-k,m<span class="number">-1</span>)]; <span class="comment">// a = 2^(m-1)^(n-k)</span></span><br><span class="line">        b = <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,m<span class="number">-1</span>,k)&#123; <span class="comment">// k个元素有j个特殊位</span></span><br><span class="line">            tt = <span class="built_in">mul</span>(powt,dp[k][j]); <span class="comment">// t^(m-1-j)*dp[k][j]</span></span><br><span class="line">            tt = <span class="built_in">mul</span>(tt,C[m<span class="number">-1</span>][j]); <span class="comment">// C(m-1,j)*t^(m-1-j)*dp[k][j]</span></span><br><span class="line">            <span class="built_in">addto</span>(b,tt); </span><br><span class="line">            powt = <span class="built_in">mul</span>(powt,t); <span class="comment">// t^(m-1-j)</span></span><br><span class="line">        &#125;</span><br><span class="line">        tt = <span class="built_in">mul</span>(C[n][k],<span class="built_in">mul</span>(a,b)); <span class="comment">// C(n,k)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans2,tt); </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sub</span>(ans1,ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Sum-of-Suffix-Sums"><a href="#C-Sum-of-Suffix-Sums" class="headerlink" title="C.Sum of Suffix Sums"></a>C.Sum of Suffix Sums</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个初始为空的数组，你需要进行 <code>q</code> 次操作：</p><ul><li>对于每次操作，给定两个非负整数 <code>t</code> 和 <code>v</code>，先从数组末尾取出 <code>t</code> 个元素，然后将 <code>v</code> 添加到数组末尾。保证 <code>t</code> 不会超过操作前数组的长度。</li></ul><p>每次操作后，假设当前数组为 <code>a1, a2, ..., an</code>，计算 <code>s1, s2, ..., sn</code> 的总和，其中 <code>si = ai + ai+1 + ... + an</code> 是从位置 <code>i</code> 开始的后缀和。</p><p>由于结果可能非常大，输出时需对 <code>1000000007</code> 取模。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑每个元素的贡献：第 $i$ 个元素对答案的贡献为 $i*a_i$ 。</p><p>在加入元素时，直接将其贡献加入答案。</p><p>同时对这个序列维护一个前缀和，以便快速移除元素和减去贡献。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll q,t,rm;cin &gt;&gt; q;</span><br><span class="line">    ll n=<span class="number">1</span>;</span><br><span class="line">    vector&lt;ll&gt; v,s;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    s.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    ll tm;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; rm &gt;&gt; t;</span><br><span class="line">        sum = <span class="built_in">Get_Mod</span>(sum-<span class="built_in">Get_Mod</span>(s[n<span class="number">-1</span>]-s[n-rm<span class="number">-1</span>]));</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">end</span>()-rm,s.<span class="built_in">end</span>());</span><br><span class="line">        v.<span class="built_in">erase</span>(v.<span class="built_in">end</span>()-rm,v.<span class="built_in">end</span>());</span><br><span class="line">        n-=rm;</span><br><span class="line"></span><br><span class="line">        tm = t;</span><br><span class="line">        tm = <span class="built_in">Get_Mod</span>(tm*n); <span class="comment">// 元素贡献</span></span><br><span class="line">        sum = <span class="built_in">Get_Mod</span>(sum+tm);</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(tm);</span><br><span class="line">        s.<span class="built_in">emplace_back</span>(sum);</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-World-Finals"><a href="#H-World-Finals" class="headerlink" title="H.World Finals"></a>H.World Finals</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>两场ICPC比赛，已知（预测的）两场比赛的所有队伍的解题数和罚时。</p><p>如果一支队伍同时具有两场比赛的资格，只能参加其中一场。</p><p>现在，<code>lzr010506</code>可以决定 同时具有两场比赛的资格 的队伍具体参加哪一场，根据预测数据求<code>lzr010506</code>可以得到的最高名次。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>开2个map分别记录两场比赛情况。</p><p>假设<code>lzr010506</code>参加其中一场，去掉那一场所有的 同时具有两场比赛的资格 的队伍，排序即可得到这一场的最佳名次。</p><p>如此求出两场比赛的最佳名次，取最小值即可。</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line">string me=<span class="string">&quot;lzr010506&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> pair&lt;string,pll&gt; &amp;a,<span class="type">const</span> pair&lt;string,pll&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pll pa,pb;</span><br><span class="line">    pa=a.second; pb=b.second;</span><br><span class="line">    <span class="keyword">if</span>(pa.first==pb.first) <span class="keyword">return</span> pa.second&lt;pb.second;</span><br><span class="line">    <span class="keyword">return</span> pa.first&gt;pb.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,pll&gt; v1,v2;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string ts; ll t1,t2;</span><br><span class="line">    ll ans1,ans2;ans1=ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; ts &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        v1[ts]=<span class="built_in">make_pair</span>(t1,t2);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; ts &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        v2[ts]=<span class="built_in">make_pair</span>(t1,t2);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;string,pll&gt; tmp;</span><br><span class="line">    tmp = v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">count</span>(x.first)&amp;&amp;x.first!=me)&#123;</span><br><span class="line">            tmp.<span class="built_in">erase</span>(x.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> tv = vector&lt;pair&lt;string,pll&gt;&gt;(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(tv),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv)&#123;</span><br><span class="line">        ans1++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==me) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">count</span>(x.first)&amp;&amp;x.first!=me)&#123;</span><br><span class="line">            tmp.<span class="built_in">erase</span>(x.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tv = vector&lt;pair&lt;string,pll&gt;&gt;(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(tv),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv)&#123;</span><br><span class="line">        ans2++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==me) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(ans1,ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-Mirror-Maze"><a href="#I-Mirror-Maze" class="headerlink" title="I.Mirror Maze"></a>I.Mirror Maze</h1><p><strong>DFS</strong></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>在一个 $n \times m$ 的镜子迷宫中，每个格子都有一面镜子。镜子的类型有以下四种：</p><ol><li><code>-</code>：来自上方或下方的光线将被反射回去，来自左方或右方的光线则继续前进而不会被反射。</li><li><code>|</code>：来自左方或右方的光线将被反射回去，来自上方或下方的光线则继续前进而不会被反射。</li><li><code>/</code>：来自左方、右方、上方、下方的光线将分别被反射到上方、下方、左方、右方。</li><li><code>\</code>：来自左方、右方、上方、下方的光线将分别被反射到下方、上方、右方、左方。</li></ol><p>现在有 $q$ 个光源（给定位置和方向）。光的信徒小G想知道，对于每个光源，在足够长的时间内，发出的光线会被反射经过的不同镜子的数量。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于一个光源，如果它的传播路径没有首尾相连成环，那么这个路径就只可能是一条链。<br>（证明：光的路径是可逆的，假设一条传播路径在某一点突然形成了环，那回溯时在这个点就可以有两条路径，这显然是不合理的）</p><p>对于给定的镜子阵列，我们可以直接处理出每个点向每个方向的答案，对最后的询问打表。</p><p>只要是一条链，它的最初起点和最后终点一定在阵列的边缘位置。我们可以从边缘位置开始向内DFS，直到遇到边缘位置，这样就可以得到一条链的路径，路径上的答案都可以处理得到。</p><p>没有遍历到的点，说明它们是环的一部分，我们可以通过时间戳来寻找和处理环上的答案。</p><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                D  U  R  L</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c0[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// -</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c1[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;; <span class="comment">// |</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c2[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;; <span class="comment">// /</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c3[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// \&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> d, <span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> c0[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>: <span class="keyword">return</span> c1[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> c2[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">return</span> c3[d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q,tms,cnt; <span class="comment">//tms:timestamp</span></span><br><span class="line">vector&lt;string&gt; mp;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vis;</span><br><span class="line">vector&lt;vector&lt;array&lt;<span class="type">int</span>,4&gt;&gt;&gt; ans,visd;</span><br><span class="line">vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_line</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    buf.<span class="built_in">push_back</span>(&#123;x,y,dir&#125;);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=n||y&lt;<span class="number">0</span>||y&gt;=m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> nd=<span class="built_in">conv</span>(dir,mp[x][y]); <span class="comment">//new direction</span></span><br><span class="line">    <span class="built_in">dfs_line</span>(x+dx[nd],y+dy[nd],nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_line</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> sd)</span></span>&#123;</span><br><span class="line">    buf.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">dfs_line</span>(sx,sy,sd);</span><br><span class="line">    <span class="built_in">reverse</span>(buf.<span class="built_in">begin</span>(),buf.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>; tms++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;buf.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123; <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">auto</span> [x,y,d]=buf[i];</span><br><span class="line">        <span class="keyword">if</span>(i)&#123;</span><br><span class="line">            <span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[x][y]==<span class="string">&#x27;-&#x27;</span>&amp;&amp;(d&amp;<span class="number">2</span>)||mp[x][y]==<span class="string">&#x27;|&#x27;</span>&amp;&amp;!(d&amp;<span class="number">2</span>)) fl=<span class="number">0</span>; <span class="comment">// 通过</span></span><br><span class="line">            <span class="keyword">if</span>(fl)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[x][y]!=tms) res+=fl; <span class="comment">// 反射</span></span><br><span class="line">                vis[x][y]=tms;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visd[x+dx[d^<span class="number">1</span>]][y+dy[d^<span class="number">1</span>]][d]=tms;</span><br><span class="line">        ans [x+dx[d^<span class="number">1</span>]][y+dy[d^<span class="number">1</span>]][d]=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_loop</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    visd[x][y][dir]=tms;</span><br><span class="line">    x += dx[dir];</span><br><span class="line">    y += dy[dir];</span><br><span class="line">    <span class="type">int</span> nd = <span class="built_in">conv</span>(dir,mp[x][y]);</span><br><span class="line">    <span class="keyword">if</span>(nd!=dir)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[x][y]!=tms) cnt++;</span><br><span class="line">        vis[x][y]=tms;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visd[x][y][nd]!=tms) <span class="built_in">dfs_loop</span>(x,y,nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mk_loop</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    ans[x][y][dir] = cnt;</span><br><span class="line">    visd[x][y][dir] = tms;</span><br><span class="line">    x+=dx[dir];</span><br><span class="line">    y+=dy[dir];</span><br><span class="line">    <span class="type">int</span> nd=<span class="built_in">conv</span>(dir,mp[x][y]);</span><br><span class="line">    <span class="keyword">if</span>(visd[x][y][nd]!=tms) <span class="built_in">mk_loop</span>(x,y,nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_loop</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> sd)</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>; tms++;</span><br><span class="line">    <span class="built_in">dfs_loop</span>(sx,sy,sd);</span><br><span class="line">    tms++;</span><br><span class="line">    <span class="built_in">mk_loop</span>(sx,sy,sd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    mp.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:mp) cin &gt;&gt; s;</span><br><span class="line">    ans.<span class="built_in">resize</span>(n,vector&lt;array&lt;<span class="type">int</span>,<span class="number">4</span>&gt;&gt;(m,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">    visd.<span class="built_in">resize</span>(n,vector&lt;array&lt;<span class="type">int</span>,<span class="number">4</span>&gt;&gt;(m,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">    vis.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">f_line</span>(i,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">f_line</span>(i,m<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">f_line</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">f_line</span>(n<span class="number">-1</span>,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visd[i][j][d]==<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">f_loop</span>(i,j,d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,d;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;</span><br><span class="line">        x--,y--;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;b&#x27;</span>) d=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>) d=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;r&#x27;</span>) d=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;l&#x27;</span>) d=<span class="number">3</span>;</span><br><span class="line">        cout &lt;&lt; ans[x][y][d] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024暑期牛客多校01</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024暑期牛客多校" scheme="https://www.cclmsy.cc/tags/2024%E6%9A%91%E6%9C%9F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>项目文档|基于科大讯飞星火大模型的Nonebot2插件</title>
    <link href="https://www.cclmsy.cc/posts/Project_nonebot_plugin_sparkapi.html"/>
    <id>https://www.cclmsy.cc/posts/Project_nonebot_plugin_sparkapi.html</id>
    <published>2024-07-11T14:00:00.000Z</published>
    <updated>2024-07-27T09:18:53.314Z</updated>
    
    <content type="html"><![CDATA[<div align="center">  <a href="https://v2.nonebot.dev/store"><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/nbp_logo.png" width="180" height="180" alt="NoneBotPluginLogo"></a>  <br>  <p><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/NoneBotPlugin.svg" width="240" alt="NoneBotPluginText"></p></div><div align="center"># nonebot-plugin-sparkapi_✨ 科大讯飞星火大模型官方API聊天机器人 ✨_<img src="https://img.shields.io/github/license/CCLMSY/nonebot-plugin-sparkapi.svg" alt="license"></a><a href="https://pypi.python.org/pypi/nonebot-plugin-sparkapi"><img src="https://img.shields.io/pypi/v/nonebot-plugin-sparkapi.svg" alt="pypi"></a><img src="https://img.shields.io/badge/python-3.8+-blue.svg" alt="python"></a></div><h2 id="📖-介绍"><a href="#📖-介绍" class="headerlink" title="📖 介绍"></a>📖 介绍</h2><p>基于Nonebot2平台/科大讯飞星火大语言模型官方API的AI聊天机器人插件，适配OneBotV11协议</p><p>适用于所有模型版本（默认当前最新（v4.0）），同时支持自定义人物预设、会话管理，兼具AI绘图、AI生成PPT等功能</p><p>开发环境：Python3.11.8 on Conda, Windows 11</p><h3 id="📦-项目地址"><a href="#📦-项目地址" class="headerlink" title="📦 项目地址"></a>📦 项目地址</h3><ul><li>Github：<a href="https://github.com/CCLMSY/nonebot-plugin-sparkapi">https://github.com/CCLMSY/nonebot-plugin-sparkapi</a> </li><li>Pypi：<a href="https://pypi.org/project/nonebot-plugin-sparkapi/">https://pypi.org/project/nonebot-plugin-sparkapi/</a></li><li>NoneBot：<a href="https://registry.nonebot.dev/plugin/nonebot-plugin-sparkapi:nonebot_plugin_sparkapi">https://registry.nonebot.dev/plugin/nonebot-plugin-sparkapi:nonebot_plugin_sparkapi</a></li><li>作者主页：<a href="https://cclmsy.cc">https://cclmsy.cc</a></li><li>觉得好用的话，请给个 Star⭐️ 谢谢喵~ </li></ul><h3 id="💬-功能"><a href="#💬-功能" class="headerlink" title="💬 功能"></a>💬 功能</h3><ul><li>[x] 支持AI对话（已适配星火4.0API）</li><li>[x] 支持上下文关联</li><li>[x] 支持自定义预设、预设管理</li><li>[x] 支持会话存储和加载、会话管理</li><li>[x] 支持预设和历史记录持久化（基于json）</li><li>[x] 完善配置项（有其他需求请发issue）</li><li>[x] 支持AI绘图（Image Generation）</li><li>[x] 支持AI生成PPT（PPT Generation）</li><li>[ ] 用户权限与功能区分（超级用户、普通用户）</li><li>[ ] 用户画像（记录用户信息以便提供更精确的内容，目前存争议，考虑允许用户自行设置）</li></ul><h2 id="💿-安装"><a href="#💿-安装" class="headerlink" title="💿 安装"></a>💿 安装</h2><details open><summary>使用 nb-cli 安装</summary>在 nonebot2 项目的根目录下打开命令行, 输入以下指令即可安装    nb plugin install nonebot-plugin-sparkapi</details><details><summary>使用包管理器安装</summary>在 nonebot2 项目的插件目录下, 打开命令行, 根据你使用的包管理器, 输入相应的安装命令<details><summary>pip</summary>    pip install nonebot-plugin-sparkapi</details><details><summary>pdm</summary>    pdm add nonebot-plugin-sparkapi</details><details><summary>poetry</summary>    poetry add nonebot-plugin-sparkapi</details><details><summary>conda</summary>    conda install nonebot-plugin-sparkapi</details><p>打开 nonebot2 项目根目录下的 <code>pyproject.toml</code> 文件, 在 <code>[tool.nonebot]</code> 部分追加写入</p><pre><code>plugins = [&quot;nonebot_plugin_sparkapi&quot;]</code></pre><p>&lt;/details&gt;</p><h2 id="⚙️-配置项"><a href="#⚙️-配置项" class="headerlink" title="⚙️ 配置项"></a>⚙️ 配置项</h2><p>在 nonebot2 项目的<code>.env</code>文件中添加下列配置项中的必填配置（SPARKAPI_APP_ID, SPARKAPI_API_SECRET, SPARKAPI_API_KEY）</p><p>服务接口认证信息 app_id, api_secret, api_key 请前往 <a href="https://console.xfyun.cn/">讯飞开放平台控制台</a> 获取</p><p>AI绘图、AI生成PPT功能的API信息在同一应用下与对话API信息相同，开启相应功能前需要在讯飞开放平台申请相应的服务用量</p><div class="table-container"><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">必填</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SPARKAPI_APP_ID</td><td style="text-align:center">是</td><td style="text-align:center">“”</td><td style="text-align:center">APPID</td></tr><tr><td style="text-align:center">SPARKAPI_API_SECRET</td><td style="text-align:center">是</td><td style="text-align:center">“”</td><td style="text-align:center">APISecret</td></tr><tr><td style="text-align:center">SPARKAPI_API_KEY</td><td style="text-align:center">是</td><td style="text-align:center">“”</td><td style="text-align:center">APIKey</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_VERSION</td><td style="text-align:center">否</td><td style="text-align:center">“”</td><td style="text-align:center">星火大模型的版本，默认为当前最新。<br>可选值：”default”, “v4.0”, “v3.5”, “v3.0”, “v2.0”, “v1.5”</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_TOP_K</td><td style="text-align:center">否</td><td style="text-align:center">4</td><td style="text-align:center">平衡生成文本的质量和多样性。<br>较小的 k 值会减少随机性，使得输出更加稳定；<br>而较大的 k 值会增加随机性，产生更多新颖的输出。<br>取值范围[1, 6]</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_TEMPERATURE</td><td style="text-align:center">否</td><td style="text-align:center">0.5</td><td style="text-align:center">控制结果随机性，取值越高随机性越强，即相同的问题得到的不同答案的可能性越高。<br>取值范围 (0，1]</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_MAXKLENGTH</td><td style="text-align:center">否</td><td style="text-align:center">8000</td><td style="text-align:center">单次上下文最大token长度，建议取值范围：[4000,8000]。<br>详细说明见下文</td></tr><tr><td style="text-align:center">SPARKAPI_PRIORITY</td><td style="text-align:center">否</td><td style="text-align:center">80</td><td style="text-align:center">本插件响应事件的优先级，建议设置较大的值。可选值：1~97。<br>详细说明见下文</td></tr><tr><td style="text-align:center">SPARKAPI_COMMAND_CHAT</td><td style="text-align:center">否</td><td style="text-align:center">“”</td><td style="text-align:center">机器人对话指令，默认为””可直接对话</td></tr><tr><td style="text-align:center">SPARKAPI_FL_NOTICE</td><td style="text-align:center">否</td><td style="text-align:center">True</td><td style="text-align:center">收到对话请求时是否提示“已收到请求”</td></tr><tr><td style="text-align:center">SPARKAPI_FL_PRIVATE_CHAT</td><td style="text-align:center">否</td><td style="text-align:center">True</td><td style="text-align:center">是否允许私聊使用</td></tr><tr><td style="text-align:center">SPARKAPI_FL_GROUP_PUBLIC</td><td style="text-align:center">否</td><td style="text-align:center">False</td><td style="text-align:center">群聊启用公共会话<br>True：所有人共享同一会话<br>False：每个人的会话各自独立</td></tr><tr><td style="text-align:center">SPARKAPI_FL_INTERFLOW</td><td style="text-align:center">否</td><td style="text-align:center">FALSE</td><td style="text-align:center">对于同一用户，群聊与私聊数据互通（公共会话启用时，群聊仍独立）</td></tr><tr><td style="text-align:center">SPARKAPI_FL_GROUP_AT</td><td style="text-align:center">否</td><td style="text-align:center">True</td><td style="text-align:center">群聊回复消息时是否需要@提问者</td></tr><tr><td style="text-align:center">SPARKAPI_FL_IMGGEN</td><td style="text-align:center">否</td><td style="text-align:center">False</td><td style="text-align:center">是否启用AI绘图功能</td></tr><tr><td style="text-align:center">SPARKAPI_FL_PPTGEN</td><td style="text-align:center">否</td><td style="text-align:center">False</td><td style="text-align:center">是否启用AI生成PPT功能</td></tr><tr><td style="text-align:center">SPARKAPI_IG_SIZE</td><td style="text-align:center">否</td><td style="text-align:center">[1280,720]</td><td style="text-align:center">AI绘图的图片尺寸，[宽,高]。<br>可选值和API消耗见下文</td></tr><tr><td style="text-align:center">SPARKAPI_BOT_NAME</td><td style="text-align:center">否</td><td style="text-align:center">“”</td><td style="text-align:center">机器人的名字</td></tr></tbody></table></div><h3 id="SPARKAPI-MODEL-MAXKLENGTH"><a href="#SPARKAPI-MODEL-MAXKLENGTH" class="headerlink" title="SPARKAPI_MODEL_MAXKLENGTH"></a>SPARKAPI_MODEL_MAXKLENGTH</h3><ul><li>单次上下文最大token长度，不能超过8000token。建议取值范围：[4000,8000]</li><li>该值越大，对话历史记录保留越长，单次请求消耗token的最大值越大。</li><li>1token≈1.5个中文字≈1个英文单词。保守起见，在本插件中1token取1.25个字符</li><li>QQ单条消息上限4500个字符（计3600token），消息超过最大长度可能导致响应不正确</li></ul><h3 id="SPARKAPI-PRIORITY"><a href="#SPARKAPI-PRIORITY" class="headerlink" title="SPARKAPI_PRIORITY"></a>SPARKAPI_PRIORITY</h3><ul><li>响应事件的优先级，该值越小，事件越先被本插件响应。可选值：1~97</li><li>本插件中事件的优先级顺序：私聊阻断（=priority）&lt; 功能（=priority+1）&lt; 对话（=priority+2）</li><li>若触发本插件事件，所有插件中优先级大于此值的事件都将被阻断，因此本插件建议设置较大的值。</li></ul><h3 id="SPARKAPI-IG-SIZE"><a href="#SPARKAPI-IG-SIZE" class="headerlink" title="SPARKAPI_IG_SIZE"></a>SPARKAPI_IG_SIZE</h3><div class="table-container"><table><thead><tr><th style="text-align:center">分辨率（可选值）</th><th style="text-align:center">消耗图点数</th></tr></thead><tbody><tr><td style="text-align:center">[512,512]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,360]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,480]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,640]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[680,512]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[512,680]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[768,768]</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">[720,1280]</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">[1280,720]</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">[1024,1024]</td><td style="text-align:center">14</td></tr></tbody></table></div><h3 id="命令相关：sparkapi-commands、sparkapi-commands-info"><a href="#命令相关：sparkapi-commands、sparkapi-commands-info" class="headerlink" title="命令相关：sparkapi_commands、sparkapi_commands_info"></a>命令相关：sparkapi_commands、sparkapi_commands_info</h3><ul><li><p>如有需要，以下命令相关配置项请在<code>/.venv/Lib/nonebot_plugin_sparkapi/config.py</code>修改：</p><ol><li>sparkapi_commands：指令表</li><li>sparkapi_commands_info：指令表说明（用于生成帮助信息）</li></ol></li><li><p>在<code>config.py</code>文件中，已经用缩进表示了命令之间的从属关系。一级命令为主命令，二级命令为子命令。</p></li><li><p>命令格式由NoneBot机器人项目下的配置文件<code>.env</code>中的<code>COMMAND_START</code>和<code>COMMAND_SEP</code>决定（请参考NoneBot文档）。默认情况下，<code>COMMAND_START</code>为<code>[&quot;/&quot;]</code>，<code>COMMAND_SEP</code>为<code>[&quot;.&quot;]</code>。</p></li><li><p>一级命令会出现在帮助信息中，二级命令在一级命令下出现。</p></li><li><p>以二级命令<code>preset_create</code>为例，默认配置下：</p><ul><li>预设管理命令<code>preset</code>、二级命令<code>create</code>。</li><li>完整命令格式为<code>/preset.create</code>。</li><li>这个命令不会出现在<code>/help</code>的帮助信息中，但会在发送<code>/preset</code>时告知用户命令和用法。</li></ul></li><li><p>当前命令模式还在测试中，如有好的建议欢迎提出。</p></li></ul><h2 id="🎉-使用"><a href="#🎉-使用" class="headerlink" title="🎉 使用"></a>🎉 使用</h2><h3 id="指令表（默认）"><a href="#指令表（默认）" class="headerlink" title="指令表（默认）"></a>指令表（默认）</h3><p>以下所有指令均可在config.py中修改，且无需重写菜单/指令生成函数</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令（默认配置下）</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">直接发送对话内容<br>SPARKAPI_COMMAND_CHAT（若不为空）+对话内容</td><td style="text-align:center">与机器人进行对话</td></tr><tr><td style="text-align:center">/help</td><td style="text-align:center">显示帮助信息</td></tr><tr><td style="text-align:center">/preset</td><td style="text-align:center">显示人物预设菜单和预设相关命令项</td></tr><tr><td style="text-align:center">/preset.create</td><td style="text-align:center">创建自定义人物预设</td></tr><tr><td style="text-align:center">/preset.set</td><td style="text-align:center">选择人物预设并切换</td></tr><tr><td style="text-align:center">/preset.show</td><td style="text-align:center">显示自定义人物预设详情</td></tr><tr><td style="text-align:center">/preset.delete</td><td style="text-align:center">删除自定义人物预设</td></tr><tr><td style="text-align:center">/session</td><td style="text-align:center">显示保存的对话记录和会话管理相关命令项</td></tr><tr><td style="text-align:center">/session.save</td><td style="text-align:center">保存当前对话上下文</td></tr><tr><td style="text-align:center">/session.load</td><td style="text-align:center">加载保存的对话上下文</td></tr><tr><td style="text-align:center">/session.show</td><td style="text-align:center">显示保存的对话记录</td></tr><tr><td style="text-align:center">/session.delete</td><td style="text-align:center">删除保存的对话记录</td></tr><tr><td style="text-align:center">/clear</td><td style="text-align:center">清除当前对话上下文</td></tr><tr><td style="text-align:center">/image</td><td style="text-align:center">AI绘图</td></tr><tr><td style="text-align:center">/ppt</td><td style="text-align:center">AI生成PPT</td></tr></tbody></table></div><h3 id="自带人物预设"><a href="#自带人物预设" class="headerlink" title="自带人物预设"></a>自带人物预设</h3><ol><li>智能助手（默认）</li><li>李白</li></ol><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/demo.png" alt="Demo"><br><a href="https://source.cclmsy.cc/Images/nbp_Sparkapi/科大讯飞星火语言模型项目汇报.pptx">DemoPPT: 科大讯飞星火语言模型项目汇报.pptx</a></p><h2 id="📝-更新日志"><a href="#📝-更新日志" class="headerlink" title="📝 更新日志"></a>📝 更新日志</h2><ul><li>2024.7.10 v2.0.0<ul><li>项目重写</li><li>支持会话存储和加载、会话管理</li><li>支持预设和历史记录持久化（基于json）</li><li>优化命令、功能的实现方式</li><li>调整了配置项和指令表</li></ul></li><li>2024.6.30 v1.5.0<ul><li>适配星火4.0API</li></ul></li><li>2024.6.25 v1.4.5<ul><li>使用默认的SSL证书</li></ul></li><li>2024.6.9 v1.4.4<ul><li>优化项目结构</li><li>优化部分功能的实现方式</li></ul></li><li>2024.5.30 v1.4.1<ul><li>新增AI生成PPT功能</li></ul></li><li>2024.5.29 v1.4.0<ul><li>项目重构</li><li>新增AI绘图功能</li></ul></li><li>2024.5.17 v1.2.0<ul><li>简化了初始命令</li><li>模块结构优化</li></ul></li><li>2024.5.16 v1.1.0<ul><li>存储和加载单次会话（基于pickle）</li><li>改用异步方式请求API</li></ul></li><li>2024.5.15 v1.0.0<ul><li>支持AI对话</li><li>支持上下文关联</li><li>支持自定义预设、预设管理</li></ul></li></ul>]]></content>
    
    
    <summary type="html">基于科大讯飞星火大模型的Nonebot2插件，支持自定义人物预设、会话管理，兼具AI绘图、AI生成PPT等功能。适配OneBotV11协议，适用于所有模型版本（默认当前最新（v4.0））</summary>
    
    
    
    <category term="项目" scheme="https://www.cclmsy.cc/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Python" scheme="https://www.cclmsy.cc/tags/Python/"/>
    
    <category term="机器人" scheme="https://www.cclmsy.cc/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="项目" scheme="https://www.cclmsy.cc/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>《数字图像处理》笔记</title>
    <link href="https://www.cclmsy.cc/posts/Note_Image_Processing.html"/>
    <id>https://www.cclmsy.cc/posts/Note_Image_Processing.html</id>
    <published>2024-06-16T18:55:00.000Z</published>
    <updated>2024-07-27T08:56:52.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、数字图像处理基础"><a href="#二、数字图像处理基础" class="headerlink" title="二、数字图像处理基础"></a>二、数字图像处理基础</h1><h2 id="2-1-数字图像采集"><a href="#2-1-数字图像采集" class="headerlink" title="2.1.数字图像采集"></a>2.1.数字图像采集</h2><ol><li>当前普遍采用的图像传感器：CCD、CMOS<ul><li>共同点：利用感光二极管进行光电转换，获取图像并转换为数字数据</li></ul></li><li>采样：空间坐标离散化<ul><li>均匀采样：等间隔划分成$N$行$M$列的网格</li></ul></li><li>量化：灰度值离散化<ul><li>均匀量化：将灰度值划分为$L$（通常为$2^k$）个等间隔的区间</li><li>通常取$k=8,L=256$，灰度从小到大，像素从暗到亮</li></ul></li></ol><h2 id="2-2-数字图像表示"><a href="#2-2-数字图像表示" class="headerlink" title="2.2.数字图像表示"></a>2.2.数字图像表示</h2><ol><li>通常采用$N\times M$大小的矩阵表示具有$N$行$M$列的数字图像</li><li>左上角坐标为$(0,0)$，每个坐标的函数值$f(x,y)$表示该点的灰度值</li><li>像素：每个坐标表示的单元格</li></ol><h2 id="2-3-分辨率与图像存储"><a href="#2-3-分辨率与图像存储" class="headerlink" title="2.3.分辨率与图像存储"></a>2.3.分辨率与图像存储</h2><ol><li>空间分辨率：一般指数字图像的阵列大小$N\times M$</li><li>灰度分辨率：指数字图像的灰度级别$L$（通常为$2^k$）<ul><li>灰度：图像中每个像素的亮度值，通常用0-255表示。灰度级别越多，图像越清晰。</li></ul></li><li>图像存储：长×宽×位数×通道数/8<ul><li>一幅空间分辨率为$N\times M$，灰度分辨率为$2^k$的RGB数字图像，需要$N\times M\times k\times 3 / 8 B$存储（$1B=8bit$）</li></ul></li></ol><h2 id="2-4-像素间关系"><a href="#2-4-像素间关系" class="headerlink" title="2.4.像素间关系"></a>2.4.像素间关系</h2><ol><li>相邻与邻域（以$p(x,y)$为例）<ul><li>4邻域：上下左右四个像素，记为$N_4(p)$</li><li>对角邻域：上左、上右、下左、下右四个像素，记为$N_D(p)$</li><li>8邻域：九宫格，记为$N_8(p)$</li></ul></li><li>像素的邻接性<ul><li>4邻接：$p$与$N_4(p)$中的像素相邻</li><li>8邻接：$p$与$N_8(p)$中的像素相邻</li><li>m邻接（混合邻接）：先进行4邻接，若存在四宫格中仅对角存在像素，则对角连接</li></ul></li><li>像素的连通性<ul><li>按照对应邻接性连接像素，形成连通块</li></ul></li><li>像素的距离<ul><li>欧几里得距离（欧氏距离，范数2）：$d(p_1,p_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$</li><li>曼哈顿距离（街区距离，范数1）：$d(p_1,p_2)=|x_1-x_2|+|y_1-y_2|$</li><li>棋盘距离（范数$\infty$）：$d(p_1,p_2)=\max(|x_1-x_2|,|y_1-y_2|)$</li><li>$D_m$距离：m邻接后，$p_1$到$p_2$的最短路径长度</li></ul></li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP08.png" alt=""></p><h2 id="2-5-习题"><a href="#2-5-习题" class="headerlink" title="2.5. 习题"></a>2.5. 习题</h2><ol><li>数字图像处理的五个经典应用领域：媒体通信、宇宙探索、气象预报、侦缉破案、考古</li><li>二值图像：具有两种灰度值的图像，但不一定是0和1。黑白图像一定是二值图像，但二值图像不一定是黑白图像。</li><li>视觉适应性：人眼对突然的亮度变化需要时间适应，亮适应性的时间比暗适应性短得多。</li><li>马赫带效应：人眼对两个颜色之间的边界，亮度感知受影响。较暗的色块靠近边界的一侧看起来更暗。</li><li>为什么在某些图像处理中，需要对图像的灰度进行对数运算？<ul><li>大量实验表明人的视觉感知到的主观亮度与进入人眼的光强度成对数关系。如此处理可以达到更好的视觉效果。</li></ul></li></ol><h1 id="三、数字图像的基本运算"><a href="#三、数字图像的基本运算" class="headerlink" title="三、数字图像的基本运算"></a>三、数字图像的基本运算</h1><h2 id="3-1-矩阵统计量"><a href="#3-1-矩阵统计量" class="headerlink" title="3.1.矩阵统计量"></a>3.1.矩阵统计量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean, stddev = cv2.meanStdDev(img) <span class="comment"># 均值、标准差</span></span><br><span class="line">minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(img) <span class="comment"># 最小值、最大值、最小值位置、最大值位置</span></span><br><span class="line">coeff = stddev / mean <span class="comment"># 变异系数</span></span><br></pre></td></tr></table></figure><h2 id="3-2-灰度直方图"><a href="#3-2-灰度直方图" class="headerlink" title="3.2.灰度直方图"></a>3.2.灰度直方图</h2><ul><li>$H(P)=[h(r<em>0),h(r_1),\cdots,h(r</em>{L-1})]$</li><li>$h(r_i)=n_i$</li><li>统计图像中每个灰度级别的像素个数</li><li>用于分析图像的对比度、亮度等信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 计算直方图</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line"><span class="comment"># images: list[MatLike]  图像列表</span></span><br><span class="line"><span class="comment"># channels : list[int]  通道</span></span><br><span class="line"><span class="comment"># mask : MatLike 掩码，大小与输入图像相同，1表示统计，0表示不统计</span></span><br><span class="line"><span class="comment"># histSize : list[int] 直方图中bin的个数（柱的个数）</span></span><br><span class="line"><span class="comment"># ranges : list[int] 灰度值范围，通常为[0, 256]，表示0-255的灰度值范围</span></span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>//<span class="number">8</span>], [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 计算binwidth=8的直方图</span></span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>//<span class="number">8</span>, [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 绘制直方图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li>对比度越小，直方图中像素分布越集中；对比度越大，直方图中像素分布越分散均匀<ul><li>对比度：最亮与最暗像素之间的差异，可以表示为最大灰度和最小灰度的比值</li></ul></li><li>亮度越低，直方图中像素分布越靠近左侧</li></ul><h3 id="灰度直方图的特征"><a href="#灰度直方图的特征" class="headerlink" title="灰度直方图的特征"></a>灰度直方图的特征</h3><ol><li>所有函数值的总和是MN</li><li>只反映每种像素值出现的次数，不反映像素的空间分布</li><li>一幅图像的直方图是唯一的，但不同图像的直方图可以相同（由第二点决定）</li></ol><h3 id="归一化直方图"><a href="#归一化直方图" class="headerlink" title="归一化直方图"></a>归一化直方图</h3><ul><li>$P(r_k)=\dfrac{h(r_k)}{MN}$</li><li>将直方图中的像素个数转换为频率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h2 id="3-3-图像的几何运算"><a href="#3-3-图像的几何运算" class="headerlink" title="3.3.图像的几何运算"></a>3.3.图像的几何运算</h2><p>修改像素之间的空间关系，由两种基本操作组成：</p><ol><li>空间变换：改变像素之间的空间关系</li><li>灰度级插值：确定空间变换后的像素灰度值</li></ol><h3 id="3-3-1-空间变换"><a href="#3-3-1-空间变换" class="headerlink" title="3.3.1.空间变换"></a>3.3.1.空间变换</h3><h4 id="3-3-1-1-平移变换"><a href="#3-3-1-1-平移变换" class="headerlink" title="3.3.1.1.平移变换"></a>3.3.1.1.平移变换</h4><script type="math/tex; mode=display">\begin{cases}   x_1=x_0+\Delta x\\\\   y_1=y_0+\Delta y\end{cases}</script><h4 id="3-3-1-2-旋转变换"><a href="#3-3-1-2-旋转变换" class="headerlink" title="3.3.1.2.旋转变换"></a>3.3.1.2.旋转变换</h4><p>记旋转前（角坐标系）：</p><script type="math/tex; mode=display">\begin{cases}   x_0=r\cos\theta\\\\   y_0=r\sin\theta\end{cases}</script><p>顺时针旋转$\alpha$角度：</p><script type="math/tex; mode=display">\begin{cases}   x_1=r\cos(\theta-\alpha)\\\\   y_1=r\sin(\theta-\alpha)\end{cases}\\\\=\begin{cases}   x_1=r\cos\theta\cos\alpha+r\sin\theta\sin\alpha\\\\   y_1=r\sin\theta\cos\alpha-r\cos\theta\sin\alpha\end{cases}\\\\=\begin{cases}   x_1=x_0\cos\alpha+y_0\sin\alpha\\\\   y_1=-x_0\sin\alpha+y_0\cos\alpha\end{cases}</script><h4 id="3-3-1-3-镜像变换"><a href="#3-3-1-3-镜像变换" class="headerlink" title="3.3.1.3.镜像变换"></a>3.3.1.3.镜像变换</h4><ol><li>水平镜像：$x_1=M-x_0,y_1=y_0$</li><li>垂直镜像：$x_1=x_0,y_1=N-y_0$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_flip = cv2.flip(img, <span class="number">1</span>) <span class="comment"># 1水平镜像，0垂直镜像，-1水平+垂直镜像</span></span><br></pre></td></tr></table></figure><h4 id="3-3-1-4-缩放变换"><a href="#3-3-1-4-缩放变换" class="headerlink" title="3.3.1.4.缩放变换"></a>3.3.1.4.缩放变换</h4><script type="math/tex; mode=display">\begin{cases}   x_1=kx_0 \\\\   y_1=ky_0\end{cases}</script><h4 id="3-3-1-5-转置变换"><a href="#3-3-1-5-转置变换" class="headerlink" title="3.3.1.5.转置变换"></a>3.3.1.5.转置变换</h4><script type="math/tex; mode=display">\begin{cases}   x_1=y_0\\\\   y_1=x_0\end{cases}</script><h3 id="3-3-2-灰度级插值"><a href="#3-3-2-灰度级插值" class="headerlink" title="3.3.2.灰度级插值"></a>3.3.2.灰度级插值</h3><h4 id="3-3-2-0-前向映射与反向映射"><a href="#3-3-2-0-前向映射与反向映射" class="headerlink" title="3.3.2.0.前向映射与反向映射"></a>3.3.2.0.前向映射与反向映射</h4><ol><li>前向映射：原图像的一个像素映射到目标图像的多个像素（放大）</li><li>反向映射：原图像的多个像素映射到目标图像的一个像素（缩小）</li></ol><h4 id="3-3-2-1-最近邻插值-零阶内插"><a href="#3-3-2-1-最近邻插值-零阶内插" class="headerlink" title="3.3.2.1.最近邻插值/零阶内插"></a>3.3.2.1.最近邻插值/零阶内插</h4><p>取前向映射变换所得位置，最近的的整数像素位置作为灰度值。<br>计算简单，容易产生锯齿。</p><h4 id="3-3-2-2-双线性插值"><a href="#3-3-2-2-双线性插值" class="headerlink" title="3.3.2.2.双线性插值"></a>3.3.2.2.双线性插值</h4><p>记：原像素位置$(0,0),(0,1),(1,0),(1,1)$，反向映射变换所得位置$(x,y)$在它们中间。</p><p>根据像素相对四点的位置，求取算术平均值作为灰度值。</p><script type="math/tex; mode=display">f(x,0)=(1-x)f(0,0)+xf(1,0)\\\\f(x,1)=(1-x)f(0,1)+xf(1,1)\\\\f(x,y)=(1-y)f(x,0)+yf(x,1)</script><h1 id="四、空间域图像增强"><a href="#四、空间域图像增强" class="headerlink" title="四、空间域图像增强"></a>四、空间域图像增强</h1><p>图像增强技术可以分为两大类：空间域方法和频率域方法。<br>空间域方法以对图像的像素进行直接处理为基础，基于点运算的方法，在单个像素层面上进行。<br>统一表示：$g(x,y)=T[f(x,y)]$，其中算子T是一种点操作。</p><h2 id="4-1-基于点运算的图像增强方法"><a href="#4-1-基于点运算的图像增强方法" class="headerlink" title="4.1.基于点运算的图像增强方法"></a>4.1.基于点运算的图像增强方法</h2><h3 id="4-1-1-对比度拉伸-分段线性变换"><a href="#4-1-1-对比度拉伸-分段线性变换" class="headerlink" title="4.1.1.对比度拉伸/分段线性变换"></a>4.1.1.对比度拉伸/分段线性变换</h3><p>一种通过增强图像的对比度来改善图像质量的方法。</p><ul><li>一种典型处理：压缩最暗和最亮部分，拉伸中间部分。</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP01.png" alt=""></p><ul><li>均匀变亮/均匀变暗：与原始灰度成线性关系。</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP02.png" alt=""></p><h3 id="4-1-2-窗切片"><a href="#4-1-2-窗切片" class="headerlink" title="4.1.2.窗切片"></a>4.1.2.窗切片</h3><p>一种强制某区间的灰度值为给定值的方法。</p><ul><li>区外灰度值不变</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP03.png" alt=""></p><h3 id="4-1-3-修剪变换"><a href="#4-1-3-修剪变换" class="headerlink" title="4.1.3.修剪变换"></a>4.1.3.修剪变换</h3><p>去除较暗和较亮部分，拉伸中间部分，特殊的对比度拉伸。</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP04.png" alt=""></p><h3 id="4-1-4-其他变换"><a href="#4-1-4-其他变换" class="headerlink" title="4.1.4.其他变换"></a>4.1.4.其他变换</h3><ul><li>对数变换：$s=c\log(1+r)$</li><li>幂次变换：$s=cr^\gamma$</li><li>离散化：$s=0\ if\ r&lt;b\ else\ L-1$</li></ul><h2 id="4-2-基于直方图的图像增强方法"><a href="#4-2-基于直方图的图像增强方法" class="headerlink" title="4.2.基于直方图的图像增强方法"></a>4.2.基于直方图的图像增强方法</h2><h3 id="4-2-1-直方图均衡化"><a href="#4-2-1-直方图均衡化" class="headerlink" title="4.2.1.直方图均衡化"></a>4.2.1.直方图均衡化</h3><p>将一副已知图像变换成灰度具有均匀概率分布的图像，通过增大灰度值范围和对比度实现图像增强。</p><ul><li>记原图像$f$的灰度级为$L$，对原图像$f$进行直方图均衡化得到的新图像为$g$。图像直方图均衡化的步骤如下：</li></ul><ol><li>统计原图像$f$中各个灰度级的像素个数，得到原图像的直方图$H(f)$。<ul><li>给定 $16\times16$的图像$f$灰度级$L=8$</li><li>给定 $H(f)=[29,40,32,27,13,10,6,3]$</li></ul></li><li>对原图像的直方图$H(f)$进行归一化处理，得到归一化直方图$P(f)$。<ul><li>归一化直方图$P(f)=[0.18,0.25,0.20,0.17,0.08,0.06,0.04,0.02]$</li></ul></li><li>计算归一化直方图$P(f)$的累积分布函数$C(f)$（前缀和）。<ul><li>累积分布函数$C(f)=[0.18,0.43,0.63,0.80,0.88,0.94,0.98,1.00]$</li></ul></li><li>计算新灰度级$t_i=round((L-1)c(i))$（四舍五入）<ul><li>$[1,3,4,6,6,7,7,7]$</li></ul></li><li>将原图像$f$中的灰度级$i$替换为新灰度级$t_i$，得到直方图均衡化后的新图像$g$。</li><li>统计新图像$g$中各个灰度级的像素个数，得到新图像的直方图$H(g)$。<ul><li>$H(g)=[0,29,0,40,32,0,40,19]$</li></ul></li><li>对新图像的直方图$H(g)$进行归一化处理，得到新图像的归一化直方图$P(g)$。<ul><li>$P(g)=[0.00,0.18,0.00,0.25,0.20,0.00,0.25,0.12]$</li></ul></li></ol><ul><li>通过直方图均衡化，可以使得图像的灰度值分布更加均匀，从而增强图像的对比度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_eq = cv2.equalizeHist(img) <span class="comment"># 直方图均衡化</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-直方图规定化"><a href="#4-2-2-直方图规定化" class="headerlink" title="4.2.2.直方图规定化"></a>4.2.2.直方图规定化</h3><p>直方图均衡化能显著的增强整个图像的对比度，但增强效果不易控制。通过直方图规定化，可以人为地改变直方图的形状。</p><ul><li>图像直方图规定化的步骤如下：</li></ul><ol><li>统计原图像$f$中各个灰度级的像素个数，得到原图像的直方图$H(f)$。<ul><li>给定$64\times64$的图像$f$灰度级$L=8$</li><li>给定 $H(f)=[790,1023,850,656,329,245,122,81]$</li></ul></li><li>对原图像的直方图$H(f)$进行归一化处理，得到归一化直方图$P(f)$。<ul><li>$P(f)=[0.19,0.25,0.21,0.16,0.08,0.06,0.03,0.02]$</li></ul></li><li>计算归一化直方图$P(f)$的累积分布函数$C(f)$（前缀和）。<ul><li>$C(f)=[0.19,0.44,0.65,0.81,0.89,0.95,0.98,1.00]$</li></ul></li><li>对于给定的目标信息，求出目标累积分布函数$C_1(f_1)$。<ul><li>假设给定$P_1(f_1)=[0,0,0,0.15,0.2,0.3,0.2,0.15]$</li><li>$C_1(f_1)=[0,0,0,0.15,0.35,0.65,0.85,1.00]$</li></ul></li><li>比较$C(f)$和$C(f_1)$，对于原图像$f$每个灰度级$i$，找到$|C(i)-C_1(j)|$最接近的$j$，得到映射关系。<ul><li>$C(f)=[0.19,0.44,0.65,0.81,0.89,0.95,0.98,1.00]$</li><li>$C_1(f_1)=[0,0,0,0.15,0.35,0.65,0.85,1.00]$</li><li>$T(i)=[3,4,5,6,6,7,7,7]$</li></ul></li><li>将原图像$f$中的灰度级$i$替换为新灰度级$t_i$，得到直方图均衡化后的新图像$g$。</li><li>统计新图像$g$中各个灰度级的像素个数，得到新图像的直方图$H(g)$。<ul><li>$H(g)=[0,0,0,790,1023,850,985,448]$</li></ul></li><li>对新图像的直方图$H(g)$进行归一化处理，得到新图像的归一化直方图$P(g)$。<ul><li>$P(g)=[0,0,0,0.19,0.25,0.21,0.24,0.11]$</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">f = cv2.imread(<span class="string">&#x27;lenna.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">f1 = cv2.imread(<span class="string">&#x27;Flower.png&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">Hf = cv2.calcHist([f], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">Pf = Hf / np.<span class="built_in">sum</span>(Hf)</span><br><span class="line">Cf = [np.<span class="built_in">sum</span>(Pf[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">Hf1 = cv2.calcHist([f1], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">Pf1 = Hf1 / np.<span class="built_in">sum</span>(Hf1)</span><br><span class="line">Cf1 = [np.<span class="built_in">sum</span>(Pf1[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">Tr = np.zeros(<span class="number">256</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    tmp_h = np.ones(<span class="number">256</span>) * Cf1[i]</span><br><span class="line">    tmp = np.fabs(Cf - tmp_h) <span class="comment"># 对应元素相减取绝对值</span></span><br><span class="line">    Tr[i] = np.argmin(tmp) <span class="comment"># 找到最小值的索引</span></span><br><span class="line"></span><br><span class="line">out = cv2.LUT(f, Tr)</span><br></pre></td></tr></table></figure><h2 id="4-滤波"><a href="#4-滤波" class="headerlink" title="4.*.滤波"></a>4.*.滤波</h2><ul><li>利用像素和其邻域像素的灰度值进行图像增强的方法。</li><li>空间滤波分为平滑滤波和锐化滤波。</li><li>filter：滤波器，用于对图像进行滤波处理</li><li>mask：滤波器的模板，用于计算滤波后的像素值</li></ul><h2 id="4-3-基于空间平滑滤波的图像增强方法"><a href="#4-3-基于空间平滑滤波的图像增强方法" class="headerlink" title="4.3.基于空间平滑滤波的图像增强方法"></a>4.3.基于空间平滑滤波的图像增强方法</h2><ul><li>平滑滤波<ul><li>目的：去除（细小）噪声、平滑图像</li><li>本质：对像素和其邻域像素的灰度值进行加权平均</li></ul></li></ul><h3 id="4-3-1-线性滤波方法——邻域平均滤波"><a href="#4-3-1-线性滤波方法——邻域平均滤波" class="headerlink" title="4.3.1.线性滤波方法——邻域平均滤波"></a>4.3.1.线性滤波方法——邻域平均滤波</h3><ul><li>mask：$h=\dfrac{1}{9}\begin{bmatrix}1&amp;1&amp;1 \\ 1&amp;1&amp;1 \\ 1&amp;1&amp;1\end{bmatrix}$</li><li>可以调整mask的大小和权重，实现不同的平滑效果。<ul><li>参数越大，平滑效果越明显，图像越模糊。</li><li>一般中心像素权重最大，边缘像素权重较小。</li></ul></li><li>可以根据Gaussian分布确定mask的权重，实现高斯滤波。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ksize = (<span class="number">5</span>, <span class="number">5</span>) <span class="comment"># mask大小，奇数</span></span><br><span class="line">img_blur = cv2.blur(img, ksize) <span class="comment"># 邻域平均滤波</span></span><br><span class="line">img_gaussian = cv2.GaussianBlur(img, ksize, <span class="number">0</span>) <span class="comment"># 高斯滤波</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-非线性滤波方法——中值滤波"><a href="#4-3-2-非线性滤波方法——中值滤波" class="headerlink" title="4.3.2.非线性滤波方法——中值滤波"></a>4.3.2.非线性滤波方法——中值滤波</h3><ul><li>中值滤波窗口形状不定：矩形、圆形、十字形等</li><li>选取窗口内像素的中值作为中心像素的灰度值</li><li>优点：在减少边缘模糊方面比邻域平均效果好，对消除冲激噪声效果好</li><li>缺点：对消除高斯噪声效果差</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_median = cv2.medianBlur(img, <span class="number">5</span>) <span class="comment"># 中值滤波</span></span><br></pre></td></tr></table></figure><h2 id="4-4-基于空间锐化滤波的图像增强方法"><a href="#4-4-基于空间锐化滤波的图像增强方法" class="headerlink" title="4.4.基于空间锐化滤波的图像增强方法"></a>4.4.基于空间锐化滤波的图像增强方法</h2><ul><li>锐化滤波<ul><li>目的：增强图像的边缘、轮廓</li><li>要求：图像具有较高的信噪比</li><li>锐化处理通常和边缘检测结合使用</li></ul></li><li>梯度<ul><li>函数$z=f(x,y)$在点$(x,y)$处的梯度：$\nabla f(x,y)=\left[\dfrac{\partial f}{\partial x},\dfrac{\partial f}{\partial y}\right]^T$</li><li>梯度是一个向量，具有方向和模</li><li>梯度的方向$\theta$：$\theta=\arctan\left(\dfrac{\partial f}{\partial y}/\dfrac{\partial f}{\partial x}\right)$</li><li>梯度的模$G$：<ul><li>按2-范数计算，对应欧几里得距离（欧氏距离）：$|\nabla f_{(2)}|=\sqrt{\left(\dfrac{\partial f}{\partial x}\right)^2+\left(\dfrac{\partial f}{\partial y}\right)^2}$</li><li>按1-范数计算，对应曼哈顿距离（街区距离）：$|\nabla f_{(1)}|=|\dfrac{\partial f}{\partial x}|+|\dfrac{\partial f}{\partial y}|$</li><li>按$\infty$-范数计算，对应棋盘距离：$|\nabla f_{(\infty)}|=\max(|\dfrac{\partial f}{\partial x}|,|\dfrac{\partial f}{\partial y}|)$</li></ul></li></ul></li><li>由于数字图像的离散性，偏导使用差分表示：<ul><li>一阶水平：$\Delta_y f(x,y)=f(x,y+1)-f(x,y)$</li><li>一阶垂直：$\Delta_x f(x,y)=f(x+1,y)-f(x,y)$</li><li>二阶水平：$\Delta_{yy} f(x,y)=f(x,y+1)+f(x,y-1)-2f(x,y)$</li><li>二阶垂直：$\Delta_{xx} f(x,y)=f(x+1,y)+f(x-1,y)-2f(x,y)$</li></ul></li></ul><h3 id="4-4-1-罗伯特算子（Roberts-Operator）"><a href="#4-4-1-罗伯特算子（Roberts-Operator）" class="headerlink" title="4.4.1.罗伯特算子（Roberts Operator）"></a>4.4.1.罗伯特算子（Roberts Operator）</h3><ul><li>$G=|\Delta_x f(x,y)|+|\Delta_y f(x,y)|$</li><li>$h=\begin{bmatrix}1&amp;0\\0&amp;-1\end{bmatrix}或\begin{bmatrix}0&amp;1\\-1&amp;0\end{bmatrix}$</li><li>优点：交叉差分法，简单，计算量小。</li><li>缺点：使用像素少，对噪声敏感。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_roberts = cv2.filter2D(img, -<span class="number">1</span>, np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]])) <span class="comment"># 罗伯特算子</span></span><br></pre></td></tr></table></figure><h3 id="4-4-2-拉普拉斯算子（Laplacian-Operator）"><a href="#4-4-2-拉普拉斯算子（Laplacian-Operator）" class="headerlink" title="4.4.2.拉普拉斯算子（Laplacian Operator）"></a>4.4.2.拉普拉斯算子（Laplacian Operator）</h3><ul><li>$G=|\Delta<em>{xx} f(x,y)|+|\Delta</em>{yy} f(x,y)|$</li><li>常用mask：<ul><li>$h_{4,1}=\begin{bmatrix}0&amp;1&amp;0\\1&amp;-4&amp;1\\0&amp;1&amp;0\end{bmatrix}$</li><li>$h_{4,2}=\dfrac{1}{2}\begin{bmatrix}1&amp;0&amp;1\\0&amp;-4&amp;0\\1&amp;0&amp;1\end{bmatrix}$</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_laplacian = cv2.Laplacian(img, cv2.CV_64F, ksize=<span class="number">3</span>) <span class="comment"># 拉普拉斯算子，参数越大，线条越粗</span></span><br></pre></td></tr></table></figure><h3 id="4-4-3-普瑞维特算子（Prewitt-Operator）"><a href="#4-4-3-普瑞维特算子（Prewitt-Operator）" class="headerlink" title="4.4.3.普瑞维特算子（Prewitt Operator）"></a>4.4.3.普瑞维特算子（Prewitt Operator）</h3><ul><li>近似一阶导数</li><li>常用mask:<ul><li>$h_1 = \begin{bmatrix}1&amp;1&amp;1\\0&amp;0&amp;0\\-1&amp;-1&amp;-1\end{bmatrix}$</li><li>其余通过旋转得到</li></ul></li></ul><h3 id="4-4-4-索贝尔算子（Sobel-Operator）"><a href="#4-4-4-索贝尔算子（Sobel-Operator）" class="headerlink" title="4.4.4.索贝尔算子（Sobel Operator）"></a>4.4.4.索贝尔算子（Sobel Operator）</h3><ul><li>近似一阶导数，往往用于估计水平和垂直方向的梯度</li><li>常用mask:<ul><li>$h_1 = \begin{bmatrix}-1&amp;-2&amp;-1\\0&amp;0&amp;0\\1&amp;2&amp;1\end{bmatrix}$</li><li>$h_2 = \begin{bmatrix}-1&amp;0&amp;1\\-2&amp;0&amp;2\\-1&amp;0&amp;1\end{bmatrix}$</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>) <span class="comment"># x方向梯度（竖直），ksize越大，成块的色块越大</span></span><br><span class="line">img_sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>) <span class="comment"># y方向梯度（水平）</span></span><br><span class="line">img_sobel = cv2.magnitude(img_sobelx, img_sobely) <span class="comment"># 梯度幅值</span></span><br></pre></td></tr></table></figure><h1 id="五、频率域图像增强"><a href="#五、频率域图像增强" class="headerlink" title="五、频率域图像增强"></a>五、频率域图像增强</h1><ul><li>三大类正交变换：正弦型变换、方波型变换、基于特征向量的变换</li><li>卷积：一种数学算子，施加于两个函数$f,g$，产生第三个函数。<ul><li>定义：$(f*g)(t)=\int<em>{-\infty}^{+\infty}f(\tau)g(t-\tau)d\tau=\int</em>{-\infty}^{+\infty}f(t-\tau)g(\tau)d\tau$</li></ul></li><li>频率域图像处理流程：<ul><li>$原图像f(x,y)\xrightarrow{傅里叶变换}F(u,v)\xrightarrow{H(u,v)滤波}G(u,v)\xrightarrow{傅里叶逆变换}结果图像g(x,y)$</li></ul></li></ul><h2 id="5-1-离散傅里叶变换（Discrete-Fourier-Transform，DFT）"><a href="#5-1-离散傅里叶变换（Discrete-Fourier-Transform，DFT）" class="headerlink" title="5.1.离散傅里叶变换（Discrete Fourier Transform，DFT）"></a>5.1.离散傅里叶变换（Discrete Fourier Transform，DFT）</h2><ul><li>傅里叶变换将一个信号从时间域转换到频率域，反傅里叶变换将一个信号从频率域转换到时间域。</li><li>离散傅里叶变换是正弦型变换</li></ul><h3 id="5-1-1-一维连续傅里叶变换"><a href="#5-1-1-一维连续傅里叶变换" class="headerlink" title="5.1.1.一维连续傅里叶变换"></a>5.1.1.一维连续傅里叶变换</h3><ul><li>一阶连续函数$f(x)$的傅里叶变换：$F(u)=\int_{-\infty}^{+\infty}f(x)e^{-j2\pi ux}dx$（j为虚数单位）</li><li>一阶连续函数$f(x)$的反傅里叶变换：$f(x)=\int_{-\infty}^{+\infty}F(u)e^{j2\pi ux}du$</li><li><strong>欧拉公式</strong>：$e^{j\theta}=\cos\theta+j\sin\theta$</li></ul><h3 id="5-1-2-一维离散傅里叶变换"><a href="#5-1-2-一维离散傅里叶变换" class="headerlink" title="5.1.2.一维离散傅里叶变换"></a>5.1.2.一维离散傅里叶变换</h3><ul><li>给定时间序列$x[n],n=0,1,2,\cdots,N-1$<ul><li>离散傅里叶变换为：<ul><li>$X[k]=\sum\limits_{n=0}^{N-1}x[n]e^{-j2\pi kn/N}$</li></ul></li><li>离散傅里叶逆变换为：<ul><li>$x[n]=\dfrac{1}{N}\sum\limits_{k=0}^{N-1}X[k]e^{j2\pi kn/N}$</li></ul></li></ul></li><li>以$N=4$为例，利用欧拉定理可知：<ul><li>$\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}=\begin{bmatrix}e^{-0\cdot i\pi/2}&amp;e^{-0\cdot i\pi}&amp;e^{-0\cdot i3\pi/2}&amp;e^{-0\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-1\cdot i\pi}&amp;e^{-2\cdot i3\pi/2}&amp;e^{-3\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-2\cdot i\pi}&amp;e^{-4\cdot i3\pi/2}&amp;e^{-6\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-3\cdot i\pi}&amp;e^{-6\cdot i3\pi/2}&amp;e^{-9\cdot i2\pi}\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}1&amp;1&amp;1&amp;1\\1&amp;-i&amp;-1&amp;i\\1&amp;-1&amp;1&amp;-1\\1&amp;i&amp;-1&amp;-i\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}$</li></ul></li></ul><h3 id="5-1-3-二维离散傅里叶变换"><a href="#5-1-3-二维离散傅里叶变换" class="headerlink" title="5.1.3.二维离散傅里叶变换"></a>5.1.3.二维离散傅里叶变换</h3><ul><li>对于给定的二维离散信号$f(x,y)$，$x\in[0,M-1],y\in[0,N-1]$<ul><li>二维离散傅里叶变换：<ul><li>$F(u,v)=\sum\limits<em>{x=0}^{M-1}\sum\limits</em>{y=0}^{N-1}f(x,y)e^{-j2\pi(\dfrac{ux}{M}+\dfrac{vy}{N})}$</li></ul></li><li>二维离散傅里叶逆变换：<ul><li>$f(x,y)=\dfrac{1}{\sqrt{MN}}\sum\limits<em>{u=0}^{M-1}\sum\limits</em>{v=0}^{N-1}F(u,v)exp({j2\pi(\dfrac{ux}{M}+\dfrac{vy}{N})})$</li></ul></li></ul></li><li>可分离性：傅里叶变换中的指数项可分离成只含有x,u的一项和只含有y,v的一项的乘积<ul><li>$exp(-j2\pi\dfrac{ux+vy}{N})=exp(-j2\pi\dfrac{ux}{N})\cdot exp(-j2\pi\dfrac{vy}{N})$</li><li>即$F(u,v)=\sum\limits_{x=0}^{N-1}F(x,v)exp(-j2\pi\dfrac{ux}{N})$</li><li>结论：对每个x，对行进行一次一维DFT，对每个y，对列进行一次一维DFT，可以得到二维DFT</li></ul></li><li>零频率分量与平均值<ul><li>$F(0,0)=\dfrac{1}{\sqrt{MN}}\sum\limits<em>{x=0}^{M-1}\sum\limits</em>{y=0}^{N-1}f(x,y)$</li><li>结论：$F(0,0)$与图像的平均值成正比，$k=\sqrt{MN}$</li></ul></li><li>共轭对称性<ul><li>$F(u,v)=F^*(-u,-v)$</li><li>结论：对于实数图像，其频谱是共轭对称的</li></ul></li><li>平移不变性<ul><li>空间域平移：$f(x-x_0,y-y_0)\leftrightarrow F(u,v)exp(-j2\pi\dfrac{ux_0}{M})exp(-j2\pi\dfrac{vy_0}{N})$</li><li>频率域平移：$f(x,y)exp(j2\pi\dfrac{ux_0}{M})exp(j2\pi\dfrac{vy_0}{N})\leftrightarrow F(u-u_0,v-v_0)$</li><li>结论：在空间域中平移图像，频率域只发生相移，不发生幅度变化；在频率域中平移图像，空间域只发生相移，图像幅值不变。</li></ul></li><li>周期性<ul><li>$|F(u,v)|=|F(u+M,v+N)|=|F(-u,-v)|=|F(M-u,N-v)|$</li></ul></li></ul><h3 id="5-1-4-OpenCV"><a href="#5-1-4-OpenCV" class="headerlink" title="5.1.4.OpenCV"></a>5.1.4.OpenCV</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img_dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT) <span class="comment"># 二维离散傅里叶变换</span></span><br><span class="line"><span class="comment"># flags: cv2.DFT_COMPLEX_OUTPUT（输出为复数数组）、cv2.DFT_REAL_OUTPUT（只输出实数数组）</span></span><br><span class="line">img_idft = cv2.idft(img_dft) <span class="comment"># 二维离散傅里叶逆变换，输出为复数数组</span></span><br><span class="line">img_dftshf = np.fft.fftshift(img_dft) <span class="comment"># 频谱中心化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当图像数组的大小为2的幂次方时，dft()的运算速度最快</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">new_rows = cv2.getOptimalDFTSize(rows) <span class="comment"># 获取最优行数</span></span><br><span class="line">new_cols = cv2.getOptimalDFTSize(cols) <span class="comment"># 获取最优列数</span></span><br><span class="line"></span><br><span class="line">dft_mag, dft_pol = cv2.cartToPolar(img_dft[:,:,<span class="number">0</span>], img_dft[:,:,<span class="number">1</span>]) <span class="comment"># 极坐标转换</span></span><br></pre></td></tr></table></figure><h2 id="5-2-图像的傅里叶频谱分析"><a href="#5-2-图像的傅里叶频谱分析" class="headerlink" title="5.2.图像的傅里叶频谱分析"></a>5.2.图像的傅里叶频谱分析</h2><h3 id="5-2-1-频谱图像关于-M-2-N-2-对称"><a href="#5-2-1-频谱图像关于-M-2-N-2-对称" class="headerlink" title="5.2.1.频谱图像关于$(M/2,N/2)$对称"></a>5.2.1.频谱图像关于$(M/2,N/2)$对称</h3><h3 id="5-2-2-频谱中心化前后的频谱图像"><a href="#5-2-2-频谱中心化前后的频谱图像" class="headerlink" title="5.2.2.频谱中心化前后的频谱图像"></a>5.2.2.频谱中心化前后的频谱图像</h3><ul><li>中心化前：频谱图像的原点位于左上角。低频分量位于图像的四角，高频分量位于图像的中心。</li><li>中心化后：频谱图像的原点位于中心。低频分量位于图像的中心，高频分量位于图像的四角。</li><li>由于傅里叶变换的周期性，可以将中心化前的图像组成$2\times2$的周期图像，取中心部分即为中心化后的图像。<h3 id="5-2-3-傅里叶变换的意义"><a href="#5-2-3-傅里叶变换的意义" class="headerlink" title="5.2.3.傅里叶变换的意义"></a>5.2.3.傅里叶变换的意义</h3></li></ul><ol><li>简化计算：傅里叶变换将空间域图像转换到频率域，在空间域中处理图像时用到的复杂卷积运算，等同于在频率域中进行简单的乘法运算。</li><li>用频谱图表示的频率域图像中：<ul><li>中心部位是能量集中的低频特征，反映图像的平滑部分</li><li>边缘部位是能量分散的高频特征，对应于细节、边缘、结构复杂区域、突变部位和噪声</li><li>因此，频率域中滤波的概念更直观、更易理解</li></ul></li><li>某些特定的应用需求只能在频率域进行处理，如频率域图像特征提取、数据压缩、纹理分析等</li></ol><h2 id="5-3-基于频率域滤波的图像噪声消除——频率域低通滤波"><a href="#5-3-基于频率域滤波的图像噪声消除——频率域低通滤波" class="headerlink" title="5.3.基于频率域滤波的图像噪声消除——频率域低通滤波"></a>5.3.基于频率域滤波的图像噪声消除——频率域低通滤波</h2><ul><li>图像的边缘和噪声对应于傅里叶频谱的高频成分。</li><li>低通滤波器：保留低频成分，抑制高频成分。</li><li>可以削弱噪声影响，但是会模糊边缘细节，降低图像清晰度。</li><li>与空间域平滑滤波效果类似。</li></ul><h3 id="5-3-1-理想低通滤波器"><a href="#5-3-1-理想低通滤波器" class="headerlink" title="5.3.1.理想低通滤波器"></a>5.3.1.理想低通滤波器</h3><p>设置一个截止频率$D_0$，只保留频率小于$D_0$的成分。</p><ul><li>理想低通滤波器：$H(u,v)=\begin{cases}1&amp;D(u,v)\leq D_0\\0&amp;D(u,v)&gt;D_0\end{cases}$</li><li>其中，$D(u,v)$是频率域中点$(u,v)$到中心的距离。若变换被中心化，注意调整$D(u,v)$的计算方式。</li><li>理想低通滤波器无法通过电子器件实现。</li></ul><h3 id="5-3-2-巴特沃斯低通滤波器（Butterworth-Lowpass-Filter）"><a href="#5-3-2-巴特沃斯低通滤波器（Butterworth-Lowpass-Filter）" class="headerlink" title="5.3.2.巴特沃斯低通滤波器（Butterworth Lowpass Filter）"></a>5.3.2.巴特沃斯低通滤波器（Butterworth Lowpass Filter）</h3><ul><li>n阶巴特沃斯低通滤波器：$H(u,v)=\dfrac{1}{1+[D(u,v)/D_0]^{2n}}$</li><li>巴特沃斯低通滤波器能够物理实现。</li></ul><h3 id="5-4-3-其他低通滤波器"><a href="#5-4-3-其他低通滤波器" class="headerlink" title="5.4.3.其他低通滤波器"></a>5.4.3.其他低通滤波器</h3><ul><li>梯形低通滤波器</li><li>n指数型低通滤波器</li></ul><h2 id="5-4-基于频率域滤波的图像增强——频率域高通滤波"><a href="#5-4-基于频率域滤波的图像增强——频率域高通滤波" class="headerlink" title="5.4.基于频率域滤波的图像增强——频率域高通滤波"></a>5.4.基于频率域滤波的图像增强——频率域高通滤波</h2><ul><li>图像的边缘和细节对应于傅里叶频谱的高频成分。</li><li>高通滤波器：保留高频成分，抑制低频成分。</li></ul><h3 id="5-4-1-理想高通滤波器"><a href="#5-4-1-理想高通滤波器" class="headerlink" title="5.4.1.理想高通滤波器"></a>5.4.1.理想高通滤波器</h3><p>与理想低通滤波器相反，只保留频率大于$D_0$的成分。</p><ul><li>理想高通滤波器：$H(u,v)=\begin{cases}1&amp;D(u,v)&gt;D_0\\0&amp;D(u,v)\leq D_0\end{cases}$</li></ul><h3 id="5-4-2-巴特沃斯高通滤波器（Butterworth-Highpass-Filter）"><a href="#5-4-2-巴特沃斯高通滤波器（Butterworth-Highpass-Filter）" class="headerlink" title="5.4.2.巴特沃斯高通滤波器（Butterworth Highpass Filter）"></a>5.4.2.巴特沃斯高通滤波器（Butterworth Highpass Filter）</h3><ul><li>n阶巴特沃斯高通滤波器：$H(u,v)=1-\dfrac{1}{1+[D_0/D(u,v)]^{2n}}$</li></ul><h3 id="5-4-3-高频增强滤波器"><a href="#5-4-3-高频增强滤波器" class="headerlink" title="5.4.3.高频增强滤波器"></a>5.4.3.高频增强滤波器</h3><ul><li>高通滤波会滤除低频成分，导致整体形象变暗。</li><li>高频增强滤波器：$H_e(u,v)=kH(u,v)+c$<ul><li>$k&gt;1$：增强高频成分</li><li>$c$：适当保留低频成分</li></ul></li></ul><h2 id="5-5-带通滤波和带阻滤波"><a href="#5-5-带通滤波和带阻滤波" class="headerlink" title="5.5.带通滤波和带阻滤波"></a>5.5.带通滤波和带阻滤波</h2><ul><li>带通滤波：只保留频率在两个截止频率之间的成分。</li><li>带阻滤波：只保留频率在两个截止频率之外的成分。</li></ul><h2 id="5-6-习题"><a href="#5-6-习题" class="headerlink" title="5.6.习题"></a>5.6.习题</h2><ol><li>空间域图像和模板之间的运算是一种卷积运算。由卷积定理，空域的卷积可以通过频域中图像的傅立叶变换和模板的傅立叶变换间的乘积运算来实现。所以，对频域中的转移函数求傅立叶反变换即可得到用于空域卷积的模板。</li></ol><h1 id="七、图像压缩编码"><a href="#七、图像压缩编码" class="headerlink" title="七、图像压缩编码"></a>七、图像压缩编码</h1><h2 id="7-1-离散余弦变换（Discrete-Cosine-Transform，DCT）"><a href="#7-1-离散余弦变换（Discrete-Cosine-Transform，DCT）" class="headerlink" title="7.1.离散余弦变换（Discrete Cosine Transform，DCT）"></a>7.1.离散余弦变换（Discrete Cosine Transform，DCT）</h2><ul><li>DCT变换避免了复数运算。若图像矩阵是实数矩阵，则DCT变换后的矩阵也是实数矩阵。</li><li>DCT是一种正交变换，变换矩阵是正交矩阵，变换核是可分离的。</li><li>DCT有快速算法。</li><li>DCT具有更强的信息集中能力。</li></ul><h3 id="7-1-1-一维离散余弦变换"><a href="#7-1-1-一维离散余弦变换" class="headerlink" title="7.1.1.一维离散余弦变换"></a>7.1.1.一维离散余弦变换</h3><ul><li>给定长度为N的一维信号$x[n],n=0,1,2,\cdots,N-1$<ul><li>一种常用的1D-DCT形式：$X[u]=a(u)\sum\limits_{m=0}^{N-1}x[m]cos(\dfrac{(2m+1)u\pi}{2N})$，其中$a(u)=\begin{cases}\sqrt{\dfrac{1}{N}}&amp;u=0\\\sqrt{\dfrac{2}{N}}&amp;u&gt;0\end{cases}$</li></ul></li><li>以$N=4$为例<ul><li>1D-DCT：$\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}=\begin{bmatrix}0.5&amp;0.5&amp;0.5&amp;0.5\\0.65&amp;0.27&amp;-0.27&amp;-0.65\\0.5&amp;-0.5&amp;-0.5&amp;0.5\\0.27&amp;-0.65&amp;0.65&amp;-0.27\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}$</li><li>1D-IDCT：$\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}0.5&amp;0.65&amp;0.5&amp;0.27\\0.5&amp;0.27&amp;-0.5&amp;-0.65\\0.5&amp;-0.27&amp;-0.5&amp;0.65\\0.5&amp;-0.65&amp;0.5&amp;-0.27\end{bmatrix}\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}$</li></ul></li></ul><h3 id="7-1-2-二维离散余弦变换"><a href="#7-1-2-二维离散余弦变换" class="headerlink" title="7.1.2.二维离散余弦变换"></a>7.1.2.二维离散余弦变换</h3><ul><li>给定二维信号$x[m,n],m=0,1,2,\cdots,M-1,n=0,1,2,\cdots,N-1$<ul><li>2D-DCT：<ul><li>$C(u,v)=a(u)a(v)\sum\limits<em>{m=0}^{M-1}\sum\limits</em>{n=0}^{N-1}f(x,y)cos(\dfrac{(2x+1)u\pi}{2M})cos(\dfrac{(2y+1)v\pi}{2N})$</li></ul></li><li>2D-IDCT：<ul><li>$f(x,y)=\sum\limits<em>{u=0}^{M-1}\sum\limits</em>{v=0}^{N-1}a(u)a(v)C(u,v)cos(\dfrac{(2x+1)u\pi}{2M})cos(\dfrac{(2y+1)v\pi}{2N})$</li></ul></li><li>其中，$a(u)=\begin{cases}\sqrt{\dfrac{1}{N}}&amp;u=0\\\sqrt{\dfrac{2}{N}}&amp;u&gt;0\end{cases}$</li></ul></li></ul><h3 id="7-1-3-OpenCV"><a href="#7-1-3-OpenCV" class="headerlink" title="7.1.3.OpenCV"></a>7.1.3.OpenCV</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img_dct = cv2.dct(img.astype(np.float32)) <span class="comment"># 二维离散余弦变换</span></span><br><span class="line">img_idct = cv2.idct(img_dct) <span class="comment"># 二维离散余弦逆变换</span></span><br></pre></td></tr></table></figure><h2 id="7-2-数字图像压缩编码基础"><a href="#7-2-数字图像压缩编码基础" class="headerlink" title="7.2.数字图像压缩编码基础"></a>7.2.数字图像压缩编码基础</h2><h3 id="7-2-1-信息冗余"><a href="#7-2-1-信息冗余" class="headerlink" title="7.2.1.信息冗余"></a>7.2.1.信息冗余</h3><ul><li>图像压缩的原理<ul><li>图像信号存在大量的冗余</li><li>人眼对图像的感知有限，可以以一定失真为代价换取数据量减少</li></ul></li><li>压缩率：$压缩率=\dfrac{原始数据量}{压缩后数据量}$</li><li>信息冗余<ul><li>空间冗余：相邻像素之间具有相关性</li><li>时间冗余：视频序列中相邻帧之间具有相关性</li><li>编码冗余：由编码方式导致的冗余</li><li>心理-视觉冗余：人眼对图像的感知有限，某些信息不重要</li></ul></li><li>图像质量的主观评价：人的主观感受，如图像的清晰度、色彩、对比度等。</li><li>图像质量的客观评价：信噪比（SNR）、峰值信噪比（PSNR）、均方误差（MSE）等。</li></ul><h3 id="7-2-2-图像质量的客观评价"><a href="#7-2-2-图像质量的客观评价" class="headerlink" title="7.2.2.图像质量的客观评价"></a>7.2.2.图像质量的客观评价</h3><p>原始图像$f$，压缩后的图像$g$，图像大小为$M\times N$</p><h4 id="7-2-2-1-均方误差（Mean-Square-Error，MSE）"><a href="#7-2-2-1-均方误差（Mean-Square-Error，MSE）" class="headerlink" title="7.2.2.1.均方误差（Mean Square Error，MSE）"></a>7.2.2.1.均方误差（Mean Square Error，MSE）</h4><ul><li>$MSE=\dfrac{1}{MN}\sum\limits<em>{x=0}^{M-1}\sum\limits</em>{y=0}^{N-1}[f(x,y)-g(x,y)]^2$</li></ul><h4 id="7-2-2-2-信噪比（Signal-to-Noise-Ratio，SNR）"><a href="#7-2-2-2-信噪比（Signal-to-Noise-Ratio，SNR）" class="headerlink" title="7.2.2.2.信噪比（Signal-to-Noise Ratio，SNR）"></a>7.2.2.2.信噪比（Signal-to-Noise Ratio，SNR）</h4><ul><li>$SNR=10\log_{10}\dfrac{\sigma^2}{MSE}$</li><li>其中$\sigma^2=\dfrac{1}{MN}\sum\limits<em>{x=0}^{M-1}\sum\limits</em>{y=0}^{N-1}f^2(x,y)$（原始图像的平方平均）</li></ul><h4 id="7-2-2-3-峰值信噪比（Peak-Signal-to-Noise-Ratio，PSNR）"><a href="#7-2-2-3-峰值信噪比（Peak-Signal-to-Noise-Ratio，PSNR）" class="headerlink" title="7.2.2.3.峰值信噪比（Peak Signal-to-Noise Ratio，PSNR）"></a>7.2.2.3.峰值信噪比（Peak Signal-to-Noise Ratio，PSNR）</h4><ul><li>$PSNR=10\log_{10}\dfrac{max(I)^2}{MSE}$</li><li>通常$max(I)=L-1$</li></ul><h2 id="7-3-图像压缩编码"><a href="#7-3-图像压缩编码" class="headerlink" title="7.3.图像压缩编码"></a>7.3.图像压缩编码</h2><ul><li>图像压缩编码处理流程：$f(x,y)\xrightarrow{信源编码器}\xrightarrow{信道编码器}信道传输\xrightarrow{信道解码器}\xrightarrow{信源解码器}g(x,y)$</li><li>信源编码：通过减少冗余来压缩数据的过程。<ul><li>信源编码器模型：$f(x,y)\rightarrow映射变换器\rightarrow量化器\rightarrow符号编码器\rightarrow 信道$</li><li>信源解码器模型：$信道\rightarrow符号解码器\rightarrow反量化器\rightarrow反向映射变换器\rightarrow g(x,y)$</li></ul></li><li>信道编码：也称差错控制编码，是一种在发送端给原数据添加与原数据相关的冗余信息，以便在接收端检测和纠正错误的编码方式。用于对抗传输过程中的噪声干扰。<ul><li>汉明码、循环冗余校验码（CRC）</li></ul></li></ul><h3 id="7-3-1-信息量与信息熵"><a href="#7-3-1-信息量与信息熵" class="headerlink" title="7.3.1.信息量与信息熵"></a>7.3.1.信息量与信息熵</h3><ul><li>事件提供的信息量：$I(x)=-\log_2P(x)$</li><li>信源：$X,x_i=p_i$，$x_i$发生的概率为$p_i$</li><li>信源熵：$H(X)=-\sum\limits_{i=1}^n p_i\log_2p_i$（比特/符号）<ul><li>信源的平均信息量，即信源发出一个符号所携带的平均信息量</li><li>非负，在所有事件概率均等时，熵最大</li></ul></li></ul><h3 id="7-3-2-编码"><a href="#7-3-2-编码" class="headerlink" title="7.3.2.编码"></a>7.3.2.编码</h3><ul><li>编码：由信源消息集到码字集的映射</li><li>根据长度是否相等分为：等长码和变长码</li><li>香农定理：无干扰下，平均码长的下限为信源熵</li><li>压缩比：$压缩比C=\dfrac{信源的平均比特率n}{编码后平均码长n_d}$</li><li>最大压缩比：$C_{max}=\dfrac{n}{H(X)}$</li></ul><h3 id="7-3-3-哈夫曼编码"><a href="#7-3-3-哈夫曼编码" class="headerlink" title="7.3.3.哈夫曼编码"></a>7.3.3.哈夫曼编码</h3><ul><li>带权路径长度（WPL）：$WPL=\sum\limits_{i=1}^n p_i l_i$</li><li>算法：<ul><li>每次选取权重最小的两个节点，合并到一个新的节点，新节点的权重为两个节点的权重之和</li><li>直到所有节点合并到一起，最终得到一棵树</li><li>每个叶子节点代表一个源符号，从根节点到叶子节点的路径上的编码即为哈夫曼编码</li></ul></li></ul><h3 id="7-3-4-算术编码"><a href="#7-3-4-算术编码" class="headerlink" title="7.3.4.算术编码"></a>7.3.4.算术编码</h3><ul><li>根据权重分配概率</li><li>符号序列映射为$[0,1)$的一个子区间</li><li>设$a:30\%,b:70\%$，则$a=[0,0.3),b=[0.3,1),aa=[0,0.09),ab=[0.09,0.3),ba=[0.3,0.51),bb=[0.51,1)$</li></ul><h2 id="7-4-位平面编码"><a href="#7-4-位平面编码" class="headerlink" title="7.4.位平面编码"></a>7.4.位平面编码</h2><ul><li>位平面分解：一幅$m$比特表示灰度的图像，可以看作$m$个二值图像序列</li><li>在位平面中存在大量具有相同值的区域，可以利用连续的0和1进行高效的压缩编码和传输</li></ul><h3 id="7-4-1-格雷码分解编码"><a href="#7-4-1-格雷码分解编码" class="headerlink" title="7.4.1.格雷码分解编码"></a>7.4.1.格雷码分解编码</h3><ul><li>格雷码：相邻两个数的二进制码只有一位不同</li><li>设源图像中像素灰度值原$m$位为$x<em>{m-1}\cdots x_1x_0$，则有：$\begin{cases}g_i=x_i\oplus x</em>{i-1}\\g<em>{m-1}=x</em>{m-1}\end{cases}$</li><li>这种方式保证了相邻像素的格雷码值只有一位不同，在位平面上的连续0和1的序列更多，有利于压缩编码</li></ul><h2 id="7-5-游程编码-行程编码"><a href="#7-5-游程编码-行程编码" class="headerlink" title="7.5.游程编码/行程编码"></a>7.5.游程编码/行程编码</h2><ul><li>适用于连续的0和1较多的序列</li><li>缺点：对于交替的0和1，效果不好甚至会增加编码长度</li></ul><h3 id="7-5-1-基本思想"><a href="#7-5-1-基本思想" class="headerlink" title="7.5.1.基本思想"></a>7.5.1.基本思想</h3><ul><li>对于连续的原符号，用一个符号和一个计数值来表示</li><li>如：$aaaaabbbcccc\rightarrow a5b3c4$</li></ul><h3 id="7-5-2-表0的游程编码"><a href="#7-5-2-表0的游程编码" class="headerlink" title="7.5.2.表0的游程编码"></a>7.5.2.表0的游程编码</h3><ul><li>用一个$k$位二进制数表示相邻两个$1$之间$0$的个数</li><li>如：$0(14)10(9)110(20)10(30)110(11)1（括号内为连续0的数量）\rightarrow 1110(14),1001(9),0000(0),1111 0101(15+5=20),1111 1111(15+15=30),0000(0),1011(11),0000(0)（括号内为二进制表示数的含义）$</li></ul><h3 id="7-5-3-国际传真标准CCITT-T-4-G3"><a href="#7-5-3-国际传真标准CCITT-T-4-G3" class="headerlink" title="7.5.3.国际传真标准CCITT T.4(G3)"></a>7.5.3.国际传真标准CCITT T.4(G3)</h3><ul><li>采用了霍夫曼编码和游程编码相结合的方法，对每种白长码字和黑长码字进行霍夫曼编码。</li><li>每一行总是以白长开始，允许为0；以唯一行尾（EOL）码字结束。</li></ul><h2 id="7-6-变换编码"><a href="#7-6-变换编码" class="headerlink" title="7.6.变换编码"></a>7.6.变换编码</h2><h1 id="九、图像分割"><a href="#九、图像分割" class="headerlink" title="九、图像分割"></a>九、图像分割</h1><h2 id="9-1-图像分割的基本概念"><a href="#9-1-图像分割的基本概念" class="headerlink" title="9.1.图像分割的基本概念"></a>9.1.图像分割的基本概念</h2><ul><li>图像分割：依据图像的灰度、颜色、纹理、边缘等特征，把图像分成各自满足某种特征的连通区域的集合。</li><li>特征：灰度、颜色、纹理、形状、边缘轮廓等</li></ul><h2 id="9-2-基于边缘检测的图像分割——哈夫变换（Hough-Transform）"><a href="#9-2-基于边缘检测的图像分割——哈夫变换（Hough-Transform）" class="headerlink" title="9.2.基于边缘检测的图像分割——哈夫变换（Hough Transform）"></a>9.2.基于边缘检测的图像分割——哈夫变换（Hough Transform）</h2><ul><li>边缘：具有不同灰度的区域的边界</li><li>常用算子：Roberts、Sobel、Prewitt、Laplacian、Canny</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edge = cv2.Canny(img, <span class="number">80</span>, <span class="number">240</span>) <span class="comment"># Canny边缘检测，建议参数3是参数2的3倍</span></span><br></pre></td></tr></table></figure><ul><li>哈夫变换：用于在数字图像中检测直线、圆等形状特征</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lines = cv2.HoughLinesP(image, rho, theta, threshold, lines=<span class="literal">None</span>, minLineLength=<span class="literal">None</span>, maxLineGap=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 1. image--输入，必须是二值图像，推荐以canny边缘检测结果作为输入;</span></span><br><span class="line"><span class="comment"># 2. rho--线段以像素为单位的距离精度，double类型，推荐值1.0;</span></span><br><span class="line"><span class="comment"># 3. theta--线段以弧度为单位的角度精度，推荐值numpy.pi/180；</span></span><br><span class="line"><span class="comment"># 4. threshlod--累加平面的阈值参数,int类型， 超过阈值才被检测出线段, 值越大, 意味着检出的线段越长, 检出的线段个数越少</span></span><br><span class="line"><span class="comment"># 5. minLineLength--线段以像素为单位的最小，需根据具体场景设定；</span></span><br><span class="line"><span class="comment"># 6. maxLineGap--同一方向上两条线段判定为一条线段的最大允，值越大则同一方向上允许的断裂越大；</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1, y1, x2, y2 = line[<span class="number">0</span>] <span class="comment"># 线段的两个端点</span></span><br><span class="line">    cv2.line(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment"># 画线</span></span><br><span class="line"></span><br><span class="line">circles = cv2.HoughCircles(image, method, dp, minDist, param1, param2, minRadius, maxRadius)</span><br><span class="line"><span class="comment"># 1. image: 输入的灰度图像</span></span><br><span class="line"><span class="comment"># 2. method: 检测方法，可为cv2.HOUGH_GRADIENT（梯度法霍夫圆检测）、cv2.HOUGH_GRADIENT_ALT（另一种梯度法）</span></span><br><span class="line"><span class="comment"># 3. dp: 文档上写的是图像分辨率与累加器分辨率的比值，通常为1</span></span><br><span class="line"><span class="comment"># 4. minDist：圆心之间最小距离，如果距离太小，会产生很多相交的圆</span></span><br><span class="line"><span class="comment"># 5. param1：canny检测的双阈值中的高阈值，低阈值是它的一半</span></span><br><span class="line"><span class="comment"># 6. param2：最小投票数（基于圆心的投票数）</span></span><br></pre></td></tr></table></figure><h2 id="9-3-基于阈值的图像分割方法"><a href="#9-3-基于阈值的图像分割方法" class="headerlink" title="9.3.基于阈值的图像分割方法"></a>9.3.基于阈值的图像分割方法</h2><p>提取物体与背景在灰度上的差异，将图像分为具有不同灰度级目标区域和背景区域</p><h3 id="9-3-1-基于单一阈值的图像分割"><a href="#9-3-1-基于单一阈值的图像分割" class="headerlink" title="9.3.1.基于单一阈值的图像分割"></a>9.3.1.基于单一阈值的图像分割</h3><ul><li>找到一个介于目标和背景灰度之间的阈值$T$，将图像分为两部分</li><li>$m(x,y)=\begin{cases}1&amp;f(x,y)&gt;T\\0&amp;f(x,y)\leq T\end{cases}$</li></ul><h3 id="9-3-2-一种阈值确定方法的步骤"><a href="#9-3-2-一种阈值确定方法的步骤" class="headerlink" title="9.3.2. 一种阈值确定方法的步骤"></a>9.3.2. 一种阈值确定方法的步骤</h3><ol><li>选择一个初始估计值$T_0$</li><li>以$T_0$进行图像分割，计算两个像素集合各自的平均灰度值$M_1$和$M_2$</li><li>计算新的阈值$T_1=\dfrac{M_1+M_2}{2}$</li></ol><h3 id="9-3-3-自适应阈值"><a href="#9-3-3-自适应阈值" class="headerlink" title="9.3.3.自适应阈值"></a>9.3.3.自适应阈值</h3><p>将图像分为$N\times N$个小区域，对每个小区域分别计算一个阈值</p><h2 id="9-4-基于区域的图像分割方法"><a href="#9-4-基于区域的图像分割方法" class="headerlink" title="9.4.基于区域的图像分割方法"></a>9.4.基于区域的图像分割方法</h2><p>根据图像的灰度、颜色、纹理和图像像素统计特征的均匀性等图像的空间局部特征，将图像中的像素划归到各个物体或区域中。</p><h3 id="9-4-1-区域生长法"><a href="#9-4-1-区域生长法" class="headerlink" title="9.4.1.区域生长法"></a>9.4.1.区域生长法</h3><ul><li>根据事先定义的相似性准则，将具有相似性质的像素点合并成一个区域</li><li>步骤：<ol><li>选择和确定一组能够正确代表所需区域的种子<ul><li>原则：接近聚类中心的像素/红外图像目标检测中最亮的像素/按位置要求/根据经验</li></ul></li><li>确定在生长过程中合并相邻像素的相似性原则<ul><li>颜色（彩色图像）/灰度值差/和已知区域构成某种形状或尺寸</li></ul></li><li>确定终止生长过程的条件或规则<ul><li>一般：没有满足合并条件的像素</li><li>其他：区域大小、灰度差、形状等触发一定条件</li></ul></li><li>从种子像素开始，逐步合并相邻像素，直到满足终止条件</li></ol></li></ul><h3 id="9-4-2-分裂合并法"><a href="#9-4-2-分裂合并法" class="headerlink" title="9.4.2.分裂合并法"></a>9.4.2.分裂合并法</h3><ul><li>从整幅图像开始，根据图像中区域间某种不一致性，逐步分裂成更小的区域；再根据相邻子区域的某种一致性准则，逐步合并。</li><li>图像四叉树表示法：<img src="https://source.cclmsy.cc/Images/Posts/IP/IP05.png" alt=""></li><li>步骤：<ol><li>对初始图像$R_0$进行一次四分裂得到四个子区域$R_1,R_2,R_3,R_4$</li><li>对于所有图像$R_i$进行检测，若满足分裂规则（$P(R_i)=TRUE$），则对该区域进行四分裂</li><li>对于所有图像$R_i$进行检测，若相邻区域满足合并规则（$M(R_i,R_j)=TRUE$），则合并这两个区域</li><li>重复步骤2和3，直到不再有区域满足分裂或合并规则</li></ol></li></ul><h1 id="十二、形态学图像处理"><a href="#十二、形态学图像处理" class="headerlink" title="十二、形态学图像处理"></a>十二、形态学图像处理</h1><h2 id="12-1-二值形态学的基本运算"><a href="#12-1-二值形态学的基本运算" class="headerlink" title="12.1.二值形态学的基本运算"></a>12.1.二值形态学的基本运算</h2><h3 id="12-1-1-膨胀运算"><a href="#12-1-1-膨胀运算" class="headerlink" title="12.1.1.膨胀运算"></a>12.1.1.膨胀运算</h3><p>$A\oplus B={x|(\hat{B})_y\cap A\neq\emptyset}$</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP07.png" alt=""></p><p>计算过程：<br>创建一个与原图像$A$形状同的全0图像$G$。<br>对于原图像$A$中的每一个1所在的像素，将结构元素$B$的原点放在该位置，将$B$中的1对应的位置在$G$中置1。</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP10.png" alt=""></p><ul><li>图$G$中：白0表示原来是1新图像是0；灰1表示原来是1新图像还是1；黑2表示原来是0，新图像是1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">1</span>), np.uint8) <span class="comment"># 5x1的结构元素</span></span><br><span class="line">img_dilate = cv2.dilate(img, kernel, iterations=<span class="number">1</span>) <span class="comment"># 膨胀运算</span></span><br></pre></td></tr></table></figure><h3 id="12-1-2-腐蚀运算"><a href="#12-1-2-腐蚀运算" class="headerlink" title="12.1.2.腐蚀运算"></a>12.1.2.腐蚀运算</h3><p>$A\ominus B={x|(\hat{B})_y\subseteq A}$</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP06.png" alt=""></p><p>计算过程：<br>创建一个与原图像$A$形状同的全0图像$G$。<br>对于原图像$A$中的每一个1所在的像素，将结构元素$B$的原点放在该位置。<br>若$B$中的1对应的位置在$A$中都是1，则将$G$中该位置置1；<br>否则，$G$中该位置为0。</p><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP11.png" alt=""></p><ul><li>图$G$中：白0表示原来是1新图像是0；灰1表示原来是1新图像还是1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">3</span>,<span class="number">1</span>), np.uint8) <span class="comment"># 3x1的结构元素</span></span><br><span class="line">img_dilate = cv2.dilate(img, kernel, iterations=<span class="number">1</span>) <span class="comment"># 膨胀运算</span></span><br></pre></td></tr></table></figure><h3 id="12-1-3-开运算"><a href="#12-1-3-开运算" class="headerlink" title="12.1.3.开运算"></a>12.1.3.开运算</h3><ul><li>先腐蚀后膨胀</li><li>$A\circ B=(A\ominus B)\oplus B$</li><li>能够消除外部噪点，平滑轮廓</li></ul><h3 id="12-1-4-闭运算"><a href="#12-1-4-闭运算" class="headerlink" title="12.1.4.闭运算"></a>12.1.4.闭运算</h3><ul><li>先膨胀后腐蚀</li><li>$A\bullet B=(A\oplus B)\ominus B$</li><li>能够消除内部噪点，保持物体的面积和形状</li></ul><h3 id="12-1-5-四种基本运算的性质"><a href="#12-1-5-四种基本运算的性质" class="headerlink" title="12.1.5.四种基本运算的性质"></a>12.1.5.四种基本运算的性质</h3><p>单调性、扩展性、交换性、结合性、平移不变性</p><h2 id="12-2-二值图像的形态学处理"><a href="#12-2-二值图像的形态学处理" class="headerlink" title="12.2.二值图像的形态学处理"></a>12.2.二值图像的形态学处理</h2><h3 id="12-2-1-形态滤波"><a href="#12-2-1-形态滤波" class="headerlink" title="12.2.1.形态滤波"></a>12.2.1.形态滤波</h3><p>形态滤波器：先开后闭/先闭后开</p><h3 id="12-2-2-边界提取"><a href="#12-2-2-边界提取" class="headerlink" title="12.2.2.边界提取"></a>12.2.2.边界提取</h3><p>原图像-腐蚀图像=边界图像</p><h3 id="12-2-3-区域填充"><a href="#12-2-3-区域填充" class="headerlink" title="12.2.3.区域填充"></a>12.2.3.区域填充</h3><ol><li>先对原图像$f$取反得到$f_c$</li><li>对$f_c$进行膨胀运算，得到$f_1$</li><li>对$f_1$和$f_c$求交集，得到$f_2$</li><li>对$f_2$和$f$求并集，得到目标图像$g$</li></ol><h3 id="12-2-4-骨架提取"><a href="#12-2-4-骨架提取" class="headerlink" title="12.2.4.骨架提取"></a>12.2.4.骨架提取</h3><p>通过迭代腐蚀和差分运算，得到图像的骨架</p><h3 id="12-2-5-物体识别-击中击不中变换"><a href="#12-2-5-物体识别-击中击不中变换" class="headerlink" title="12.2.5.物体识别/击中击不中变换"></a>12.2.5.物体识别/击中击不中变换</h3><p>利用具有特定形状的结构元素，对图像进行腐蚀运算，根据内部像素的变化判断物体的形状</p><h1 id="零一、彩色图像与颜色模型"><a href="#零一、彩色图像与颜色模型" class="headerlink" title="零一、彩色图像与颜色模型"></a>零一、彩色图像与颜色模型</h1><h2 id="01-1-彩色图像的概述"><a href="#01-1-彩色图像的概述" class="headerlink" title="01.1.彩色图像的概述"></a>01.1.彩色图像的概述</h2><ol><li>颜色模型：也称作颜色空间，常见的包括：HSI、HSV、RGB、NTSC、YCbCr等</li><li>光谱分布和彩色感觉是多对一关系：为了得到某一种彩色感觉，可以用不同光谱分布的光以适当比例混合而成，参与混合的光的成分不唯一</li><li>三基色原理：合理地选取三种基本颜色，几乎自然界中所有颜色都可以用这三种颜色的适当混合来表示</li><li>彩色电视及图像处理系统的彩色显示器，都采用红绿蓝三色作为三基色</li></ol><h2 id="01-2-HSI"><a href="#01-2-HSI" class="headerlink" title="01.2.HSI"></a>01.2.HSI</h2><h3 id="01-2-1-HSI"><a href="#01-2-1-HSI" class="headerlink" title="01.2.1.HSI"></a>01.2.1.HSI</h3><ul><li>HSI模型：色调（Hue）、饱和度（Saturation）、亮度/灰度（Intensity）</li><li>色调：反映颜色的类别，决定于彩色光的光谱成分，是“质”的特征</li><li>饱和度：反映颜色的纯度，即色彩的浓淡。纯色光谱色的含量越多，饱和度越高</li><li>亮度/灰度：决定了彩色光的强度</li><li>色调和饱和度合称“色度”</li></ul><h3 id="01-2-2-HSI模型"><a href="#01-2-2-HSI模型" class="headerlink" title="01.2.2.HSI模型"></a>01.2.2.HSI模型</h3><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP09.png" alt=""></p><ul><li>HSI模型可以表示为一个纺锤体</li><li>色调$H$对应极坐标的$\rho$，饱和度$S$对应极坐标的$\theta$，亮度$I$对应垂直坐标$z$</li><li>$\theta=0,120,240$对应红、绿、蓝三原色</li><li>$I$越大，越靠近白色；$I$越小，越靠近黑色</li></ul><h3 id="01-2-3-HSI与RGB之间的转换"><a href="#01-2-3-HSI与RGB之间的转换" class="headerlink" title="01.2.3.HSI与RGB之间的转换"></a>01.2.3.HSI与RGB之间的转换</h3><ol><li>求色调$H$<ul><li>$\theta=\arccos(\dfrac{[(R-G)+(R-B)]}{2\sqrt{(R-G)^2+(R-B)(G-B)}})$</li><li>$H=\begin{cases}\theta&amp;G\geq B\\2\pi-\theta&amp;G&lt;B\end{cases}$</li></ul></li><li>求饱和度$S$<ul><li>$S=1-\dfrac{3min(R,G,B)}{R+G+B}$</li></ul></li><li>求亮度$I$<ul><li>$I=\dfrac{R+G+B}{3}$</li></ul></li></ol><h2 id="01-3-HSV"><a href="#01-3-HSV" class="headerlink" title="01.3.HSV"></a>01.3.HSV</h2><h3 id="01-3-1-HSV"><a href="#01-3-1-HSV" class="headerlink" title="01.3.1.HSV"></a>01.3.1.HSV</h3><ul><li>与HSI类似，只是计算亮度的方式不同</li><li>V：Value，表示颜色的亮度</li></ul><h3 id="01-3-2-HSV与RGB之间的转换"><a href="#01-3-2-HSV与RGB之间的转换" class="headerlink" title="01.3.2.HSV与RGB之间的转换"></a>01.3.2.HSV与RGB之间的转换</h3><ul><li>$V=\dfrac{max(R,G,B)}{255}$</li></ul><h2 id="01-4-YUV"><a href="#01-4-YUV" class="headerlink" title="01.4.YUV"></a>01.4.YUV</h2><h3 id="01-4-1-YUV"><a href="#01-4-1-YUV" class="headerlink" title="01.4.1.YUV"></a>01.4.1.YUV</h3><ul><li>欧洲电视系统所采用的一种颜色编码</li><li>Y：亮度信号；U、V：色差信号</li></ul><h3 id="01-4-2-YUV与RGB之间的转换"><a href="#01-4-2-YUV与RGB之间的转换" class="headerlink" title="01.4.2.YUV与RGB之间的转换"></a>01.4.2.YUV与RGB之间的转换</h3><ul><li>$Y=0.299R+0.587G+0.114B$</li><li>$U=-0.147R-0.289G+0.436B$</li><li>$V=0.615R-0.515G-0.100B$</li></ul><h3 id="01-4-3-YUV的优点"><a href="#01-4-3-YUV的优点" class="headerlink" title="01.4.3.YUV的优点"></a>01.4.3.YUV的优点</h3><ul><li>采用YUV色彩空间，可以将亮度信号和色度信号分开处理，使得黑白电视机也能接收彩色信号</li><li>与RGB相比，最大的优点在于只需要占用极少的带宽，适合于传输和存储</li></ul><h2 id="01-5-YCbCr"><a href="#01-5-YCbCr" class="headerlink" title="01.5.YCbCr"></a>01.5.YCbCr</h2><h3 id="01-5-1-YCbCr"><a href="#01-5-1-YCbCr" class="headerlink" title="01.5.1.YCbCr"></a>01.5.1.YCbCr</h3><ul><li>DVD、DV摄像机、数字电视等消费类视频产品中广泛使用的一种颜色编码</li><li>Y：亮度信号；Cb：蓝色与参考值的差；Cr：红色与参考值的差</li></ul><h3 id="01-5-2-YCbCr与RGB之间的转换"><a href="#01-5-2-YCbCr与RGB之间的转换" class="headerlink" title="01.5.2.YCbCr与RGB之间的转换"></a>01.5.2.YCbCr与RGB之间的转换</h3><script type="math/tex; mode=display">\begin{bmatrix} Y\\\\Cb\\\\Cr\end{bmatrix}=\begin{bmatrix}16\\\\128\\\\128\end{bmatrix}+\begin{bmatrix}0.257&0.504&0.098\\\\-0.148&-0.291&0.439\\\\0.439&-0.368&-0.071\end{bmatrix}\begin{bmatrix}R\\\\G\\\\B\end{bmatrix}</script><h3 id="01-5-3-YCbCr与YUV的对比"><a href="#01-5-3-YCbCr与YUV的对比" class="headerlink" title="01.5.3.YCbCr与YUV的对比"></a>01.5.3.YCbCr与YUV的对比</h3><ul><li>YUV：适合于模拟电视系统</li><li>YCbCr：适合于数字系统</li></ul><h2 id="01-6-彩色图像增强"><a href="#01-6-彩色图像增强" class="headerlink" title="01.6.彩色图像增强"></a>01.6.彩色图像增强</h2><ol><li>单分量变化，亮度增强</li><li>单分量变化，饱和度增强</li><li>每个像素看作向量，以向量方式处理</li></ol><h1 id="零二、图像特征与理解"><a href="#零二、图像特征与理解" class="headerlink" title="零二、图像特征与理解"></a>零二、图像特征与理解</h1><h2 id="02-1-边界表示：链码"><a href="#02-1-边界表示：链码" class="headerlink" title="02.1.边界表示：链码"></a>02.1.边界表示：链码</h2><h3 id="02-1-1-链码"><a href="#02-1-1-链码" class="headerlink" title="02.1.1.链码"></a>02.1.1.链码</h3><ul><li>用一组数字序列来表示边界的形状</li><li>以右向为0，顺时针方向为正方向，为每个方向编码。分为：4方向链码、8方向链码</li><li>从边界最左上角的像素开始，按照逆时针方向，将边界上的像素点用链码表示</li><li>链码是一个循环序列</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP12.png" alt=""></p><ul><li>上图的链码<ul><li>4方向链码：$00333332322121110101$</li><li>8方向链码：$07666553321202$</li></ul></li></ul><h3 id="02-1-2-链码归一化"><a href="#02-1-2-链码归一化" class="headerlink" title="02.1.2.链码归一化"></a>02.1.2.链码归一化</h3><p>对链码进行循环右移，直到链码的字典序最小</p><h3 id="02-1-3-链码一阶差分"><a href="#02-1-3-链码一阶差分" class="headerlink" title="02.1.3.链码一阶差分"></a>02.1.3.链码一阶差分</h3><p>对链码进行模下差分，即$x<em>i=(x_i-x</em>{i-1}+n)\mod n$（n为链码的方向数）</p><h2 id="02-2-二值图像的几何特征"><a href="#02-2-二值图像的几何特征" class="headerlink" title="02.2.二值图像的几何特征"></a>02.2.二值图像的几何特征</h2><h3 id="02-2-1-位置"><a href="#02-2-1-位置" class="headerlink" title="02.2.1.位置"></a>02.2.1.位置</h3><p>一般以物体面积的重心表示物体的位置</p><script type="math/tex; mode=display">\begin{cases}x_c=\dfrac{1}{N}\sum\limits_{i=1}^N x_i\\\\\\\\y_c=\dfrac{1}{N}\sum\limits_{i=1}^N y_i\end{cases}</script><h3 id="02-2-2-方向"><a href="#02-2-2-方向" class="headerlink" title="02.2.2.方向"></a>02.2.2.方向</h3><ul><li>物体的方向：物体的主轴方向</li><li>确定主轴：（旋转）寻找最小外接矩形，主轴与矩形的长边平行</li></ul><h3 id="02-2-3-面积"><a href="#02-2-3-面积" class="headerlink" title="02.2.3.面积"></a>02.2.3.面积</h3><p>物体的像素个数</p><h3 id="02-2-4-周长"><a href="#02-2-4-周长" class="headerlink" title="02.2.4.周长"></a>02.2.4.周长</h3><ol><li>链码计算：$C=n_0+\sqrt{2}n_1$（$n_0$为偶数方向的个数，$n_1$为奇数方向的个数）</li><li>边界所占面积</li><li>边界的长度</li></ol><h3 id="02-2-5-形状"><a href="#02-2-5-形状" class="headerlink" title="02.2.5.形状"></a>02.2.5.形状</h3><ol><li>矩形度：$R=\dfrac{A}{A_r}$（$A$为物体面积，$A_r$为最小外接矩形的面积）</li><li>宽长比：$W=\dfrac{W_r}{L_r}$（$W_r$为最小外接矩形的宽度，$L_r$为最小外接矩形的长度）</li><li>圆形度<ol><li>周长平方与面积的比值：$\dfrac{C^2}{A}$</li><li>面积与平均半径的比值：$\dfrac{A}{\bar{r}^2}$</li></ol></li><li>偏心率</li></ol><h2 id="02-3-形状描述子"><a href="#02-3-形状描述子" class="headerlink" title="02.3.形状描述子"></a>02.3.形状描述子</h2><ul><li>傅里叶描述子</li><li>边界链码</li><li>微分链码</li></ul><h2 id="02-4-矩描述"><a href="#02-4-矩描述" class="headerlink" title="02.4.矩描述"></a>02.4.矩描述</h2><h2 id="02-5-纹理分析：灰度共生矩阵"><a href="#02-5-纹理分析：灰度共生矩阵" class="headerlink" title="02.5.纹理分析：灰度共生矩阵"></a>02.5.纹理分析：灰度共生矩阵</h2><p><img src="https://source.cclmsy.cc/Images/Posts/IP/IP13.png" alt=""></p><ul><li>数组合数量</li></ul><h1 id="考试重点"><a href="#考试重点" class="headerlink" title="考试重点"></a>考试重点</h1><ul><li><a href="#32灰度直方图">3.2 灰度直方图</a></li><li><a href="#42基于直方图的图像增强方法">4.2 基于直方图的图像增强方法</a><ul><li>直方图均衡化</li></ul></li><li><a href="#43基于空间平滑滤波的图像增强方法">4.3 基于空间平滑滤波的图像增强方法</a></li><li><a href="#44基于空间锐化滤波的图像增强方法">4.4 基于空间锐化滤波的图像增强方法</a></li><li><a href="#51离散傅里叶变换discrete-fourier-transformdft">5.1 2D-DFT</a><ul><li>2D-DFT的性质</li><li>图像的傅里叶频谱图特性分析</li></ul></li><li><a href="#71离散余弦变换discrete-cosine-transformdct">7.1 DCT</a></li><li><a href="#73图像压缩编码">7.3 图像压缩编码</a><ul><li>Huffman编码</li></ul></li><li><a href="#74位平面编码">7.4 位平面编码</a></li><li><a href="#93基于阈值的图像分割方法">9.3 基于阈值的图像分割</a></li><li><a href="#94基于区域的图像分割方法">9.5 基于区域的图像分割</a></li><li><a href="#121二值形态学的基本运算">12.2 二值形态学基本运算</a></li><li><a href="#122二值图像的形态学处理">12.2 二值图像的形态学处理</a></li></ul><h1 id="cv2-np"><a href="#cv2-np" class="headerlink" title="cv2/np"></a>cv2/np</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(filename, flag) <span class="comment"># 读取图像</span></span><br><span class="line"><span class="comment"># filename: str 图像文件名 &quot;lenna.jpg&quot;</span></span><br><span class="line"><span class="comment"># flag: int cv2.IMREAD_COLOR（默认彩色）、cv2.IMREAD_GRAYSCALE（灰度）</span></span><br><span class="line">img[:,:,] <span class="comment"># 行切片、列切片、通道（BGR）</span></span><br><span class="line">b,g,r = cv2.split(img) <span class="comment"># 分离通道 </span></span><br><span class="line">img_rgb = cv2.merge([r,g,b]) <span class="comment"># 合并通道</span></span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) <span class="comment"># 转换为灰度图</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;image&quot;</span>, img) <span class="comment"># 显示图像 </span></span><br><span class="line">cv2.waitKey() <span class="comment"># 等待键盘输入</span></span><br><span class="line">cv2.destroyAllWindows() <span class="comment"># 关闭所有窗口</span></span><br><span class="line"><span class="comment"># 求反色：255-原像素值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>,<span class="number">600</span>):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>,<span class="number">600</span>):</span><br><span class="line">         img[i,j] = [<span class="number">255</span>-img[i,j][<span class="number">0</span>],<span class="number">255</span>-img[i,j][<span class="number">1</span>],<span class="number">255</span>-img[i,j][<span class="number">2</span>]] </span><br><span class="line">img_cat = cv2.hconcat([r,g,b]) <span class="comment"># 从左到右水平拼接图像</span></span><br></pre></td></tr></table></figure><h1 id="plt"><a href="#plt" class="headerlink" title="plt"></a>plt</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">221</span>) <span class="comment"># 2行2列，第1个图</span></span><br><span class="line">plt.imshow(img) <span class="comment"># 显示图像</span></span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>) <span class="comment"># 图像标题</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴</span></span><br><span class="line"></span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>//<span class="number">8</span>], [<span class="number">0</span>, <span class="number">256</span>]) </span><br><span class="line">plt.subplot(<span class="number">222</span>) <span class="comment"># 2行2列，第2个图</span></span><br><span class="line">plt.plot(hist) <span class="comment"># 绘制hist折线图（坐标0-31）</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">223</span>) <span class="comment"># 2行2列，第3个图</span></span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>//<span class="number">8</span>, [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 绘制binwidth=8的直方图（坐标0-255）</span></span><br><span class="line"><span class="comment"># img.ravel()：将图像转换为一维数组</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一门凭实力让数字图像更糊的学科（雾）</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.cclmsy.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《计算机组成原理》笔记</title>
    <link href="https://www.cclmsy.cc/posts/Note_Principle_of_Computer.html"/>
    <id>https://www.cclmsy.cc/posts/Note_Principle_of_Computer.html</id>
    <published>2024-06-15T18:55:00.000Z</published>
    <updated>2024-06-24T02:28:17.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h1><h2 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h2><h3 id="1-1-1-计算机系统的组成"><a href="#1-1-1-计算机系统的组成" class="headerlink" title="1.1.1 计算机系统的组成"></a>1.1.1 计算机系统的组成</h3><ol><li>计算机由<strong>硬件</strong>与<strong>软件</strong>两部分组成</li><li>软件分为<strong>系统软件</strong>与<strong>应用软件</strong>两大类<ul><li>系统软件：管理整个计算机系统</li><li>应用软件：根据任务需要编制的程序</li></ul></li></ol><h3 id="1-1-2-计算机系统的层次结构"><a href="#1-1-2-计算机系统的层次结构" class="headerlink" title="1.1.2 计算机系统的层次结构"></a>1.1.2 计算机系统的层次结构</h3><div class="table-container"><table><thead><tr><th>层次</th><th>说明</th></tr></thead><tbody><tr><td>应用层</td><td>用户直接使用的软件</td></tr><tr><td>高级语言机器$M_4$</td><td>高级语言编译成汇编语言</td></tr><tr><td>汇编语言机器$M_3$</td><td>汇编语言汇编成机器语言</td></tr><tr><td>操作系统机器$M_2$</td><td>用机器语言解释操作系统</td></tr><tr><td>机器语言机器$M_1$</td><td>用微程序解释机器指令</td></tr><tr><td>微程序机器$M_0$</td><td>用硬件直接执行微指令</td></tr></tbody></table></div><p>虚拟机器：$M_4$、$M_3$、$M_2$；实际机器：$M_1$；微程序机器：$M_0$</p><ul><li>机器语言、汇编语言、高级语言的区别<ul><li>机器语言是一种用二进制代码表示的计算机语言，机器可以直接执行用机器语言编写的程序。</li><li>汇编语言是一种用助记符表示的与机器语言一一对应的语言，用汇编语言编写的程序需经过汇编后才能执行。</li><li>高级语言是一种接近人类自然语言的与计算机结构无关的语言，用高级语言编写的程序要经过解释和编译才能执行。</li></ul></li></ul><h2 id="1-2-计算机的基本组成"><a href="#1-2-计算机的基本组成" class="headerlink" title="1.2 计算机的基本组成"></a>1.2 计算机的基本组成</h2><h3 id="1-2-1-冯·诺依曼计算机的特点"><a href="#1-2-1-冯·诺依曼计算机的特点" class="headerlink" title="1.2.1 冯·诺依曼计算机的特点"></a>1.2.1 冯·诺依曼计算机的特点</h3><ol><li>核心特征：存储程序的工作方式</li><li>计算机由五大功能部件组成：运算器、控制器、存储器、输入设备、输出设备<ul><li>运算器：完成算术运算和逻辑运算</li><li>控制器：控制程序的执行</li><li>存储器：存放指令和数据</li><li>输入输出设备：与外部环境交换信息</li></ul></li><li>指令和数据用二进制代码表示<ul><li>原因：<ol><li>二进制编码的运算规则简单</li><li>制造2个稳定状态的物理器件较容易</li><li>便于使用逻辑电路实现算术运算   </li></ol></li></ul></li><li>工作原理：存储程序、程序控制<ul><li>存储程序程序控制方式：事先编写程序，再由计算机把这些程序存储起来，然后连续地、快速地执行程序，从而完成各种运算过程。</li><li>根据存储程序原理，计算机具有五大功能：数据传送、数据存储、数据处理、操作控制、操作判断</li></ul></li><li>基本工作方式：控制流驱动方式</li><li>指令和数据以同等地位存放在存储器中，可按地址寻访</li><li>指令由操作码和地址码组成</li><li>以运算器为中心</li></ol><h3 id="1-2-2-计算机的硬件框图"><a href="#1-2-2-计算机的硬件框图" class="headerlink" title="1.2.2 计算机的硬件框图"></a>1.2.2 计算机的硬件框图</h3><p>改进：以存储器为核心<br><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC02.png" alt="冯·诺依曼计算机结构VS以存储器为中心的体系结构"><br>（实线：数据传输；虚线：指令传输）<br><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC01.png" alt="冯·诺依曼体系结构VS哈弗体系结构"></p><h2 id="1-3-计算机硬件的主要技术指标"><a href="#1-3-计算机硬件的主要技术指标" class="headerlink" title="1.3 计算机硬件的主要技术指标"></a>1.3 计算机硬件的主要技术指标</h2><h3 id="1-3-1-字长"><a href="#1-3-1-字长" class="headerlink" title="1.3.1 字长"></a>1.3.1 字长</h3><ul><li>机器字长：计算机一次能处理的二进制数的位数，通常与CPU的寄存器位数有关。等于ALU位数，直接影响数据总线和存储字长的位数</li><li>指令字长：计算机指令中二进制代码的总位数。</li><li>存储字长：存储器的一个存储单元中能存放的二进制数的位数。</li><li>三者可以相当也可以不等，视不同机器而定。<h3 id="1-3-2-存储容量"><a href="#1-3-2-存储容量" class="headerlink" title="1.3.2 存储容量"></a>1.3.2 存储容量</h3></li><li>存储容量：计算机存储器中能存放的二进制数的位数</li><li>存储容量 = 主存+辅存 = 存储单元数×存储字长 （/8（字节））<h3 id="1-3-3-存储器带宽"><a href="#1-3-3-存储器带宽" class="headerlink" title="1.3.3 存储器带宽"></a>1.3.3 存储器带宽</h3></li><li>存储器带宽：存储器的数据传输速率</li><li>存储器带宽=存储字数/存储周期（字/秒）</li><li>存储字长（字长）：一个存储单元中存放的二进制数的位数</li><li>字节：8位二进制数<h3 id="1-3-4-运算速度"><a href="#1-3-4-运算速度" class="headerlink" title="1.3.4 运算速度"></a>1.3.4 运算速度</h3></li></ul><ol><li>CPI（Cycle Per Instruction）：每条指令的平均时钟周期数<ul><li>$CPI = CPU时钟周期数 \div 指令数（加权平均）$</li><li>注意平均指令周期（时间）与CPI（时钟周期数）的区别</li></ul></li><li>MIPS（Million Instructions Per Second）：每秒执行的百万条指令数<ul><li>$MIPS = \dfrac{指令条数N}{执行时间t×10^6} = \dfrac{主频f}{CPI\times 10^6}$</li></ul></li><li>主频f：CPU时钟频率；时钟周期T：CPU时钟周期</li><li>执行时间t：执行一组指令所需的时间<ul><li>$t = \dfrac{指令条数N\times CPI}{主频f}$ = $\dfrac{指令条数N}{MIPS\times 10^6}$</li></ul></li><li>每秒浮点运算次数：FLOPS（Floating Point Operations Per Second）</li></ol><h1 id="二、计算机发展史（了解）"><a href="#二、计算机发展史（了解）" class="headerlink" title="二、计算机发展史（了解）"></a>二、计算机发展史（了解）</h1><h1 id="三、系统总线"><a href="#三、系统总线" class="headerlink" title="三、系统总线"></a>三、系统总线</h1><h2 id="3-1-总线的基本概念"><a href="#3-1-总线的基本概念" class="headerlink" title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h2><h3 id="3-1-1-总线的作用"><a href="#3-1-1-总线的作用" class="headerlink" title="3.1.1 总线的作用"></a>3.1.1 总线的作用</h3><ul><li>总线：连接各个部件的信息传输线，各个部件共享的传输介质</li><li>提供信息交换时所需的数据、地址、时序和控制信息</li><li>提供一个共同遵循的协议或标准<h2 id="3-2-总线的分类（按连接部件）"><a href="#3-2-总线的分类（按连接部件）" class="headerlink" title="3.2 总线的分类（按连接部件）"></a>3.2 总线的分类（按连接部件）</h2></li></ul><ol><li>片内总线：CPU内部的总线</li><li>系统总线：CPU与其他部件之间的总线<ul><li>根据传输的信息划分：数据总线、地址总线、控制总线 </li><li>数据总线：双向，位数与机器字长相关</li><li>地址总线：单向，位数与存储单元个数相关</li><li>控制总线：双向，传输控制信息</li></ul></li><li>通信总线：连接计算机与其它系统的总线<h2 id="3-3-总线的特性与性能指标"><a href="#3-3-总线的特性与性能指标" class="headerlink" title="3.3 总线的特性与性能指标"></a>3.3 总线的特性与性能指标</h2><h3 id="3-3-1-总线的特性"><a href="#3-3-1-总线的特性" class="headerlink" title="3.3.1 总线的特性"></a>3.3.1 总线的特性</h3></li><li>机械特性（物理特性）：总线的物理连接方式（根数、插口形状）</li><li>电气特性：传输方向、有效电平范围</li><li>功能特性：根据传输的信息划分（数据、地址、控制）</li><li>时间特性：同步、异步、功能复用<h3 id="3-3-2-总线的性能指标"><a href="#3-3-2-总线的性能指标" class="headerlink" title="3.3.2 总线的性能指标"></a>3.3.2 总线的性能指标</h3></li><li>总线宽度：数据总线的位数</li><li>总线带宽：单位时间内传输的数据量（Bps：字节/秒）</li><li>总线时钟频率：总线的工作频率</li><li>总线复用</li><li>信号线数量</li><li>总线控制方式</li></ol><h2 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h2><h3 id="3-4-1-总线事务"><a href="#3-4-1-总线事务" class="headerlink" title="3.4.1 总线事务"></a>3.4.1 总线事务</h3><ol><li>总线事务：从请求总线到完成总线使用的操作序列</li><li>典型事务：存储器R/W，I/O-R/W，中断请求，DMA请求</li><li>典型事务操作：请求、仲裁、地址传输、数据传输、总线释放</li></ol><h3 id="3-4-2-单总线结构"><a href="#3-4-2-单总线结构" class="headerlink" title="3.4.2 单总线结构"></a>3.4.2 单总线结构</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC25.png" alt=""></p><ul><li>结构简单、使用方便、易扩充</li><li>统一编址、简化指令系统、存储空间减少</li><li>共享总线、分时使用、通讯速度慢</li><li>高速设备的高速性能得不到发挥</li></ul><h3 id="3-4-3-双总线结构1：增加CPU-主存的存储总线"><a href="#3-4-3-双总线结构1：增加CPU-主存的存储总线" class="headerlink" title="3.4.3 双总线结构1：增加CPU-主存的存储总线"></a>3.4.3 双总线结构1：增加CPU-主存的存储总线</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC26.png" alt=""></p><ul><li>存储总线有效的降低了系统总线的负载，提高了并行性能</li><li>需要增加专门的I/O指令，存储空间增加</li><li>结构简单、易扩充</li></ul><h3 id="3-4-4-双总线结构2：增加I-O总线"><a href="#3-4-4-双总线结构2：增加I-O总线" class="headerlink" title="3.4.4 双总线结构2：增加I/O总线"></a>3.4.4 双总线结构2：增加I/O总线</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC27.png" alt=""></p><h3 id="3-4-5-三总线结构"><a href="#3-4-5-三总线结构" class="headerlink" title="3.4.5 三总线结构"></a>3.4.5 三总线结构</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC28.png" alt=""></p><ul><li>高速与低速传输活动分离<ul><li>I/O设备与主存之间的通信和CPU活动分离</li><li>高速设备靠近CPU，低速设备远离CPU</li></ul></li><li>不同层次的总线之间采用桥接方式连接和缓冲</li></ul><h3 id="3-4-6-总线结构与设备性能之间的关系"><a href="#3-4-6-总线结构与设备性能之间的关系" class="headerlink" title="3.4.6 总线结构与设备性能之间的关系"></a>3.4.6 总线结构与设备性能之间的关系</h3><ul><li>最大存储容量：单总线系统中，内存要为外部设备预留地址</li><li>指令系统：单总线结构无需专门的I/O指令</li><li>吞吐率：三总线系统比单总线系统大得多</li></ul><h3 id="3-4-7-采用南北桥结构的奔腾机系统总线结构"><a href="#3-4-7-采用南北桥结构的奔腾机系统总线结构" class="headerlink" title="3.4.7 采用南北桥结构的奔腾机系统总线结构"></a>3.4.7 采用南北桥结构的奔腾机系统总线结构</h3><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC29.png" alt="南北桥结构"></p><ul><li>北桥靠近CPU，连接高速设备：主存、图形设备、CPU</li><li>南桥连接低速设备：I/O设备、硬盘、USB、网卡</li><li>南北桥之间通过PCI总线连接</li></ul><h2 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h2><h3 id="3-5-1-信息传送方式"><a href="#3-5-1-信息传送方式" class="headerlink" title="3.5.1 信息传送方式"></a>3.5.1 信息传送方式</h3><ol><li>串行传送<ul><li>位信息从低到高在一条传输线上逐位以脉冲方式传送</li><li>成本低、速度慢、传输距离远</li></ul></li><li>并行传送<ul><li>每位一条数据线，同时传送多位信息</li><li>速度快、传输距离短</li></ul></li><li>分时传送<ul><li>采用总线复用技术，地址数据共用</li><li>分时使用总线<h3 id="3-5-2-总线判优控制（总线仲裁）"><a href="#3-5-2-总线判优控制（总线仲裁）" class="headerlink" title="3.5.2 总线判优控制（总线仲裁）"></a>3.5.2 总线判优控制（总线仲裁）</h3></li></ul></li></ol><ul><li>总线仲裁：多个设备同时请求总线时，由总线控制器判定哪个设备优先使用总线</li><li>根据总线控制部件的位置，仲裁方式分为两类：集中式、分布式</li></ul><div class="table-container"><table><thead><tr><th>集中式仲裁</th><th>链式查询方式</th><th>计数器定时查询方式</th><th>独立请求方式</th></tr></thead><tbody><tr><td>控制线</td><td>3根：总线状态BS，总线请求BR，总线授权BG</td><td>$2+log_2n$根：总线状态BS，总线请求BR，地址计数线（$log_2n$根）</td><td>$2n$根：总线请求BR（$n$根），总线授权BG（$n$根）</td></tr><tr><td>响应速度</td><td>慢</td><td>慢</td><td>快</td></tr><tr><td>优先级</td><td>固定</td><td>可适当变化</td><td>可灵活调整</td></tr><tr><td>故障敏感性</td><td>敏感</td><td>不敏感</td><td>不敏感</td></tr><tr><td>扩展性</td><td>容易</td><td>困难</td><td>容易</td></tr></tbody></table></div><h3 id="3-5-3-总线定时"><a href="#3-5-3-总线定时" class="headerlink" title="3.5.3 总线定时"></a>3.5.3 总线定时</h3><ul><li>总线定时主要解决通信双方如何获知传输开始和传输结束，通信双方如何配合的问题</li><li>同步方式：用公共时钟信号对传输过程的每一步进行控制，适合快速设备<ul><li>无应答方式</li><li>事件时刻由总线时钟信号决定，采用公共时钟，数据传输率高</li><li>木桶效应：必须按照最慢的设备定时</li></ul></li><li>异步方式：用应答信号对传输过程进行控制。又分为非互锁、半互锁和全互锁；适合慢速设备<ul><li>不互锁<ul><li>主模块：发出请求一段时间，认为副模块收到请求，撤销请求并通信</li></ul></li><li>半互锁<ul><li>主模块：发出请求，收到副模块应答后撤销请求并通信</li><li>副模块：收到请求后应答一段时间，认为主模块收到应答，撤销应答并通信</li></ul></li><li>全互锁<ul><li>主模块：发出请求，收到副模块应答后撤销请求并通信</li><li>副模块：收到请求后应答，收到主模块撤销请求后撤销应答并通信</li></ul></li></ul></li><li>半同步方式：结合同步方式和异步方式的特点，在同步时钟的控制下进行采样和应答</li><li>分离式通信</li></ul><h2 id="3-5-4-总线通讯控制-总线传输过程"><a href="#3-5-4-总线通讯控制-总线传输过程" class="headerlink" title="3.5.4 总线通讯控制/总线传输过程"></a>3.5.4 总线通讯控制/总线传输过程</h2><ol><li>总线申请（总线仲裁）：部件提出请求，总线控制器确定将下一个总线使用权分配给谁</li><li>地址阶段（总线寻址）：主设备通过总线发出从部件的存储器地址或I/O端口地址及相关命令，启动从设备</li><li>数据传输阶段</li><li>结束阶段：主部件撤消总线请求等有关信息，总线控制器释放总线</li></ol><h2 id="3-6-例题"><a href="#3-6-例题" class="headerlink" title="3.6 例题"></a>3.6 例题</h2><ol><li>假定某总线的时钟周期为50ns,每次总线传输需要1个时钟周期，总线宽度为32位，存储器的存储周期为300ns,求同步方式下从该存储器中读一个字时总线的数据传输率为多少?<ul><li>同步方式下按顺序进行以下步骤：<ol><li>送地址和读命令：1个总线周期 = 50ns</li><li>存储器读数据：300ns</li><li>总线传输数据：1个总线周期 = 50ns</li></ol></li><li>一个字的总时间：$50+300+50=400ns$</li><li>数据传输率：$32bit/8/400ns=10MBps$</li></ul></li><li>系统总线传输的信息类型为：数据、地址、控制信号 <ul><li>握手应答信号是通信总线传输的信息类型！ </li></ul></li><li>提高同步总线数据传输速率的方法<ol><li>增加总线宽度</li><li>增加总线时钟频率</li><li>支持突发传输</li></ol><ul><li>地址/数据线复用不能提高数据传输速率</li></ul></li><li>主存通过<strong>总线类型</strong>识别地址和数据 </li></ol><h1 id="四、存储器"><a href="#四、存储器" class="headerlink" title="四、存储器"></a>四、存储器</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="4-1-1-存储器的分类"><a href="#4-1-1-存储器的分类" class="headerlink" title="4.1.1 存储器的分类"></a>4.1.1 存储器的分类</h3><ol><li>按存储介质分类<ul><li>半导体存储器（易失性：断电即失）<ul><li>TTL：高速</li><li>MOS：高集成度、低功耗、低成本、应用广泛</li></ul></li><li>磁表面存储器：磁头+磁载体</li><li>磁芯存储器：体积大、功耗大、工艺复杂</li><li>激光存储器：CD、DVD</li></ul></li><li>按存取方式分类<ul><li>物理地址和存取时间无关（随机访问）<ul><li>随机存储器（RAM） 可读可写<ul><li>SRAM（静态RAM）：速度快、价格高、集成度低</li><li>DRAM（动态RAM）：速度慢、价格低、集成度高</li></ul></li><li>只读存储器（ROM） <ul><li>M：Masked（掩模）；P：Programmable（可编程）；E：Erasable（可擦写）；EE：Electrically-Erasable（电可擦写）</li></ul></li></ul></li><li>物理地址和存取时间有关（串行访问）<ul><li>顺序存储器：磁带</li><li>直接存储器：磁盘</li></ul></li></ul></li><li>按在计算机中的作用分类<ul><li>$<br>存储器\begin{cases}<br>主存\begin{cases}<br>随机存储器（RAM）\begin{cases}<br> SRAM \\<br> DRAM<br>\end{cases} \\<br>只读存储器（ROM）\begin{cases}<br> MROM\\<br> PROM\\<br> EPROM\\<br> EEPROM<br> \end{cases}<br>\end{cases}\\<br>闪速存储器（Flash Memory）\\<br>辅助存储器\begin{cases}<br>磁盘\\<br>磁带\\<br>光盘<br>\end{cases}\\<br>缓存（Cache）<br>\end{cases}<br>$<h3 id="4-1-2-存储器的层次结构"><a href="#4-1-2-存储器的层次结构" class="headerlink" title="4.1.2 存储器的层次结构"></a>4.1.2 存储器的层次结构</h3></li></ul></li><li>存储系统的层次结构（自上到下从内到外） <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU寄存器</span><br><span class="line">缓存<span class="keyword">Cache</span>（SRAM）（内存）</span><br><span class="line">主存储器（DRAM） （内存）</span><br><span class="line">磁盘 （辅助存储器）</span><br><span class="line">磁带、光盘 （辅助存储器）</span><br></pre></td></tr></table></figure></li><li>存储器的主要特性（自上到下）<ul><li>速度：快 -&gt; 慢<ul><li>存储时间、存取周期、存储带宽</li></ul></li><li>容量：小 -&gt; 大</li><li>价格：贵 -&gt; 便宜</li></ul></li><li>存储器的层次结构的作用<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC03.png" alt="存储器的层次结构"></li><li>缓存-主存层次：解决CPU与主存之间速度不匹配的问题<ul><li>透明：对系统程序员和应用程序员屏蔽</li><li>主存储器、实地址、物理地址</li></ul></li><li>主存-辅存层次：解决存储系统的容量问题<ul><li>不透明：系统程序员可以对此层次进行修改</li><li>虚拟存储器、虚地址、逻辑地址</li></ul></li></ul></li><li>存储系统为什么采用分层体系结构？<ul><li>采用层次化存储体系的目的包括两方面：其一是解决快速的CPU和慢速的主存之间的速度差异；其二是解决主存容量不够大的问题。存储系统的分级结构由Cache、主存和辅助存储器三级结构构成。其理论基础是时间局部性原理和空间局部性原理，Cache—主存存储层次解决了主存速度不快的问题；而主存-辅存存储层次解决了主存容量不足的问题。<h2 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h2><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3></li></ul></li><li>主存的基本组成<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC05.png" alt=""></li><li>存储体：存储数据</li><li>MAR：存储器地址寄存器，保存要访问的存储单元地址<ul><li>经过译码器进行译码，选定存储单元</li></ul></li><li>MDR：存储器数据寄存器，存储要写入或读出的数据<ul><li>通过读写电路和控制电路控制数据的读写</li></ul></li></ul></li><li>主存中存储单位地址分配方式<ul><li>子地址+字节地址</li><li>大端存储（大尾存储）：<code>0x12345678</code>存储为<code>12 34 56 78</code></li><li>小端存储（小尾存储）：<code>0x12345678</code>存储为<code>78 56 34 12</code> </li><li>（小格中顺序正常，大格中顺序颠倒） 小端存储例：x86</li><li>n根地址线可按字节寻址$2^n$个字节（按字寻址按比例计算）</li></ul></li><li>主存中的数据组织和边界对齐</li></ol><ul><li>寄巧：每种数据类型的数据存储在存储器中的<strong>起始地址</strong>必须是该数据所占字节数的<strong>整数倍</strong></li></ul><ol><li>主存储器的技术指标<ol><li>字长：一个存储单元存放的二进制数的位数</li><li>存储容量：存储器中能存放的二进制数的总位数<ul><li>存储容量=存储单元数×存储字长（位）/8（字节）</li></ul></li><li>存储速度：由存取周期表示<ul><li>存取周期：连续2次存取所需的最小时间间隔</li><li>分为读周期和写周期</li></ul></li><li>存储器带宽=存储字数/存储周期（字/秒）=(存储字数*存储字长)/8/存储周期（字节/秒）</li></ol></li></ol><h3 id="4-2-2-半导体存储芯片"><a href="#4-2-2-半导体存储芯片" class="headerlink" title="4.2.2 半导体存储芯片"></a>4.2.2 半导体存储芯片</h3><ol><li>基本结构与芯片容量<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC13.png" alt="半导体存储芯片"></li><li>例：地址线10位；数据线8位</li><li>存储单元：$2^{10}$个；存储字长：8位；芯片容量：$2^{10}\times 8=1K*8位=8Kbit=1KB$</li><li>片选线CS/CE：选择芯片Chip Select/Enable</li><li>读写控制线WE/OE：读写控制Write/Output Enable</li></ul></li><li>译码驱动方式<ul><li>单译码结构：$n$位地址输入，经$n$位译码器译码，指向$2^n$个存储单元</li><li>双译码结构：将存储芯片阵列，分为行译码和列译码，指向$2^{2n}$个存储单元<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC04.png" alt="静态存储器芯片结构"></li><li>地址译码器：将二进制地址译码为存储单元的物理地址（类比3-8线译码器）</li><li>Y向驱动器：将地址译码后的列地址送到存储矩阵的列选择线<h3 id="4-2-3-随机存取存储器（RAM）"><a href="#4-2-3-随机存取存储器（RAM）" class="headerlink" title="4.2.3 随机存取存储器（RAM）"></a>4.2.3 随机存取存储器（RAM）</h3></li></ul></li></ul></li><li>SRAM（静态RAM）<ol><li>存储原理：触发器<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC06.png" alt="SRAM存储单元"></li><li>中心与GND相连的T1, T2：存储数据</li><li>中心与VCC相连的T3, T4：补充电荷</li><li>外侧的T5-T8：T5、T6行选，T7、T8列选</li></ul></li><li>SRAM芯片（以Intel 2114为例）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC14.png" alt="SRAM芯片"> </li><li>地址线：$A_{9-0}$，地址数=$2^{10}$个</li><li>数据线：$I/O_{3-0}$，数据位数=$4$位</li><li>芯片存储容量=$2^{10}\times 4bit=1K\times 4bit$</li></ul></li><li>SRAM的不足<ul><li>晶体管数量多，集成度低，功耗大  </li></ul></li></ol></li><li>DRAM（动态RAM）<ol><li>分单管式和三管式，存储原理：电容</li><li>DRAM的优点<ul><li>存储密度高，集成度高，功耗低</li><li>速度慢，需要刷新</li></ul></li><li>DRAM刷新<ol><li>刷新：DRAM存储单元中的电荷会逐渐泄漏，需要定期刷新补充</li><li>刷新周期：存储器两次完整刷新之间的时间间隔</li><li>刷新方式：集中式、分散式、异步式（假设刷新周期为2ms）<ul><li>集中式<ul><li>一个刷新间隔（2ms）：|——-R/W/维持——-|—-集中刷新n行—-|</li><li>在数据丢失之前集中刷新所有行</li><li>保持存储单体的高速特性，存在死区（死时间）</li><li>死区=存取周期*刷新行数，死时间率=死区/刷新间隔</li><li>场景：实时性要求不高</li></ul></li><li>分散式<ul><li>一个刷新间隔（小于2ms）：|R/W|刷新第0行|R/W|刷新第1行|…|R/W|刷新第n行|</li><li>存储周期=读写+刷新：各刷新周期分散安排在存取周期中</li><li>过度刷新，通常刷新间隔远小于所需最大刷新间隔，芯片性能下降</li><li><strong>不存在死区</strong></li></ul></li><li>异步式<ul><li>一个刷新间隔（2ms）：|R/W|R/W|…|R/W|刷新第0行|R/W|R/W|…|R/W|刷新第n行|</li><li>每行每隔一定时间/多次读写后刷新一次，（平均）分散在一个刷新间隔的任意部分</li><li>存在死区，但可以将刷新安排在指令译码阶段</li></ul></li></ul></li></ol></li></ol></li><li><p>SRAM与DRAM的比较</p><p>|                  | SRAM           | DRAM         |<br>| ———————— | ——————— | —————— |<br>| 存储原理         | 触发器         | 电容         |<br>| 集成度           | 低             | 高           |<br>| 刷新             | 不需要         | 需要         |<br>| 存储成本（功耗） | 高             | 低           |<br>| 速度             | 快（无需重写） | 慢（需重写） |<br>| 破坏性读出       | 非             | 是           |<br>| 送行列地址       | 同时           | 分2次        |<br>| 主要用途         | Cache高速缓存  | 主存         |</p></li></ol><h3 id="4-2-4-只读存储器（ROM）"><a href="#4-2-4-只读存储器（ROM）" class="headerlink" title="4.2.4 只读存储器（ROM）"></a>4.2.4 只读存储器（ROM）</h3><p>MROM：Masked（掩模）<br>PROM：Programmable（可编程）<br>EPROM：Erasable P（可擦写可编程）<br>EEPROM：Electrically-Erasable P（电可擦写可编程）<br>Flash Memory：闪速存储器</p><h3 id="4-2-5-主存与CPU的连接方式（不考察）"><a href="#4-2-5-主存与CPU的连接方式（不考察）" class="headerlink" title="4.2.5 主存与CPU的连接方式（不考察）"></a>4.2.5 主存与CPU的连接方式（不考察）</h3><ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC07.png" alt="主存与CPU的连接方式"></li><li>$MREQ(存储器请求)\Rightarrow CS(片选线)$</li><li>$A_{17-0}(地址线)\Rightarrow A$：存储单元数=$2^{18-10} K$个</li><li>$R/W(读写控制)\Rightarrow WE(写使能)$</li><li>$D_{31-0}(数据线)\Rightarrow D$：数据位数=$32$位<h3 id="4-2-6-存储器容量扩展（不考察）"><a href="#4-2-6-存储器容量扩展（不考察）" class="headerlink" title="4.2.6 存储器容量扩展（不考察）"></a>4.2.6 存储器容量扩展（不考察）</h3></li><li>位扩展（DBUS）：增加存储字长<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC08.png" alt="位扩展"></li><li>方法：<ul><li>MREQ、A同时连接$n$个芯片</li><li>R/W同时连接所有RAM芯片</li><li>D位数扩展到原来的$n$倍，按顺序分配给每个芯片</li></ul></li><li>特点：<ul><li>从每个芯片内部相同的地址单元中读取数据，同时读写</li><li>位扩展后的存储容量=单元数×（字长×片数）</li></ul></li></ul></li><li>字扩展（ABUS）：增加存储单元数<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC09.png" alt="字扩展"></li><li>方法：<ul><li>D同时连接$n$个芯片</li><li>R/W同时连接所有RAM芯片</li><li>MREQ连接到3-8译码器的OE</li><li>A位数增加$log_2n$，原来的部分与每一片连接，增加的部分分配给3-8译码器</li><li>3-8译码器的输出连接到$n$个芯片的CS（片选）</li></ul></li><li>特点：<ul><li>从单个芯片（组）中的地址单元中读取数据</li><li>字扩展后的存储容量=（单元数×片数）×字长</li></ul></li></ul></li><li>字位综合扩展：同时增加存储单元数和存储字长<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC10.png" alt="字位扩展"></li><li>方法：<ul><li>R/W同时连接所有RAM芯片组</li><li>D位数扩展到原来的$n$倍，连接每个芯片组</li><li>MREQ连接到3-8译码器的OE</li><li>A位数增加$log_2n$，原来的部分与每一片连接，增加的部分分配给3-8译码器</li><li>3-8译码器的输出连接到$n$个芯片的CS（片选）</li></ul></li></ul></li><li>例：存储器容量扩展<ul><li>需求：<ul><li>0x0000到3FFF为ROM存储区域</li><li>0x4000到0x5FFF为保留地址区域</li><li>0x6000到0xFFFF为RAM地址区域</li><li>RAM的控制信号为CS#和WE#，CPU地址线A15~A0，数据线D7~D0，控制信号有读写控制R/W#和访存请求MREQ#</li></ul></li><li>材料：16K×8 ROM 4K×8 RAM</li><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC11.png" alt="存储器容量扩展"></li><li>注意：<ul><li>译码器一位信号对应两片芯片时，高位地址（$A_{12}$）参与片选</li><li>译码器两位信号对应一片芯片时，信号取或传入片选</li></ul></li><li>不同区域选择芯片类型：<ul><li>系统程序区域：ROM</li><li>保留区域：无需选择</li><li>用户程序区域：RAM</li></ul></li></ul></li></ul><h3 id="4-2-7-优化主存性能的方法"><a href="#4-2-7-优化主存性能的方法" class="headerlink" title="4.2.7 优化主存性能的方法"></a>4.2.7 优化主存性能的方法</h3><ol><li>采用高速器件：SDRAM（同步DRAM）</li><li>增加Cache：采用层级结构 Cache-主存 （CDRAM）</li><li>双端口存储器<ul><li>具有两个独立的读写控制线</li><li>地址不冲突时，可并行读写</li></ul></li><li>增加字长、每个存储周期存取多个字：单体多字存储器（位扩展）<ul><li>多个单字长存储器并行工作</li><li>共用一个地址寄存器</li><li>单存储周期内访问多个存储字</li></ul></li><li>将主存分为多个模块，并行存取：多体并行存储器<ul><li>高位交叉、顺序编址（顺序方式）（字扩展）</li><li>低位交叉、轮流编址（交叉方式）<ul><li>流水线式存储：<ul><li>总线传输周期$\tau$，存储周期$T$，交叉模数$m$</li><li>流水线方式存储的条件：$T=m\tau$</li><li>连续传输n个字的时间：$T+(n-1)\tau$</li></ul></li><li>存储体数量：不小于$\dfrac{存储周期}{总线传输周期}$</li></ul></li><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC12.png" alt="多模块存储器"></li></ul></li></ol><div class="table-container"><table><thead><tr><th></th><th>高位交叉</th><th>低位交叉</th></tr></thead><tbody><tr><td>相邻数据地址</td><td>同一存储体</td><td>不同存储体</td></tr><tr><td>地址寄存器</td><td>一个</td><td>每个存储体一个</td></tr><tr><td>局部性原理</td><td>高位片选，多模块串行</td><td>低位片选，多模块并行</td></tr><tr><td>性能</td><td>无提升</td><td>提升</td></tr><tr><td>故障隔离</td><td>方便</td><td>-</td></tr><tr><td>连续读取$n$个字的时间</td><td>$nT$</td><td>$T+(n-1)\tau$</td></tr></tbody></table></div><h2 id="4-3-高速缓存存储器Cache"><a href="#4-3-高速缓存存储器Cache" class="headerlink" title="4.3 高速缓存存储器Cache"></a>4.3 高速缓存存储器Cache</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><ol><li>Cache解决的问题<ul><li>避免CPU“空等”状态</li><li>弥补CPU与主存的速度差异</li></ul></li><li>程序访问的局部性原理<ul><li>时间局部性：刚访问过的数据很可能马上再次访问</li><li>空间局部性：刚访问过的数据附近的数据很可能马上访问</li><li>优化手段：调度算法（时间局部性）；预读优化（空间局部性）</li></ul></li><li>Cache的工作原理<ul><li>主存地址：n位=m位主存块号+b位块内地址（字地址）</li><li>Cache地址：c位Cache块号+b位块内地址（c &lt;&lt; m）</li><li>按块存储，块大小相同</li><li>命中（HIT）：Cache中有所需数据</li><li>缺失（MISS）：Cache中无所需数据，需要从主存中读取</li><li>标记记录某缓存块对应的主存块号</li></ul></li><li>命中率、访问时间、访问效率<ul><li>记$N$为访问次数，$N_c$为命中次数，$N_m$为缺失次数（访问主存次数）；$t_c$为Cache存取时间，$t_m$为主存存取时间</li><li>命中率：$h=\dfrac{N_c}{N}$ / 缺失率：$1-h$</li><li>平均访问时间：$t_{avg}=ht_c+(1-h)t_m$</li><li>访问效率：$E=\dfrac{t<em>c}{t</em>{avg}}$</li></ul></li><li>关键技术<ul><li>数据查找、地址映射、替换策略、写入策略</li></ul></li><li>Cache的读操作<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC15.png" alt="Cache的读操作"></li></ul></li><li>Cache的写操作<ul><li>写穿法（Write Through）：写Cache同时写主存<ul><li>优点：维持了主存和Cache的数据一致性</li><li>缺点：写主存次数多，在连续多次更新同一数据时效率低</li></ul></li><li>写回法（Write Back）：只写Cache，标记为脏，被替换时才写回主存<ul><li>优点：减少了写主存次数，提高了效率</li><li>缺点：需要额外的标记位和判断，增加了Cache复杂度</li></ul></li></ul></li><li>Cache的改进<ul><li>增加Cache级数（CPU片内、片外）</li><li>统一Cache（指令、数据共用）和分立Cache（指令、数据分开）</li></ul></li></ol><h3 id="4-3-2-Cache-主存地址映射"><a href="#4-3-2-Cache-主存地址映射" class="headerlink" title="4.3.2 Cache-主存地址映射"></a>4.3.2 Cache-主存地址映射</h3><ol><li>直接映射<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC16.png" alt="直接映射"></li><li>根据Cache块数对主存块号取模，只能存放在对应模数的位置</li><li>主存地址n位=t位标记位+c位Cache块号+b位块内地址（t+c=m）</li></ul></li><li>全相联映射（主存容量大考虑采用）<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC17.png" alt="全相联映射"></li><li>任意主存块可以存放在任意Cache块中</li><li>主存地址n位=m位标记位+b位块内地址</li></ul></li><li>组相联映射<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC18.png" alt="组相联映射"></li><li>组间直接映射，组内全相联映射，先分组</li><li>组数$2^q$，组内Cache块数$2^r$，$q+r=c$</li><li>主存地址n位=(t+r)位标记位+q(c-r)位组号+b位块内地址</li></ul></li></ol><div class="table-container"><table><thead><tr><th></th><th>直接映射</th><th>全相联映射</th><th>组相联映射</th></tr></thead><tbody><tr><td>冲突</td><td>最容易</td><td>最不容易</td><td>中等</td></tr><tr><td>Cache利用率</td><td>低</td><td>高</td><td>中等</td></tr><tr><td>淘汰算法</td><td>无</td><td>需要</td><td>需要</td></tr></tbody></table></div><h3 id="4-3-3-Cache的替换策略"><a href="#4-3-3-Cache的替换策略" class="headerlink" title="4.3.3 Cache的替换策略"></a>4.3.3 Cache的替换策略</h3><ol><li>先进先出（FIFO）<ul><li>优点：易实现、开销小</li><li>缺点：未考虑局部性原理，被替换的数据再次被访问</li></ul></li><li>近期最少使用（Least Recently Used，LRU）<ul><li>优点：减少了被替换的数据再次被访问的概率，提高了命中率</li></ul></li><li>随机法</li></ol><h2 id="4-4-存储器的校验"><a href="#4-4-存储器的校验" class="headerlink" title="4.4 存储器的校验"></a>4.4 存储器的校验</h2><ol><li>概述<ul><li>存储器校验的意义：解决编码在时间、空间上传输可靠性问题；减少基于软件检错的代价</li><li>码距：两个合法码之间的不同位数。<ul><li>码距越大，抗干扰能力、纠错能力越强，数据冗余越大，编码效率越低</li></ul></li><li>检错和纠错：检错位数=码距//2，纠错位数=（码距-1）//2</li></ul></li><li>奇偶校验（以偶校验为例）<ul><li>待传输数据：$D_1D_2D_3D_4D_5D_6D_7D_8$</li><li>校验位：$P=D_1\oplus D_2\oplus D_3\oplus D_4\oplus D_5\oplus D_6\oplus D_7\oplus D_8$（奇校验取反）</li><li>发送与接收的数据：$D_1D_2D_3D_4D_5D_6D_7D_8P$（末尾加校验码）</li><li>检错码：$G=D_1\oplus D_2\oplus D_3\oplus D_4\oplus D_5\oplus D_6\oplus D_7\oplus D_8\oplus P$<ul><li>$G=0$，无错；$G=1$，有错</li></ul></li><li>码距：2</li><li>检1位错，纠0位错</li></ul></li><li>汉明校验<ul><li>待传输数据：$D_n…D_3D_2D_1$</li><li>增加校验位$P$数量：$k$，$2^k\geq n+k+1$ （$n=4$时，$k=3$）</li><li>校验位$P<em>i$处于$2^{i-1}$位置，即传输数据：$H</em>{7-1}=D_4D_3D_2P_3D_1P_2P_1$</li><li>校验位$P_i$为位置下标二进制第$i$位为1的数据（除自己外）的异或和。<ul><li>$P_1= H_3\oplus H_5\oplus H_7=D_1\oplus D_2\oplus D_4$</li><li>$P_2= H_3\oplus H_6\oplus H_7=D_1\oplus D_3\oplus D_4$</li><li>$P_3= H_5\oplus H_6\oplus H_7=D_2\oplus D_3\oplus D_4$</li></ul></li><li>检错码$G_i$为位置下标二进制第$i$位为1的数据的异或和。<ul><li>$G_1=H_1\oplus H_3\oplus H_5\oplus H_7=P_1\oplus D_1\oplus D_2\oplus D_4$</li><li>$G_2=H_2\oplus H_3\oplus H_6\oplus H_7=P_2\oplus D_1\oplus D_3\oplus D_4$</li><li>$G_3=H_4\oplus H_5\oplus H_6\oplus H_7=P_3\oplus D_2\oplus D_3\oplus D_4$</li></ul></li><li>每一组数据都是一次偶校验</li><li>检错码的排列$G_3G_2G_1$所示的二进制数表示出错的位置</li><li>码距：3</li><li>检1位错，纠1位错</li><li>实现检2位错<ul><li>开头增加一个总偶校验位$P_4=H_1\oplus H_2\oplus H_3\oplus H_4\oplus H_5\oplus H_6\oplus H_7$</li><li>检错码：$G_4=P_4\oplus H_1\oplus H_2\oplus H_3\oplus H_4\oplus H_5\oplus H_6\oplus H_7$</li></ul></li><li>优点<ul><li>编码效率高：数据增加一倍，校验位增加1位</li><li>可纠正1位错，检错2位错</li></ul></li></ul></li><li>CRC循环冗余校验<ul><li>待传输数据：$1100$</li><li>约定一个$r+1$位二进制数$1011$（r=3）</li><li>将待传输数据左移$r$位，得到$1100|000$</li><li>做模二除法，做减法时做异或，余数首位为1时商上1</li><li>$1100000\div1011=1110\cdots 010$其中余数$010$是校验位</li><li>$1100|000$和余数$010$相加，得到传输数据$D=1100|010$</li><li>接收方将接收到的数据$D$除以约定的数$1011$，余数为0则无错</li></ul></li></ol><h2 id="4-5-辅助存储器-外存储器"><a href="#4-5-辅助存储器-外存储器" class="headerlink" title="4.5 辅助存储器/外存储器"></a>4.5 辅助存储器/外存储器</h2><h3 id="4-5-1-概述"><a href="#4-5-1-概述" class="headerlink" title="4.5.1 概述"></a>4.5.1 概述</h3><ul><li>磁表面存储器、硬盘存储器、光盘存储器</li><li>特点；容量大、速度慢、价格低、长期存储、非破坏性读出</li><li>原理：电磁变换<h3 id="4-5-2-磁表面存储器的技术指标"><a href="#4-5-2-磁表面存储器的技术指标" class="headerlink" title="4.5.2 磁表面存储器的技术指标"></a>4.5.2 磁表面存储器的技术指标</h3></li></ul><ol><li>记录密度<ul><li>道密度$D_t(TPI)$</li><li>位密度$D_b(BPI)$</li><li>面密度$D_s=D_t\times D_b$</li></ul></li><li>$圆柱面数N_c=(外径R-内径r)\times F_t$</li><li>$磁道长度l=2\pi r(内径)$</li><li>$存储容量C=l\times D_b\times N_c\times 盘面数$</li><li>$寻址时间/定位时间T_a=寻道时间t_s+等待时间t_w$</li><li>数据传输率$D_r$：单位时间传输的数据量</li><li>误码率：$\dfrac{错误位数}{总位数}$，通常用CRC校验纠正<h3 id="4-5-3-硬磁盘存储器"><a href="#4-5-3-硬磁盘存储器" class="headerlink" title="4.5.3 硬磁盘存储器"></a>4.5.3 硬磁盘存储器</h3></li><li>类型<ul><li>固定磁头/移动磁头</li><li>可换盘/固定盘</li></ul></li><li>结构<ul><li>$主机\Leftrightarrow 磁盘控制器\Leftrightarrow 磁盘驱动器\Leftrightarrow 磁盘盘片$</li></ul></li><li>磁盘控制器：主机与磁盘驱动器之间的接口<ul><li>功能：数据传输、数据校验、磁盘调度、磁盘格式化</li></ul></li></ol><h3 id="4-5-4-软盘存储器"><a href="#4-5-4-软盘存储器" class="headerlink" title="4.5.4 软盘存储器"></a>4.5.4 软盘存储器</h3><div class="table-container"><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>快</td><td>慢</td></tr><tr><td>磁头</td><td>固定/活动、浮动</td><td>固定、接触盘片</td></tr><tr><td>盘片</td><td>固定、盘组、大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>工作环境</td><td>苛刻</td></tr></tbody></table></div><h3 id="4-5-5-光盘存储器"><a href="#4-5-5-光盘存储器" class="headerlink" title="4.5.5 光盘存储器"></a>4.5.5 光盘存储器</h3><ul><li>采用光存储技术，利用激光读写</li><li>第一代：非磁性介质、不可擦写</li><li>第二代：磁性介质、可擦写</li><li>只读型/只写一次型：热作用</li><li>可擦写型：热磁效应</li></ul><h1 id="五、输入输出系统"><a href="#五、输入输出系统" class="headerlink" title="五、输入输出系统"></a>五、输入输出系统</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><h3 id="5-1-1-输入输出系统的发展概况"><a href="#5-1-1-输入输出系统的发展概况" class="headerlink" title="5.1.1* 输入输出系统的发展概况"></a>5.1.1* 输入输出系统的发展概况</h3><ol><li>早期阶段<ul><li>分散连接</li><li>CPU与I/O设备 串行工作</li><li>程序查询方式</li></ul></li><li>接口模块和DMA阶段<ul><li>总线连接</li><li>CPU与I/O设备 并行工作</li><li>中断方式/直接存储器访问（DMA）</li></ul></li><li>具有通道结构的阶段</li><li>具有I/O处理机的阶段<h3 id="5-1-2-输入输出系统的组成"><a href="#5-1-2-输入输出系统的组成" class="headerlink" title="5.1.2* 输入输出系统的组成"></a>5.1.2* 输入输出系统的组成</h3></li><li>I/O软件<ul><li>I/O指令：CPU指令的部分。 操作码|命令码|设备码<ul><li>操作码：I/O指令的标志，指出该指令是I/O指令</li><li>命令码：指出I/O操作的类型：输入、输出、状态测试、控制</li><li>设备码：指出I/O设备的地址（端口号）</li></ul></li><li>通道指令<ul><li>通道：具有特殊功能的处理器IOP</li><li>指出要传输的字节数、数据地址、操作命令</li></ul></li></ul></li><li>I/O硬件<ul><li>接口方式：设备、I/O接口：设备通过接口连接到总线，和主机进行数据交换</li><li>通道方式：设备、设备控制器、通道</li></ul></li></ol><h3 id="5-1-3-I-O设备与主机的联系方式"><a href="#5-1-3-I-O设备与主机的联系方式" class="headerlink" title="5.1.3 I/O设备与主机的联系方式"></a>5.1.3 I/O设备与主机的联系方式</h3><ol><li>外设分类<ul><li>按功能：输入设备、输出设备</li><li>按速度：低速设备、中速设备、高速设备</li><li>按作用：人机交互设备、外存储器设备、通信设备</li></ul></li><li>I/O设备的编址方式<ul><li>统一编址方式：将I/O设备看作是内存地址的一部分，共用地址空间，指令集相对简单</li><li>不统一编址方式：内存之外专设I/O设备地址空间，有专门的I/O指令集</li></ul></li><li>设备寻址：通过设备选择电路</li><li>传送方式：串行、并行</li><li>联络方式/外围设备定时方式<ul><li>立即响应方式（极慢的设备）</li><li>异步工作采用应答信号联络（慢速和中速设备）</li><li>同步工作采用同步时标联络（高速设备）</li></ul></li><li>I/O设备和主机的连接方式<ul><li>辐射式（分散连接）：每台设备都配有独立的控制电路和信号线</li><li>总线式：便于增删设备</li></ul></li></ol><h2 id="5-2-I-O端口"><a href="#5-2-I-O端口" class="headerlink" title="5.2 I/O端口"></a>5.2 I/O端口</h2><ol><li>设置I/O端口的原因<ul><li>外部设备工作的异步性：外部设备工作的时钟和时序与微处理器不同</li><li>速度差异：外部设备的速度远远低于微处理器</li><li>信号线与数据格式不同</li><li>便于外设发展</li></ul></li><li>I/O端口的功能<ul><li>实现数据缓冲</li><li>执行CPU的命令返回外设状态</li><li>设备选择</li><li>数据格式、信号的转换</li><li>中断管理</li></ul></li><li>I/O接口的组成<ul><li>基本电路：寄存器及逻辑控制</li><li>端口地址译码电路</li><li>供选电路：可选器件</li></ul></li></ol><h2 id="5-3-I-O控制方式-信息交换方式-总览"><a href="#5-3-I-O控制方式-信息交换方式-总览" class="headerlink" title="5.3 I/O控制方式 / 信息交换方式 总览"></a>5.3 I/O控制方式 / 信息交换方式 总览</h2><ol><li>程序查询方式<ul><li>$启动设备\Rightarrow 反复查询设备状态直至设备准备好\Rightarrow 传输单个数据\Rightarrow 结束设备$</li><li>信息交换完全由CPU执行程序实现</li><li>串行工作、反复查询、系统效率低</li><li>用于早期计算机系统</li></ul></li><li>程序中断方式<ul><li>$CPU发起指令\Rightarrow 设备准备数据+CPU处理其他进程\Rightarrow 设备准备好数据，向CPU发出中断请求\Rightarrow CPU响应中断$</li><li>主动告知避免反复查询</li><li>仍需CPU占用</li><li>一次中断传输数据少，CPU开销大</li></ul></li><li>直接存储器存取（DMA）方式<ul><li>适用于成组数据传输</li><li>传输阶段DMAC从CPU接管总线，直接在内存及外设之间进行，节约了中断开销</li><li>需要更多硬件</li></ul></li><li>通道方式<ul><li>通道：具有特殊功能的处理器IOP，独立于CPU，分担I/O处理，可实现外设的统一管理和DMA操作</li><li>通道执行通道程序来完成CPU指定的I/O任务，通道程序是由一系列通道指令组成的</li></ul></li></ol><h2 id="5-4-程序中断方式"><a href="#5-4-程序中断方式" class="headerlink" title="5.4 程序中断方式"></a>5.4 程序中断方式</h2><ol><li>中断概念<ul><li>中断：CPU暂时中止现行程序的执行，转去执行为某个随机事件服务的中断处理子程序，处理完后自动恢复原程序的执行</li><li>作用：实现CPU与I/O设备的并行工作、故障处理等</li></ul></li><li>中断的分类<ul><li>$<br>中断\begin{cases}<br>内中断（异常）：来自CPU内部\begin{cases}<br>软件中断\\<br>异常\begin{cases}<br> 故障Fault\\<br> 陷阱Trap\\<br> 终止Abort<br>\end{cases}<br>\end{cases} \\<br>外中断（强迫中断）：来自CPU外部\begin{cases}<br>不可屏蔽中断NMI：由系统内部硬件引发的中断\\<br>可屏蔽中断INTR：由外设通过中断请求线向处理器申请<br>\end{cases}<br>\end{cases}<br>$</li></ul></li><li><p>中断系统基本功能</p><ol><li>中断请求的保持和清除：硬件实现</li><li>中断仲裁：多个中断请求同时到达时，确定优先级</li><li>中断源识别：获取中断号（识别中断源）</li><li>中断处理</li><li>中断控制<ul><li>中断触发方式：边沿触发、电平触发</li><li>中断排队方式：优先级高先服务</li></ul></li></ol></li><li><p>单级中断和多级中断</p><ul><li>单级中断：所有中断同级，离CPU近的优先，处理中断时不响应其他中断</li><li>多级中断：优先级高的中断可打断优先级低的中断，中断嵌套</li></ul></li><li>优先级划分一般规律<ul><li>硬件中断最高，程序错误中断其次</li><li>NMI&gt;INTR</li><li>DMA&gt;I/O</li><li>高速设备&gt;低速设备</li><li>输入设备&gt;输出设备</li><li>实时设备&gt;非实时设备</li></ul></li><li>中断屏蔽字与优先级设定<ul><li>以A,B,C为例，设定优先级B&gt;C&gt;A</li><li>A：100；B：111；C：101</li><li>0所在的位置表示允许被该位中断</li></ul></li><li>缺点<ol><li>传输一次数据就要中断一次，CPU开销大</li><li>效率低，不适合高速传输系统</li></ol></li></ol><h2 id="5-5-DMA（直接存储器存取）方式"><a href="#5-5-DMA（直接存储器存取）方式" class="headerlink" title="5.5 DMA（直接存储器存取）方式"></a>5.5 DMA（直接存储器存取）方式</h2><ol><li>优点<ul><li>外设与主存间建立一个由硬件管理的数据通路</li><li>CPU不介入外设与主存的数据传输</li><li>减少CPU开销，提高系统效率</li></ul></li><li>内存争用： DMA控制器和CPU可能同时访问内存<ol><li>DMA访内过程中，停止CPU访问内存<ul><li>DMA批量数据传输周期过长，CPU长期无法访内</li><li>外设传送两个数据的时间间隔大于存储周期，内存未充分利用</li></ul></li><li>DMA与CPU交替访问内存<ul><li>每个CPU工作周期分成两段：DMA访内和CPU访内</li><li>无主存使用权移交过程</li></ul></li><li>周期挪用法<ul><li>DMA要求访问主存时，CPU暂停一个或多个存储周期。一个数据传送结束后，CPU继续运行。</li></ul></li></ol></li></ol><h1 id="六、计算机的运算方法"><a href="#六、计算机的运算方法" class="headerlink" title="六、计算机的运算方法"></a>六、计算机的运算方法</h1><h1 id="6-1-无符号数和有符号数"><a href="#6-1-无符号数和有符号数" class="headerlink" title="6.1 无符号数和有符号数"></a>6.1 无符号数和有符号数</h1><h2 id="6-1-1-无符号数"><a href="#6-1-1-无符号数" class="headerlink" title="6.1.1 无符号数"></a>6.1.1 无符号数</h2><p>按照规定的长度（字长）以二进制保存，只有数值部分，没有符号位。</p><h2 id="6-1-2-有符号数"><a href="#6-1-2-有符号数" class="headerlink" title="6.1.2 有符号数"></a>6.1.2 有符号数</h2><ol><li>机器数与真值<ul><li>机器数：计算机内部表示的数</li><li>真值：数的实际值</li><li>四种机器码：原码、反码、补码、移码<ul><li>最高位表示符号：0为正，1为负</li><li>其余位表示数值</li><li>小数的定点表示：原码、反码、补码</li></ul></li></ul></li><li>原码<ul><li>整数：数值位表示小数点前的整数部分</li><li>小数：数值位表示小数点后的小数部分（绝对值小于1）</li><li>特点：<ol><li>有+0(0,000)和-0(1,000)两种0</li><li>加、减运算方式不统一，符号相异不能直接计算</li></ol></li></ul></li><li>反码<ul><li>正数：原码</li><li>负数：其正数原码的各位取反</li><li>特点：<ol><li>有+0(0,000)和-0(1,111)两种0</li><li>运算较复杂</li></ol></li></ul></li><li>补码<ul><li>正数：原码</li><li>负数：反码+1</li><li>特点：<ol><li>0有唯一的表示方式</li><li>加、减运算方式统一</li><li>机器数的唯一表示</li><li>小数可以表示-1(1.000)</li></ol></li><li>补码运算：<ol><li>$[[X]<em>补]</em>补=-(-X)=X$</li><li>//2：右移1位，最高位补符号位（正数补0，负数补1）</li><li>*2：左移1位，最低位补0，符号位变化即为溢出</li><li>不同位数加减法：位数少的数，高位补符号位直至位数相同，然后按位加减</li></ol></li></ul></li><li>移码<ul><li>补码的符号位取反</li><li>保持数据原有的大小顺序，便于比较</li><li>仅用于表示整数，通常用于浮点数的阶码<h1 id="6-2-小数的浮点表示（原码表示）"><a href="#6-2-小数的浮点表示（原码表示）" class="headerlink" title="6.2 小数的浮点表示（原码表示）"></a>6.2 小数的浮点表示（原码表示）</h1></li></ul></li><li>表示格式<ul><li>$N=S\times r^j$</li><li>S：尾数（小数）；r：基数($2^k$)；j：阶码（二进制表示）</li><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC19.png" alt="浮点数表示"></li><li>$S_f$：浮点数的符号</li><li>$n$：决定浮点数的精度</li><li>$m$：决定浮点数的表示范围</li></ul></li><li>规格化数<ul><li>基数$r=2^k$时</li><li>尾数$S$的最高的$k$位（小数点后$k$位）不全为0</li><li>特别的，$r=2$时，S=0.1xxxxxx</li><li>尾数左右移动$k$位，阶码变化$1$</li></ul></li><li>表示范围<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC20.png" alt="浮点数表示范围"></li><li>尾数$S$：$0,[2^{-n},1-2^{-n}]$</li><li>阶码$j$：$[-2^m+1,2^m-1]$</li><li>表示范围：$[-(1-2^{-n})\times 2^{2^m-1},-(2^{-n})\times 2^{-2^m+1}],0,[2^{-n}\times 2^{-2^m+1},(1-2^{-n})\times 2^{2^m-1}]$</li></ul></li><li>机器0<ul><li>尾数$S=0$的数：x,xxxx;0.0000000000</li><li>阶码小于等于精度（$-2^m+1,-15$）的数：1,0000(-16);x.xxxxxxxxxx</li><li>阶码用移码时，机器$0$为：0,0000;0.0000000000</li></ul></li><li>IEEE754 Standard<ul><li>构成：符号位$m_s$（数符），阶码$E$（含阶符，移码表示，基数为2），尾数$M$（隐去开头的1，原码表示）  </li><li>$(-1)^{m_s}\times 1.M\times 2^E$</li><li>偏置值：阶码的移码与原码的差值（$2^{k-1}-1$）</li></ul></li></ol><div class="table-container"><table><thead><tr><th></th><th>符号位</th><th>阶码</th><th>尾数</th><th>总位数</th></tr></thead><tbody><tr><td>单精度float</td><td>1</td><td>8</td><td>23</td><td>32</td></tr><tr><td>双精度double</td><td>1</td><td>11</td><td>52</td><td>64</td></tr><tr><td>临时实数</td><td>1</td><td>15</td><td>64</td><td>80</td></tr></tbody></table></div><h1 id="6-3-定点运算"><a href="#6-3-定点运算" class="headerlink" title="6.3 定点运算"></a>6.3 定点运算</h1><h2 id="6-3-1-移位运算"><a href="#6-3-1-移位运算" class="headerlink" title="6.3.1 移位运算"></a>6.3.1 移位运算</h2><ol><li>算术移位与逻辑移位<ul><li>算术移位：符号位不变</li><li>逻辑移位：左移右移补0</li></ul></li><li>算术移位添补</li></ol><div class="table-container"><table><thead><tr><th>正负</th><th>码值</th><th>添补</th></tr></thead><tbody><tr><td>+</td><td>原码、反码、补码</td><td>补0</td></tr><tr><td>-</td><td>原码</td><td>补0</td></tr><tr><td>-</td><td>反码</td><td>补1</td></tr><tr><td>-</td><td>补码</td><td>左移补0，右移补1</td></tr></tbody></table></div><ol><li>丢失有效位<ul><li>左移丢高位：溢出</li><li>右移丢低位：损失精度</li></ul></li></ol><h2 id="6-3-2-加减法运算"><a href="#6-3-2-加减法运算" class="headerlink" title="6.3.2 加减法运算"></a>6.3.2 加减法运算</h2><ol><li>补码加减运算公式<ol><li>加法：$[A]<em>补+[B]</em>补=[A+B]_补$</li><li>减法：$[A]<em>补-[B]</em>补=[A+(-B<em>补)]</em>补=[A]<em>补+[-B]</em>补$</li><li>连同符号位一起相加，溢出位舍去</li><li>真实溢出：正正得负/负负得正</li></ol></li><li>硬件实现<ol><li>串行加法器：逐位相加，进位传递<ol><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC21.png" alt="串行加法器"></li><li>缺点：高位依赖低位，速度慢</li><li>$S<em>i=X_i\oplus Y_i\oplus C</em>{i-1}$</li><li>$C<em>i=X_iY_i+X_iC</em>{i-1}+Y<em>iC</em>{i-1}=X<em>iY_i+(X_i\oplus Y_i)C</em>{i-1}$</li></ol></li><li>并行加法器：每一位并行计算<ol><li>原理<ol><li>记：<ul><li>$G_i=X_iY_i$：生成位（Generate）</li><li>$P_i=X_i\oplus Y_i$：传递位（Propagate）</li></ul></li><li>则：<ul><li>$C<em>i = G_i + P_iC</em>{i-1}$</li></ul></li><li>传递得到：<ul><li>$C<em>i = G_i + P_iG</em>{i-1} + P<em>iP</em>{i-1}G<em>{i-2} + \cdots + P_iP</em>{i-1}\cdots P_1C_0$</li><li>$以i=4为例，C_4 = G_4 + P_4G_3 + P_4P_3G_2 + P_4P_3P_2G_1 + P_4P_3P_2P_1C_0$</li></ul></li><li>记：<ul><li>$G_4^* = G_4 + P_4G_3 + P_4P_3G_2 + P_4P_3P_2G_1$：组进位生成位</li><li>$P_3^* = P_4P_3P_2P_1$：组进位传递位</li><li>$C_4 = G_4^<em> + P_4^</em>C_0$：组进位传递函数</li></ul></li><li>$S<em>i=P_i\oplus C</em>{i-1}$ </li></ol></li><li>1级门电路延迟-与门异或门电路：计算$G_i,P_i$<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC22.png" alt="1级门电路"> </li></ul></li><li>2级门电路延迟-先行进位电路：计算$C_i$<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC23.png" alt="2级门电路"> </li></ul></li><li>四位快速加法器<ul><li><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC24.png" alt="四位快速加法器"></li></ul></li></ol></li></ol></li></ol><h2 id="6-3-3-乘法运算"><a href="#6-3-3-乘法运算" class="headerlink" title="6.3.3 乘法运算"></a>6.3.3 乘法运算</h2><ul><li>思想：移位相加<h3 id="6-3-3-1-原码乘法"><a href="#6-3-3-1-原码乘法" class="headerlink" title="6.3.3.1 原码乘法"></a>6.3.3.1 原码乘法</h3></li><li>符号位：单独计算</li><li>数值位：从$Y$的最低位开始，逐位决定$SUM$是否加$X$，然后$Sum$右移一位。</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC30.png" alt="原码乘法"></p><h3 id="6-3-3-2-（重点）补码乘法：Booth算法"><a href="#6-3-3-2-（重点）补码乘法：Booth算法" class="headerlink" title="6.3.3.2 （重点）补码乘法：Booth算法"></a>6.3.3.2 （重点）补码乘法：Booth算法</h3><ul><li>给定：$[X]<em>补,[Y]</em>补$，求$[X]<em>补\times [Y]</em>补$</li></ul><ol><li>求$[-X]<em>补$，$[Y]</em>补$最后补一位0</li><li>当前$Y$的末2位$Y<em>{-2}Y</em>{-1}$决定$SUM$加$X,0,-X$的哪一个<ul><li>$SUM+=X\times (Y<em>{-1}-Y</em>{-2})=\begin{cases}<br>0 &amp; Y<em>{-2}Y</em>{-1}=00\\<br>X &amp; Y<em>{-2}Y</em>{-1}=01\\<br>-X &amp; Y<em>{-2}Y</em>{-1}=10\\<br>0 &amp; Y<em>{-2}Y</em>{-1}=11<br>\end{cases}$</li></ul></li><li>右移$SUM$，左边补符号位</li><li>去掉$Y$的最低位，重复步骤2-3，直到$Y$只剩1位</li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC31.png" alt="补码乘法"></p><h2 id="6-3-4-除法运算"><a href="#6-3-4-除法运算" class="headerlink" title="6.3.4 除法运算"></a>6.3.4 除法运算</h2><h3 id="6-3-4-1-恢复余数法"><a href="#6-3-4-1-恢复余数法" class="headerlink" title="6.3.4.1 恢复余数法"></a>6.3.4.1 恢复余数法</h3><ul><li>给定：$[X]<em>补,[Y]</em>补$，求$[X]<em>补\div [Y]</em>补$（$X,Y$为正数）</li></ul><ol><li>求$[-Y]_补$</li><li>计算$X+=(-Y)$</li><li>若双符号位为$11$，即$X$为负数，不够减，则该位为$0$，恢复余数：$X+=Y$</li><li>若双符号位为$00$，即$X$为正数，够减，该位为$1$</li><li>$X$左移一位，右边补0</li><li>重复步骤2-5，直到$X$左移$4$位（$Y$的位数）</li><li>当前的余数为$X\times 2^{-4}$</li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC32.png" alt="恢复余数法"></p><h3 id="6-3-4-2-重点-非恢复余数法-加减交替法"><a href="#6-3-4-2-重点-非恢复余数法-加减交替法" class="headerlink" title="6.3.4.2 (重点)非恢复余数法/加减交替法"></a>6.3.4.2 (重点)非恢复余数法/加减交替法</h3><ul><li>给定：$[X]<em>补,[Y]</em>补$，求$[X]<em>补\div [Y]</em>补$（$X,Y$为正数）</li></ul><ol><li>求$[-Y]_补$</li><li>若双符号位为$00$，即$X$为正数，计算$X+=(-Y)$（第一次必定做减法）</li><li>若双符号位为$11$，即$X$为负数，计算$X+=Y$</li><li>若双符号位为$00$，即$X$为正数，该位为$1$</li><li>若双符号位为$11$，即$X$为负数，该位为$0$</li><li>$X$左移一位，右边补0</li><li>重复步骤2-6，直到$X$左移$4$位（$Y$的位数）</li><li>当前的余数为$X\times 2^{-4}$</li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC33.png" alt="非恢复余数法"></p><h1 id="6-4-浮点运算"><a href="#6-4-浮点运算" class="headerlink" title="6.4 浮点运算"></a>6.4 浮点运算</h1><p><a href="#62-小数的浮点表示原码表示">规格化浮点数</a></p><h2 id="6-4-1-浮点加减法"><a href="#6-4-1-浮点加减法" class="headerlink" title="6.4.1 浮点加减法"></a>6.4.1 浮点加减法</h2><p>例：</p><script type="math/tex; mode=display">X=2^{E_x}M_x=2^{101}\times 0.11011011 \\\\Y=2^{E_y}M_y=2^{111}\times-0.10101100</script><p>尾数在计算机中以补码表示，可存储10位尾数，2位符号位，阶码以补码表示，双符号位, 求$X+Y$</p><h3 id="6-4-1-1-将X-Y转化为带符号的浮点补码格式"><a href="#6-4-1-1-将X-Y转化为带符号的浮点补码格式" class="headerlink" title="6.4.1.1 将X,Y转化为带符号的浮点补码格式"></a>6.4.1.1 将X,Y转化为带符号的浮点补码格式</h3><script type="math/tex; mode=display">X=00101,00.11011011 \\\\Y=00111,11.01010100(-0.10101100)</script><h3 id="6-4-1-2-对阶"><a href="#6-4-1-2-对阶" class="headerlink" title="6.4.1.2 对阶"></a>6.4.1.2 对阶</h3><ul><li>原则：小阶对大阶</li></ul><ol><li>计算$[-E<em>y]</em>补=11001$</li><li>计算阶差$E=E_x+(-E_y)=00101+11001=11110=-2(D)&lt;0$</li><li>$X$是小阶，$M_x$右移$|E|=2$位：$M_x=00.0011011011$，$E=111$</li><li>$X=00111,00.0011011011$<h3 id="6-4-1-3-尾数求和-差"><a href="#6-4-1-3-尾数求和-差" class="headerlink" title="6.4.1.3 尾数求和/差"></a>6.4.1.3 尾数求和/差</h3><script type="math/tex; mode=display">M=M_x+M_y=00.0011011011+11.01010100=11.1000101011 \\\\X+Y=00111,11.1000101011</script><h3 id="6-4-1-4-结果规格化"><a href="#6-4-1-4-结果规格化" class="headerlink" title="6.4.1.4 结果规格化"></a>6.4.1.4 结果规格化</h3></li></ol><ul><li>双符号位为$11$，是负数，规格化到小数点后一位为$0$。（本题中，$M$双符号位为$11$）</li><li>双符号位为$00$，是正数，规格化到小数点后一位为$1$。</li><li>结果左移一位得到：<script type="math/tex; mode=display">X+Y=00110,11.000101011</script></li><li>尾数溢出时可能需要尾数右移<h3 id="6-4-1-5-舍入处理"><a href="#6-4-1-5-舍入处理" class="headerlink" title="6.4.1.5 舍入处理"></a>6.4.1.5 舍入处理</h3></li><li>0舍1入：$X+Y=00111,11.00010110$</li><li>截断：$X+Y=00111,11.00010101$<h3 id="6-4-1-6-得出结果"><a href="#6-4-1-6-得出结果" class="headerlink" title="6.4.1.6 得出结果"></a>6.4.1.6 得出结果</h3><script type="math/tex; mode=display">X+Y=00110,11.00010101 \\\\=2^{110}\times -0.11101011</script></li></ul><h3 id="6-4-1-7-溢出判断"><a href="#6-4-1-7-溢出判断" class="headerlink" title="6.4.1.7 溢出判断"></a>6.4.1.7 溢出判断</h3><p>根据阶码的双符号位进行判断：</p><ul><li>01：正溢出</li><li>10：负溢出</li></ul><h2 id="6-4-2-浮点乘法-除法"><a href="#6-4-2-浮点乘法-除法" class="headerlink" title="6.4.2 浮点乘法/除法"></a>6.4.2 浮点乘法/除法</h2><ul><li>乘法：尾数定点相乘，阶码相加</li><li>除法：尾数定点相除，阶码相减</li></ul><h1 id="七、指令系统"><a href="#七、指令系统" class="headerlink" title="七、指令系统"></a>七、指令系统</h1><h1 id="7-0-基本概念"><a href="#7-0-基本概念" class="headerlink" title="7.0 基本概念"></a>7.0 基本概念</h1><ol><li>指令：计算机能直接识别、执行的操作命令（机器指令）；冯诺依曼结构“程序控制”原理实现的载体</li><li>指令集：一台计算机能执行的全部指令的集合</li><li>等长指令（MIPS）/变长指令（x86）</li><li>指令系统的特点：完备、高效、规整、兼容</li><li>为什么说“指令系统是计算机系统硬件与软件之间的界面”？<ul><li>从程序的编写与执行角度看，指令规定了计算机的操作类型及操作数地址，它们是产生各种控制信号的基础。</li><li>从硬件设计角度看，在设计计算机的时候先要确定硬件能够直接执行哪些操作，表现为一组指令集合，称之为计算机的指令系统。</li><li>因此，指令系统体现了一台计算机的软、硬件界面。<h1 id="7-1-机器指令"><a href="#7-1-机器指令" class="headerlink" title="7.1 机器指令"></a>7.1 机器指令</h1><h2 id="7-1-1-指令的一般格式"><a href="#7-1-1-指令的一般格式" class="headerlink" title="7.1.1 指令的一般格式"></a>7.1.1 指令的一般格式</h2>$操作码OP|(寻址模式Mode)|地址码A_1|地址码A_2|\cdots$</li></ul></li><li>操作码字段：反映机器（对什么数据）做什么操作<ol><li><ul><li>定长操作码：总操作种类=2^k</li><li>变长操作码：操作码向不用的地址码字段扩展</li></ul></li><li>扩展操作码技术<ul><li>假设二操作数指令格式为：$OP(4)|A_1(6)|A_2(8)$ 15条</li><li>只保留全1为长操作数的锚点，那么：<ul><li>单操作数指令格式可以为：$1111|OP(6)|A_1(8)$ 63条</li><li>无操作数指令格式可以为：$1111|111111|OP(8)$ 256条</li></ul></li><li>原则：短操作码不能是长操作码的前缀</li><li>可以根据实际指令数量，通过保留多个锚点，识别更多的操作码：<ul><li>假设二操作数指令有10条，则可以保留6个锚点</li><li>可用于单操作数指令的条数变为$6\times 2^6$ 条</li><li>按需分配后剩下的可以作为无操作数指令的锚点</li></ul></li><li>例题：设某指令系统指令字长16位，每个地址码为6位。若要求设计二地址指令15条、一地址指令34条，问最多还可设计多少条零地址指令？<ul><li>指令格式：$OP(4)|A_1(6)|A_2(6)$</li><li>二地址指令条数15，保留锚点数$2^4-15=1$</li><li>一地址指令条数34，保留锚点数$1\times 2^6 - 34 = 30$</li><li>零地址指令条数：$30\times 2^6 = 1920$</li></ul></li></ul></li><li>经常使用的操作设计为短操作码，不常用的设计为长操作码 </li></ol></li><li>操作数字段（地址码字段）：<ul><li>四地址指令（$OP|A_1|A_2|A_3|A_4$）：$(A_1)OP(A_2)\rightarrow A_3$，下一条指令位于$A_4$  </li><li>三地址指令（$OP|A_1|A_2|A_3$）：$(A_1)OP(A_2)\rightarrow A_3$，下一条指令位于$PC+1$（利用$PC$代替$A_4$）</li><li>二地址指令（$OP|A_1|A_2$）：$(A_1)OP(A_2)\rightarrow AC$，下一条指令位于$PC+1$（利用$AC$代替$A_3$）</li><li>一地址指令（$OP|A_1$）：$(A_1)OP(AC)\rightarrow AC$，下一条指令位于$PC+1$（利用$AC$代替$A_2,A_3$）</li><li>零地址指令（$OP$）：基本的无操作数操作指令，如空操作、停机、中断、返回等</li><li>访存次数：取指令1次+读取操作数次数+存结果到操作数次数（若存入AC则不计）</li><li>直接寻址范围：$2^k$，k是单个地址码位数</li><li>减少操作数个数的优点：<ol><li>利用硬件资源代替地址码字段</li><li>扩大指令的寻址范围</li><li>缩短指令字长 <h2 id="7-1-2-指令字长"><a href="#7-1-2-指令字长" class="headerlink" title="7.1.2 指令字长"></a>7.1.2 指令字长</h2></li></ol></li></ul></li><li>指令字长决定于：<ul><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数的个数</li></ul></li><li><ul><li>定长指令：指令字长=存储字长</li><li>变长指令：通常按字节的倍数存储</li></ul></li></ol><h1 id="7-2-操作数类型和操作类型"><a href="#7-2-操作数类型和操作类型" class="headerlink" title="7.2* 操作数类型和操作类型"></a>7.2* 操作数类型和操作类型</h1><h2 id="7-2-1-操作数类型"><a href="#7-2-1-操作数类型" class="headerlink" title="7.2.1 操作数类型"></a>7.2.1 操作数类型</h2><ol><li>地址：用于表示地址的无符号整数</li><li>数字：定点数、浮点数、十进制数</li><li>字符：ASCII</li><li>逻辑：逻辑数据/运算<h2 id="7-2-2-数据在存储器中的存储方式"><a href="#7-2-2-数据在存储器中的存储方式" class="headerlink" title="7.2.2 数据在存储器中的存储方式"></a>7.2.2 数据在存储器中的存储方式</h2></li></ol><ul><li>边界对齐/边界不对齐</li><li>大端存储/小端存储<h2 id="7-2-3-操作类型"><a href="#7-2-3-操作类型" class="headerlink" title="7.2.3 操作类型"></a>7.2.3 操作类型</h2>1.数据传送 2.算术/逻辑运算 3.移位运算 4.控制转移</li></ul><h1 id="7-3-寻址方式"><a href="#7-3-寻址方式" class="headerlink" title="7.3 寻址方式"></a>7.3 寻址方式</h1><h2 id="7-3-1-指令寻址"><a href="#7-3-1-指令寻址" class="headerlink" title="7.3.1 指令寻址"></a>7.3.1 指令寻址</h2><ol><li>顺序寻址：通过程序计数器PC+指令占用字节数，自动生成下一条指令地址<ul><li>PC的变化时机：每当CPU从存储器中读取出一个字节时，PC+1</li></ul></li><li>跳跃寻址：通过指令中的转移类操作，跳转到指定地址</li></ol><h2 id="7-3-2-数据寻址"><a href="#7-3-2-数据寻址" class="headerlink" title="7.3.2 数据寻址"></a>7.3.2 数据寻址</h2><p>$操作码OP|(寻址模式Mode)|地址码A_1|地址码A_2|\cdots$</p><p>记：形式地址$D$/寄存器地址$R$、实际地址$E$、实际操作数$S$、基址/变址寄存器$B$、解地址符号$()$</p><ol><li>隐含寻址：操作数地址隐含在操作码或寄存器中（有利于减少指令字长）</li><li>立即寻址：操作数直接在指令中给出（补码，形式地址位数限制了范围）$S=D$</li><li>直接寻址：操作数在存储器中，地址码在指令中给出 $E=D$</li><li>寄存器寻址：操作数在寄存器中，寄存器编号在指令中给出 $E=R$</li><li>间接寻址：地址码指向的存储器中存放的地址是操作数的地址（二级指针）$E=(D),S=((D))$<ul><li>优点：减少指令字长，增加寻址范围，方便编程</li><li>缺点：两次访存，速度慢，已淘汰</li></ul></li><li>寄存器间接寻址：地址码（寄存器编号）指向的寄存器中存放的地址是操作数地址（应用广泛）$E=(R)$</li><li>相对寻址：操作数地址=PC+偏移量 $E=D+(PC)$</li><li>基址/变址寻址：操作数地址=基址/变址+偏移量（可以指定通用寄存器作为基址/变址寄存器）$E=D+(B)$</li><li>堆栈寻址：操作数地址=栈顶指针寄存器SP<ul><li>入栈：SP-1（上移），存入数据</li><li>出栈：取出数据，SP+1（下移）</li><li>单次变化量取决于主存编址方式：<ul><li>按字编址：$SP\pm 1$</li><li>按字节编址存储字长32位：$SP\pm 4(32/8)$</li></ul></li></ul></li></ol><h1 id="7-4-指令格式分析与设计"><a href="#7-4-指令格式分析与设计" class="headerlink" title="7.4 指令格式分析与设计"></a>7.4 指令格式分析与设计</h1><h2 id="7-4-1-指令格式分析"><a href="#7-4-1-指令格式分析" class="headerlink" title="7.4.1 指令格式分析"></a>7.4.1 指令格式分析</h2><p>例：$OP(15-12)|Mode(11-9)|Reg(8-6)|Mode(5-3)|Reg(2-0)$</p><ol><li>二地址指令</li><li>操作码：最多支持16种指令</li><li>寻址方式：源数据和目的数据都最多支持8种寻址方式</li><li>寄存器个数：源地址和目的地址都最多支持8个寄存器</li><li>可寻址范围：<ul><li>直接寻址范围：$2^3=8$（寄存器地址）</li><li>间接寻址范围：默认存储字长=指令字长，$2^{16}=64K$（存储器地址）</li></ul></li></ol><h1 id="7-5-RISC-CISC"><a href="#7-5-RISC-CISC" class="headerlink" title="7.5 RISC/CISC"></a>7.5 RISC/CISC</h1><ul><li>CISC：复杂指令集计算机（Complex Instruction Set Computer）</li><li>RISC：精简指令集计算机（Reduced Instruction Set Computer）</li><li>80-20规律：经典程序中80%的指令只使用了处理机指令集20%的指令</li></ul><div class="table-container"><table><thead><tr><th></th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>指令系统</td><td>复杂、庞大</td><td>简单、精简</td></tr><tr><td>指令数目</td><td>一般&gt;200</td><td>一般&lt;100</td></tr><tr><td>指令字长</td><td>变长</td><td>定长</td></tr><tr><td>寻址方式</td><td>多</td><td>少</td></tr><tr><td>访存指令</td><td>不限</td><td>只有LOAD/STORE</td></tr><tr><td>单条指令执行时间</td><td>相差较大</td><td>多数在一个周期内</td></tr><tr><td>各指令使用频度</td><td>相差较大</td><td>都较常用</td></tr><tr><td>通用寄存器数量</td><td>较少</td><td>多</td></tr><tr><td>目标代码</td><td>难以优化</td><td>优化编译生成高效代码</td></tr><tr><td>控制方式</td><td>大多为微程序控制</td><td>大多为硬布线控制</td></tr></tbody></table></div><h1 id="八、CPU的结构和功能"><a href="#八、CPU的结构和功能" class="headerlink" title="八、CPU的结构和功能"></a>八、CPU的结构和功能</h1><h1 id="8-0-基本概念"><a href="#8-0-基本概念" class="headerlink" title="8.0 基本概念"></a>8.0 基本概念</h1><ol><li>CPU的功能（控制器：1~4，ALU：5）<ol><li>程序控制：控制程序的顺序执行</li><li>操作控制：产生完成每条指令所需的控制命令</li><li>时序控制：对各种操作实施时间上的控制</li><li>异常控制：处理中断</li><li>数据加工：对数据进行算术运算和逻辑运算</li></ol></li><li>CPU的组成：<ol><li>专用寄存器以及通用寄存器:程序控制元生成各种微操作命令序列</li><li>算术逻辑单元ALU：进行算术运算和逻辑运算</li><li>控制器：中断系统用于处理各种中断</li></ol></li><li>数据通路分为：共享通路（总线型）、专用通路（看作多总线型）</li></ol><h1 id="8-1-CPU的结构"><a href="#8-1-CPU的结构" class="headerlink" title="8.1 CPU的结构"></a>8.1 CPU的结构</h1><ol><li>寄存器</li><li>ALU</li><li>控制单元和中断系统<ul><li>控制器的基本功能：取指令、分析指令、执行指令<h1 id="8-2-指令周期"><a href="#8-2-指令周期" class="headerlink" title="8.2 指令周期"></a>8.2 指令周期</h1>指令周期：去除并执行一条指令所需要的全部时间</li></ul><ol><li>取址周期：取指令的时间</li><li>间址周期：用于间址寻址取操作数</li><li>执行周期：执行指令，存取操作数和结果的时间</li><li>中断周期：CPU采用中断方式实现主机和I/O设备的通信时，发送中断信号的时间</li></ol></li></ol><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC34.png" alt="指令周期"></p><ul><li>提高机器速度的方法<ol><li>提高访存速度：高速芯片、Cache、多体并行</li><li>提高I/O和主机之间的传输速度：中断、DMA、I/O处理机、多总线</li><li>提高CPU的运算速度：高速芯片、改进算法、快速进位链</li></ol></li></ul><h1 id="8-3-指令流水线"><a href="#8-3-指令流水线" class="headerlink" title="8.3 指令流水线"></a>8.3 指令流水线</h1><p>指令流水线：将指令执行过程分为多个阶段，使多条指令在不同阶段同时执行（并行性）</p><h2 id="8-3-1-影响流水线性能的因素"><a href="#8-3-1-影响流水线性能的因素" class="headerlink" title="8.3.1 影响流水线性能的因素"></a>8.3.1 影响流水线性能的因素</h2><ol><li>结构相关：不同指令争用同一功能部件产生资源冲突</li><li>数据相关：不同指令因重叠操作，可能改变操作数的读/写访问顺序<ul><li>读后写/写后读/写后写</li></ul></li><li>控制相关：分支指令的执行可能改变程序计数器的值，导致流水线中的其他指令失效<h2 id="8-3-2-流水线性能"><a href="#8-3-2-流水线性能" class="headerlink" title="8.3.2 流水线性能"></a>8.3.2 流水线性能</h2></li><li>吞吐率$T_p$：单位时间内完成的指令数/输出结果的数量<ul><li>设$m$段流水线的各段时间为$\Delta t$</li><li>最大吞吐率：$\dfrac{1}{\Delta t}$</li><li>实际吞吐率：连续处理$n$条指令的吞吐率：$\dfrac{n}{(m+n-1)\Delta t}$</li></ul></li><li>加速比$S_p$：流水线处理速度与非流水线处理速度的比值<ul><li>加速比=原处理时间/流水线处理时间&gt;1</li><li>连续处理$n$条指令的加速比：$S_p=\dfrac{nm\Delta t}{(m+n-1)\Delta t}=\dfrac{mn}{m+n-1}$</li></ul></li><li>效率$E_p$：流水线中各功能段的利用率<ul><li>由于流水线有建立时间和排空时间 ，因此各功能段的设备不可能一直处于工作状态</li><li>$E_p=\dfrac{实际工作的时空区域}{总时空区域}=\dfrac{n}{m+n-1}$<h2 id="8-3-3-流水线的多发技术"><a href="#8-3-3-流水线的多发技术" class="headerlink" title="8.3.3 流水线的多发技术"></a>8.3.3 流水线的多发技术</h2></li></ul></li><li>超标量技术：多个流水线并行执行多条指令</li><li>超流水线技术：将流水线分为多个较短的段，提高吞吐率</li><li>超长指令字技术VLIW：将多条能够并行操作的指令组合成一条指令，提高吞吐率<h2 id="8-3-4-流水线结构"><a href="#8-3-4-流水线结构" class="headerlink" title="8.3.4 流水线结构"></a>8.3.4 流水线结构</h2></li><li>指令流水线：取指令、指令译码、地址形成、取操作数、操作执行、写回结果</li><li>运算流水线（浮点数）：对阶功能、尾数相加、规格化</li></ol><h1 id="8-4-指令周期与时序"><a href="#8-4-指令周期与时序" class="headerlink" title="8.4 指令周期与时序"></a>8.4 指令周期与时序</h1><ul><li>时钟周期=节拍脉冲=震荡周期：完成一次微操作的时间</li><li>机器周期=CPU周期：从主存读出一条指令的<strong>最短时间</strong></li><li>指令周期：从主存取一条指令到执行完毕的时间</li></ul><p><img src="https://source.cclmsy.cc/Images/Posts/PoCC/PoCC35.png" alt="时序"></p><h1 id="8-5-控制器设计"><a href="#8-5-控制器设计" class="headerlink" title="8.5 控制器设计"></a>8.5 控制器设计</h1><div class="table-container"><table><thead><tr><th></th><th>硬布线控制器</th><th>微程序控制器</th></tr></thead><tbody><tr><td>逻辑</td><td>同步逻辑</td><td>存储逻辑</td></tr><tr><td>特点</td><td>繁、快、贵</td><td>简、慢、廉</td></tr><tr><td>更改</td><td>难</td><td>易</td></tr></tbody></table></div><h2 id="8-5-1-硬布线控制器"><a href="#8-5-1-硬布线控制器" class="headerlink" title="8.5.1 硬布线控制器"></a>8.5.1 硬布线控制器</h2><ol><li>设计时序产生器：根据固定机器周期、节拍数固定构建状态图</li><li>画出指令周期流程图</li><li>找控制信号产生条件</li><li>写出逻辑表达式</li><li>化简表达式</li><li>利用组合逻辑电路实现</li></ol><p>优化：有限状态机、异步控制</p><p>特点：</p><ul><li>结构复杂、无规则</li><li>设计和调试困难</li><li>不可改变指令系统和功能</li><li>速度快、成本高</li></ul><h2 id="8-5-2-微程序控制器"><a href="#8-5-2-微程序控制器" class="headerlink" title="8.5.2 微程序控制器"></a>8.5.2 微程序控制器</h2><p>（计组实验相关）</p>]]></content>
    
    
    <summary type="html">一门教你手搓计算机的奇妙学科</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.cclmsy.cc/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://www.cclmsy.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024牛客寒假06</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Winter_NCD06.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Winter_NCD06.html</id>
    <published>2024-02-22T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-宇宙的终结"><a href="#A-宇宙的终结" class="headerlink" title="A.宇宙的终结"></a>A.宇宙的终结</h1><p><strong>1签</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在$[1,100]$中给定的某个区间内找到一个数，它是$3$个不同素数的积。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>打出$100$以内素数表，然后暴力枚举判定。</p><p>手算也行，$100$以内答案只有$30,42,66,70,78$。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; phi=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pend</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:phi)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%p==<span class="number">0</span>) &#123; cnt++; x/=p; &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;cnt==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r;cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r) <span class="keyword">if</span>(<span class="built_in">pend</span>(i)) &#123;cout &lt;&lt; i &lt;&lt; endl;<span class="keyword">return</span>;&#125; </span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; ans=&#123;<span class="number">30</span>,<span class="number">42</span>,<span class="number">66</span>,<span class="number">70</span>,<span class="number">78</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r;cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:ans) <span class="keyword">if</span>(x&gt;=l&amp;&amp;x&lt;=r) &#123;cout &lt;&lt; x &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-爱恨的纠葛"><a href="#B-爱恨的纠葛" class="headerlink" title="B.爱恨的纠葛"></a>B.爱恨的纠葛</h1><p><strong>思维</strong></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定$2$个长度为$n$的数组$a,b$。调整$a$数组使得$|a_i-b_i|$的最小值最小。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>在$a,b$中分别找到一个数，它们的差的绝对值最小。</p><p>对数组$a$排序，在数组$a$中二分查找$b_i$的最近邻，记录差的绝对值最小的一对的下标$i,j$，最后把$a_i$和$a_j$交换使这一对在同一位置。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">SORT</span>(a);</span><br><span class="line">    ll mindif=INF,idxa=<span class="number">-1</span>,idxb=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(a),b[i]);</span><br><span class="line">        <span class="keyword">if</span>(it!=a.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="built_in">abs</span>(b[i]-*it);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;mindif)</span><br><span class="line">            &#123;</span><br><span class="line">                mindif=t;</span><br><span class="line">                idxa=i;</span><br><span class="line">                idxb=it-a.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(it!=a.<span class="built_in">begin</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            it--;</span><br><span class="line">            t=<span class="built_in">abs</span>(b[i]-*it);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;mindif)</span><br><span class="line">            &#123;</span><br><span class="line">                mindif=t;</span><br><span class="line">                idxa=i;</span><br><span class="line">                idxb=it-a.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[idxa],a[idxb]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; a[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-心绪的解剖"><a href="#C-心绪的解剖" class="headerlink" title="C.心绪的解剖"></a>C.心绪的解剖</h1><p><strong>思维</strong></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个数$x$，问$x$是否可以表示为$3$个斐波那契数之和。<br>其中，斐波那契数指的是斐波那契数列$0,1,1,2,3,5\cdots$ 中的数。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>预处理$N$以内斐波那契数列，每次二分找到恰小于等于$x$的数，然后$x$减去这个数。<br>三次之后，如果$x$为$0$，则可以表示。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preFeb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Feb.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    Feb.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(Feb.<span class="built_in">back</span>()&lt;=<span class="number">1e10</span>)&#123;</span><br><span class="line">        Feb.<span class="built_in">pb</span>(Feb[Feb.<span class="built_in">size</span>()<span class="number">-1</span>]+Feb[Feb.<span class="built_in">size</span>()<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;cin &gt;&gt; x;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(<span class="number">3</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = --<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(Feb),x);</span><br><span class="line">        ans[i] = *it;</span><br><span class="line">        x -= *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-友谊的套路"><a href="#D-友谊的套路" class="headerlink" title="D.友谊的套路"></a>D.友谊的套路</h1><p><strong>2签</strong></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>在五局三胜的游戏中，一方先胜$2$场，另一方再胜$3$场逆袭，这种情况叫做“让二追三”。<br>已知小红的胜率为$p$，求让二追三的概率。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>分小红让二追三和小红被让二追三两种情况。</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ld p;cin &gt;&gt; p;</span><br><span class="line">    ld np=<span class="number">1</span>-p;</span><br><span class="line">    ld ans=p*p*np*np*np+np*np*p*p*p;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-未来的预言"><a href="#E-未来的预言" class="headerlink" title="E.未来的预言"></a>E.未来的预言</h1><p><strong>思维</strong></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定一个形如“BOx”的字符串，表示进行$x$局的游戏（$x$为奇数），赢得更多场次的队伍获胜。<br>另给一个字符串，表示每局胜利的队伍。</p><p>问第几局已经确定了胜负，或是还未确定。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>数数</p><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getnum</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        ret*=<span class="number">10</span>;</span><br><span class="line">        ret+=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ts;cin &gt;&gt; ts;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    ll tn=<span class="built_in">getnum</span>(ts); tn/=<span class="number">2</span>;</span><br><span class="line">    ll cntR=<span class="number">0</span>,cntP=<span class="number">0</span>;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>) cntR++;</span><br><span class="line">        <span class="keyword">else</span> cntP++;</span><br><span class="line">        <span class="keyword">if</span>(cntR&gt;tn)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;kou!&quot;</span> &lt;&lt; endl &lt;&lt; i+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cntP&gt;tn)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;yukari!&quot;</span> &lt;&lt; endl &lt;&lt; i+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;to be continued.&quot;</span> &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-命运的抉择"><a href="#F-命运的抉择" class="headerlink" title="F.命运的抉择"></a>F.命运的抉择</h1><p><strong>思维</strong></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n$的数组，把它分成非空的两部分$a,b$，使得从$a,b$中分别任取一个元素$a_i,b_j$，它们互质$gcd(a_i,b_j)=1$</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>先在$a$中放置一个数，开一个set记录$a$中已存在的质数因子。</p><p>在剩余的数字中多次扫描，一旦某个数$x$能被$a$中的质数因子整除，就把它放入$a$中，直到某次扫描没有加入新的数字。<br>剩余的数字作为$b$。</p><p>时间复杂度比较抽象//</p><h2 id="参考程序-5"><a href="#参考程序-5" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">GetFac</span><span class="params">(ll x)</span></span>&#123;<span class="comment">//返回x的质因数集合</span></span><br><span class="line">    vector&lt;ll&gt; ret;</span><br><span class="line">    ll i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[x])&#123;<span class="comment">//check[i]==1表示i是合数</span></span><br><span class="line">            <span class="keyword">if</span>(x%prime[i]==<span class="number">0</span>)&#123;<span class="comment">//prime是质数表</span></span><br><span class="line">                ret.<span class="built_in">pb</span>(prime[i]);</span><br><span class="line">                <span class="keyword">while</span>(x%prime[i]==<span class="number">0</span>) x/=prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; ret.<span class="built_in">pb</span>(x); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; vFac;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">push_back</span>(t);</span><br><span class="line">        vFac.<span class="built_in">push_back</span>(<span class="built_in">GetFac</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;ll&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sa</span><span class="params">(n,<span class="number">0</span>)</span></span>;<span class="comment">//放入集合a</span></span><br><span class="line">    sa[<span class="number">0</span>]=<span class="number">1</span>; t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vFac[<span class="number">0</span>]) st.<span class="built_in">insert</span>(x);<span class="comment">//将第一个数的质因数放入集合</span></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        t=<span class="number">0</span>;<span class="comment">//t表示本轮是否有数放入集合a</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(sa[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vFac[i]) <span class="keyword">if</span>(st.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">                sa[i]=<span class="number">1</span>; t++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:vFac[i]) st.<span class="built_in">insert</span>(y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; a,b;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(sa[i]) a.<span class="built_in">pb</span>(v[i]); <span class="keyword">else</span> b.<span class="built_in">pb</span>(v[i]);</span><br><span class="line">    <span class="keyword">if</span>(b.<span class="built_in">size</span>()==<span class="number">0</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll na=a.<span class="built_in">size</span>(),nb=b.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; na &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; nb &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,na<span class="number">-1</span>) cout &lt;&lt; a[i] &lt;&lt; <span class="built_in">Presentation</span>(i,na<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,nb<span class="number">-1</span>) cout &lt;&lt; b[i] &lt;&lt; <span class="built_in">Presentation</span>(i,nb<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-人生的起落"><a href="#G-人生的起落" class="headerlink" title="G.人生的起落"></a>G.人生的起落</h1><p><strong>构造</strong></p><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>形如$(a,b,a),a\gt b$的三元组称为“v-三元组”。<br>构造一个长度为$n$，和为$S$，且恰好有$k$个“v-三元组”的正整数数组。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>限定正整数，“v-三元组”至少为$(2,1,2)$。<br>依此开局特判：</p><ol><li>$n&lt;k*2+1$：k个“v-三元组”最少需要$2k+1$个数。</li><li>$S&lt;n+k+1$：k个“v-三元组”最少需要$k+1$个$2$，其余为$1$，和至少为$n+k+1$。</li></ol><p>构造方法是，先在最前的$k+1$个奇数位上放置尽可能大的数，然后在剩余的位置上放置$1$。若还有多余的数，放在第$k+1$个奇数位（$k*2+1$）上。</p><p>若$n$恰好等于$k*2+1$，则将多余的数放置在偶数位上，但偶数位上的数不能超过奇数位上的数。</p><h2 id="参考程序-6"><a href="#参考程序-6" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,S,k;cin &gt;&gt; n &gt;&gt; S &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) cout &lt;&lt; S/<span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; S-S/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; S-n+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>*k+<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(k&amp;&amp;S&lt;n+k+<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    ll t=(S-(n-(k+<span class="number">1</span>)))/(k+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; ans;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        ans.<span class="built_in">pb</span>(t);</span><br><span class="line">        ans.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">        S-=t+<span class="number">1</span>;</span><br><span class="line">    &#125;ans.<span class="built_in">pb</span>(t); S-=t;</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;=n)&#123;</span><br><span class="line">        t=S/(n/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n/<span class="number">2</span><span class="number">-1</span>)&#123;</span><br><span class="line">            ans[i*<span class="number">2</span>+<span class="number">1</span>]+=t;</span><br><span class="line">            S-=t;</span><br><span class="line">        &#125;</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(S)&#123;</span><br><span class="line">            ans[t*<span class="number">2</span>+<span class="number">1</span>]++;</span><br><span class="line">            S--;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span>&amp;&amp;ans[<span class="number">1</span>]&gt;=ans[<span class="number">0</span>]) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t=ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&lt;n)&#123;</span><br><span class="line">            ans.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">            S--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[t]+=S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i==n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-时空的交织"><a href="#I-时空的交织" class="headerlink" title="I.时空的交织"></a>I.时空的交织</h1><p><strong>贪心</strong></p><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>给定$n$个数的数组$a$和$m$个数的数组$b$，表示一个$n\times m$的矩阵，矩阵中的元素$m_{i,j}=a_i*b_j$。<br>选择一个子矩阵，使得子矩阵中的元素之和最大，输出这个和。</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设选定的矩阵区间为$(r<em>i,r_j):(c_i,c_j)$，则子矩阵的和为$\sum</em>{i=r<em>i}^{r_j}\sum</em>{j=c<em>i}^{c_j}a_i*b_j=\sum</em>{i=r<em>i}^{r_j}a_i*\sum</em>{j=c_i}^{c_j}b_j$。</p><p>问题转化为求$a$数组的一个非空连续子数组和乘上$b$数组的一个非空连续子数组和的最大值。</p><p>可为空的数组区间和的最大值可以贪心的求解：</p><ol><li>用$cur$表示对当前区间和，$max$表示区间和的最大值。</li><li>将当前元素$a_i$加入区间，和当前最大值比较。</li><li>若当前区间和$cur&lt;0$，则舍弃之前的区间，重新开始计算（$cur:=0$）。</li></ol><p>本题中的区间要求非空，可以用最值修正。</p><p>此外，$a$数组和$b$数组的元素可以为负数，因此同时求出区间和的最大值和最小值，两两相乘取最大即可。</p><h2 id="参考程序-7"><a href="#参考程序-7" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,m);</span><br><span class="line">    ll mxa,mxb,mna,mnb,curmn,curmx;</span><br><span class="line">    mxa=mxb=-INF; mna=mnb=INF;</span><br><span class="line">    curmn=curmx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn+=a[i];</span><br><span class="line">        curmx+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(curmn&gt;<span class="number">0</span>) curmn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(curmx&lt;<span class="number">0</span>) curmx=<span class="number">0</span>;</span><br><span class="line">        mna=<span class="built_in">min</span>(mna,curmn);</span><br><span class="line">        mxa=<span class="built_in">max</span>(mxa,curmx);</span><br><span class="line">    &#125;</span><br><span class="line">    curmn=curmx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn+=b[i];</span><br><span class="line">        curmx+=b[i];</span><br><span class="line">        <span class="keyword">if</span>(curmn&gt;<span class="number">0</span>) curmn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(curmx&lt;<span class="number">0</span>) curmx=<span class="number">0</span>;</span><br><span class="line">        mnb=<span class="built_in">min</span>(mnb,curmn);</span><br><span class="line">        mxb=<span class="built_in">max</span>(mxb,curmx);</span><br><span class="line">    &#125;</span><br><span class="line">    curmn=INF; curmx=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn=<span class="built_in">min</span>(curmn,a[i]);</span><br><span class="line">        curmx=<span class="built_in">max</span>(curmx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curmx&lt;=<span class="number">0</span>) mxa=<span class="built_in">min</span>(mxa,curmx);</span><br><span class="line">    <span class="keyword">if</span>(curmn&gt;=<span class="number">0</span>) mna=<span class="built_in">max</span>(mna,curmn);</span><br><span class="line">    curmn=INF; curmx=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn=<span class="built_in">min</span>(curmn,b[i]);</span><br><span class="line">        curmx=<span class="built_in">max</span>(curmx,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curmx&lt;=<span class="number">0</span>) mxb=<span class="built_in">min</span>(mxb,curmx);</span><br><span class="line">    <span class="keyword">if</span>(curmn&gt;=<span class="number">0</span>) mnb=<span class="built_in">max</span>(mnb,curmn);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(&#123;mna*mnb,mna*mxb,mxa*mnb,mxa*mxb&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-时空的交织"><a href="#J-时空的交织" class="headerlink" title="J.时空的交织"></a>J.时空的交织</h1><p><strong>贪心、构造</strong></p><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>给定一棵有根树，若干个节点为红色。<br>为每个节点赋值$1$或$2$，使得每个以红色节点为根的子树，其节点值之和为$3$的倍数。</p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于每个红色节点，如果它没有白色子节点，则它的子树除它以外的和已经是$3$的倍数，它为$1$或$2$都不可能再使它的子树和为$3$的倍数。</p><p>如果它至少有1个白色子节点，则它和白色子节点可以配合使得它的子树和为$3$的倍数。</p><p>因此，按DFS逆序遍历，白色节点先赋值为$1$。若红色节点除其本身外，和不是$3$的倍数，则用它补上；否则将任一白色子节点改为$2$，它赋为$2$。</p><h2 id="参考程序-8"><a href="#参考程序-8" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;ll&gt; vDFS_rev;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) <span class="built_in">DFS</span>(y);</span><br><span class="line">    vDFS_rev.<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n; G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    bitset&lt;N&gt; red;<span class="comment">//red[i]表示第i个节点是否为红色</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) red[i+<span class="number">1</span>]=(s[i]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">white</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//white[i]表示第i个节点下的某一白色节点，0表示没有</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t; G[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(white[t]==<span class="number">0</span>&amp;&amp;!red[i]) white[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(white[i]==<span class="number">0</span>&amp;&amp;red[i]) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;<span class="comment">//红色节点下必须有白色节点</span></span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>);<span class="comment">//获取逆DFS序列</span></span><br><span class="line">    ll S[N]=&#123;<span class="number">0</span>&#125;,ans[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vDFS_rev)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) S[x]+=S[y];</span><br><span class="line">        <span class="keyword">if</span>(red[x])&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[x]%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[x]=<span class="number">2</span>; S[x]+=<span class="number">3</span>;</span><br><span class="line">                ans[white[x]]=<span class="number">2</span>; S[white[x]]+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S[x]%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                ans[x]=<span class="number">2</span>; S[x]+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[x]=<span class="number">1</span>; S[x]+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[x]=<span class="number">1</span>;</span><br><span class="line">            S[x]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024牛客寒假06</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024牛客寒假" scheme="https://www.cclmsy.cc/tags/2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024牛客寒假05</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Winter_NCD05.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Winter_NCD05.html</id>
    <published>2024-02-20T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-mutsumi的质数合数"><a href="#A-mutsumi的质数合数" class="headerlink" title="A.mutsumi的质数合数"></a>A.mutsumi的质数合数</h1><p><strong>1签</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个正整数集合，问其中质数和合数的个数之和。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>正整数中只有$1$既不是质数也不是合数，总数减去$1$的个数即为答案</p><p>(P.S.)：有人这题WA了4发。。。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t,cnt=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>) cnt++;</span><br><span class="line">    &#125;cout &lt;&lt; n-cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-anon的私货"><a href="#C-anon的私货" class="headerlink" title="C.anon的私货"></a>C.anon的私货</h1><p><strong>贪心</strong></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n$的正整数序列，可以在其中任意位置插入$0$。<br>在保证除全$0$外的任意子序列的平均值大于$1$的条件下最多可以插入多少个$0$。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目可以转换为：对于每个数字，两边插入的$0$的个数之和不大于它。</p><p>贪心的，先从左往右扫描，对于每个数字，尽量往左插入$0$，<br>第$i$个数字$a_i$左边插入$0$的个数记为$pl_i$。</p><p>最左边的数字$a_1$可以往左插入$a_1-1$个$0$，<br>后面的数字$a_i$允许往左插入$0$的个数$pl_i$被限制为以下两个值的最小值：</p><ol><li>$a_i-1$：$a_i$左边插入的数量最多为$a_i-1$</li><li>$a<em>{i-1}-1-pl</em>{i-1}$：$a<em>{i-1}$两边插入的数量$pl</em>{i-1}+pl<em>i&lt;=a</em>{i-1}-1$</li></ol><p>接着，从右往左扫描，对于每个数字，尽量往右插入$0$，类比上面的过程。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pl</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">//pl[i]表示第i个位置左边的空当，pl[n]表示最右端</span></span><br><span class="line">    pl[<span class="number">0</span>]=v[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">    pl[n]=v[n<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        pl[i]=<span class="built_in">min</span>(v[i<span class="number">-1</span>]<span class="number">-1</span>-pl[i<span class="number">-1</span>],v[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        pl[i]=<span class="built_in">min</span>(&#123;v[i]<span class="number">-1</span>-pl[i+<span class="number">1</span>],v[i<span class="number">-1</span>]<span class="number">-1</span>,pl[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n) ans+=pl[i];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) ans=v[<span class="number">0</span>]<span class="number">-1</span>;<span class="comment">//特判</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-soyorin的数组操作（easy）"><a href="#E-soyorin的数组操作（easy）" class="headerlink" title="E.soyorin的数组操作（easy）"></a>E.soyorin的数组操作（easy）</h1><p><strong>贪心</strong></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n$的数组，每次可以选定一个$n$以内的偶数$k$，使得$a_1$到$a_k$这$k$个数的值都增加它们的下标。<br>问任意次操作后能否使得数组不严格单调递增。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果$n$为偶数，每次选中全数组都可以使相邻两个数之差（后一个减前一个）增加$1$，显然必定可以使得数组递增。</p><p>如果$n$为奇数。<br>从后往前遍历，对于每个偶数位置$i$，在满足$a<em>i&lt;=a</em>{i+1}$的前提下使其最大。<br>这样做可以保证，在合法的情况下，这个数减前面的数最大。</p><p>同时记录操作次数，同步到前面的元素。</p><p>最后判断数组是否有序。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123; cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;<span class="comment">//偶数个数，直接YES</span></span><br><span class="line"></span><br><span class="line">    ll cur=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n<span class="number">-2</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        v[i]+=cur*(i+<span class="number">1</span>);</span><br><span class="line">        v[i<span class="number">-1</span>]+=cur*i;<span class="comment">//同步更新左边的值</span></span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;v[i+<span class="number">1</span>])&#123; cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="comment">//v[i+1]已经是满足条件下最大的值了。如果还是小于v[i]，那么就不可能满足条件了</span></span><br><span class="line">        t=(v[i+<span class="number">1</span>]-v[i])/(i+<span class="number">1</span>);</span><br><span class="line">        v[i]+=t*(i+<span class="number">1</span>);</span><br><span class="line">        v[i<span class="number">-1</span>]+=t*i;</span><br><span class="line">        cur+=t; i--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>) <span class="keyword">if</span>(v[i]&gt;v[i+<span class="number">1</span>])&#123; cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GH-sakiko的排列构造（easy-hard）"><a href="#GH-sakiko的排列构造（easy-hard）" class="headerlink" title="GH.sakiko的排列构造（easy+hard）"></a>GH.sakiko的排列构造（easy+hard）</h1><p><strong>构造</strong></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个正整数$n$，构造一个$n$的排列$p$，使得$p_i+i$全为质数</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑一段连续的数字$[l,r]$，如果两端之和$l+r$是质数，那么把这段数字倒过来，与原来的数字序列对应相加，将得到$r-l+1$个质数$r+l$。</p><p>先确定右端点$r=n$，从后往前寻找一个左端点$l$，使得$l+r$为质数，再将这个区间的数字序列倒过来放入这个区间。</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Phi_and_Prime_Table</span>(<span class="number">2</span>*n+<span class="number">2</span>);<span class="comment">//预处理质数表，数据区间有限暴力判断也可</span></span><br><span class="line">    ll r=n;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check[i+r])&#123;<span class="comment">//check[i+r]==0表示i+r是质数</span></span><br><span class="line">            <span class="built_in">FORLL</span>(j,i,r) ans[j]=r+i-j;</span><br><span class="line">            r=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; ans[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-rikki的最短路"><a href="#I-rikki的最短路" class="headerlink" title="I.rikki的最短路"></a>I.rikki的最短路</h1><p><strong>思维</strong></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>在一条数轴上，你在原点$O$，$A$在$a$处，$T$在$t$处，你的视线区间为$k$。<br>你先去找$T$。</p><p>如果路上看到$A$，先去找$A$，再去找$T$。<br>如果路上没看到$A$，先去去找$T$，再去找$A$，再去找$T$。</p><p>问最短路程。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>分类讨论</p><ol><li>$t&gt;=0$：$T$在原点右边，去找$T$可以看到的区间为$[-k,t+k]$<ol><li>$A$在$[-k,0]$：先去找$A$，再去找$T$，最短路程为$t+2|a|=t-2a$</li><li>$A$在$[0,t]$：路上把$A$捡走，再去找$T$，最短路程为$t$</li><li>$A$在$[t,t+k]$：先去找$T$，再去找$A$，再去找$T$，合并到其他情况</li><li>其他：先去找$T$，再去找$A$，再去找$T$，最短路程为$t+2|a-t|$</li></ol></li><li>$t&lt;0$：$T$在原点左边，类比即可</li></ol><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t,a,k;cin &gt;&gt; t &gt;&gt; a &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=-k&amp;&amp;a&lt;=t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;=<span class="number">0</span>) cout &lt;&lt; t-a*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; t+<span class="built_in">abs</span>(t-a)*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=t&amp;&amp;a&lt;=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">0</span>) cout &lt;&lt; a*<span class="number">2</span>-t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; -t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; -t+<span class="built_in">abs</span>(t-a)*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-rikki的数组陡峭值"><a href="#J-rikki的数组陡峭值" class="headerlink" title="J.rikki的数组陡峭值"></a>J.rikki的数组陡峭值</h1><p><strong>贪心</strong></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>长度为$n$的数组，每个元素$a_i$限定在一个区间$[l_i,r_i]$内。</p><p>定义陡峭值为每对相邻元素的差的绝对值之和$\sum\limits<em>{i=1}^{n-1}|a</em>{i+1}-a_i|$，求陡峭值的最小值。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>从前往后遍历。</p><p>如果$[l_i,r_i]$和当前区间有交集，那么都取交集内的数字，陡峭值为$0$。<br>如果$[l_i,r_i]$和当前区间没有交集，那么取两个区间的边界，将当前区间退化成一点。<br>退化后，改为用前一点和区间作比。在区间外，取区间边界。</p><h2 id="参考程序-5"><a href="#参考程序-5" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>+<span class="number">5</span>,pre=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll tl,tr;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tl &gt;&gt; tr;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;<span class="comment">//当前为一区间</span></span><br><span class="line">            <span class="keyword">if</span>(tr&lt;=l||tl&gt;=r)&#123;<span class="comment">//元素a_i区间与当前区间不相交</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(tr&lt;=l)&#123;</span><br><span class="line">                    ans+=<span class="built_in">abs</span>(l-tr);</span><br><span class="line">                    pre=tr;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans+=<span class="built_in">abs</span>(tl-r);</span><br><span class="line">                    pre=tl;</span><br><span class="line">                &#125;<span class="comment">//区间退化</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tl&gt;=l) l=tl;</span><br><span class="line">                <span class="keyword">if</span>(tr&lt;=r) r=tr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前为一点</span></span><br><span class="line">            <span class="keyword">if</span>(tl&lt;=pre&amp;&amp;tr&gt;=pre) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(tl&gt;=pre)&#123;</span><br><span class="line">                ans+=<span class="built_in">abs</span>(tl-pre);</span><br><span class="line">                pre=tl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr&lt;=pre)&#123;</span><br><span class="line">                ans+=<span class="built_in">abs</span>(pre-tr);</span><br><span class="line">                pre=tr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="K-soyorin的通知"><a href="#K-soyorin的通知" class="headerlink" title="K.soyorin的通知"></a>K.soyorin的通知</h1><p><strong>完全背包</strong></p><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>你要通知$n$个人。你通知1个人花费$p$，第$i$个人通知$a_i$个人花费$b_i$。问最少花费。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先你至少需要通知$1$个人，才能使他们相互传递通知。<br>再让这个人去通知其他人，以此传递，直到其他$n-1$个人都被通知到。<br>把$a_i$看作容量，$b_i$看作价值，每个人可以选多次，问题转化为求最小价值完全背包问题。<br>DP前，也要把自己作为$a=1,b=q$的物品加入，因为自己也可以单独通知多个人。</p><h2 id="参考程序-6"><a href="#参考程序-6" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,p,t;cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">cost</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">val</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; cost[i] &gt;&gt; val[i];</span><br><span class="line">    cost[<span class="number">0</span>]=p;val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INF)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">            t=j+val[i]&gt;n<span class="number">-1</span>?n<span class="number">-1</span>:j+val[i];</span><br><span class="line">            dp[t]=<span class="built_in">min</span>(dp[t],dp[j]+cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n<span class="number">-1</span>]+p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="L-rikki的星星"><a href="#L-rikki的星星" class="headerlink" title="L.rikki的星星"></a>L.rikki的星星</h1><p><strong>2签</strong></p><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>进行$n$局游戏，赢一局$+1$分，输一局$-1$分，没有平局。</p><p>游戏结束后分数为$x$，问赢多少局输多少局，或是无解。</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>赢一局和输一局的分差为$2$，因此最终得分和局数的奇偶性一定相同。</p><p>记赢了$a$局，则：$a+(n-a)=x$，解得$a=\dfrac{x+n}{2}$。</p><h2 id="参考程序-7"><a href="#参考程序-7" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x;cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span>((x+n)%<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (x+n)/<span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (n-x)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="M-rikki的排列连通"><a href="#M-rikki的排列连通" class="headerlink" title="M.rikki的排列连通"></a>M.rikki的排列连通</h1><p><strong>贪心</strong></p><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>给定$2$个$n$的排列，置入$2\times n$的矩阵。<br>每次操作可以消掉同一数字所在的方块。</p><p>问最少操作多少次可以把矩阵分为没有相邻边的两部分（及以上）。</p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>以下是几种合法的情况：</p><ol><li>某个数字在两个排列中的位置相同，且两边都有数字，消除它即可，答案为$1$。</li><li>某个数字在两个排列中的位置相差$1$，交叉的部分一定有数字，消除它即可，答案为$1$。</li><li>每个数字在两个排列中的位置都至少相差$2$，选择同一位置的两个数字消除，答案为$2$。</li></ol><p>特判是<code>n=1,&#123;1&#125;,&#123;1&#125;</code>、<code>n=2,&#123;1,2&#125;,&#123;1,2&#125;</code>、<code>n=2,&#123;2,1&#125;,&#123;2,1&#125;</code>。<br>第一种情况中，某个数字在两个排列中都位于最左或都位于最右，这个数字不能计入答案。</p><h2 id="参考程序-8"><a href="#参考程序-8" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t; cin &gt;&gt; n;</span><br><span class="line">    ll mndif=INF;<span class="comment">//最小差值</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pos</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    pos.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        pos[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;pos[t]==<span class="number">1</span>) ;<span class="comment">//最左</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==n&amp;&amp;pos[t]==n) ;<span class="comment">//最右</span></span><br><span class="line">        <span class="keyword">else</span> mndif=<span class="built_in">min</span>(mndif,<span class="built_in">abs</span>(i-pos[t]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;mndif&gt;<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(mndif&lt;<span class="number">2</span>) &#123;cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024牛客寒假05</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024牛客寒假" scheme="https://www.cclmsy.cc/tags/2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024牛客寒假04</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Winter_NCD04.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Winter_NCD04.html</id>
    <published>2024-02-18T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-柠檬可乐"><a href="#A-柠檬可乐" class="headerlink" title="A.柠檬可乐"></a>A.柠檬可乐</h1><p><strong>1签</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>第一行输入三个整数$a,b,k$，判断是否$a\ge k\times b$</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如题</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,k;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=b*k) cout &lt;&lt; <span class="string">&quot;good\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;bad\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-左右互博"><a href="#B-左右互博" class="headerlink" title="B.左右互博"></a>B.左右互博</h1><p><strong>思维</strong></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有$n$堆石子，每堆石子有$a_i$个，两个人轮流取操作。<br>每次操作可以选择一堆至少有$2$个石子的石子堆，然后任意分成两堆，每堆至少有一个石子。<br>最先无法操作的人输。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于有$x$个石子的石堆，它被分成$x$堆一个石子的石堆，需要操作$x-1$次。<br>因此，对所有石堆的操作次数求和 $sum = \sum\limits_{i=1}^{n}a_i-1$。<br>判断奇偶性</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ans+=t<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;gui&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;sweet&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-冬眠"><a href="#C-冬眠" class="headerlink" title="C.冬眠"></a>C.冬眠</h1><p><strong>模拟</strong></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定$n\times m$的字符矩阵和一段有$q$次操作的操作序列，包含两种操作：</p><ol><li><code>1 t</code>表示将第$t$行向右移动$1$次，最右的一个字符移到最左的位置。</li><li><code>2 t</code>表示将第$t$列向下移动$1$次，最下的一个字符移到最上的位置。<br>问最后的字符矩阵第$x$行第$y$列的字符是什么</li></ol><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>数据范围不大，模拟操作</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,x,y;cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    x--;y--;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">mp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; mp[i];</span><br><span class="line">    ll p,q;cin &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">op</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,q<span class="number">-1</span>) cin &gt;&gt; op[i].first &gt;&gt; op[i].second;</span><br><span class="line">    <span class="type">char</span> tc;</span><br><span class="line">    <span class="keyword">while</span>(p--)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,q<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[i].first==<span class="number">1</span>)&#123;<span class="comment">//行向右循环移动一次</span></span><br><span class="line">                tc=mp[op[i].second<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">FORLL_rev</span>(j,m<span class="number">-1</span>,<span class="number">1</span>) mp[op[i].second<span class="number">-1</span>][j]=mp[op[i].second<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                mp[op[i].second<span class="number">-1</span>][<span class="number">0</span>]=tc;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//列向下循环移动一次</span></span><br><span class="line">                tc=mp[n<span class="number">-1</span>][op[i].second<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">FORLL_rev</span>(j,n<span class="number">-1</span>,<span class="number">1</span>) mp[j][op[i].second<span class="number">-1</span>]=mp[j<span class="number">-1</span>][op[i].second<span class="number">-1</span>];</span><br><span class="line">                mp[<span class="number">0</span>][op[i].second<span class="number">-1</span>]=tc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; mp[x][y] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-守恒"><a href="#D-守恒" class="headerlink" title="D.守恒"></a>D.守恒</h1><p><strong>数学</strong></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定$n$个正整数，可以将它们的和重新分配为$n$个正整数。<br>求所有分配方法中，这$n$个数的最大公约数有多少种可能性。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>先对所有数求和，记为$sum$。<br>假设这$n$个数的最大公约数为$g$，则$g$一定是$sum$的因子。<br>且因为这$n$个数至少都为$g$，所以$sum/g\ge n$。</p><p>$O(\sqrt(n))$遍历$sum$的因子，判断是否满足条件</p><p>注意特判：当$n=1$时，答案为$1$</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll sum=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) &#123;cin &gt;&gt; t;sum+=t;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;<span class="comment">//特判</span></span><br><span class="line">    ll ub=<span class="built_in">sqrt</span>(sum)+<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i*i&gt;sum) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum%i==<span class="number">0</span>)&#123;</span><br><span class="line">            t=sum/i;</span><br><span class="line">            <span class="keyword">if</span>(t==i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;=n) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;=n) ans++;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=n) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-漂亮数组"><a href="#E-漂亮数组" class="headerlink" title="E.漂亮数组"></a>E.漂亮数组</h1><p><strong>思维</strong></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n$的整数数组$a$和一个正整数$k$。<br>可以将$a$划分成任意个非空子串，如果子串和能被$k$整除，则称这个子串是漂亮的。<br>求 使得漂亮子串最多的方案 得到的漂亮子串的个数。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>从前往后遍历，计算（从上个割点开始的）前缀和对$k$的余数$pre$。<br>如果当前位置的前缀和余数$pre_i$在上个割点之后的位置$j$有出现过，即$pre_i=pre_j$，则子串$[j+1,i]$区间和能被$k$整除。</p><p>因此，我们可以记录每个前缀和对$k$的余数在上个割点之后是否出现过，贪心的求出最多的漂亮子串个数。</p><p>时间复杂度：$O(n)$</p><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k,t;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//余数为0即空</span></span><br><span class="line">    ll sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        sum+=t;</span><br><span class="line">        <span class="keyword">if</span>(mp[sum%k])&#123;<span class="comment">//如果当前 前缀和对k的余数在上个割点之后出现过</span></span><br><span class="line">            ans++;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            mp.<span class="built_in">clear</span>();<span class="comment">//清空map</span></span><br><span class="line">            mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mp[sum%k]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-数三角形（easy）"><a href="#G-数三角形（easy）" class="headerlink" title="G.数三角形（easy）"></a>G.数三角形（easy）</h1><p><strong>计数</strong></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>将<code>*</code>看作实体，<code>.</code>看作空白，等腰三角形具有类似以下的形状且不可旋转：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一阶：</span><br><span class="line">.*.</span><br><span class="line">*** </span><br><span class="line"></span><br><span class="line">二阶：</span><br><span class="line"><span class="string">..</span>*<span class="string">..</span></span><br><span class="line">.*.*.</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">三阶：</span><br><span class="line"><span class="string">...</span>*<span class="string">...</span></span><br><span class="line"><span class="string">..</span>*.*<span class="string">..</span></span><br><span class="line">.*<span class="string">...</span>*.</span><br><span class="line">*******</span><br></pre></td></tr></table></figure></p><p>以此类推，给定一个$n\times m$的字符矩阵，求有多少个等腰三角形</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>枚举三角形的顶点，然后向两边延展，判断是否满足条件。</p><p>对于底边，如果每次都从左往右扫描，则时间复杂度较高。<br>可以预处理每一个<code>*</code>在该行连续最左的<code>*</code>的位置，使用时直接查询$O(1)$判断。</p><h2 id="参考程序-5"><a href="#参考程序-5" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    <span class="type">char</span> mp[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//字符矩阵</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m) cin &gt;&gt; mp[i][j];</span><br><span class="line">    ll pre[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//预处理</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[i][j<span class="number">-1</span>]) pre[i][j]=pre[i][j<span class="number">-1</span>];<span class="comment">//如果当前位置是*，且左边有*，则pre[i][j]等于左边的*的位置</span></span><br><span class="line">                <span class="keyword">else</span> pre[i][j]=j;<span class="comment">//否则pre[i][j]等于当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pre[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FORLL(i,1,n) FORLL(j,1,m) cout &lt;&lt; pre[i][j] &lt;&lt; &quot; \n&quot;[j==m];//test</span></span><br><span class="line">    ll ans=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m) <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        ll l=j<span class="number">-1</span>,r=j+<span class="number">1</span>,d=i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//d表示当前底边所在的行，l和r表示底边的两个端点位置</span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">1</span>&amp;&amp;r&lt;=m&amp;&amp;d&lt;=n&amp;&amp;mp[d][l]==<span class="string">&#x27;*&#x27;</span>&amp;&amp;mp[d][r]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre[d][r]&lt;=l) t=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t) ans++;</span><br><span class="line">            l--;r++;d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024牛客寒假04</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024牛客寒假" scheme="https://www.cclmsy.cc/tags/2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024牛客寒假03</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Winter_NCD03.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Winter_NCD03.html</id>
    <published>2024-02-06T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-智乃与瞩目狸猫、幸运水母、月宫龙虾"><a href="#A-智乃与瞩目狸猫、幸运水母、月宫龙虾" class="headerlink" title="A.智乃与瞩目狸猫、幸运水母、月宫龙虾"></a>A.智乃与瞩目狸猫、幸运水母、月宫龙虾</h1><p><strong>1签</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目分享了一个冷知识：<br>Ubuntu 发行版的每个代号都包含一个形容词和一个动物。例如：瞩目狸猫(Focal Fossa)、幸运水母(Jammy Jellyfish)、月宫龙虾(Lunar Lobster)，每个代号的两个单词首字母相同。<br>现在给定两个字符串，问首字母是否相同（忽略大小写）。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接比较首字母即可。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">if</span>(s1[<span class="number">0</span>]==s2[<span class="number">0</span>]||s1[<span class="number">0</span>]<span class="number">-32</span>==s2[<span class="number">0</span>]||s1[<span class="number">0</span>]+<span class="number">32</span>==s2[<span class="number">0</span>]) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-智乃的数字手串"><a href="#B-智乃的数字手串" class="headerlink" title="B.智乃的数字手串"></a>B.智乃的数字手串</h1><p><strong>博弈、猜结论</strong></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有一串首尾相连的数字，两个玩家轮流操作。<br>当且仅当相邻$2$个数字之和为偶数时，可以消除其中一个，<br>然后<strong>可以</strong>交换剩下的数字中任意两个数字的位置（也可以不交换）。<br>特别的，如果只有$1$个数字，可以直接消除。<br>最先无法操作的玩家输。<br>问对于给定的数字串，qcjj（先手）和zn（后手）谁会赢。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑游戏结束时的状态：手串上的数字排布为<code>奇偶奇偶...奇偶</code>，特点是数量为偶数。<br>数量为奇数时，一定存在两个相邻的数，奇偶校验相同（和为偶数）。</p><p>判断原始数字串长度的奇偶性即可。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;qcjj&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;zn&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-chino’s-bubble-sort-and-maximum-subarray-sum-easy-version"><a href="#D-chino’s-bubble-sort-and-maximum-subarray-sum-easy-version" class="headerlink" title="D.chino’s bubble sort and maximum subarray sum(easy version)"></a>D.chino’s bubble sort and maximum subarray sum(easy version)</h1><p><strong>最大子段和</strong></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n$的数组$a$，求恰好执行“交换任意相邻元素”操作$k$次后，数组$a$的最大非空子段和。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于easy version的$k$范围极小（$k\in [0,1]$），暴力枚举所有情况求最大非空子段和即可。</p><p>对于最大非空字段和的求法，可以用贪心方法：<br>记$cur$为：包含当前位置元素的最大子段和。<br>从$a_2$开始遍历数组，记当前元素为$a_i$，则当前最大子段和有$2$种情况：</p><ol><li>将当前位置的元素加入当前最大子段和，值为$cur+a_i$；</li><li>以当前位置的元素为起点，重新开始计算最大子段和，值为$a_i$。</li></ol><p>每个位置的$cur$取这$2$种情况的较大值，每个位置$cur$的最大值即为最大非空子段和。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll ans=-INF,cur;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        vector&lt;ll&gt; tv;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">            tv=v;</span><br><span class="line">            <span class="built_in">swap</span>(tv[i],tv[i+<span class="number">1</span>]);</span><br><span class="line">            ll tans=tv[<span class="number">0</span>];</span><br><span class="line">            cur=tv[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                cur=<span class="built_in">max</span>(tv[j],cur+tv[j]);</span><br><span class="line">                tans=<span class="built_in">max</span>(tans,cur);</span><br><span class="line">            &#125;ans=<span class="built_in">max</span>(ans,tans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//求原数组的最大子段和</span></span><br><span class="line">        ans=v[<span class="number">0</span>];</span><br><span class="line">        cur=v[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cur=<span class="built_in">max</span>(v[i],cur+v[i]);</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GH-智乃的比较函数-easy-normal"><a href="#GH-智乃的比较函数-easy-normal" class="headerlink" title="GH.智乃的比较函数(easy+normal)"></a>GH.智乃的比较函数(easy+normal)</h1><p><strong>偏序</strong></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定$3$个数字的$n$对关系<code>x y z</code>，$z=1$表示$x\lt y$；$z=0$表示$x\ge y$。<br>问这$n$对关系是否存在逻辑矛盾。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于只有$3$个数字，可以直接暴力赋值，验证是否有情况可以满足所有关系。<br>时间复杂度：$O(3^3n)$</p><p>赛时本人直接对给定的关系集进行判断，会很麻烦，需要注意很多细节；<br>还有大佬用Floyd算法求偏序关系//%%%</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;array&lt;ll,3&gt;&gt; cmp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pending</span><span class="params">(array&lt;ll,<span class="number">4</span>&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y,o]:cmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="number">1</span>) &#123; <span class="keyword">if</span>(a[x]&gt;=a[y]) <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">if</span>(a[x]&lt;a[y]) <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//判断是否满足所有关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y,o;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cmp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; o;</span><br><span class="line">        cmp.<span class="built_in">pb</span>(&#123;x,y,o&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">FORLL</span>(k,<span class="number">1</span>,<span class="number">3</span>) ans|=<span class="built_in">pending</span>(&#123;<span class="number">0</span>,i,j,k&#125;);</span><br><span class="line">    <span class="comment">//存在满足所有关系的情况即可</span></span><br><span class="line">    cout &lt;&lt; (ans?YES:NO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-智乃的相亲活动"><a href="#J-智乃的相亲活动" class="headerlink" title="J.智乃的相亲活动"></a>J.智乃的相亲活动</h1><p><strong>建图、概率论</strong></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>有$n$名男嘉宾和$m$名女嘉宾，异性之间存在$k$对双向的好感关系。<br>每位男嘉宾和女嘉宾都会从ta喜欢的异性中均匀随机的选择一个，<br>被至少选中一次的嘉宾称为“心动嘉宾”。<br>求本次相亲活动中，心动男嘉宾和女嘉宾的期望数量。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>建图：对每对好感关系，建立一条从男嘉宾到女嘉宾的无向边。<br>对于任一嘉宾$i$：<br>ta喜欢的每位嘉宾被ta选中的概率为$\frac{1}{deg<em>i}$；<br>ta成为心动嘉宾的概率为$1-\prod</em>{j\in like_i}(1-\frac{1}{deg_j})$，其中$like_i$为ta喜欢的嘉宾集合（因为好感关系为双向）。</p><p>分别求出每位嘉宾成为心动嘉宾的概率，再对男女嘉宾分别求和即可。</p><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+m+<span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">deg</span><span class="params">(n+m+<span class="number">1</span>)</span></span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;  </span><br><span class="line">        G[u].<span class="built_in">pb</span>(n+v);</span><br><span class="line">        G[n+v].<span class="built_in">pb</span>(u);</span><br><span class="line">        deg[u]++;</span><br><span class="line">        deg[n+v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ansn,ansm,t;</span><br><span class="line">    ansn=ansm=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:G[i])&#123;</span><br><span class="line">            <span class="built_in">multo</span>(t,<span class="built_in">mdiv</span>(deg[x]<span class="number">-1</span>,deg[x]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ansn,<span class="built_in">sub</span>(<span class="number">1</span>,t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,n+<span class="number">1</span>,n+m)&#123;</span><br><span class="line">        t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:G[i])&#123;</span><br><span class="line">            <span class="built_in">multo</span>(t,<span class="built_in">mdiv</span>(deg[x]<span class="number">-1</span>,deg[x]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ansm,<span class="built_in">sub</span>(<span class="number">1</span>,t));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;modint&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ansn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ansm &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="K-智乃的“黑红树”"><a href="#K-智乃的“黑红树”" class="headerlink" title="K.智乃的“黑红树”"></a>K.智乃的“黑红树”</h1><p><strong>数据结构</strong></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>定义“黑红树”满足以下条件：</p><ol><li>一棵以黑色节点$1$为根的二叉树</li><li>每个节点只能有$0$或$2$个子节点。</li><li>黑色节点的子节点只能是红色；红色节点的子节点只能是黑色。</li></ol><p>给定黑红节点的数量$a,b$，构造一棵黑红树。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据定义$1,2$，黑色节点的个数必须为奇数，红色节点的个数必须为偶数，因此$a$必须为奇数，$b$必须为偶数。<br>根据定义$3$，节点颜色将由节点的深度决定。</p><p>在满二叉树的情况下：</p><ol><li>如果最后一层是黑色节点，则节点数满足$a=2*b+1$</li><li>如果最后一层是红色节点，则节点数满足$b=2*a$</li></ol><p>利用这两个关系，可以再排除不合法的情况，剩余的情况都可以构造。</p><p>本人选用的构造方法为：按照层序遍历顺序铺设节点，直到节点数达到要求。</p><h2 id="参考程序-5"><a href="#参考程序-5" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ub=a+b;</span><br><span class="line">    <span class="keyword">if</span>((a%<span class="number">2</span>==<span class="number">0</span>)||b%<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="comment">//奇偶性不符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(b&gt;<span class="number">2</span>*a||a<span class="number">-1</span>&gt;<span class="number">2</span>*b)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="comment">//节点数超出临界值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ll i=<span class="number">2</span>,st=<span class="number">1</span>,ed=<span class="number">1</span>;a--;</span><br><span class="line">    <span class="comment">//[st,ed]为上一层的节点范围，i为当前节点编号</span></span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">son</span><span class="params">(ub+<span class="number">5</span>,pll(<span class="number">-1</span>,<span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(a||b)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,st,ed)&#123;<span class="comment">//铺设红色节点</span></span><br><span class="line">            <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            son[j]=<span class="built_in">pll</span>(i,i+<span class="number">1</span>);</span><br><span class="line">            i+=<span class="number">2</span>;b-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st=ed+<span class="number">1</span>;ed=i<span class="number">-1</span>;<span class="comment">//更新本层的节点范围</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,st,ed)&#123;<span class="comment">//铺设黑色节点</span></span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(son[j].first==<span class="number">-1</span>)&#123;</span><br><span class="line">                son[j]=<span class="built_in">pll</span>(i,i+<span class="number">1</span>);</span><br><span class="line">                i+=<span class="number">2</span>;a-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st=ed+<span class="number">1</span>;ed=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub) cout &lt;&lt; son[i].first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; son[i].second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LM-智乃的36倍数-easy-normal"><a href="#LM-智乃的36倍数-easy-normal" class="headerlink" title="LM.智乃的36倍数(easy+normal)"></a>LM.智乃的36倍数(easy+normal)</h1><p><strong>模数</strong></p><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给定$n$个$10^{18}$范围内的非负整数。<br>求在其中取不同的$2$个元素，拼接起来后能被$36$整除的方案数。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设$a$和$b$拼接，拼接后的数记为$c=a\times10^k+b$，其中$k$为$b$的位数。<br>可以发现：</p><script type="math/tex; mode=display">c\\\%36=(a\times10^k+b)\\\%36 =(a\times10^k)\\\%36+b\\\%36 =(a\\\%36)\times(10^k\\\%36)+b\\\%36</script><p>因此，预处理$10^k\\%36$的值，记录每个数对$36$的余数及其位数。<br>计算时，枚举每个数作为右半部分$b$，此时$k$也被确定为$b$的位数，<br>只需枚举左半部分$a$的余数，对满足条件的部分求和即可。</p><h2 id="参考程序-6"><a href="#参考程序-6" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; DM;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;<span class="comment">//预处理10^k%36</span></span><br><span class="line">    ll t=<span class="number">1</span>;</span><br><span class="line">    DM.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">19</span>)&#123;</span><br><span class="line">        t*=<span class="number">10</span>;</span><br><span class="line">        DM.<span class="built_in">pb</span>(t%<span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dig</span><span class="params">(ll x)</span></span>&#123;<span class="comment">//求位数</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123; x/=<span class="number">10</span>; ret++; &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll t;pll tp;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    vector&lt;pll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        tp=<span class="built_in">make_pair</span>(t%<span class="number">36</span>,<span class="built_in">dig</span>(t));</span><br><span class="line">        v.<span class="built_in">pb</span>(tp);</span><br><span class="line">        mp[t%<span class="number">36</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v)&#123;</span><br><span class="line">        t=x.second;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">35</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i*DM[t]+x.first)%<span class="number">36</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=mp[i];</span><br><span class="line">                <span class="keyword">if</span>(i==x.first) ans--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024牛客寒假03</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024牛客寒假" scheme="https://www.cclmsy.cc/tags/2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024牛客寒假02</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Winter_NCD02.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Winter_NCD02.html</id>
    <published>2024-02-04T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Tokitsukaze-and-Bracelet"><a href="#A-Tokitsukaze-and-Bracelet" class="headerlink" title="A.Tokitsukaze and Bracelet"></a>A.Tokitsukaze and Bracelet</h1><p><strong>1签</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>装备有$a,b,c$三个值，每个值分别对应一个强化等级，求装备的总强化等级。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据每项数值判断强化等级，然后求和即可。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">150</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">200</span>) ans+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;<span class="number">32</span>&amp;&amp;b&lt;<span class="number">41</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b&gt;<span class="number">42</span>) ans+=<span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span>(c&gt;<span class="number">32</span>&amp;&amp;c&lt;<span class="number">41</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;<span class="number">42</span>) ans+=<span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Tokitsukaze-and-Cats"><a href="#B-Tokitsukaze-and-Cats" class="headerlink" title="B.Tokitsukaze and Cats"></a>B.Tokitsukaze and Cats</h1><p><strong>模拟</strong></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>上场关鸡，这场关猫//<br>有$n$只猫，在$(n,m)$大小的矩阵中，每只猫占据一个格子，坐标给定。<br>每只猫的四面需要围上围栏，求需要多少根围栏。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>模拟，一只一只放入，根据已经放入的猫的位置，判断需要增加多少根围栏。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> v[<span class="number">305</span>][<span class="number">305</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll x,y,cnt;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x<span class="number">-1</span>][y<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;v[x<span class="number">-2</span>][y<span class="number">-1</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;n&amp;&amp;v[x][y<span class="number">-1</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;<span class="number">1</span>&amp;&amp;v[x<span class="number">-1</span>][y<span class="number">-2</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;m&amp;&amp;v[x<span class="number">-1</span>][y]) cnt++;</span><br><span class="line">        <span class="keyword">switch</span>(cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: ans+=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: ans+=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: ans+=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: ans+=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Tokitsukaze-and-Slash-Draw"><a href="#D-Tokitsukaze-and-Slash-Draw" class="headerlink" title="D.Tokitsukaze and Slash Draw"></a>D.Tokitsukaze and Slash Draw</h1><p><strong>图论</strong></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>有一堆$n$张卡牌的牌堆。<br>有$m$种操作，第$i$种操作可以将牌堆顶的前$a_i$张卡牌按原本的顺序放置在牌堆底，代价为$b_i$.<br>求将牌堆<strong>从下往上数</strong>第$k$张卡牌放到牌堆顶的最小代价。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>将牌堆看作一个有向图，$n$个位置代表$n$个节点。<br>第$i$种操作可以看作从每个顶点引出一条指向向后$a_i$个节点的边，边权为$b_i$。<br>求从第$n-k$个节点（从上往下数）到第$0$个节点的最短路即可。<br>由于总边数来到了$mn=5\times10^6$，最短路算法可以用$O(m\log n)$的Dijkstra。</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  ll v, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  ll dis, u;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">ll dis[N], vis[N];</span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(ll n, ll s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ll u = q.<span class="built_in">top</span>().u;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            ll v = ed.v, w = ed.w;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    ll a,b,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n) e[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) e[i].<span class="built_in">push_back</span>((edge)&#123;(i+a)%n,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dis[n-k]==INF) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dis[n-k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-F-Tokitsukaze-and-Eliminate-easy-hard"><a href="#E-F-Tokitsukaze-and-Eliminate-easy-hard" class="headerlink" title="E.F.Tokitsukaze and Eliminate(easy+hard)"></a>E.F.Tokitsukaze and Eliminate(easy+hard)</h1><p><strong>贪心</strong></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>$n$个宝石排成一排，第$i$个宝石的颜色为$col_i$<br>每次操作可以任选一种颜色，消除这种颜色的最右端的宝石和它右边的所有宝石。<br>问最少需要多少次操作才能消除所有宝石。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心，从右往左扫描，直到从当前位置到最右端。<br>这一区间内的宝石，包含了当前剩余的所有颜色，操作消除。<br>当前剩余颜色可在读入时处理前缀和</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt; v,sc;<span class="comment">//sc[i]记录位置i之前出现过的颜色数量</span></span><br><span class="line">    v.<span class="built_in">pb</span>(<span class="number">0</span>);sc.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">pb</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(mp[t]==<span class="number">0</span>) &#123;sc.<span class="built_in">pb</span>(sc[i<span class="number">-1</span>]+<span class="number">1</span>);mp[t]++;&#125;</span><br><span class="line">        <span class="keyword">else</span> sc.<span class="built_in">pb</span>(sc[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    t=<span class="number">0</span>;<span class="comment">//t记录当前的颜色数量</span></span><br><span class="line">    ll r=n,ans=<span class="number">0</span>;<span class="comment">//r记录当前剩余宝石数量</span></span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[v[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">            t++;</span><br><span class="line">            mp[v[i]]=<span class="number">1</span>;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==sc[r])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            t=<span class="number">0</span>;mp.<span class="built_in">clear</span>();</span><br><span class="line">            r=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-Tokitsukaze-and-Power-Battle-esay"><a href="#G-Tokitsukaze-and-Power-Battle-esay" class="headerlink" title="G.Tokitsukaze and Power Battle (esay)"></a>G.Tokitsukaze and Power Battle (esay)</h1><p><strong>数据结构</strong></p><h2 id="题意-esay-version"><a href="#题意-esay-version" class="headerlink" title="题意 (esay version)"></a>题意 (esay version)</h2><p>有一个长度为$n$的<strong>非负</strong>整数数组，有$q$次操作：</p><ol><li><code>1 i x</code>：将第$i$个数改为$x$</li><li><code>2 l r</code>：查询区间$[l,r]$内，每个长度不小于$2$的<strong>子区间</strong>，任意分成连续两段后，<code>左段之和减去右段之和</code>的最大值。</li></ol><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>实现单点修改、区间查询的数据结构，可以选用线段树或树状数组（本人采用树状数组）。<br>根据贪心的思想，由于数组非负，要最大化<code>左段之和减去右段之和</code>，子区间的左端点选定查询区间的左端点。<br>从右往左枚举右端点，并在分段时，右段只需留下一个数即可。</p><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))<span class="comment">//取最后一个1所在位置的权值</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BITree</span>&#123;<span class="comment">//树状数组，下标i从1开始</span></span><br><span class="line">    vector&lt;ll&gt; Data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BITree</span><span class="params">(ll n)</span>:Data(n*<span class="number">2</span>+<span class="number">5</span>,<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll i,ll dif)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//给予i增量dif,维护树状数组，O(logn)</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;Data.<span class="built_in">size</span>())&#123;</span><br><span class="line">            Data[i]+=dif;</span><br><span class="line">            i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">presum</span><span class="params">(ll i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//查询前缀和sum[i]，O(logn)</span></span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            sum+=Data[i];</span><br><span class="line">            i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll l,ll r)</span></span>&#123;<span class="comment">//查询区间和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">presum</span>(r)-<span class="built_in">presum</span>(l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,Q,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="function">BITree <span class="title">bt</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        bt.<span class="built_in">update</span>(i,t);<span class="comment">//维护原数组，实现单点修改，区间查询</span></span><br><span class="line">    &#125;<span class="comment">//建树</span></span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        ll l,r;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            r=r-bt.<span class="built_in">query</span>(l,l);</span><br><span class="line">            bt.<span class="built_in">update</span>(l,r);</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans=-INF;</span><br><span class="line">            <span class="built_in">FORLL_rev</span>(i,r,l+<span class="number">1</span>)&#123;<span class="comment">//枚举右端点</span></span><br><span class="line">                <span class="keyword">if</span>(ans&gt;=bt.<span class="built_in">query</span>(l,i)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//优化：如果当前答案已经大于接下来的区间前缀和，则不必再继续枚举</span></span><br><span class="line">                ans=<span class="built_in">max</span>(ans,bt.<span class="built_in">query</span>(l,i<span class="number">-1</span>)-bt.<span class="built_in">query</span>(i,i));</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-Tokitsukaze-and-Short-Path-plus"><a href="#I-Tokitsukaze-and-Short-Path-plus" class="headerlink" title="I.Tokitsukaze and Short Path (plus)"></a>I.Tokitsukaze and Short Path (plus)</h1><p><strong>思维</strong></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给定一个有$n$个点的完全图（每两点之间有一条边），每个点$i$具有点权$a<em>i$。<br>每两个点之间的边权为这两点点权<strong>较大</strong>的值的2倍。<br>求每两个点之间的最短路之和：$\sum\limits</em>{i=1}^{n}\sum\limits_{j=1}^{n}dist(i,j)$</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>$n\le 2e5$ 的数据范围，首先排除建图暴算</p><p>对于任意两点$u,v$：<br>假设$u&gt;v$，那么$e(u,v)$（$u,v$之间的直接边）的权值为$2a_u$。<br>除$u$之外的任意点$w$，$e(u,w)$的权值为$2max{a_u,a_w}\ge a_u$，因此经过任意点$w$再到$u$的路径都不会比$e(u,v)$更短。<br>因此，对于任意两点$u,v$，$e(u,v)$是$u$到$v$的最短路。</p><p>对所有点权升序排序，点权的位次也是这个点权对答案贡献的次数。<br>时间复杂度：$O(n)$</p><h2 id="参考程序-5"><a href="#参考程序-5" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) ans+=v[i]*i;</span><br><span class="line">    cout &lt;&lt; ans*<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//*4的含义：边权有系数2；每两个点互相到达要计算2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-Tokitsukaze-and-Short-Path-minus"><a href="#J-Tokitsukaze-and-Short-Path-minus" class="headerlink" title="J.Tokitsukaze and Short Path (minus)"></a>J.Tokitsukaze and Short Path (minus)</h1><p><strong>思维</strong></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给定一个有$n$个点的完全图（每两点之间有一条边），每个点$i$具有点权$a<em>i$。<br>每两个点之间的边权为这两点点权<strong>较小</strong>的值的2倍。<br>求每两个点之间的最短路之和：$\sum\limits</em>{i=1}^{n}\sum\limits_{j=1}^{n}</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于任意两点$u,v$：<br>假设$u&lt;v$，那么$e(u,v)$（$u,v$之间的直接边）的权值为$2a_v$。<br>又假设$u,v$都不是点权最小的点，对于图中点权最小的点$w$，$u\rightarrow v\rightarrow w$的路径长度为$4a_w$（两条边）。<br>那么$dist(u,v)=min{4a_w,2a_v}$<br>因此，每个点为$min{2a_w,a_v}$在对答案做贡献</p><p>对所有点权降序排序，点权的位次也是这个点（$min{2a_w,a_v}$）对答案贡献的次数</p><h2 id="参考程序-6"><a href="#参考程序-6" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    ll mn=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mn=<span class="built_in">min</span>(mn,t);</span><br><span class="line">        v.<span class="built_in">pb</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) ans+=<span class="built_in">min</span>(mn*<span class="number">2</span>,v[i])*(n-i<span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; ans*<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//*4的含义：边权有系数2；每两个点互相到达要计算2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="K-Tokitsukaze-and-Password-easy"><a href="#K-Tokitsukaze-and-Password-easy" class="headerlink" title="K.Tokitsukaze and Password (easy)"></a>K.Tokitsukaze and Password (easy)</h1><p><strong>暴力</strong></p><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n$的字符串$x$，其中包含数字、小写字母和下划线‘_’，用来表示一个纯数字密码。<br>密码满足以下条件：</p><ol><li>密码没有前导$0$</li><li>密码可以被$8$整除</li><li>给定另一个长度为$n$的数字$y$，保证$x\lt y$</li><li>每种字母表示$[0,9]$中的一个，且不同字母表示的数字必定不同</li><li>每一位下划线‘_’都可以表示$[0,9]$中的任意一个数字，下划线上的数字不必相同</li></ol><p>求可能成为密码的数量</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于easy version的数据范围极小，暴力枚举判断是否满足条件即可<br>(srd有点考验耐心细心qwq)</p><h2 id="参考程序-7"><a href="#参考程序-7" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ll n,y;</span><br><span class="line">string sx;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ub;<span class="comment">//记录待定字符的取值上界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pending</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vk)</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(sx[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(sx[<span class="number">0</span>])&amp;&amp;vk[sx[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sx[<span class="number">0</span>]==<span class="string">&#x27;_&#x27;</span>&amp;&amp;vk[<span class="number">4</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不含前导0</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">3</span>) <span class="keyword">if</span>(ub[i])</span><br><span class="line">        <span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(ub[j]&amp;&amp;vk[i]==vk[j]) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不同字母取值不同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:sx)&#123;</span><br><span class="line">        x*=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) x+=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(c)) x+=vk[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x+=vk[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">8</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不是8的倍数</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//大于y</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sy;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">    y=<span class="built_in">stoll</span>(sy);</span><br><span class="line">    ub.<span class="built_in">clear</span>();</span><br><span class="line">    ub.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:sx) <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:ub[<span class="number">0</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:ub[<span class="number">1</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:ub[<span class="number">2</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:ub[<span class="number">3</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;_&#x27;</span>:ub[<span class="number">4</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vk;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(a,<span class="number">0</span>,ub[<span class="number">0</span>]) <span class="built_in">FORLL</span>(b,<span class="number">0</span>,ub[<span class="number">1</span>]) <span class="built_in">FORLL</span>(c,<span class="number">0</span>,ub[<span class="number">2</span>]) <span class="built_in">FORLL</span>(d,<span class="number">0</span>,ub[<span class="number">3</span>]) <span class="built_in">FORLL</span>(e,<span class="number">0</span>,ub[<span class="number">4</span>])&#123;</span><br><span class="line">        vk.<span class="built_in">clear</span>();</span><br><span class="line">        vk.<span class="built_in">pb</span>(a);vk.<span class="built_in">pb</span>(b);vk.<span class="built_in">pb</span>(c);vk.<span class="built_in">pb</span>(d);vk.<span class="built_in">pb</span>(e);</span><br><span class="line">        ans+=<span class="built_in">pending</span>(vk);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024牛客寒假02</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024牛客寒假" scheme="https://www.cclmsy.cc/tags/2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87/"/>
    
  </entry>
  
  <entry>
    <title>题解|2024牛客寒假01</title>
    <link href="https://www.cclmsy.cc/posts/ACM_2024Winter_NCD01.html"/>
    <id>https://www.cclmsy.cc/posts/ACM_2024Winter_NCD01.html</id>
    <published>2024-02-01T16:00:00.000Z</published>
    <updated>2024-07-30T07:52:14.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-DFS搜索"><a href="#A-DFS搜索" class="headerlink" title="A.DFS搜索"></a>A.DFS搜索</h1><p><strong>1签</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目字面意思，问能不能在长度为 $n$ 的字符串 $s$ 中找到子序列”DFS”和”dfs”；</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接暴力搜索<br>时间复杂度 $O(n)$</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,s1,s2;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s1=<span class="string">&quot;DFS&quot;</span>;s2=<span class="string">&quot;dfs&quot;</span>;</span><br><span class="line">    <span class="type">int</span> cnt1,cnt2;cnt1=cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1&lt;<span class="number">3</span>&amp;&amp;c==s1[cnt1]) cnt1++;</span><br><span class="line">        <span class="keyword">if</span>(cnt2&lt;<span class="number">3</span>&amp;&amp;c==s2[cnt2]) cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt1&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">1</span>; <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>; cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt2&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">1</span>; <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>; cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-关鸡"><a href="#B-关鸡" class="headerlink" title="B.关鸡"></a>B.关鸡</h1><p><strong>模拟</strong></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有一条宽为$2$，长为$2*10^9+1$的管道，每个格子的坐标标记为$(x,y)$，$x\in[-10^9,10^9],y\in [1,2]$<br>管道内有$n$个障碍，给定障碍的坐标<br>鸡哥在$(0,1)$处，可以上下左右移动，但不能穿过障碍<br>求最少还需多少个障碍物才能使鸡哥被困在管道内无法到达管道两端</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>将管道两排看作两侧，如果某处有障碍（下图红），只要它的另一侧相邻的位置中有一个有障碍（下图黄）即可堵住管道：<br><img src="/images/ACM/2024Winter_NCD01_B.png" alt="alt text"><br>换个角度，从管道左端到右端，对于每个障碍，check它对面且与它的$x$距离不大于$1$的位置是否有障碍，即可确定是否堵住管道。</p><p>要把鸡哥困在管道内，需要把鸡哥两侧管道全都堵住。</p><p>对于鸡哥的一侧管道，如果：<br>  没有堵住，没有障碍，则需放置$2$个障碍；<br>  没有堵住，至少有$1$个障碍，则需放置$1$个障碍；<br>  已经堵住，则不需要放置障碍。</p><p>特别的，和鸡哥直接相邻的3个位置如果都有障碍，鸡哥就直接被困住了。</p><h2 id="参考程序-1"><a href="#参考程序-1" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> f,fl,fr; f=fl=fr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v)&#123;</span><br><span class="line">        cin &gt;&gt; x.second &gt;&gt; x.first; <span class="comment">// 为了方便排序，将x轴坐标放在前面</span></span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">-1</span>&amp;&amp;x.second==<span class="number">1</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">0</span>&amp;&amp;x.second==<span class="number">2</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">1</span>&amp;&amp;x.second==<span class="number">1</span>) f++;<span class="comment">//和鸡哥直接相邻的障碍数</span></span><br><span class="line">        <span class="keyword">if</span>(x.first&lt;=<span class="number">0</span>) fl=<span class="number">1</span>;<span class="comment">//鸡哥左侧有障碍</span></span><br><span class="line">        <span class="keyword">if</span>(x.first&gt;=<span class="number">0</span>) fr=<span class="number">1</span>;<span class="comment">//鸡哥右侧有障碍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    <span class="type">int</span> ffl,ffr;ffl=ffr=<span class="number">0</span>;<span class="comment">//记录左右两侧是否被堵住</span></span><br><span class="line">    deque&lt;pll&gt; dq;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>()&amp;&amp;v[i].first-dq.<span class="built_in">front</span>().first&gt;<span class="number">1</span>) dq.<span class="built_in">pop_front</span>();<span class="comment">//dq只保存[x-1,x]内的障碍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:dq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.second!=v[i].second)&#123;<span class="comment">//如果有不同侧的障碍即堵住管道</span></span><br><span class="line">                <span class="keyword">if</span>(v[i].first&lt;=<span class="number">0</span>) ffl=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> ffr=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;dq.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">3</span>-f;<span class="comment">//直接围堵鸡哥</span></span><br><span class="line">    <span class="keyword">if</span>(ffl&amp;&amp;ffr) ans=<span class="built_in">min</span>(ans,<span class="number">0ll</span>);<span class="comment">//左右两侧都被堵住，无需添加</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ffl&amp;&amp;fr||fl&amp;ffr) ans=<span class="built_in">min</span>(ans,<span class="number">1ll</span>);<span class="comment">//一侧被堵住，另一侧有障碍，需要添加1个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ffl||ffr) ans=<span class="built_in">min</span>(ans,<span class="number">2ll</span>);<span class="comment">//一侧被堵住，另一侧无障碍，需要添加2个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fl&amp;&amp;fr) ans=<span class="built_in">min</span>(ans,<span class="number">2ll</span>);<span class="comment">//两侧没被堵住，但有障碍，需要添加2个</span></span><br><span class="line">    <span class="comment">//其余情况不如直接围堵鸡哥</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-按闹分配"><a href="#C-按闹分配" class="headerlink" title="C.按闹分配"></a>C.按闹分配</h1><p><strong>贪心</strong></p><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>$n$个人在$1$个窗口前排队办事，第$i$个人办事需要时间$t_i$<br>开始为$0$时刻，每个人的不满意度$D_i$为其办完事的时刻$D_i$<br>工作人员安排队伍顺序使得所有人的不满意度之和 $S=\sum D_i$ 最小</p><p>你也来办事，需要时间$t_c$。你可以插队，但是因此增加的不满意度之和不能超过$M$<br>问你最早什么时候能办完事</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据贪心的思想，初始使得不满意度之和最小的排序是按照$t_i$从小到大排序<br>你插队导致的不满意度之和的增量为：你插队的位置之后的人数*你的办事时间<br>因此你后面的人数不得超过 $M/t_c$ 个<br>在这个约束下计算前缀和即可</p><h2 id="参考程序-2"><a href="#参考程序-2" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Q,tc,M;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q &gt;&gt; tc;</span><br><span class="line">    <span class="built_in">create_vec</span>(t,n);</span><br><span class="line">    <span class="built_in">SORT</span>(t);</span><br><span class="line">    vector&lt;ll&gt; St;</span><br><span class="line">    St.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) St.<span class="built_in">pb</span>(St.<span class="built_in">back</span>()+t[i]);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin &gt;&gt; M;</span><br><span class="line">        ll x=M/tc;</span><br><span class="line">        ll pl=<span class="built_in">max</span>(<span class="number">0ll</span>,n-x);</span><br><span class="line">        cout &lt;&lt; St[pl]+tc &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-数组成鸡"><a href="#D-数组成鸡" class="headerlink" title="D.数组成鸡"></a>D.数组成鸡</h1><p><strong>思维</strong></p><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n$的整数数组，每次操作可以使所有元素都$+1$或都$-1$。<br>$Q$次询问，问任意次操作后能否使数组所有元素的乘积等于给定的数$M$（$-1e9\le M \le 1e9$）。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>询问的$M$范围不大，所以数组稍微长一点儿，就很可能溢出$1e9$的范围。</p><p>由于元素都是整数，若数组中绝对值大于$1$的元素的个数超过$20$个，那么乘积的绝对值最小为$2^20$，超过$1e9$。</p><p>枚举出现过的数字$x_i$，再向$x_i$两边枚举它附近的数字$t$，使全数组$-t$，然后直接计算数组的乘积进行$check$。<br>当乘积的绝对值已经超过$1e9$，即出现最多$20$个绝对值大于$1$的元素时，直接判不合法，$check$枚举的元素个数是比较少的。<br>若最终乘积的绝对值不大于$1e9$，则加入答案集合。</p><p>询问时在答案中二分查找即可。</p><h2 id="参考程序-3"><a href="#参考程序-3" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Q,t;cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    set&lt;ll&gt; ans; ans.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    set&lt;ll&gt; exi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        exi.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll x) -&gt; <span class="type">bool</span>&#123;</span><br><span class="line">        ll tt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:a)&#123;</span><br><span class="line">            tt*=y+x;</span><br><span class="line">            <span class="keyword">if</span>(tt==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(tt)&gt;<span class="number">1e9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;ans.<span class="built_in">insert</span>(tt);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:exi)&#123;</span><br><span class="line">        t=-x<span class="number">-1</span>; <span class="keyword">while</span>(<span class="built_in">check</span>(t)) t--;</span><br><span class="line">        t=-x+<span class="number">1</span>; <span class="keyword">while</span>(<span class="built_in">check</span>(t)) t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">count</span>(t)) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-本题又主要考察了贪心"><a href="#E-本题又主要考察了贪心" class="headerlink" title="E.本题又主要考察了贪心"></a>E.本题又主要考察了贪心</h1><p><strong>DFS、诈骗</strong></p><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>$n$个人参加比赛，当前第$i$个人已经得到了$a_i$分，接下来还有$m$轮比赛<br>每轮两个人PK,赢的人$+3$分；平局则每人$+1$分<br>给定$m$轮比赛的名单，问$1$号选手能取得的最高名次</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接贪心很难贪（反正我是贪不出来）<br>由于人数和局数很少，直接DFS到每种结局，找到最优解即可<br>时间复杂度：$O(3^m)$</p><h2 id="参考程序-4"><a href="#参考程序-4" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pll&gt; q; <span class="comment">//记录每轮比赛的参赛选手</span></span><br><span class="line">ll n,m,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;ll&gt; a,ll i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==m)&#123;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:a) <span class="keyword">if</span>(x&gt;a[<span class="number">0</span>]) cnt++;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; aa=a,ab=a,ac=a;</span><br><span class="line">    aa[q[i].first<span class="number">-1</span>]+=<span class="number">3</span>;<span class="comment">//a赢</span></span><br><span class="line">    <span class="built_in">DFS</span>(aa,i+<span class="number">1</span>);</span><br><span class="line">    ab[q[i].second<span class="number">-1</span>]+=<span class="number">3</span>;<span class="comment">//b赢</span></span><br><span class="line">    <span class="built_in">DFS</span>(ab,i+<span class="number">1</span>);</span><br><span class="line">    ac[q[i].first<span class="number">-1</span>]+=<span class="number">1</span>;<span class="comment">//平局</span></span><br><span class="line">    ac[q[i].second<span class="number">-1</span>]+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">DFS</span>(ac,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans=INF;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cin &gt;&gt; x;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        q.<span class="built_in">pb</span>(&#123;u,v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(a,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-鸡数题！"><a href="#F-鸡数题！" class="headerlink" title="F.鸡数题！"></a>F.鸡数题！</h1><p><strong>概率论-排列组合</strong></p><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>将$n$位的最大二进制数$111\cdots 1$（n个1）的每一位$1$分配给$m$个数，且每个数都不为$0$，问有多少种分配方案</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>$n$个不同的球放入$m$个不同的盒子，每个盒子至少一个球，有多少种放法<br>答案为第二类斯特林数$S(n,m)$<br>通项公式：$S(n,m)=\sum\limits_{i=0}^m\dfrac{(-1)^{m-i}\times i^n}{i!\times (m-i)!}$</p><h2 id="参考程序-5"><a href="#参考程序-5" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ll pown[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        pown[i]=<span class="built_in">qcpow</span>(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Prepare_Factorium</span>(m);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        ll t=<span class="built_in">mul</span>(pown[i],<span class="built_in">mul</span>(Fac_inv[i],Fac_inv[m-i]));</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>) t=MOD-t;</span><br><span class="line">        <span class="built_in">addto</span>(ans,t);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-why买外卖"><a href="#G-why买外卖" class="headerlink" title="G.why买外卖"></a>G.why买外卖</h1><p><strong>贪心</strong></p><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>有$n$张外卖券，第$i$张满$a_i$减$b_i$，$a_i$为餐品原价。<br>所有券可以叠加使用，你手上有$m$元，问你最多可以购买到原价为多少的餐品</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设餐品原价为$x$，则所有$a_i&lt;x$的券都可以使用。<br>根据使用门槛$a_i$对券排序，对减免部分做前缀和。<br>在每个门槛处计算：该门槛需支付的价格$x$（或溢出的优惠）=当前门槛-减免金额<br>如果$x$小于$m$，则更新答案，当前门槛下最高餐品价格为$m+减免金额$</p><h2 id="参考程序-6"><a href="#参考程序-6" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">vp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vp) cin &gt;&gt; x.first &gt;&gt; x.second;</span><br><span class="line">    <span class="built_in">SORT</span>(vp);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">S</span><span class="params">(n+<span class="number">1</span>)</span></span>;S[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) S[i]=S[i<span class="number">-1</span>]+vp[i<span class="number">-1</span>].second;</span><br><span class="line">    ll ans=m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vp[i<span class="number">-1</span>].first-S[i]&lt;=m)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,S[i]+m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-01背包，但是bit"><a href="#H-01背包，但是bit" class="headerlink" title="H.01背包，但是bit"></a>H.01背包，但是bit</h1><p><strong>位运算</strong></p><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>有$n$个物品，第$i$个物品的价值为$v_i$，重量为$w_i$，每个物品只有一个。<br>选定物品的重量之和定义为这些物品各自重量的“或”和，即$w=w_1|w_2|w_3|\cdots|w_c$；价值之和定义为这些物品各自重量的初等代数和：$v=\sum v_i$<br>问选定物品的重量之和不超过$m$的情况下，价值之和的最大值</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>或运算的性质：有$1$出$1$，全$0$出$0$。</p><p>把所有“重量”看作二进制。</p><p>假设选定物品后结果为$x$，那么$x$的每个$1bit$的位置，一定有某个被选中的物品的重量在该位上是$1bit$。</p><p>枚举所有允许出现$1$的位置的所有情况。<br>将$m$的某一$1bit$置$0$，则该位的低位可以任意取值，高位不变。<br>如$m=1010000B$，将第二个$1bit$置$0$，则$1bit$的合法位置变为$1001111$。<br>确定了$1bit$的合法位置，那每个物品只能是选或不选。<br>遍历$m$的所有$1bit$，计算将其置$0$的情况：遍历所有物品，应选尽选。<br>取所有情况的最大值。</p><h2 id="参考程序-7"><a href="#参考程序-7" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; v,w;</span><br><span class="line">ll n,m,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span>((w[i]&amp;x)==w[i])</span><br><span class="line">            t+=v[i];</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; ans=<span class="number">0</span>;</span><br><span class="line">    v.<span class="built_in">resize</span>(n); w.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">29</span>) <span class="keyword">if</span>(m&amp;(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">        <span class="built_in">Update</span>((m^(<span class="number">1</span>&lt;&lt;i))|((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//m^(1&lt;&lt;i)：m的第i位置0</span></span><br><span class="line">        <span class="comment">//(1&lt;&lt;i)-1：低i位全1</span></span><br><span class="line">    &#125;<span class="built_in">Update</span>(m);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-It’s-bertrand-paradox-Again"><a href="#I-It’s-bertrand-paradox-Again" class="headerlink" title="I.It’s bertrand paradox. Again!"></a>I.It’s bertrand paradox. Again!</h1><p><strong>概率论</strong></p><h2 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h2><p>现在有两种在$x\in [-100,100],y\in [-100,100]$平面范围内生成（圆心在整点上且半径为整数的）圆形的算法（仅第3步不同）：</p><ol><li>均匀随机生成一个 $(-100,100)$ 内的整点 $(x,y)$</li><li>均匀随机生成一个 $[1,100]$ 内的整数半径 $r$</li></ol><p>bit的检验：不满足在范围内，返回第2步，即仅重新生成$r$<br>buaa的检验：不满足在范围内，返回第1步，即重新生成一个圆</p><p>现在给出其中某个算法的生成 $10^5$ 个圆的结果，问是由哪个算法生成的</p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>两种算法下，生成结果的圆心和半径的分布是不同的。<br>明显bit的方法圆心是均匀分布在平面内的，而buaa的方法不是。</p><p>根据抽样分布原理，大量独立同分布随机变量和的极限分布是正态分布。<br>因此对样本建立统计量，使得两种算法下，该统计量有显著不同即可。<br>此处建立的统计量$U$为：圆心到原点的距离的均值$A(\sqrt{x^2+y^2})$。<br>用两种算法生成样本，暴算得到$U<em>{buaa}\approx56，U</em>{bit}\approx 75$。</p><h2 id="参考程序-8"><a href="#参考程序-8" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        sum+=<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;sum/=n;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">65</span>) cout &lt;&lt; <span class="string">&quot;buaa-noob&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;bit-noob&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-又鸟之亦心"><a href="#J-又鸟之亦心" class="headerlink" title="J.又鸟之亦心"></a>J.又鸟之亦心</h1><p><strong>思维</strong></p><h2 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h2><p>两个人分别在数轴的$x,y$位置。<br>接下来$n$天，第$i$天必须从两人中选择一人到$a_i$的位置。<br>记这$n$天内两人最远的距离为$D$，决策使得$D$最小，求这个最小的$D$</p><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>二分答案$D$，判断是否存在一种决策使得两人最远距离不超过$D$。</p><p>忽略两人的身份，第$i$天一定有一个人的位置在$a_i$，记录另一个人可能的位置集合$s$。<br>对于二分点，遍历每个$a_i$，更新$s$，使得$s$中的点与$a_i$的距离不超过$D$。<br>如果$s$为空，说明不存在一种决策使得两人最远距离不超过$D$。</p><h2 id="参考程序-9"><a href="#参考程序-9" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y;cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll d) -&gt; <span class="type">bool</span>&#123;</span><br><span class="line">        set&lt;ll&gt; s;</span><br><span class="line">        ll lst=y;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-y)&gt;d) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(t-lst)&lt;=d) s.<span class="built_in">insert</span>(lst);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;*s.<span class="built_in">begin</span>()&lt;t-d) s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;*s.<span class="built_in">rbegin</span>()&gt;t+d) s.<span class="built_in">erase</span>(*s.<span class="built_in">rbegin</span>());</span><br><span class="line">            lst=t;</span><br><span class="line">        &#125;<span class="keyword">return</span> !s.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        ll mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="K-牛镇公务员考试"><a href="#K-牛镇公务员考试" class="headerlink" title="K.牛镇公务员考试"></a>K.牛镇公务员考试</h1><p><strong>图论</strong></p><h2 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h2><p>有$n$道题，每道题的题目为：“第$a_i$题的答案是（）？”<br>每题有<code>A B C D E</code>五个选项，选项的内容是字符串<code>ABCDE</code>的一个排列，记为字符串$s_i$<br>例如第$i$题的题目为：</p><p>第$a_i$题的答案是（）？<br>A. $s_i[0]$ B. $s_i[1]$ C. $s_i[2]$ D. $s_i[3]$ E. $s_i[4]$</p><p>求答对所有题目的方案数</p><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>将题目看作节点。<br>第$i$道题决定了第$a_i$道题的答案，视为一条从$i$到$a_i$的有向边。<br>同时，每个节点的出度为$1$，这意味着每个连通分量都是一个内向基环树。<br>（内向基环树：每个节点的出度为$1$的弱连通图）</p><p>反过来看，一旦确定了第$a_i$道题的答案，第$i$道题的答案也就确定了。<br>因此对于一条链，只要确定了一个节点的答案，整条链的答案也就唯一确定了。<br>显然在内向基环树中，链一定是挂在某个环上，链的答案随环的选择而唯一确定，因此可以忽略链。</p><p>对于环，先确定一个节点的答案（5种），然后递推确定整个环的答案，判断是否合法。<br>每个环的方案数在$0-4$之间</p><p>最终答案为每个连通分量方案数的乘积</p><h2 id="参考程序-10"><a href="#参考程序-10" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n ;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; s[i];</span><br><span class="line">        a[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        ll j=i;</span><br><span class="line">        <span class="keyword">while</span>(vis[j]==<span class="number">-1</span>)&#123;</span><br><span class="line">            vis[j]=i;</span><br><span class="line">            j=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[j]!=i) <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;ll&gt; cycle;<span class="comment">//环</span></span><br><span class="line">        ll k=j;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            cycle.<span class="built_in">push_back</span>(k);</span><br><span class="line">            k=a[k];</span><br><span class="line">        &#125;<span class="keyword">while</span>(k!=j);</span><br><span class="line">        ll res=<span class="number">0</span>,t;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">            t=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:cycle) t=s[x][t]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(t==i) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">multo</span>(ans,res);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="L-要有光"><a href="#L-要有光" class="headerlink" title="L.要有光"></a>L.要有光</h1><p><strong>诈骗题</strong></p><h2 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h2><p>给了一些几何形状的方程，求在<strong>地面</strong>（$z=0$）上的最大阴影面积</p><h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目拐弯抹角吓唬人///<br>保证符合题意的状态是光源处于$xOy$平面上($z=0$)。<br>目的是求一个$xOy$平面上的梯形阴影的面积。<br>上底长$2w$，下底长$4w$，高为$c$，面积为$3wc$。</p><h2 id="参考程序-11"><a href="#参考程序-11" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll c,d,h,w;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; d &gt;&gt; h &gt;&gt; w;</span><br><span class="line">    cout &lt;&lt; w*<span class="number">3</span>*c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="M-牛客老粉才知道的秘密"><a href="#M-牛客老粉才知道的秘密" class="headerlink" title="M.牛客老粉才知道的秘密"></a>M.牛客老粉才知道的秘密</h1><p><strong>2签</strong></p><h2 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h2><p>某场比赛一共有$n$道题目，但每面只能显示$6$道。<br>点击<code>下一页</code>时，如果后面的题目足够$6$题，则显示下面的$6$题，否则显示最后6题。<br>点击<code>上一页</code>时，如果前面的题目足够$6$题，则显示上面的$6$题，否则显示最前6题。<br>求比赛中可能出现在第一题位置的题目数量。</p><h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果题目数量是$6$的倍数，那页面可能的题目排布为$n/6$。<br>如果题目数量不是$6$的倍数，<br>从第一页到最后一页，可能的题目排布为$n/6+1$；<br>从最后一页到第一页，可能的题目排布为$n/6+1$。<br>去除首页尾页，可能的题目排布为$(n/6)*2$。</p><h2 id="参考程序-12"><a href="#参考程序-12" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">6</span>==<span class="number">0</span>) cout &lt;&lt; n/<span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; n/<span class="number">6</span>*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">题解|2024牛客寒假01</summary>
    
    
    
    <category term="算法竞赛" scheme="https://www.cclmsy.cc/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="2024牛客寒假" scheme="https://www.cclmsy.cc/tags/2024%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87/"/>
    
  </entry>
  
</feed>
