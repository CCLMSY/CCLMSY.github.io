<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>复现|PlugIR：基于对话的图像检索系统</title>
      <link href="/posts/PlugIR.html"/>
      <url>/posts/PlugIR.html</url>
      
        <content type="html"><![CDATA[<p>论文：<a href="https://arxiv.org/abs/2406.03411">Interactive Text-to-ImageRetrieval with Large Language Models: A Plug-and-Play Approach</a></p><h2 id="1-Introduction">1. Introduction</h2><p>ChatIR是一种基于聊天的文本到图像的方法，提出了利用LLM进行多轮对话以提高检索效率。（我的阅读笔记见<a href="https://www.cclmsy.cc/posts/ChatIR.html">复现|ChatIR</a>）</p><p>这个方法具有以下不足：</p><ol><li>需要进行微调文本编码器，来适应多轮对话数据<ul><li>微调耗费资源、可扩展性差。</li><li>解决方法：将对话重构为可以直接输入到预训练的视觉语言模型的格式，不需要对模型进行微调</li></ul></li><li>LLM提问者G只知道对话历史，无法查看候选图像<ul><li>可能生成图像中不存在的属性的询问</li><li>LLM提问者基于候选集提问，确保问题与图像属性相关</li></ul></li></ol><p>本文提出的PlugIR系统包含2个部分：上下文重构（Context Reformulation）和上下文感知对话生成（Context-aware Dialogue Generation）</p><p><img src="https://source.cclmsy.cc/Posts/DL/PlugIR/PlugIR.png" alt="PlugIR"></p><p>本文贡献：</p><ol><li>实证0样本或微调的大模型难以理解对话数据</li><li>提出了一种LLM提问者，解决了因冗余问题和噪声问题带来的性能瓶颈</li><li>提出新指标BRI（最佳对数排名积分，Best log Rank Integral）<ul><li>比Recall@K和Hit@K更接近人的评价，更全面地评估交互式检索系统</li></ul></li><li>PlugIR具有即插即用的特性，且具有实用性</li></ol><h2 id="2-Related-Work">2. Related Work</h2><ul><li>文本到图像检索</li><li>视觉语言模型：BLIP、CLIP</li><li>大语言模型LLM</li></ul><h2 id="3-Method">3. Method</h2><h3 id="3-1-Preliminaries-InteractiveText-to-Image-Retrieval-交互式文本到图像检索">3.1 Preliminaries:InteractiveText-to-Image Retrieval 交互式文本到图像检索</h3><p>对话记录表示：$D_i = (C, Q_1, A_1, …, Q_i)$</p><ul><li>$C$：目标图像的初始文本描述（标题）</li><li>$Q_i$：第i个问题</li><li>$A_i$：第i个回答</li></ul><p>检索系统将数据库中的所有图片与文本进行匹配，根据相似度进行排序，根据目标排名评估系统性能。</p><ul><li>Recall@K：本轮交互检索到的前K张图片包含目标的概率</li><li>Hit@K：本轮以及任意一轮的交互检索到的前K张图片包含目标的概率</li></ul><h3 id="3-2-Context-Reformulation-上下文重构">3.2 Context Reformulation 上下文重构</h3><p>作者测试了0样本的CLIP、BLIP、BLIP-2和一个黑箱模型ATM</p><ul><li>Hit@K逐步提升，但这是由其定义决定的</li><li>Recall@K在仅包含最初的文本描述时最高，随着对话轮次增加而下降<ul><li>对话在0样本模型上可能没有贡献、产生了噪声</li><li>0样本模型无法理解对话数据</li></ul></li></ul><p>为了解决这个问题，一种方法是像ChatIR一样对模型进行微调，但这样做有以下限制：</p><ol><li>不能使用黑箱模型，比如ATM</li><li>需要大量的训练数据</li></ol><p>本文不直接使用对话作为输入进行查询，而是将对话重构为可以直接输入到预训练的视觉语言模型的格式，不需要对模型进行微调（即所谓的Plug-and-Play）。</p><h3 id="3-3-Context-aware-Dialogue-Generation-上下文感知对话生成">3.3 Context-aware Dialogue Generation 上下文感知对话生成</h3><p>仅靠对话历史生成问题具有以下问题：</p><ol><li>生成的问题可能与图像属性无关</li><li>可能询问历史对话中已有信息</li></ol><p>提问过程（用于解决问题1）：</p><ol><li>使用重构后的查询语句进行检索，找出高相似度的“检索候选”图像集</li><li>对候选图像Embeddings进行K-means聚类，得到每个候选图像与其他图像的相似度得分分布</li><li>对于每个聚类，选择<code>相似度分布熵</code>最小的图像作为代表<ul><li>熵越小，属性越真实、越容易区分</li><li>例如，同一组图像对“一张配有2台电脑显示器和一副键盘的桌子”的描述熵更低，对“办公室”的描述熵更高</li></ul></li><li>将这K副图像通过image2text模型生成caption，作为附加信息提供给LLM提问者</li></ol><p>提问（算法1）伪代码：</p><ol><li>输入：对话上下文$c$、图像库$I$、“检索候选”图像数$n$、聚类数$m$、相似度函数$sim$、$KMeans$、i2t模型$Captioning$</li><li>从$I$中选出前$n$个和$c$最相似的图像，作为$S_R$<ol><li>初始化$S_R \leftarrow {}$</li><li>$while S_R.size() &lt; n do$<ol><li>将和$c$最相似的图像$x$加入$S_R$</li><li>将$x$从$I$中移除</li></ol></li></ol></li><li>对$S_R$进行$KMeans$聚类，得到$m$个聚类$S_R^{(1)}, S_R^{(2)}, …, S_R^{(m)}$</li><li>计算每个图像相对$S_R$的概率，使用Softmax得到$P_c(x)=\frac{exp(sim(c, x))}{\sum_{x’ \in S_R} exp(sim(c, x’))}$</li><li>从每个簇$S_R^{(i)}$中选择最优的图像，并对这$m$个图像进行$Captioning$，得到$T$<ol><li>$for i in range(1,m+1) do$<ol><li>计算当前簇$S_R^{(i)}$中所有图像的熵，并找出最小熵的图像$\hat x^{(i)}$</li><li>对$\hat x^{(i)}$进行$Captioning$，并加入$T$</li></ol></li></ol></li><li>返回：$T$</li></ol><p>采用思维链（Chain of Thought）的方法，提示词位于原文18~19页，获取与图像相关的问题。<br>这样生成的问题仍然可能冗余（已经知道答案），还需要经过过滤。</p><p>过滤过程（用于解决问题2）：</p><ol><li>通过上下文回答函数，判断问题是否“确定”，选取“不确定”的问题</li><li>选择“不确定”的问题中KL散度最小的问题<ol><li>KL散度：$KL(P_c||P_{c,q})=\sum_{x \in T} P_c(x)log\frac{P_c(x)}{P_{c,q}(x)}$</li><li>用于防止不合适的问题导致相似度骤变</li></ol></li></ol><p>过滤（算法2）伪代码：</p><ol><li>输入：对话上下文$c$、问题集合$Q$、检索候选集$T$、相似度函数$sim$、上下文回答函数$Answer$</li><li>定义计算上下文概率分布的函数<ol><li>图像$x$在上下文$c$下的分布：$P_c(x)=\frac{exp(sim(c, x))}{\sum_{x’ \in T} exp(sim(c, x’))}$</li><li>加入问题$q$后图像$x$在上下文$c$下的分布：$P_{c,q}(x)=\frac{exp(sim(concat(c, q), x))}{\sum_{x’ \in T} exp(sim(concat(c, q), x’))}$</li></ol></li><li>筛选出答案“不确定”的问题，作为$Q’$<ol><li>初始化$Q’ \leftarrow {}$</li><li>$for q in Q do$<ol><li>如果$Answer(c, q)$为“不确定”，则加入$Q’$</li></ol></li></ol></li><li>选择KL散度最小的问题$\hat q$</li><li>返回：$\hat q$</li></ol><h3 id="3-4-The-Best-Log-Rank-Integral-BRI-Metric-最佳对数排名积分">3.4 The Best Log Rank Integral (BRI) Metric 最佳对数排名积分</h3><p>作者指出，在评估交互式检索系统时，有3个关键点：</p><ol><li>用户满意度：在多少次交互中至少找到了一次目标图像算满意</li><li>效率：成功检索所需轮次越少越好</li><li>排名提升意义：排名靠前时提升排名的意义更大，如从2到1比从100到99更有意义</li></ol><p>Recall@K用于非交互式检索；Hit@K只考虑了用户满意度</p><p>作者提出了BRI指标，综合了用户满意度、效率和排名提升意义</p><p>记：$Q$问题集合、$T$最大轮次</p><p>$\pi(q_t)$：表示具有$t$轮对话的查询$q_t$，在这$t$轮查询中，目标图像的历史最佳排名，用于衡量用户满意度</p><p>BRI：$\mathbb E_{q \in Q}\left[ \dfrac{1}{2T}\log\pi(q_0)\pi(q_T)+\dfrac{1}{T}\sum\limits_{t=1}^{T-1}\log\pi(q_t)\right]$</p><ul><li>边界项：$\dfrac{1}{2T}\log\pi(q_0)\pi(q_T)$<ul><li>权重较小，反映初始查询$q_0$到最终查询$q_T$的排名改善情况</li></ul></li><li>平均查询排名项：$\dfrac{1}{T}\sum\limits_{t=1}^{T-1}\log\pi(q_t)$<ul><li>计算了查询$q$的所有$t$轮中，目标的历史最佳排名的对数的均值</li><li>对数函数使得低排名的进一步降低对BRI变化的影响更大</li></ul></li><li>BRI越小，性能越好</li><li>BRI不依赖于具体的K值，更全面、统一</li><li>实验表明，BRI与人类评价更接近</li></ul><h2 id="4-Experiments">4. Experiments</h2><ul><li>数据集：Visdail、COCO、Flickr30k</li><li>文本到图像检索模型：默认BLIP，也有BLIP-2、ATM</li><li>LLM提问者：ChatGPT</li><li>测试集回答者：BLIP-2</li><li>聚类数m：10</li></ul><p>Baseline：0-shot、ChatIR</p><p>同时进行了Ablation Study，测试了不同组件的加入对结果的影响</p><h2 id="总结和实现">总结和实现</h2><ul><li>PlugIR系统也是一个基于对话的图像检索系统，在ChatIR的基础上进行了改进</li><li>主要优化了提问过程，使得提问的有效性提升</li><li>使用了新的评估指标BRI，能够更全面地评估交互式检索系统</li></ul><p>由于系统代码量较大，在实现时划分到多个文件</p><h3 id="config-py"><a href="http://config.py">config.py</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">&quot;hitk&quot;</span> : <span class="number">10</span>, <span class="comment"># hit@k</span></span><br><span class="line">    <span class="string">&quot;q_num&quot;</span> : <span class="number">5</span>, <span class="comment"># 待select的问题数量</span></span><br><span class="line">    <span class="string">&quot;threshold_low&quot;</span> : <span class="number">500</span>, <span class="comment"># 低阈值，用于计算Kmeans聚类时的样本数</span></span><br><span class="line">    <span class="string">&quot;gpt_model&quot;</span> : <span class="string">&#x27;gpt-4o-mini&#x27;</span>, <span class="comment"># OpenAI模型名称</span></span><br><span class="line">    <span class="string">&quot;api_key&quot;</span> : <span class="string">&quot;&quot;</span>, <span class="comment"># OpenAI API密钥</span></span><br><span class="line">    <span class="string">&quot;vqa_model&quot;</span> : <span class="string">&#x27;Salesforce/blip2-flan-t5-xl&#x27;</span>, <span class="comment"># VQA模型名称</span></span><br><span class="line">    <span class="string">&quot;retriever&quot;</span> : <span class="string">&quot;blip&quot;</span>, <span class="comment"># 检索器名称，blip或clip</span></span><br><span class="line">    <span class="string">&quot;device&quot;</span> : torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>),</span><br><span class="line">    <span class="string">&quot;sep_token&quot;</span> : <span class="string">&quot;, &quot;</span>, <span class="comment"># ChatIR分隔符</span></span><br><span class="line">    <span class="string">&quot;eval_caption&quot;</span> : <span class="literal">True</span>, <span class="comment"># eval时是否为PlugIR总结的Caption，True：PlugIR，False：ChatIR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 算法配置</span></span><br><span class="line">    <span class="string">&quot;referring&quot;</span> : <span class="literal">True</span>, <span class="comment"># 是否参考候选集Caption提问（算法1）</span></span><br><span class="line">    <span class="string">&quot;filtering&quot;</span> : <span class="literal">True</span>, <span class="comment"># 是否AI过滤问题（算法2）</span></span><br><span class="line">    <span class="string">&quot;select&quot;</span> : <span class="literal">True</span>, <span class="comment"># 是否使用KL散度选择问题（算法2）</span></span><br><span class="line">    <span class="string">&quot;reconstruct&quot;</span> : <span class="literal">True</span>, <span class="comment"># 是否重构对话</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路径配置</span></span><br><span class="line">    <span class="comment"># 图片路径前缀，路径=dir_prefix+&lt;img_path&gt;(&quot;unlabeled2017/xxx.jpg&quot;)</span></span><br><span class="line">    <span class="string">&quot;dir_prefix&quot;</span> : <span class="string">&quot;./&quot;</span>, </span><br><span class="line">    <span class="comment"># Visdial数据，[&#123;&quot;img&quot;:&quot;&lt;img_path&gt;&quot;, &quot;dialog&quot;:[&quot;&lt;caption&gt;&quot;, &quot;Q? A&quot;, &quot;Q? A&quot;, ...]&#125;, ...]，2064</span></span><br><span class="line">    <span class="string">&quot;visdial_path&quot;</span> : <span class="string">&quot;./dialogues/VisDial_v1.0_queries_val.json&quot;</span>, </span><br><span class="line">    <span class="comment"># 搜索空间，[&quot;&lt;img_path&gt;&quot;, &quot;&lt;img_path&gt;&quot;, ...]，50000</span></span><br><span class="line">    <span class="string">&quot;search_space&quot;</span> : <span class="string">&quot;./Protocol/Search_Space_val_50k.json&quot;</span>, </span><br><span class="line"><span class="comment"># Visdial数据，仅保留caption，[&#123;&quot;id&quot;: &quot;&lt;img_path&gt;&quot;, &quot;caption&quot;: [&quot;&lt;caption&gt;&quot;]&#125;,...]，50000</span></span><br><span class="line">    <span class="string">&quot;captions_path&quot;</span> : <span class="string">&quot;./ChatIR/ChatIR_Protocol/visdial_captions.json&quot;</span>,</span><br><span class="line">    <span class="comment"># blip预处理的embeddings</span></span><br><span class="line">    <span class="string">&quot;img_emb_path&quot;</span> : <span class="string">&quot;./ChatIR/temp/corpus_finetuned_blip.pth&quot;</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OpenAI-py"><a href="http://OpenAI.py">OpenAI.py</a></h3><p>所有函数统一返回response对象，包含了所有信息。</p><p>messages.py中定义了消息格式，包含prompt信息，具体文本见论文附录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> API.messages <span class="keyword">as</span> messages</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">client = openai.OpenAI(api_key=config[<span class="string">&quot;api_key&quot;</span>])</span><br><span class="line"></span><br><span class="line">SEED = <span class="number">1021</span> <span class="comment"># 随机种子 <span class="doctag">TODO:</span>不设置的效果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconstruct_dialog</span>(<span class="params">dialog:<span class="built_in">list</span>[<span class="built_in">str</span>], temperature:<span class="built_in">float</span>=<span class="number">.0</span>, model:<span class="built_in">str</span>=<span class="string">&#x27;gpt-4o-mini&#x27;</span></span>)-&gt;<span class="built_in">str</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;重构对话框</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">将对话中的有效信息总结为一段描述。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">dialog : 对话列表</span></span><br><span class="line"><span class="string">temperature : 采样温度，越小越保守 [0.0,2.0]</span></span><br><span class="line"><span class="string">model : 模型名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">retry_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=model,</span><br><span class="line">messages=messages.reconstruct_dialog_message(dialog),</span><br><span class="line">n=<span class="number">1</span>,</span><br><span class="line">temperature=temperature,</span><br><span class="line">seed=SEED,</span><br><span class="line">max_tokens=<span class="number">512</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">retry_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> retry_count &gt; <span class="number">5</span>:</span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">&quot;Retry limit exceeded!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Retry <span class="subst">&#123;retry_count&#125;</span> times...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_questions</span>(<span class="params">dialog:<span class="built_in">list</span>[<span class="built_in">str</span>], n:<span class="built_in">int</span>=<span class="number">1</span>, model:<span class="built_in">str</span>=<span class="string">&#x27;gpt-4o-mini&#x27;</span></span>)-&gt;<span class="built_in">list</span>[<span class="built_in">str</span>]:</span><br><span class="line"><span class="string">&quot;&quot;&quot;Baseline: 1-shot生成问题 ChatIR</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">仅参考历史对话生成新的问题。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">dialog : 对话列表</span></span><br><span class="line"><span class="string">n : 生成问题数量</span></span><br><span class="line"><span class="string">model : 模型名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">response :</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">retry_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=model,</span><br><span class="line">messages=messages.generate_questions_message(dialog),</span><br><span class="line">n=n,</span><br><span class="line">temperature=<span class="number">0.5</span>,</span><br><span class="line">max_tokens=<span class="number">32</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">retry_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> retry_count &gt; <span class="number">5</span>:</span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">&quot;Retry limit exceeded!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Retry <span class="subst">&#123;retry_count&#125;</span> times...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_questions_referring</span>(<span class="params">dialog:<span class="built_in">list</span>[<span class="built_in">str</span>], prompt_related_captions:<span class="built_in">str</span>=<span class="string">&quot;&quot;</span>, questions:<span class="built_in">list</span>=[], n:<span class="built_in">int</span>=<span class="number">1</span>, model=<span class="string">&#x27;gpt-4o-mini&#x27;</span></span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;利用思维链CoT和候选集Captions生成新问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">dailog : 对话列表</span></span><br><span class="line"><span class="string">prompt_related_captions : 预处理的候选集Caption</span></span><br><span class="line"><span class="string">questions : 历史问答对</span></span><br><span class="line"><span class="string">n : 生成问题数量</span></span><br><span class="line"><span class="string">model : 模型名称</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">retry_count = <span class="number">0</span></span><br><span class="line">message = messages.generate_questions_referring_message(dialog, prompt_related_captions, questions)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=model,</span><br><span class="line">messages=message,</span><br><span class="line">n=<span class="number">1</span>,</span><br><span class="line">temperature=<span class="number">0.5</span>,</span><br><span class="line">max_tokens=<span class="number">32</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">retry_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> retry_count &gt; <span class="number">5</span>:</span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">&quot;Retry limit exceeded!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Retry <span class="subst">&#123;retry_count&#125;</span> times...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter_questions</span>(<span class="params">context:<span class="built_in">str</span>, question:<span class="built_in">str</span>, model=<span class="string">&#x27;gpt-4o-mini&#x27;</span></span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;过滤问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">判断问题是否“Uncertain”</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">context : 上下文</span></span><br><span class="line"><span class="string">question : 问题</span></span><br><span class="line"><span class="string">model : 模型名称</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">retry_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=model,</span><br><span class="line">messages=messages.filter_questions_message(context, question),</span><br><span class="line">n=<span class="number">1</span>,</span><br><span class="line">temperature=<span class="number">.0</span>,</span><br><span class="line">max_tokens=<span class="number">32</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">retry_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> retry_count &gt; <span class="number">5</span>:</span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">&quot;Retry limit exceeded!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Retry <span class="subst">&#123;retry_count&#125;</span> times...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paraphrase</span>(<span class="params">text:<span class="built_in">str</span>=<span class="string">&quot;&quot;</span>, model=<span class="string">&#x27;gpt-4o-mini&#x27;</span></span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;重述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重述给定的文本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">text : 待重述文本</span></span><br><span class="line"><span class="string">model : 模型名称</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">retry_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=model,</span><br><span class="line">messages=messages.paraphrase(text),</span><br><span class="line">n=<span class="number">1</span>,</span><br><span class="line">temperature=<span class="number">0.7</span>,</span><br><span class="line">top_p=<span class="number">0.8</span>,</span><br><span class="line">max_tokens=<span class="number">512</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">retry_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> retry_count &gt; <span class="number">5</span>:</span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">&quot;Retry limit exceeded!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Retry <span class="subst">&#123;retry_count&#125;</span> times...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h3 id="utils-py"><a href="http://utils.py">utils.py</a></h3><p>实现了特征提取、K-means聚类、KL散度计算、获取簇中心caption、熵计算等函数功能，使主程序代码简洁易读。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn.functional <span class="keyword">import</span> normalize</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BlipForImageTextRetrieval,AutoProcessor</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> InterpolationMode</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./Protocol/visdial_captions.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> ss_cap_json:</span><br><span class="line">captions = json.load(ss_cap_json) <span class="comment"># length:50000</span></span><br><span class="line"><span class="comment"># &#123;&quot;id&quot;: &quot;&lt;img_path&gt;&quot;, &quot;caption&quot;: [&quot;&lt;caption&gt;&quot;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlipForRetrieval</span>(<span class="title class_ inherited__">BlipForImageTextRetrieval</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_text_features</span>(<span class="params"></span></span><br><span class="line"><span class="params">self,</span></span><br><span class="line"><span class="params">input_ids: torch.LongTensor, <span class="comment"># Tokenized input IDs</span></span></span><br><span class="line"><span class="params">attention_mask: torch.LongTensor | <span class="literal">None</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">return_dict: <span class="built_in">bool</span>|<span class="literal">None</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; torch.FloatTensor:</span><br><span class="line"><span class="string">&quot;&quot;&quot;获取文本特征</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">input_ids : 文本的token ID（即经过分词后的输入）</span></span><br><span class="line"><span class="string">attention_mask : 注意力掩码</span></span><br><span class="line"><span class="string">return_dict : 是否返回字典</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">return_dict=return_dict <span class="keyword">if</span> return_dict <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> self.config.use_return_dict</span><br><span class="line"></span><br><span class="line">text_embeddings = self.text_encoder(</span><br><span class="line">input_ids=input_ids,</span><br><span class="line">attention_mask=attention_mask,</span><br><span class="line">return_dict=return_dict,</span><br><span class="line">)</span><br><span class="line">text_embeddings = text_embeddings[<span class="number">0</span>] <span class="keyword">if</span> <span class="keyword">not</span> return_dict <span class="keyword">else</span> text_embeddings.last_hidden_state</span><br><span class="line"><span class="keyword">return</span> normalize(self.text_proj(text_embeddings[:, <span class="number">0</span>, :]), dim=-<span class="number">1</span>) <span class="comment"># [:,0,:]取的是[CLS]标记的隐藏状态，它通常被用作整个句子的特征表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image_features</span>(<span class="params"></span></span><br><span class="line"><span class="params">self,</span></span><br><span class="line"><span class="params">pixel_values: torch.FloatTensor,</span></span><br><span class="line"><span class="params">output_attentions: <span class="built_in">bool</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">output_hidden_states: <span class="built_in">bool</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">return_dict: <span class="built_in">bool</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; torch.FloatTensor:</span><br><span class="line"><span class="string">&quot;&quot;&quot;获取图片特征</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">pixel_values : 图片像素值</span></span><br><span class="line"><span class="string">output_attentions : 是否输出注意力</span></span><br><span class="line"><span class="string">output_hidden_states : 是否输出隐藏状态</span></span><br><span class="line"><span class="string">return_dict : 是否返回字典</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">return_dict = return_dict <span class="keyword">if</span> return_dict <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> self.config.use_return_dict</span><br><span class="line"></span><br><span class="line">output_attentions = output_attentions <span class="keyword">if</span> output_attentions <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> self.config.output_attentions</span><br><span class="line">output_hidden_states = output_hidden_states <span class="keyword">if</span> output_hidden_states <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> self.config.output_hidden_states</span><br><span class="line"></span><br><span class="line">vision_outputs = self.vision_encoder(</span><br><span class="line">pixel_values=pixel_values,</span><br><span class="line">output_attentions=output_attentions,</span><br><span class="line">output_hidden_states=output_hidden_states,</span><br><span class="line">return_dict=return_dict,</span><br><span class="line">)</span><br><span class="line">image_embeddings = vision_outputs[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> normalize(self.vision_proj(image_embeddings[:, <span class="number">0</span>, :]), dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">processor = AutoProcessor.from_pretrained(<span class="string">&quot;Salesforce/blip-itm-large-coco&quot;</span>)</span><br><span class="line">model = BlipForRetrieval.from_pretrained(<span class="string">&quot;Salesforce/blip-itm-large-coco&quot;</span>).to(config[<span class="string">&quot;device&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_text_features</span>(<span class="params">text: <span class="built_in">str</span>, model=model, processor=processor</span>) -&gt; torch.FloatTensor:</span><br><span class="line"><span class="string">&quot;&quot;&quot;获取文本特征</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">text : 文本</span></span><br><span class="line"><span class="string">model : Pretrained Model，用于获取文本特征</span></span><br><span class="line"><span class="string">processor : 文本处理器，用于将文本转换为模型输入</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">text_encodings = processor(text=text, padding=<span class="literal">True</span>, return_tensors=<span class="string">&quot;pt&quot;</span>).to(config[<span class="string">&quot;device&quot;</span>])</span><br><span class="line"><span class="keyword">return</span> model.get_text_features(**text_encodings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_imgs</span>(<span class="params">query=<span class="string">&quot;&quot;</span>, img_embs=<span class="literal">None</span>, search_space=<span class="literal">None</span>, k=<span class="number">10</span></span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;搜索前k个相关图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">query : 查询文本</span></span><br><span class="line"><span class="string">img_embs : 图片特征</span></span><br><span class="line"><span class="string">search_space : 搜索空间，图片路径列表</span></span><br><span class="line"><span class="string">k : 返回的图片数量</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">related_imgs : 前k个相关图片</span></span><br><span class="line"><span class="string">related_indices : 前k个相关图片的索引</span></span><br><span class="line"><span class="string">cos_sim : 余弦相似度</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">query_emb = get_text_features(query)</span><br><span class="line">query_emb_norm = normalize(query_emb, dim=-<span class="number">1</span>) <span class="comment"># 归一化查询特征</span></span><br><span class="line">cos_sim = torch.matmul(query_emb_norm, img_embs.T).squeeze() <span class="comment"># 计算余弦相似度</span></span><br><span class="line">related_indices = cos_sim.sort()[<span class="number">1</span>][-k:]</span><br><span class="line"><span class="comment"># related_indices = cos_sim.topk(k).indices</span></span><br><span class="line">related_imgs = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">related_imgs.append(search_space[related_indices[idx].item()])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> related_imgs, related_indices, cos_sim</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fast_pytorch_kmeans <span class="keyword">import</span> KMeans</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">10</span>, mode=<span class="string">&#x27;cosine&#x27;</span>, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_related_captions</span>(<span class="params">caption_recon, <span class="built_in">round</span>=<span class="number">1</span>, threshold_low=<span class="number">500</span>, img_embs=<span class="literal">None</span>, captions=<span class="literal">None</span></span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;获取簇中心的相关图片描述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">将low-(round-1)*(low/10.0)个最相关的图片作为候选集S_R，进行k-means聚类，</span></span><br><span class="line"><span class="string">得到10个簇中，信息熵最小的图片描述作为当前轮次的相关图片描述。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">caption_recon : 对话上下文（重构的）</span></span><br><span class="line"><span class="string">round : 当前轮次</span></span><br><span class="line"><span class="string">threshold_low : 根据轮次计算相关图片的数量 low-(round-1)*(low/10.0)</span></span><br><span class="line"><span class="string">img_embs : 图片特征</span></span><br><span class="line"><span class="string">captions : 图片描述</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">caps = []</span><br><span class="line"><span class="comment"># related_size = 100 - (round-1)*10</span></span><br><span class="line">related_size = <span class="built_in">int</span>(threshold_low - (<span class="built_in">round</span>-<span class="number">1</span>) * (threshold_low / <span class="number">10.0</span>)) <span class="comment"># 候选集大小 500-(round-1)*50</span></span><br><span class="line">emb = normalize(get_text_features(caption_recon), dim=-<span class="number">1</span>) </span><br><span class="line">sim = torch.matmul(emb, img_embs.T).squeeze() <span class="comment"># 计算余弦相似度</span></span><br><span class="line">topk = sim.argsort()[-related_size:] <span class="comment"># 获取前related_size个相关图片的索引</span></span><br><span class="line">img_embs_topk = img_embs[topk] <span class="comment"># 获取前related_size个相关图片的特征</span></span><br><span class="line"></span><br><span class="line">entropies = torch.zeros([related_size]) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(related_size):</span><br><span class="line">cap = captions[topk[i].item()][<span class="string">&#x27;caption&#x27;</span>]</span><br><span class="line">emb = normalize(get_text_features(cap), dim=-<span class="number">1</span>)</span><br><span class="line">sim = torch.matmul(emb, img_embs_topk.T).squeeze()</span><br><span class="line">p = torch.nn.functional.softmax(sim, dim=<span class="number">0</span>)</span><br><span class="line">entropy = (-p * p.log()).<span class="built_in">sum</span>().detach().cpu() <span class="comment"># 信息熵</span></span><br><span class="line">entropies[i] += entropy</span><br><span class="line">idx_entropies_sorted = entropies.argsort()</span><br><span class="line"></span><br><span class="line">cluster_label = kmeans.fit_predict(img_embs_topk)</span><br><span class="line">cluster_label_sorted = cluster_label[idx_entropies_sorted]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="keyword">if</span> (cluster_label_sorted == i).<span class="built_in">any</span>():</span><br><span class="line">idx_c = (cluster_label_sorted == i).nonzero().squeeze().<span class="built_in">min</span>() </span><br><span class="line">caps.append(captions[topk[idx_entropies_sorted[idx_c]].item()][<span class="string">&#x27;caption&#x27;</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(10):</span></span><br><span class="line"><span class="comment">#     caps.append(captions[topk[entropies.argsort()[i]].item()][&#x27;caption&#x27;][0])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> caps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_referring_prompt</span>(<span class="params">caption=<span class="string">&quot;&quot;</span>, img_embs=<span class="literal">None</span>, k=<span class="number">10</span>, <span class="built_in">round</span>=<span class="number">1</span>, search_space=<span class="literal">None</span></span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot; 进行k-means聚类，获取相关图片描述；获取前k个相关图片的索引和余弦相似度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">caption : 图片描述</span></span><br><span class="line"><span class="string">img_embs : 图片特征</span></span><br><span class="line"><span class="string">k : 返回的图片数量</span></span><br><span class="line"><span class="string">round : 当前轮次</span></span><br><span class="line"><span class="string">search_space : 搜索空间，图片路径列表</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">prompt_sys : 系统prompt</span></span><br><span class="line"><span class="string">prompt_related_captions : 相关图片描述</span></span><br><span class="line"><span class="string">top_k : 前k个相关图片的索引</span></span><br><span class="line"><span class="string">cos_sims : 余弦相似度</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">img_paths, top_k, cos_sims = search_imgs(caption, img_embs, search_space, k=k)</span><br><span class="line">related_captions = get_related_captions(caption, <span class="built_in">round</span>, img_embs=img_embs, captions=captions)</span><br><span class="line"></span><br><span class="line">prompt_sys = <span class="string">&quot;&quot;</span></span><br><span class="line">prompt_sys += <span class="string">&quot;You should leverage the &#x27;related_captions Information&#x27; that is related to the target image &quot;</span></span><br><span class="line">prompt_sys += <span class="string">&quot;corresponding to the caption but does not match the target image.&quot;</span></span><br><span class="line"><span class="comment"># 你需要利用与目标图像相关的“虚假信息”，该信息与目标图像标题相关，但与目标图像不匹配。</span></span><br><span class="line"></span><br><span class="line">prompt_related_captions = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(related_captions)):</span><br><span class="line">prompt_related_captions += <span class="built_in">str</span>(i) + <span class="string">&#x27;. &#x27;</span> + related_captions[i] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="comment"># 1. caption1</span></span><br><span class="line"><span class="comment"># 2. caption2</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> prompt_sys, prompt_related_captions, top_k, cos_sims</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_question</span>(<span class="params">caption_recon=<span class="string">&quot;&quot;</span>, questions=[], cossim_prev=<span class="literal">None</span>, k=<span class="number">10</span>, img_embs=<span class="literal">None</span>, threshold=<span class="number">500</span>, <span class="built_in">round</span>=<span class="number">1</span></span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;选择KL散度最小的问题</span></span><br><span class="line"><span class="string">根据上一次的相似度，选择KL散度最小的问题。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">caption_recon : 对话上下文（重构的）</span></span><br><span class="line"><span class="string">questions : 问题列表</span></span><br><span class="line"><span class="string">cossim_prev : 上一轮的相似度</span></span><br><span class="line"><span class="string">k : 返回的图片数量</span></span><br><span class="line"><span class="string">img_embs : 图片特征</span></span><br><span class="line"><span class="string">threshold : 相关图片的数量 low-(round-1)*(low/10.0)</span></span><br><span class="line"><span class="string">round : 当前轮次</span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">str : 选择的问题</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">threshold = <span class="built_in">int</span>(threshold - (<span class="built_in">round</span>-<span class="number">1</span>) * (threshold / <span class="number">10.0</span>))</span><br><span class="line">idx_related = cossim_prev.argsort()[-threshold:-k]</span><br><span class="line">p_prev = torch.nn.functional.softmax(cossim_prev[idx_related], dim=<span class="number">0</span>)</span><br><span class="line">kl_divs = torch.zeros([<span class="built_in">len</span>(questions)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ques <span class="keyword">in</span> <span class="built_in">enumerate</span>(questions):</span><br><span class="line">caption_tmp = caption_recon + <span class="string">&quot;, &quot;</span> + ques</span><br><span class="line"></span><br><span class="line">query_emb_tmp = normalize(get_text_features(caption_tmp), dim=-<span class="number">1</span>)</span><br><span class="line">cossim_tmp = torch.matmul(query_emb_tmp, img_embs.T).squeeze()</span><br><span class="line">p_tmp = torch.nn.functional.softmax(cossim_tmp[idx_related], dim=<span class="number">0</span>)</span><br><span class="line">kl_div = (p_prev*(p_prev.log() - p_tmp.log())).<span class="built_in">sum</span>().detach().cpu()</span><br><span class="line">kl_divs[i] += kl_div</span><br><span class="line"></span><br><span class="line">idx_final = kl_divs.argsort()[<span class="number">0</span>].item()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> questions[idx_final]</span><br></pre></td></tr></table></figure><h3 id="系统实现：PlugIR-exec-py">系统实现：PlugIR_exec.py</h3><p>PlugIR的运行版，实现利用多轮对话进行图像检索的功能，描述以及每次问答后显示当前最相关的图片。</p><p>改写为<code>PlugIR_func.py</code>，实现了函数化，便于后续批量生成对话数据用于evaluation。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> API <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">img_embs = torch.load(config[<span class="string">&quot;img_emb_path&quot;</span>], map_location=config[<span class="string">&quot;device&quot;</span>])[<span class="number">1</span>] <span class="comment"># blip预处理的embeddings</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> config[<span class="string">&quot;filtering&quot;</span>]:</span><br><span class="line">    config[<span class="string">&quot;q_num&quot;</span>] = <span class="number">1</span> <span class="comment"># 不过滤问题，生成1个问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(config[<span class="string">&quot;search_space&quot;</span>], <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> ss_json:</span><br><span class="line">    search_space = json.load(ss_json) <span class="comment"># length:50000</span></span><br><span class="line">    search_space = [config[<span class="string">&quot;dir_prefix&quot;</span>] + path <span class="keyword">for</span> path <span class="keyword">in</span> search_space]</span><br><span class="line">    <span class="comment"># [&quot;&lt;img_path&gt;&quot;, &quot;&lt;img_path&gt;&quot;, ...]</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(config[<span class="string">&quot;visdial_path&quot;</span>], <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> diag_json:</span><br><span class="line">visdial = json.load(diag_json) <span class="comment"># length:2064</span></span><br><span class="line"><span class="comment"># [&#123;&quot;img&quot;:&quot;&lt;img_path&gt;&quot;, &quot;dialog&quot;:[&quot;&lt;caption&gt;&quot;, &quot;Q? A&quot;, &quot;Q? A&quot;, ...]&#125;, ...]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(config[<span class="string">&quot;captions_path&quot;</span>], <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> ss_cap_json:</span><br><span class="line">captions = json.load(ss_cap_json) <span class="comment"># length:50000</span></span><br><span class="line">    <span class="comment"># [&#123;&quot;id&quot;: &quot;&lt;img_path&gt;&quot;, &quot;caption&quot;: [&quot;&lt;caption&gt;&quot;]&#125;,...]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ask_for_caption</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;询问用户描述&quot;&quot;&quot;</span></span><br><span class="line">    caption = <span class="built_in">input</span>(<span class="string">&quot;Caption: &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> caption.strip()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ask_question</span>(<span class="params">question</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;询问用户问题&quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="built_in">input</span>(<span class="string">f&quot;<span class="subst">&#123;question&#125;</span> &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ans.strip()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_image</span>(<span class="params">img_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示图片&quot;&quot;&quot;</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">    img.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    caption = ask_for_caption() <span class="comment"># 询问用户描述</span></span><br><span class="line">    dialogue = [caption] <span class="comment"># 对话框</span></span><br><span class="line">    caption_recon = caption <span class="comment"># 重构后的描述，用于匹配图片</span></span><br><span class="line">    caption_recons = [caption] <span class="comment"># 重构描述列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">round</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): <span class="comment"># 10轮对话</span></span><br><span class="line">        questions = [] <span class="comment"># 合法问题列表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> config[<span class="string">&quot;referring&quot;</span>]: <span class="comment"># 参考候选集的Caption提问</span></span><br><span class="line">            ques_prior = [] <span class="comment"># 非法问题列表</span></span><br><span class="line">            _, prompt_related_captions, top_k, cos_sims = utils.get_referring_prompt(</span><br><span class="line">                caption_recon,</span><br><span class="line">                img_embs=img_embs,</span><br><span class="line">                k=config[<span class="string">&quot;hitk&quot;</span>],</span><br><span class="line">                <span class="built_in">round</span>=<span class="built_in">round</span>+<span class="number">1</span>,</span><br><span class="line">                search_space=search_space)</span><br><span class="line">            display_image(search_space[top_k[-<span class="number">1</span>]]) <span class="comment"># 显示第一张图片</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(config[<span class="string">&quot;q_num&quot;</span>]): <span class="comment"># 生成config[&quot;q_num&quot;]个问题</span></span><br><span class="line">                <span class="keyword">if</span> config[<span class="string">&quot;filtering&quot;</span>]: <span class="comment"># AI过滤问题</span></span><br><span class="line">                    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment"># 尝试3次根据候选集Caption生成问题</span></span><br><span class="line">                        resp = OpenAI.generate_questions_referring(</span><br><span class="line">                            dialog=dialogue,</span><br><span class="line">                            prompt_related_captions=prompt_related_captions,</span><br><span class="line">                            questions=ques_prior,</span><br><span class="line">                            model=config[<span class="string">&quot;gpt_model&quot;</span>]</span><br><span class="line">                        ).choices[<span class="number">0</span>].message.content</span><br><span class="line">                        question = resp.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>]+<span class="string">&#x27;?&#x27;</span></span><br><span class="line">                        fq = OpenAI.filter_questions(caption_recon, question).choices[<span class="number">0</span>].message.content</span><br><span class="line">                        <span class="keyword">if</span> <span class="string">&quot;uncertain&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> fq.lower(): <span class="comment"># 如果不uncertain，问题非法</span></span><br><span class="line">                            ques_prior.append(question)</span><br><span class="line">                        <span class="keyword">else</span> : <span class="comment"># 如果uncertain，问题合法</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(ques_prior) == <span class="number">3</span>: <span class="comment"># 三次非法问题，尝试直接询问一次，再不行，就固定询问其他对象</span></span><br><span class="line">                        response = OpenAI.generate_questions(dialog=dialogue, n=<span class="number">1</span>).choices[<span class="number">0</span>].message.content</span><br><span class="line">                        question = response.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>]+<span class="string">&#x27;?&#x27;</span></span><br><span class="line">                        fq = OpenAI.filter_questions(caption_recon, question).choices[<span class="number">0</span>].message.content</span><br><span class="line">                        <span class="keyword">if</span> <span class="string">&quot;uncertain&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> fq.lower():</span><br><span class="line">                            question = <span class="string">&quot;what is the other object in the image?&quot;</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 不过滤问题</span></span><br><span class="line">                    response = OpenAI.generate_questions_referring(</span><br><span class="line">                        dialog=dialogue, prompt_related_captions=prompt_related_captions, questions=ques_prior, n=<span class="number">1</span>, model=config[<span class="string">&quot;gpt_model&quot;</span>]</span><br><span class="line">                    ).choices[<span class="number">0</span>].message.content</span><br><span class="line">                    question = response.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>]+<span class="string">&#x27;?&#x27;</span></span><br><span class="line">            questions.append(question)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># ChatIR：直接提问</span></span><br><span class="line">            _, top_k, cos_sims = utils.search_imgs(</span><br><span class="line">                query=caption_recon,</span><br><span class="line">                img_embs=img_embs, </span><br><span class="line">                search_space=search_space,</span><br><span class="line">                k=config[<span class="string">&quot;hitk&quot;</span>]</span><br><span class="line">            )</span><br><span class="line">            display_image(search_space[top_k[-<span class="number">1</span>]]) <span class="comment"># 显示第一张图片</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(config[<span class="string">&quot;q_num&quot;</span>]): <span class="comment"># 生成config[&quot;q_num&quot;]个问题</span></span><br><span class="line">                question = OpenAI.generate_questions(</span><br><span class="line">                    dialog=dialogue, n=<span class="number">1</span>, model=config[<span class="string">&quot;gpt_model&quot;</span>]</span><br><span class="line">                ).choices[<span class="number">0</span>].message.content</span><br><span class="line">                questions.append(question)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> config[<span class="string">&quot;select&quot;</span>]: <span class="comment"># 选择KL散度最小的问题</span></span><br><span class="line">            question_final = utils.select_question( </span><br><span class="line">                caption_recon=caption_recon,</span><br><span class="line">                questions=questions,</span><br><span class="line">                cossim_prev=cos_sims,</span><br><span class="line">                k=config[<span class="string">&quot;hitk&quot;</span>],</span><br><span class="line">                img_embs=img_embs,</span><br><span class="line">                threshold=config[<span class="string">&quot;threshold_low&quot;</span>],</span><br><span class="line">                <span class="built_in">round</span>=<span class="built_in">round</span>+<span class="number">1</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            question_final = questions[<span class="number">0</span>] </span><br><span class="line"></span><br><span class="line">        answer = ask_question(question_final)</span><br><span class="line">        qa = question_final + <span class="string">&#x27; &#x27;</span> + answer</span><br><span class="line">        dialogue.append(qa)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> config[<span class="string">&quot;reconstruct&quot;</span>]: <span class="comment"># 重构对话上下文</span></span><br><span class="line">            caption_recon = OpenAI.reconstruct_dialog(</span><br><span class="line">                dialog=dialogue,</span><br><span class="line">                model=config[<span class="string">&quot;gpt_model&quot;</span>]</span><br><span class="line">            ).choices[<span class="number">0</span>].message.content</span><br><span class="line">            <span class="keyword">if</span> caption_recon == caption_recons[-<span class="number">1</span>]:</span><br><span class="line">                caption_recon = OpenAI.paraphrase(caption_recon, model=config[<span class="string">&quot;gpt_model&quot;</span>]).choices[<span class="number">0</span>].message.content</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># ChatIR：&quot;, &quot;连接&quot;</span></span><br><span class="line">            caption_recon = <span class="string">&#x27;, &#x27;</span>.join(dialogue)</span><br><span class="line">        caption_recons.append(caption_recon)</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://source.cclmsy.cc/Posts/DL/PlugIR/PlugIR_exec.png" alt="PlugIR_exec"></p><h3 id="对话数据生成：test-gen-py">对话数据生成：test_gen.py</h3><p>为了自动获取测试数据，免除人工回答，使用了BLIP2模型回答问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> lavis.models <span class="keyword">import</span> load_model_and_preprocess</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> PlugIR_func <span class="keyword">import</span> generate_question</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> API <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(config[<span class="string">&quot;visdial_path&quot;</span>], <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> diag_json:</span><br><span class="line">visdial = json.load(diag_json) <span class="comment"># length:2064</span></span><br><span class="line"><span class="comment"># [&#123;&quot;img&quot;:&quot;&lt;img_path&gt;&quot;, &quot;dialog&quot;:[&quot;&lt;caption&gt;&quot;, &quot;Q? A&quot;, &quot;Q? A&quot;, ...]&#125;, ...]</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># st,ed = 5,100 # 目标范围[0,2064]</span></span><br><span class="line">st,ed = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>]), <span class="built_in">int</span>(sys.argv[<span class="number">2</span>]) <span class="comment"># 目标范围[0,2064]</span></span><br><span class="line">images = [visdial[i][<span class="string">&quot;img&quot;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(st,ed)] <span class="comment"># 目标图片列表</span></span><br><span class="line">target_captions = [visdial[i][<span class="string">&quot;dialog&quot;</span>][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(st,ed)] <span class="comment"># 目标图片对应的caption作为用户描述</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> Blip2Processor, Blip2ForConditionalGeneration</span><br><span class="line">processor2 = Blip2Processor.from_pretrained(config[<span class="string">&quot;vqa_model&quot;</span>])</span><br><span class="line">blip2 = Blip2ForConditionalGeneration.from_pretrained(config[<span class="string">&quot;vqa_model&quot;</span>], device_map=&#123;<span class="string">&quot;&quot;</span>: <span class="number">0</span>&#125;, torch_dtype=torch.float16)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconstruct_caption</span>(<span class="params">dialogue, caption_recons</span>):</span><br><span class="line">caption_recon=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> config[<span class="string">&quot;reconstruct&quot;</span>]: <span class="comment"># 重构对话上下文</span></span><br><span class="line">caption_recon = OpenAI.reconstruct_dialog(</span><br><span class="line">dialog=dialogue,</span><br><span class="line">model=config[<span class="string">&quot;gpt_model&quot;</span>]</span><br><span class="line">).choices[<span class="number">0</span>].message.content</span><br><span class="line"><span class="keyword">if</span> caption_recon == caption_recons[-<span class="number">1</span>]:</span><br><span class="line">caption_recon = OpenAI.paraphrase(caption_recon, model=config[<span class="string">&quot;gpt_model&quot;</span>]).choices[<span class="number">0</span>].message.content</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># ChatIR：&quot;, &quot;连接</span></span><br><span class="line">caption_recon = config[<span class="string">&quot;sep_token&quot;</span>].join(dialogue)</span><br><span class="line"><span class="keyword">return</span> caption_recon</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_dialog</span>(<span class="params">idx</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;生成对话数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">idx : 图片索引(st-&gt;0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(images[idx])</span><br><span class="line">caption = target_captions[idx] <span class="comment"># 目标图片对应的caption作为用户描述</span></span><br><span class="line">tqdm.write(<span class="string">f&quot;\nCaption <span class="subst">&#123;idx&#125;</span>: <span class="subst">&#123;caption&#125;</span>&quot;</span>)</span><br><span class="line">dialogue = [caption] <span class="comment"># 对话框</span></span><br><span class="line">caption_recon = caption <span class="comment"># 重构后的描述，用于匹配图片</span></span><br><span class="line">caption_recons = [caption] <span class="comment"># 重构描述列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): <span class="comment"># 10轮对话</span></span><br><span class="line">question = generate_question(dialogue, caption_recon)</span><br><span class="line">prompt = <span class="string">f&quot;Question: <span class="subst">&#123;question&#125;</span> Answer: &quot;</span></span><br><span class="line">_inputs = processor2(images=image, text=prompt, return_tensors=<span class="string">&#x27;pt&#x27;</span>).to(config[<span class="string">&quot;device&quot;</span>])</span><br><span class="line">_outputs = blip2.generate(**_inputs, do_sample=<span class="literal">False</span>)</span><br><span class="line">answer = processor2.decode(_outputs[<span class="number">0</span>], skip_special_tokens=<span class="literal">True</span>).strip()</span><br><span class="line">qa = question.strip()+ <span class="string">&#x27; &#x27;</span> + answer</span><br><span class="line">dialogue.append(qa)</span><br><span class="line">caption_recon = reconstruct_caption(dialogue, caption_recons)</span><br><span class="line">caption_recons.append(caption_recon)</span><br><span class="line">tqdm.write(<span class="string">f&quot;Round <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;caption_recon&#125;</span>&quot;</span>)</span><br><span class="line">ret = &#123;</span><br><span class="line"><span class="string">&quot;img&quot;</span>: images[idx],</span><br><span class="line"><span class="string">&quot;dialog&quot;</span>: caption_recons</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">filename = <span class="string">&quot;dialogues/&quot;</span>+<span class="string">&quot;mine_&quot;</span> + config[<span class="string">&quot;gpt_model&quot;</span>]+<span class="string">&quot;_&quot;</span>+<span class="string">&quot;BLIP2&quot;</span>+<span class="string">&quot;.txt&quot;</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(images)), desc=<span class="string">&quot;对话生成进度&quot;</span>, position=<span class="number">0</span>):</span><br><span class="line">dialog = generate_dialog(idx)</span><br><span class="line">f.write(json.dumps(dialog, ensure_ascii=<span class="literal">False</span>)+<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="Debug日志">Debug日志</h3><p>测试使用了项目仓库的<code>eval.py</code>源代码。</p><p>可能是我使用Windows系统的缘故，<code>eval.py</code>代码中有一些报错，具体问题和调整如下：</p><ol><li><code>AttributeError: Can't pickle local object 'BLIP_ZERO_SHOT_BASELINE.&lt;locals&gt;.&lt;lambda&gt;'</code><ul><li>原因：在Windows上使用多进程（<code>num_workers&gt;0</code>）时，需要pickle对象，但是其中的lambda函数或局部函数不能被pickle</li><li>解决：将lambda函数改为全局函数，再使用<code>functools.partial</code>进行参数绑定</li></ul></li><li><code>RuntimeError: Expected all tensors to be on the same device, but found at least two devices, cuda:0 and cpu!</code><ul><li>原因：函数<code>text_encode_fn</code>中的<code>processor</code>没有<code>to(device)</code></li><li>解决：多做一步，将<code>processor</code>的输出``to(device)`</li></ul></li></ol><p>尝试跑通<code>generate_dialog.py</code>的过程中也遇到了上述问题，解决方法同。</p><h3 id="测试结果">测试结果</h3><p>正常情况下3~5分钟可以生成1条数据（大约80次请求）。<br>但由于我生成数据短时间内大量调用OpenAI API，导致被限流，20~30分钟才能产生1条数据，故本次实现在eval阶段仅有253条数据。</p><p>在使用ChatGPT-4o-mini作为提问模型G，BLIP2作为回答模型A，使用同一测试代码的情况下，测试结果和仓库的对话数据Hit@K对比如下：</p><table><thead><tr><th style="text-align:center">length</th><th style="text-align:center">仓库数据Hit@10(2064 testcases)</th><th style="text-align:center">实现数据Hit@10（253 testcases）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">71.12%</td><td style="text-align:center">72.33%</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">79.02%</td><td style="text-align:center">81.42%</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">83.09%</td><td style="text-align:center">83.40%</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">85.85%</td><td style="text-align:center">85.38%</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">87.55%</td><td style="text-align:center">86.56%</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">88.71%</td><td style="text-align:center">87.75%</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">89.39%</td><td style="text-align:center">88.14%</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">90.12%</td><td style="text-align:center">88.54%</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">90.70%</td><td style="text-align:center">88.93%</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">91.09%</td><td style="text-align:center">89.33%</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">91.47%</td><td style="text-align:center">90.12%</td></tr></tbody></table><p>BRI对比（越低越好）：</p><ul><li>仓库对话的BRI：10.195615768432617</li><li>实现对话的BRI：10.252569198608398</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 论文实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bag of Features 图像检索算法</title>
      <link href="/posts/Bag_of_Features.html"/>
      <url>/posts/Bag_of_Features.html</url>
      
        <content type="html"><![CDATA[<h2 id="算法原理">算法原理</h2><h3 id="引入：词袋模型（Bag-of-Words）">引入：词袋模型（Bag of Words）</h3><p>Bag of Words是文本分类中一种通俗易懂的策略。<br>一般来讲，如果我们要了解一段文本的主要内容，最行之有效的策略是抓取文本中的关键词，根据关键词出现的频率确定这段文本的中心思想。</p><p>Bag of Words中的Words是区分度较高的单词。<br>根据这些Words ，我们就可以快速识别出文章内容，并对文章进行分类。</p><p>Bag of Features是对图像的一种类似的处理方法，抽出图像中的关键特征，根据这些特征来识别图像。</p><h3 id="Bag-of-Features-算法流程">Bag of Features 算法流程</h3><ol><li>提取出关键特征，通常会使用SIFT特征。</li><li>将这些特征进行K-Means聚类，得到包含K个视觉词汇的词典。</li><li>对图像中的特征点进行量化，将特征点映射到视觉词汇上。</li><li>统计每个视觉词汇的出现频率，得到频率直方图。</li><li>构造特征到图像的倒排表，用于图像检索。</li><li>根据索引结果，进行直方图匹配</li></ol><h3 id="代码实现">代码实现</h3><p><code>image</code>文件夹下存放图像，<code>query</code>文件夹下存放查询图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> distance</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;LOKY_MAX_CPU_COUNT&quot;</span>] = <span class="string">&quot;4&quot;</span> <span class="comment"># KMenas 多线程设置</span></span><br><span class="line"></span><br><span class="line">descriptors_list = [] <span class="comment"># 描述符列表</span></span><br><span class="line">histograms = &#123;&#125; <span class="comment"># 直方图字典</span></span><br><span class="line">sift = cv2.SIFT_create() <span class="comment"># 创建SIFT对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件夹下所有图片路径</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_images</span>(<span class="params">image_folder</span>):</span><br><span class="line">    images = []</span><br><span class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(image_folder): </span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> filename.lower().endswith(<span class="string">&quot;.jpg&quot;</span>):</span><br><span class="line">                images.append(os.path.join(root, filename))</span><br><span class="line">    <span class="keyword">return</span> images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 提取SIFT特征</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_sift_feature</span>(<span class="params">img_path</span>):</span><br><span class="line">    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE) </span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    keypoints, descriptors = sift.detectAndCompute(img, <span class="literal">None</span>) <span class="comment"># 提取特征点和描述符</span></span><br><span class="line">    <span class="keyword">return</span> keypoints, descriptors</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_sift_features</span>(<span class="params">image_paths, cache=<span class="string">&quot;cache/BOF_SIFT_desc.pkl&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1.提取SIFT特征&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cache):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(cache, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;从缓存中加载SIFT特征: <span class="subst">&#123;cache&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> pickle.load(f)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> img_path <span class="keyword">in</span> tqdm(image_paths):</span><br><span class="line">        keypoints, descriptors = extract_sift_feature(img_path)</span><br><span class="line">        <span class="keyword">if</span> descriptors <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            descriptors_list.append(descriptors) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(cache, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;保存SIFT特征到缓存: <span class="subst">&#123;cache&#125;</span>&quot;</span>)</span><br><span class="line">        pickle.dump(descriptors_list, f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> descriptors_list <span class="comment"># 保存描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. K-Means聚类，创建视觉词典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_vocabulary</span>(<span class="params">descriptors_list, K, cache=<span class="string">&quot;cache/BOF_kmeans.pkl&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2.创建视觉词典&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cache):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(cache, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;从缓存中加载K-Means模型: <span class="subst">&#123;cache&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> pickle.load(f)</span><br><span class="line"></span><br><span class="line">    st = time()</span><br><span class="line">    all_descriptors = np.vstack(descriptors_list)  <span class="comment"># 汇总所有特征点</span></span><br><span class="line">    kmeans = KMeans(n_clusters=K, random_state=<span class="number">0</span>, n_init=<span class="number">10</span>)</span><br><span class="line">    kmeans.fit(all_descriptors)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;K-Means聚类耗时: <span class="subst">&#123;time()-st:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(cache, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;保存K-Means模型到缓存: <span class="subst">&#123;cache&#125;</span>&quot;</span>)</span><br><span class="line">        pickle.dump(kmeans, f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kmeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 计算数据库的BoF直方图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_histogram</span>(<span class="params">img_path, kmeans, K</span>):</span><br><span class="line">    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    keypoints, descriptors = sift.detectAndCompute(img, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> descriptors <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        words = kmeans.predict(descriptors)</span><br><span class="line">        hist, _ = np.histogram(words, bins=np.arange(K+<span class="number">1</span>))</span><br><span class="line">        hist = hist / np.linalg.norm(hist)  <span class="comment"># 归一化</span></span><br><span class="line">        <span class="keyword">return</span> hist</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_histograms</span>(<span class="params">image_paths, kmeans, K, cache=<span class="string">&quot;cache/BOF_histogram.pkl&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3.计算数据库的BoF直方图&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cache):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(cache, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;从缓存中加载数据库直方图: <span class="subst">&#123;cache&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> pickle.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> img_path <span class="keyword">in</span> tqdm(image_paths):</span><br><span class="line">        hist = compute_histogram(img_path, kmeans, K)</span><br><span class="line">        <span class="keyword">if</span> hist <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            histograms[img_path] = hist</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(cache, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;保存数据库直方图到缓存: <span class="subst">&#123;cache&#125;</span>&quot;</span>)</span><br><span class="line">        pickle.dump(histograms, f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> histograms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 构造倒排索引</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_inverted_index</span>(<span class="params">histograms</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4.构造倒排索引&quot;</span>)</span><br><span class="line">    inverted_index = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> img_path, hist <span class="keyword">in</span> tqdm(histograms.items()):</span><br><span class="line">        <span class="keyword">for</span> word_idx, freq <span class="keyword">in</span> <span class="built_in">enumerate</span>(hist):</span><br><span class="line">            <span class="keyword">if</span> freq &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> word_idx <span class="keyword">not</span> <span class="keyword">in</span> inverted_index:</span><br><span class="line">                    inverted_index[word_idx] = []</span><br><span class="line">                inverted_index[word_idx].append((img_path, freq))</span><br><span class="line">    <span class="keyword">return</span> inverted_index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 直方图匹配</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">match_image</span>(<span class="params">query_hist, histograms</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5.直方图匹配&quot;</span>)</span><br><span class="line">    best_match = <span class="literal">None</span></span><br><span class="line">    min_dist = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> img_path, hist <span class="keyword">in</span> tqdm(histograms.items()):</span><br><span class="line">        dist = distance.euclidean(query_hist, hist)</span><br><span class="line">        <span class="keyword">if</span> dist &lt; min_dist:</span><br><span class="line">            min_dist = dist</span><br><span class="line">            best_match = img_path</span><br><span class="line">    <span class="keyword">return</span> best_match</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行BoF流程</span></span><br><span class="line">image_folder = <span class="string">&quot;image&quot;</span></span><br><span class="line">image_paths = get_images(image_folder)</span><br><span class="line">descriptors_list = extract_sift_features(image_paths)</span><br><span class="line">kmeans = create_vocabulary(descriptors_list, K=<span class="number">50</span>)</span><br><span class="line">histograms = compute_histograms(image_paths, kmeans, K=<span class="number">50</span>)</span><br><span class="line">inverted_index = build_inverted_index(histograms)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试：检索图像</span></span><br><span class="line">test_img = <span class="string">&quot;query/A0C573_20151029074136_6562078379.jpg&quot;</span></span><br><span class="line">histograms[test_img] = compute_histogram(test_img, kmeans, K=<span class="number">50</span>)</span><br><span class="line">test_hist = histograms[test_img]</span><br><span class="line">matched_img = match_image(test_hist, histograms)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;test_img&#125;</span> 匹配到的最相似图片是 <span class="subst">&#123;matched_img&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(DL) PS <span class="attr">D:</span>\Repos\Course\CVLab&gt; &amp; <span class="attr">C:</span><span class="regexp">/Users/</span>CCLMSY<span class="regexp">/.conda/</span>envs<span class="regexp">/DL/</span>python.exe <span class="attr">d:</span><span class="regexp">/Repos/</span>Course<span class="regexp">/CVLab/</span>BOF.py</span><br><span class="line"><span class="number">1.</span>提取SIFT特征</span><br><span class="line">从缓存中加载SIFT特征: cache/BOF_SIFT_desc.pkl</span><br><span class="line"><span class="number">2.</span>创建视觉词典</span><br><span class="line">从缓存中加载K-Means模型: cache/BOF_kmeans.pkl</span><br><span class="line"><span class="number">3.</span>计算数据库的BoF直方图</span><br><span class="line">从缓存中加载数据库直方图: cache/BOF_histogram.pkl</span><br><span class="line"><span class="number">4.</span>构造倒排索引</span><br><span class="line"><span class="number">100</span>%|██████████████████████████████████████████████████| <span class="number">945</span><span class="regexp">/945 [00:00&lt;00:00, 23779.80it/</span>s] </span><br><span class="line"><span class="number">5.</span>直方图匹配</span><br><span class="line"><span class="number">100</span>%|██████████████████████████████████████████████████| <span class="number">946</span><span class="regexp">/946 [00:00&lt;00:00, 157646.77it/</span>s] </span><br><span class="line">query/A0C573_20151029074136_6562078379.jpg 匹配到的最相似图片是 image\A0C573\A0C573_20151029074136_6562078379.jpg</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SIFT 图像特征匹配算法</title>
      <link href="/posts/SIFT.html"/>
      <url>/posts/SIFT.html</url>
      
        <content type="html"><![CDATA[<h2 id="SIFT简介">SIFT简介</h2><p>SIFT（Scale-Invariant Feature Transform，尺度不变特征变换匹配算法）是一种高效区域检测算法。</p><p>SIFT算法可以解决的问题：</p><ol><li>RST（Rotation Scale Translation）：图像的旋转、缩放、平移等变换</li><li>图像的仿射变换（Affine Transformation）：图像的拉伸、压缩、扭曲等变换</li><li>图像的光照变化</li><li>目标部分遮挡</li><li>杂物和噪声干扰</li></ol><h2 id="SIFT算法原理">SIFT算法原理</h2><h3 id="1-高斯滤波">1. 高斯滤波</h3><p>一个图像的尺度空间$L$是高斯函数$G(x,y,\sigma)$与图像$I(x,y)$的卷积：</p><p>$$L(x,y,\sigma) = G(x,y,\sigma) * I(x,y) \\<br>G(x,y,\sigma) = \dfrac{1}{2\pi\sigma^2}e^{-\frac{(x-x_0)^2+(y-y_0)^2}{2\sigma^2}}$$</p><p>其中，$G(x,y,\sigma)$是高斯函数，$\sigma$是尺度因子，$*$是卷积运算，$x_0,y_0$是高斯函数的中心（卷积核的中心）。</p><p>$\sigma$越小，图像被平滑的越少，图像的细节越多。<br>小尺度对应于图像的细节，大尺度对应于图像的整体特征。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/Gaussian_Blur.png" alt="Gaussian Blur"></p><h3 id="2-高斯金字塔">2. 高斯金字塔</h3><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94.png" alt="高斯金字塔"></p><p>高斯金字塔包含多组（Octave）图像，每组图像由多层（Interval）不同尺度的高斯模糊图像组成。</p><p>构建过程：</p><ol><li>将原图像扩大到两倍，作为第0组的第0层</li><li>对第0组的第0层进行$\sigma_0$的高斯模糊，得到第0组的第1层</li><li>选定一个比例系数$k$，对第0组的第1层进行$k\sigma_0$的高斯模糊，得到第0组的第2层</li><li>对第0组的第2层进行$k^2\sigma_0$的高斯模糊，得到第0组的第3层，以此类推…</li><li>将<strong>上一组倒数第3层图像</strong>做比例因子为2的降采样，得到下一组的第0层，重复步骤2-4</li></ol><p>组数计算公式：$O=\lfloor\log_2(\min(M,N))\rfloor-3$</p><ul><li>$M,N$：原图像的长宽</li></ul><p>层数公式：$S=n+3$</p><ul><li>$S$是每组的层数（自设）</li><li>$n$是最终想在差分金字塔中提取极值点的层数（见差分金字塔）</li></ul><p>平滑因子公式：$\sigma(o,r)=\sigma_0 2^{o+\frac{r}{n}}$，其中$o$是组数，$r$是层数</p><ul><li>SIFT算法中，$\sigma_0=1.6$。但由于相机具有初始模糊$\sigma_0=0.5$，实际$\sigma_0=\sqrt{1.6^2-0.5^2}=1.52$</li><li>第o层的初始平滑因子$\sigma(o,0)=2^o\sigma_0$</li><li>$k=2^{1/n}$</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%942.png" alt="高斯金字塔2"></p><p>金字塔内各图片的关系：</p><ul><li>在同一组内，不同层图像的尺寸是一样的，后一层图像的高斯平滑因子σ是前一层图像平滑因子的k倍</li><li>在不同组内，后一组第一个图像是前一组倒数第三个图像的二分之一采样，图像大小是前一组的一半</li></ul><h3 id="3-高斯差分金字塔与极值点检测">3. 高斯差分金字塔与极值点检测</h3><h4 id="3-1-高斯差分金字塔">3.1 高斯差分金字塔</h4><p>对高斯金字塔的每一组图像，计算相邻两层图像的差分，得到高斯差分金字塔(DoG, Difference of Gaussian)。</p><p>$$D(x,y,\sigma) = (G(x,y,k\sigma)-G(x,y,\sigma)) * I(x,y)$$</p><h4 id="3-2-估计极值点">3.2 估计极值点</h4><p>将每个像素点和它在3×3×3的邻域内的26个像素点进行比较。<br>如果这个点是这27个点中的最大值或最小值，则认为这个点是一个极值点。</p><p>DoG金字塔是离散的(因为尺度空间和像素点都是离散的)，所以找到的极值点不太准确的，很大可能在真正极值点附近，因此需要对每个极值点进行插值。</p><h4 id="3-3-泰勒展开求精确极值点">3.3 泰勒展开求精确极值点</h4><p>对每个极值点$X_0(x_0,y_0,\sigma_0)^T$，进行三元二次泰勒展开：</p><p>$$<br>f(X) = f(x_0)+\dfrac{\partial f}{\partial X}^T\hat{X}+\dfrac{1}{2}\hat{X}^T\dfrac{\partial^2 f}{\partial X^2}\hat{X} \\<br>\hat{X} = X-X_0 \\<br>X = (x,y,\sigma)^T<br>$$</p><p>将$f(X)$对$X$求导：</p><p>$$<br>\dfrac{\partial f(X)}{\partial X} = \dfrac{\partial f}{\partial X}^T+\dfrac{1}{2}\left( \dfrac{\partial^2 f}{\partial X^2} + \dfrac{\partial^2 f}{\partial X^2}^T \right)\hat{X} = \dfrac{\partial f}{\partial X}^T+\dfrac{\partial^2 f}{\partial X^2}\hat{X}<br>$$</p><p>导数为0时，解得极值点：</p><p>$$<br>\hat{X} = -\dfrac{\partial^2 f}{\partial X^2}^{-1}\dfrac{\partial f}{\partial X}<br>$$</p><p>代入$f(X)$得到极值：</p><p>$$<br>f(X) = f(x_0)+\dfrac{1}{2}\dfrac{\partial f}{\partial X}^T\hat{X}<br>$$</p><h4 id="3-4-去除低对比度点">3.4 去除低对比度点</h4><p>舍去$|f(X_0)|&lt;\dfrac{T}{n}, T=0.04$的极值点，因为这些点对应的差分值太小，对比度低，不具有代表性。</p><h4 id="3-5-去除边缘响应">3.5 去除边缘响应</h4><p>DoG在边缘会有比较大的值（边缘响应强），但边缘不一定能够提供稳定的特征，因此需要去除边缘响应强的点。</p><p>对于每个极值点，计算Hessian矩阵的迹和行列式：</p><p>$$<br>H = \begin{bmatrix} D_{xx} &amp; D_{xy} \ D_{xy} &amp; D_{yy} \end{bmatrix} \\<br>Tr(H) = D_{xx}+D_{yy}=\alpha+\beta \\<br>Det(H) = D_{xx}D_{yy}-(D_{xy})^2=\alpha\beta<br>$$</p><p>其中：</p><ul><li>$\alpha$为较大的特征值，$\beta$为较小的特征值</li><li>$\alpha = r \beta$，$r$是一个大于1的实数</li></ul><p>过滤：</p><ol><li>$Det(H)&lt;0$</li><li>$\dfrac{(Tr(H))^2}{Det(H)}\ge (r+1)^2/r$，论文推荐值$r=10$</li></ol><h3 id="4-关键点方向分配">4. 关键点方向分配</h3><ol><li>0~360度划分为36 bins，每个bin为10度</li><li>在<strong>高斯金字塔</strong>找到关键点对应位置，以它为圆心，半径为$1.5\sigma$画圆</li><li>统计圆中所有像素的梯度方向、梯度幅值（模），直方图平滑处理，用$1.5\sigma$进行高斯加权<ul><li>平滑处理：防止某个梯度方向角度受噪声干扰等因素突变</li><li>高斯加权：使特征点附件的梯度幅值具有更大的权重，弥补因没有仿射不变性而导致的特征不稳定</li></ul></li><li>统计出数值最高的梯度方向，作为主方向；保留大于主方向80%的方向作为辅方向</li></ol><p>梯度方向和梯度幅值的计算：</p><p>$$<br>m(x,y) = \sqrt{(L(x+1,y)-L(x-1,y))^2+(L(x,y+1)-L(x,y-1))^2}<br>$$</p><p>$$<br>\theta(x,y) = \arctan\left(\dfrac{L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)}\right)<br>$$</p><p>高斯加权公式：</p><p>$$<br>W_{i,j} = e^{\dfrac{-(i^2+j^2)}{2\times(1.5\sigma)^2}}<br>$$</p><ul><li>$i,j$是像素点到关键点的距离</li></ul><h3 id="5-关键点描述">5. 关键点描述</h3><p>描述符是一组向量，用于描述特征点及其领域点的特征，以便更好地与其他图片匹配</p><ol><li>将坐轴标移到关键点方向</li><li>将特征点的领域划分为$d\times d$个子区域，每个子区域大小为$m\sigma\times m\sigma$，并划分为8个方向。论文推荐值：$m=3$，$d=4$</li><li>每一个子块进行8个方向的直方图统计操作，共$d\times d\times 8=128$个bin，得到一个128维的特征向量（描述符）</li></ol><h3 id="6-特征点匹配">6. 特征点匹配</h3><p>分别对模板图（参考图，reference image）和实时图（观测图，observation image）建立关键点描述子集合。</p><p>目标的识别是通过两点集内关键点描述子的比对来完成，一般采用欧氏距离来衡量两个描述子之间的相似度。</p><p>可以使用<a href="https://oi-wiki.org/ds/kdt/">KD树</a>优化搜索过程。</p><h2 id="SIFT实现">SIFT实现</h2><p>cv2中已经给出了SIFT算法的实现，可以直接调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img=cv2.imread(<span class="string">&#x27;nz.jpg&#x27;</span>)</span><br><span class="line">cat=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SIFT对象</span></span><br><span class="line">sift=cv2.SIFT_create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键点检测：kp关键点信息包括方向，尺度，位置信息，des是关键点的描述符</span></span><br><span class="line">kp,des=sift.detectAndCompute(cat,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在图像上绘制关键点的检测结果</span></span><br><span class="line">cv2.drawKeypoints(img,kp,img,flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像显示</span></span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.title(<span class="string">&#x27;SIFT Result&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://source.cclmsy.cc/Posts/DL/Note/SIFT_Result.png" alt="SIFT Result"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-means/K-means++</title>
      <link href="/posts/k_means.html"/>
      <url>/posts/k_means.html</url>
      
        <content type="html"><![CDATA[<h2 id="K-Means聚类算法">K-Means聚类算法</h2><h3 id="算法思想">算法思想</h3><p>K-means算法是一种迭代求解的聚类算法，将数据集中的n个样本划分为K个簇（聚类）。<br>每个对象到簇中心的距离之和最小。<br>簇内的对象相似度较高，簇间的对象相似度较低。</p><h3 id="算法步骤">算法步骤</h3><h4 id="1-选择K个初始聚类中心">1. 选择K个初始聚类中心</h4><p>随机选择K个样本作为初始聚类中心。</p><p>选择对最终的聚类结果有一定影响，因此在实际应用中，通常会采用一些启发式的方法来选择较好的初始聚类中心，如K-means++算法</p><h4 id="2-计算每个样本到聚类中心的距离">2. 计算每个样本到聚类中心的距离</h4><p>对于每个样本，计算其到K个聚类中心的距离，将其划分到距离最近的聚类中心所在的簇中。</p><p>通常使用欧式距离：$d(x_i, c_j) = \sqrt{\sum_{k=1}^{n}(x_{ik}-c_{jk})^2}$</p><h4 id="3-更新聚类中心">3. 更新聚类中心</h4><p>对于每个聚类，重新计算其聚类中心，新的聚类中心是该聚类内所有数据点的均值：$c_j = \dfrac{1}{|S_j|}\sum_{x_i\in S_j}x_i$</p><h4 id="4-迭代">4. 迭代</h4><p>重复步骤2和3，直到聚类中心不再发生显著变化或者达到最大迭代次数。</p><h3 id="算法优缺点">算法优缺点</h3><p>优点：逻辑简单、易于实现、收敛速度快</p><p>缺点：需要事先确定聚类数目K，对初始聚类中心敏感，可能收敛到局部最优解</p><h3 id="K-Means-实现">K-Means 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params">data, k=<span class="number">3</span>, max_iter=<span class="number">100</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;K-means 聚类算法</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        data: 数据集，list[element]，element是一个list[float]</span></span><br><span class="line"><span class="string">        k: 聚类数</span></span><br><span class="line"><span class="string">        max_iter: 最大迭代次数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化聚类中心</span></span><br><span class="line">    centers = random.sample(data, k)</span><br><span class="line">    <span class="comment"># 初始化聚类结果</span></span><br><span class="line">    clusters = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    <span class="comment"># 迭代聚类</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">iter</span> <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        <span class="comment"># 分配数据到最近的聚类中心</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> data: <span class="comment"># 对于每个数据</span></span><br><span class="line">            min_dist = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment"># 最小距离</span></span><br><span class="line">            min_idx = -<span class="number">1</span> <span class="comment"># 最近聚类</span></span><br><span class="line">            <span class="keyword">for</span> i, center <span class="keyword">in</span> <span class="built_in">enumerate</span>(centers):</span><br><span class="line">                dist = <span class="built_in">sum</span>((x-y)**<span class="number">2</span> <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(element, center)) <span class="comment"># 计算距离</span></span><br><span class="line">                <span class="keyword">if</span> dist &lt; min_dist:</span><br><span class="line">                    min_dist = dist</span><br><span class="line">                    min_idx = i</span><br><span class="line">            clusters[min_idx].append(element)</span><br><span class="line">        <span class="comment"># 更新聚类中心</span></span><br><span class="line">        new_centers = [<span class="literal">None</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i, cluster <span class="keyword">in</span> <span class="built_in">enumerate</span>(clusters):</span><br><span class="line">            new_centers[i] = [<span class="built_in">sum</span>(x)/<span class="built_in">len</span>(cluster) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(*cluster)]</span><br><span class="line">        <span class="comment"># 判断是否收敛：中心点是否变化小于eps</span></span><br><span class="line">        eps = <span class="number">1e-6</span></span><br><span class="line">        fl = <span class="built_in">all</span>((<span class="built_in">sum</span>((x-y)**<span class="number">2</span> <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b)) &lt; eps) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(centers, new_centers))</span><br><span class="line">        <span class="keyword">if</span> fl <span class="keyword">or</span> <span class="built_in">iter</span> == max_iter-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        centers = new_centers</span><br><span class="line">        clusters = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    <span class="keyword">return</span> clusters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">data = [[random.random() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line">clusters = k_means(data, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;m&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i, cluster <span class="keyword">in</span> <span class="built_in">enumerate</span>(clusters):</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> cluster:</span><br><span class="line">        plt.scatter(element[<span class="number">0</span>], element[<span class="number">1</span>], c=colors[i])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://source.cclmsy.cc/Posts/DL/Note/k_means_1.png" alt="k_means"></p><h2 id="K-Means-算法">K-Means++算法</h2><p>K-Means++算法是K-means算法的改进，优化了初始聚类中心的选择，使得初始聚类中心更有代表性，收敛速度更快。</p><p>逐个选取k个簇中心，且离其它簇中心越远的样本点越有可能被选为下一个簇中心</p><h3 id="算法步骤（选择K个初始聚类中心的过程）">算法步骤（选择K个初始聚类中心的过程）</h3><h4 id="1-选择第一个簇中心">1. 选择第一个簇中心</h4><p>随机选择一个样本作为第一个簇中心</p><h4 id="2-选择下一个簇中心">2. 选择下一个簇中心</h4><p>对于样本x，计算其到已有簇中心的最短距离，记为$D(x)$，选取x作为下一个簇中心的概率为$\dfrac{D(x)^2}{\sum_{x\in X}D(x)^2}$</p><h4 id="3-迭代">3. 迭代</h4><p>重复步骤2，直到选取k个簇中心</p><h3 id="实现">实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择第一个聚类中心</span></span><br><span class="line">centers = [random.choice(data)]</span><br><span class="line"><span class="comment"># 选择其他聚类中心</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">    dists = [<span class="built_in">min</span>(<span class="built_in">sum</span>((x-y)**<span class="number">2</span> <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(element, center)) <span class="keyword">for</span> center <span class="keyword">in</span> centers) <span class="keyword">for</span> element <span class="keyword">in</span> data]</span><br><span class="line">    probs = [dist**<span class="number">2</span>/<span class="built_in">sum</span>(dists) <span class="keyword">for</span> dist <span class="keyword">in</span> dists]</span><br><span class="line">    centers.append(random.choices(data, probs)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 聚类算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复现|ChatIR：基于对话的图像检索系统</title>
      <link href="/posts/ChatIR.html"/>
      <url>/posts/ChatIR.html</url>
      
        <content type="html"><![CDATA[<p>论文：<a href="https://arxiv.org/abs/2305.20062">Chatting Makes Perfect: Chat-based Image Retrival</a></p><h2 id="1-Introduction">1. Introduction</h2><p>传统的文本到图像检索方法，用户需要一次性提供全面详细的描述，来搜索目标图像。</p><p>本文提出了一个基于对话的图像检索系统ChatIR，用户可以通过多轮对话逐步细化搜索目标。</p><p>ChatIR系统包含2个部分：对话构建（Dialog Building）和图像搜索（Image Search）</p><ul><li>对话构建：使用问题生成器G，考虑当前对话历史，生成下一个问题</li><li>图像搜索：使用模型F，将不同长度的对话序列映射到视觉嵌入空间</li><li>两个组成部分建立在Instructional LLMs和fundation Vision and Language Models上</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/ChatIR.png" alt="Figure1"></p><p>考虑三个问题：</p><ol><li>使用什么数据集训练？是否需要新创建和标注数据集？<ul><li>使用VisDial数据集</li><li>问题：VisDial是一个用于“创建关于图像的聊天”的数据集，没有检索目标</li><li>解决：输入输出反置，对话作为输入、图像作为输出</li></ul></li><li>如何独立评估ChatIR系统的不同组件？<ul><li>测试使用不同的<code>F训练策略</code>和<code>提问模型G</code>对检索性能的影响</li><li>使用了BLIP替代用户回答问题</li></ul></li><li>如何定义评估指标？<ul><li>每一轮对话的成功检索概率Hit@10</li></ul></li></ol><h2 id="2-Related-Work">2. Related Work</h2><ol><li>视觉对话（Visual Conversation）领域<ul><li>当前视觉领域工作的重点在于图像理解和生成模型，而不是检索</li><li>生成式视觉对话中，近期的基础模型V&amp;L性能优越，因此ChatIR系统在此基础上构建</li></ul></li><li>视觉搜索（Visual Search）领域<ul><li>CoIR：使用多模态询问查找目标图像</li><li>一些研究基于CoIR，利用用户反馈细化查询结果</li><li>但是，没有考虑用户交互（只有用户反馈，没有机器提问）、没有明确利用对话历史</li></ul></li></ol><h2 id="3-Method">3. Method</h2><h3 id="3-1-Dialog-Builder-Model-对话生成模型">3.1 Dialog Builder Model 对话生成模型</h3><p>对话记录表示：$D_i = (C, Q_1, A_1, …, Q_i)$</p><ul><li>$C$：目标图像的初始文本描述（标题）</li><li>$Q_i$：第i个问题</li><li>$A_i$：第i个回答</li></ul><p>对话生成模型包含两个部分：</p><ul><li>问题生成器G：一个LLM，根据对话记录生成下一个问题<ul><li>$G: D_i \rightarrow Q_{i+1}$</li><li>G不知道目标图像T是什么，只知道对话历史</li></ul></li><li>答案提供者A：在实践中，通常是一个脑海中有大致目标图像的人类<ul><li>由于需要大规模实验，不能依赖用户提供答案</li><li>因此，使用了一个现成的模型BLIP2来回答</li></ul></li></ul><h3 id="3-2-Image-Retrieval-Model-图像检索模型">3.2 Image Retrieval Model 图像检索模型</h3><p>图像搜索过程：在<code>查询</code>和<code>目标图像</code>共享的视觉嵌入空间中，搜索匹配项。</p><ul><li>所有的目标图像先经过图像嵌入模块进行编码，由一个$d$维的特征向量$f\in \mathbb R^d$表示。</li><li>图像检索模块F将对话历史$D_i$映射到视觉嵌入空间，$F: D_i \rightarrow \mathbb R^d$，</li><li>候选对象根据相似度进行排序。</li></ul><p>引入分隔符[SEP]和添加符[CLS]，表示整个对话序列，投射到视觉嵌入空间。</p><p>F采用（使用BLIP）预训练的图像/文本编码器，并通过对比学习，对基于对话的检索进行微调。</p><p>通过提取VisDial数据集中的图像和相应对话，手动标注，训练F。</p><h2 id="4-Evaluation">4. Evaluation</h2><p>在评估环节，原文使用了Hit@10指标，即目标图像在前10个检索结果中的试验占比。</p><p>原文从三个方面进行了对比：</p><ol><li>与现有文本到图像（Text to Image,TTI）检索方法的比较<ol><li>ChatIR使用ChatGPT作为提问者G，BLIP2作为回答者A</li><li>与Zero-shot的BLIP、CLIP以及fine-tuned SoTA TTI BLIP进行比较</li><li>结论：ChatIR在多轮对话环境中，相比传统单跳 TTI 方法表现更优</li></ol></li><li>不同提问者G的比较<ol><li>使用ChatGPT、FLAN-ALPACA-XXL、人类等8中不同提问者</li><li>ChatGPT表现最好</li></ol></li><li>人类参与对话的影响<ol><li>ChatGPT提问，人类回答；ChatGPT提问，BLIP2回答；人类提问，人类回答</li><li>由于人类生成的答案质量明显优于BLIP2，因此人类参与对话时，检索性能会比测试的数据更好</li></ol></li></ol><h2 id="总结和实现">总结和实现</h2><ul><li>ChatIR系统是一个基于对话的图像检索系统，包含对话构建和图像搜索两个部分</li><li>对话构建：使用问题生成器G，考虑当前对话历史，生成下一个问题<ul><li>原文测试了不同的问题生成器，其中ChatGPT表现最好</li></ul></li><li>图像搜索：使用模型F，将不同长度的对话序列映射到视觉嵌入空间<ul><li>我使用了论文仓库提供的预训练BLIP_ITM模型</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms.functional <span class="keyword">import</span> InterpolationMode</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="comment"># 多进程处理</span></span><br><span class="line">multiprocessing.set_start_method(<span class="string">&#x27;spawn&#x27;</span>, force=<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> OpenAI <span class="keyword">import</span> request_chat <span class="comment"># 自己实现的调用API函数 request_chat(dialog:list) -&gt; new_question:str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment"># 添加import路径</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;./BLIP&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> BLIP.models.blip_itm <span class="keyword">import</span> blip_itm <span class="comment"># BLIP用于图像文本匹配的预训练模型</span></span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">&quot;corpus_path&quot;</span>: <span class="string">&quot;VisualDial/search_space.json&quot;</span>, <span class="comment"># 图像库路径</span></span><br><span class="line">    <span class="string">&quot;queries_path&quot;</span>: <span class="string">&quot;dialogues/ChatGPT4oMini_BLIP2.json&quot;</span>, <span class="comment"># 测试对话数据路径</span></span><br><span class="line">    <span class="string">&quot;corpus_cache&quot;</span>: <span class="string">&quot;VisualDial/corpus_cache.pth&quot;</span>, <span class="comment"># 处理好的图像库缓存的路径</span></span><br><span class="line">    <span class="string">&quot;device&quot;</span>: <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sep&quot;</span>: <span class="string">&quot;, &quot;</span>, <span class="comment"># 对话分隔符</span></span><br><span class="line">    <span class="string">&quot;batch_size&quot;</span>: <span class="number">100</span>, <span class="comment"># 批处理大小</span></span><br><span class="line">    <span class="string">&quot;num_workers&quot;</span>: <span class="number">8</span>, <span class="comment"># 多进程处理数</span></span><br><span class="line">    <span class="string">&quot;image_size&quot;</span> : <span class="number">224</span> <span class="comment"># 图像大小</span></span><br><span class="line">&#125;</span><br><span class="line">corpus = <span class="literal">None</span> <span class="comment"># 处理好的图像库 </span></span><br><span class="line">dialog = [] <span class="comment"># 对话</span></span><br><span class="line">images = [] <span class="comment"># 图像库路径 list[图像路径]</span></span><br></pre></td></tr></table></figure><h3 id="图像数据集类">图像数据集类</h3><p>继承自Dataset，用于加载图像数据集</p><p>corpus_path：图像数据集.json，包含一个list[str]，每个元素是一个图像的路径</p><p>建立路径字符串到索引的映射，便于赋值传递和查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Corpus</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图像数据集&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, corpus_path, preprocessor</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;加载图像数据集</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            corpus_path: 图片路径列表</span></span><br><span class="line"><span class="string">            preprocessor: 图像预处理函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(corpus_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self.corpus = json.load(f)</span><br><span class="line">            f.close()</span><br><span class="line">        self.preprocessor = preprocessor</span><br><span class="line">        <span class="comment"># 图片路径到索引的映射，用于快速查找</span></span><br><span class="line">        self.path2idx = &#123;self.corpus[i]:i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.corpus))&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.corpus)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        image = self.preprocessor(self.corpus[idx])</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;idx&quot;</span>: idx, <span class="string">&quot;image&quot;</span>: image&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">path_to_index</span>(<span class="params">self, path</span>):</span><br><span class="line">        <span class="keyword">return</span> self.path2idx[path]</span><br></pre></td></tr></table></figure><h3 id="图像预处理函数">图像预处理函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">image_preprocessor</span>(<span class="params">image_path</span>):</span><br><span class="line">    transform_prep = transforms.Compose([ </span><br><span class="line">        transforms.Resize((config[<span class="string">&quot;image_size&quot;</span>], config[<span class="string">&quot;image_size&quot;</span>]), </span><br><span class="line">                          interpolation=InterpolationMode.BICUBIC),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.48145466</span>, <span class="number">0.4578275</span>, <span class="number">0.40821073</span>), </span><br><span class="line">                             (<span class="number">0.26862954</span>, <span class="number">0.26130258</span>, <span class="number">0.27577711</span>)) <span class="comment"># 参数参考BLIP的demo</span></span><br><span class="line">    ])</span><br><span class="line">    raw = Image.<span class="built_in">open</span>(image_path).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    img = transform_prep(raw)</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><h3 id="BLIP-ITM模型的图像编码器和对话编码器">BLIP_ITM模型的图像编码器和对话编码器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_funcs</span>():</span><br><span class="line">    <span class="comment"># model_url = &#x27;https://storage.googleapis.com/sfr-vision-language-research/BLIP/models/model_base_retrieval_coco.pth&#x27;</span></span><br><span class="line">    model = blip_itm(pretrained=<span class="string">&#x27;chatir_weights.ckpt&#x27;</span>, <span class="comment"># 论文仓库中的预训练模型</span></span><br><span class="line">                    med_config=<span class="string">&quot;BLIP/configs/med_config.json&quot;</span>, </span><br><span class="line">                    image_size=config[<span class="string">&quot;image_size&quot;</span>],</span><br><span class="line">                    vit=<span class="string">&quot;base&quot;</span>)</span><br><span class="line">    device = config[<span class="string">&quot;device&quot;</span>]</span><br><span class="line">    model = model.to(device).<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">image_encoder</span>(<span class="params">img</span>):</span><br><span class="line">        embeddings = model.visual_encoder(img) <span class="comment"># embedding</span></span><br><span class="line">        <span class="comment"># print(embeddings.shape) # (批次大小, patch个数+1, 隐层维度)</span></span><br><span class="line">        vision_proj = model.vision_proj(embeddings[:, <span class="number">0</span>, :]) <span class="comment"># 取[CLS] token，提取全局特征</span></span><br><span class="line">        <span class="keyword">return</span> F.normalize(vision_proj, dim=-<span class="number">1</span>) <span class="comment"># 正则化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dialog_encoder</span>(<span class="params">dialog</span>):</span><br><span class="line">        text = model.tokenizer(dialog, padding=<span class="string">&#x27;longest&#x27;</span>, truncation=<span class="literal">True</span>, max_length=<span class="number">200</span>, <span class="comment"># 填充到最长，截断到200</span></span><br><span class="line">                            return_tensors=<span class="string">&quot;pt&quot;</span>).to(device)  <span class="comment"># 返回PyTorch张量</span></span><br><span class="line">        text_out = model.text_encoder(text.input_ids, attention_mask=text.attention_mask, </span><br><span class="line">                                    return_dict=<span class="literal">True</span>, mode=<span class="string">&#x27;text&#x27;</span>) <span class="comment"># embedding</span></span><br><span class="line">        shift = model.text_proj(text_out.last_hidden_state[:, <span class="number">0</span>, :]) <span class="comment"># 同</span></span><br><span class="line">        <span class="keyword">return</span> F.normalize(shift, dim=-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image_encoder, dialog_encoder</span><br></pre></td></tr></table></figure><h3 id="处理图像库">处理图像库</h3><p>由于加载时间长，一次加载后将数据存储在本地，便于二次调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">corpus_dataset = Corpus(config[<span class="string">&quot;corpus_path&quot;</span>], image_preprocessor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_corpus</span>(<span class="params">image_encoder</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;处理图像库</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        corpus: tuple[torch.Tensor, torch.Tensor] 图像库索引和对应的图像特征向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> corpus</span><br><span class="line">    corpus_cache = config[<span class="string">&quot;corpus_cache&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> corpus_cache <span class="keyword">and</span> os.path.exists(corpus_cache): <span class="comment"># 读取缓存</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;-----Loading corpus from <span class="subst">&#123;corpus_cache&#125;</span>-----&quot;</span>)</span><br><span class="line">        corpus = torch.load(corpus_cache)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----Preparing corpus-----&quot;</span>)</span><br><span class="line">    corpus_dataloader = DataLoader( <span class="comment"># 图像库的DataLoader</span></span><br><span class="line">        corpus_dataset,</span><br><span class="line">        batch_size=config[<span class="string">&quot;batch_size&quot;</span>],</span><br><span class="line">        shuffle=<span class="literal">False</span>,</span><br><span class="line">        num_workers=config[<span class="string">&quot;num_workers&quot;</span>],</span><br><span class="line">        pin_memory=<span class="literal">True</span>,</span><br><span class="line">        drop_last=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line">    corpus_vectors = []</span><br><span class="line">    corpus_ids = []</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(corpus_dataloader): <span class="comment"># 预处理图像库</span></span><br><span class="line">        batch_vectors = F.normalize(image_encoder(batch[<span class="string">&quot;image&quot;</span>].to(config[<span class="string">&quot;device&quot;</span>])), dim=-<span class="number">1</span>) <span class="comment"># 正则化</span></span><br><span class="line">        corpus_vectors.append(batch_vectors)</span><br><span class="line">        corpus_ids.append(batch[<span class="string">&quot;idx&quot;</span>].to(config[<span class="string">&quot;device&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    corpus_vectors = torch.cat(corpus_vectors)</span><br><span class="line">    corpus_ids = torch.cat(corpus_ids)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照索引排序</span></span><br><span class="line">    arg_ids = torch.argsort(corpus_ids)</span><br><span class="line">    corpus_vectors = corpus_vectors[arg_ids]</span><br><span class="line">    corpus_ids = corpus_ids[arg_ids]</span><br><span class="line"></span><br><span class="line">    corpus = corpus_ids, corpus_vectors</span><br><span class="line">    <span class="keyword">if</span> config[<span class="string">&quot;corpus_cache&quot;</span>]:</span><br><span class="line">        torch.save(corpus, config[<span class="string">&quot;corpus_cache&quot;</span>]) </span><br></pre></td></tr></table></figure><h3 id="提问与匹配函数">提问与匹配函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ask_for_caption</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;询问用户描述&quot;&quot;&quot;</span></span><br><span class="line">    caption = <span class="built_in">input</span>(<span class="string">&quot;Describe the image: &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> caption</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ask_question</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;询问用户问题，获取回答&quot;&quot;&quot;</span></span><br><span class="line">    question = request_chat(dialog)</span><br><span class="line">    answer = <span class="built_in">input</span>(<span class="string">f&quot;Q: <span class="subst">&#123;question&#125;</span>\nA: &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> question+<span class="string">&#x27; &#x27;</span>+answer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_top_results</span>(<span class="params">dialog, dialog_encoder, n=<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取前n最佳匹配结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dialog: str 对话</span></span><br><span class="line"><span class="string">        dialog_encoder: 对话编码器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        tops: list[int] 前n个匹配结果的索引</span></span><br><span class="line"><span class="string">        topscores: list[float] 前n个匹配结果的得分</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dialog = config[<span class="string">&quot;sep&quot;</span>].join(dialog)</span><br><span class="line">    dialog_vector = dialog_encoder(dialog) <span class="comment"># 提取特征&amp;正则化</span></span><br><span class="line">    scores = dialog_vector @ corpus[<span class="number">1</span>].T <span class="comment"># 计算点积相似度</span></span><br><span class="line">    top_id = torch.argsort(scores, descending=<span class="literal">True</span>) <span class="comment"># 排序</span></span><br><span class="line">    tops = top_id.tolist()[<span class="number">0</span>][:n]</span><br><span class="line">    topscores = scores[<span class="number">0</span>][tops].tolist()</span><br><span class="line">    <span class="keyword">return</span> tops, topscores</span><br></pre></td></tr></table></figure><h3 id="主函数">主函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    image_encoder, dialog_encoder = get_funcs()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(config[<span class="string">&quot;corpus_path&quot;</span>], <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        images = json.load(f)</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        prepare_corpus(image_encoder)</span><br><span class="line">    </span><br><span class="line">        dialog.append(ask_for_caption())</span><br><span class="line">        tops,topscores = get_top_results(dialog, dialog_encoder)</span><br><span class="line">        best_image = images[tops[<span class="number">0</span>]]</span><br><span class="line">        best_score = topscores[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Best image: <span class="subst">&#123;best_image&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Best score: <span class="subst">&#123;best_score&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># display(Image.open(best_image))</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            dialog.append(ask_question())</span><br><span class="line">            tops,topscores = get_top_results(dialog, dialog_encoder)</span><br><span class="line">            best_image = images[tops[<span class="number">0</span>]]</span><br><span class="line">            best_score = topscores[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Best image: <span class="subst">&#123;best_image&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Best score: <span class="subst">&#123;best_score&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">                display(Image.<span class="built_in">open</span>(best_image))</span><br></pre></td></tr></table></figure><h2 id="测试和评估">测试和评估</h2><p>原文评估ChatIR性能的指标是Hit@10，即目标图像出现在最匹配的10个候选图像中的概率，我采用相同的评估方式</p><h3 id="对话数据集类">对话数据集类</h3><p>单个测试对话数据结构：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image_path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dialog&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;caption&quot;</span><span class="punctuation">,</span> <span class="string">&quot;question1? answer1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;question2? answer2&quot;</span><span class="punctuation">,</span> ...<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queries</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对话-图像数据集&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, queries_path, sep</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;加载对话-图像数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            queries_path: str 查询数据集路径</span></span><br><span class="line"><span class="string">            sep: str 分隔符</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(queries_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self.queries = json.load(f)</span><br><span class="line">            f.close()</span><br><span class="line">        self.dialog_length = <span class="literal">None</span></span><br><span class="line">        self.sep = sep</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queries)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">assert</span> self.dialog_length <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        target_path = self.queries[idx][<span class="string">&quot;img&quot;</span>]</span><br><span class="line">        <span class="comment"># 保留对话的前dialog_length轮</span></span><br><span class="line">        text = self.sep.join(self.queries[idx][<span class="string">&quot;dialog&quot;</span>][:self.dialog_length + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;text&quot;</span>: text, <span class="string">&quot;target_path&quot;</span>: target_path&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码">测试代码</h3><p>使用了论文仓库提供的测试代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">corpus_dataset = Corpus(config[<span class="string">&quot;corpus_path&quot;</span>], image_preprocessor)</span><br><span class="line">query_dataset = Queries(config[<span class="string">&quot;queries_path&quot;</span>], config[<span class="string">&quot;sep&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_recalls</span>(<span class="params">dataloader, dialog_length, dialog_encoder</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 计算dataloader中长度为dialog_length的对话的召回结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dataloader: 数据加载器</span></span><br><span class="line"><span class="string">        dialog_length: 对话长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dataloader.dataset.dialog_length = dialog_length  <span class="comment"># 设置对话长度</span></span><br><span class="line">    recalls = []  <span class="comment"># 每个对话的召回结果</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(dataloader):</span><br><span class="line">        target_ids = torch.tensor(</span><br><span class="line">            [corpus_dataset.path_to_index(p) <span class="keyword">for</span> p <span class="keyword">in</span> batch[<span class="string">&#x27;target_path&#x27;</span>]]</span><br><span class="line">            ).unsqueeze(<span class="number">1</span>).to(config[<span class="string">&#x27;device&#x27;</span>]) <span class="comment"># 图片路径转换为索引</span></span><br><span class="line">        pred_vec = F.normalize(dialog_encoder(batch[<span class="string">&#x27;text&#x27;</span>]), dim=-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        scores = pred_vec @ corpus[<span class="number">1</span>].T <span class="comment"># 计算点积，得到相似度分数</span></span><br><span class="line">        arg_ranks = torch.argsort(scores, descending=<span class="literal">True</span>, dim=<span class="number">1</span>).long() <span class="comment"># 对分数进行排序</span></span><br><span class="line">        </span><br><span class="line">        target_recall = ((arg_ranks - target_ids) == <span class="number">0</span>).nonzero()[:, <span class="number">1</span>] <span class="comment"># 目标图像在检索排名中出现的位置</span></span><br><span class="line">        recalls.append(target_recall)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.cat(recalls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_first_hitting_time</span>(<span class="params">target_recall, hitting_recall=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 返回(11, n)张量，其中包含每轮（0, 11）的命中时间。inf表示未命中（10轮后没有命中） &quot;&quot;&quot;</span></span><br><span class="line">    target_recalls = target_recall.view(<span class="number">11</span>, -<span class="number">1</span>).T <span class="comment"># 转置</span></span><br><span class="line">    hits = (target_recalls &lt; hitting_recall) <span class="comment"># 目标图像是否在前 hitting_recall 轮内出现</span></span><br><span class="line"></span><br><span class="line">    final_hits = torch.inf * torch.ones(target_recalls.shape[<span class="number">0</span>]) <span class="comment"># 初始化为inf</span></span><br><span class="line"></span><br><span class="line">    hitting_times = [] <span class="comment"># 每轮的命中时间</span></span><br><span class="line">    <span class="keyword">for</span> ro_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">        rh = hits[:, ro_i]</span><br><span class="line">        final_hits[rh] = torch.<span class="built_in">min</span>(final_hits[rh], torch.ones(final_hits[rh].shape) * ro_i)</span><br><span class="line">        hitting_times.append(final_hits.clone())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.stack(hitting_times)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cumulative_hits_per_round</span>(<span class="params">target_recall, hitting_recall=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 返回直到第x轮的平均命中次数 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(hitting_recall) <span class="keyword">is</span> <span class="built_in">tuple</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(hitting_recall) == <span class="number">1</span></span><br><span class="line">        hitting_recall = hitting_recall[<span class="number">0</span>]</span><br><span class="line">    ht_times = get_first_hitting_time(target_recall, hitting_recall)</span><br><span class="line">    <span class="keyword">return</span> ((ht_times &lt; torch.inf).<span class="built_in">sum</span>(dim=-<span class="number">1</span>) * <span class="number">100</span> / ht_times[<span class="number">0</span>].shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval</span>(<span class="params">image_encoder, dialog_encoder, hits_at=<span class="number">10</span></span>):</span><br><span class="line">    prepare_corpus(image_encoder)</span><br><span class="line">    query_dataloader = torch.utils.data.DataLoader(query_dataset, <span class="comment"># 询问数据集</span></span><br><span class="line">                                             batch_size=config[<span class="string">&#x27;batch_size&#x27;</span>], <span class="comment"># 批大小</span></span><br><span class="line">                                             shuffle=<span class="literal">False</span>, <span class="comment"># 不打乱</span></span><br><span class="line">                                             num_workers=config[<span class="string">&#x27;num_workers&#x27;</span>], <span class="comment"># 多线程</span></span><br><span class="line">                                             pin_memory=<span class="literal">True</span>, <span class="comment"># 锁页内存</span></span><br><span class="line">                                             drop_last=<span class="literal">False</span></span><br><span class="line">                                             )</span><br><span class="line">    hits_results = []</span><br><span class="line">    <span class="keyword">for</span> dl <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>): <span class="comment"># 对话长度从0到10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Calculate recalls for each dialogues of length <span class="subst">&#123;dl&#125;</span>...&quot;</span>)</span><br><span class="line">        dialog_recalls = _get_recalls(query_dataloader, dialog_length=dl, dialog_encoder=dialog_encoder)</span><br><span class="line">        hits_results.append(dialog_recalls)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用cumulative_hits_per_round计算最终的Hits@10结果</span></span><br><span class="line">    <span class="comment"># Hits@10：`在预测的前 10 个候选项中，包含了正确答案`的比例</span></span><br><span class="line">    hits_results = cumulative_hits_per_round(torch.cat(hits_results).cpu(), hitting_recall=<span class="number">10</span>).tolist()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;====== Results for Hits@10 ====== &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> dl <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\t Dialog Length: <span class="subst">&#123;dl&#125;</span>: <span class="subst">&#123;<span class="built_in">round</span>(hits_results[dl], <span class="number">2</span>)&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    image_encoder, dialog_encoder = get_funcs()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(config[<span class="string">&quot;corpus_path&quot;</span>], <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        images = json.load(f)</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="built_in">eval</span>(image_encoder, dialog_encoder)</span><br></pre></td></tr></table></figure><h3 id="对话数据生成">对话数据生成</h3><p>原文中，为了自动获取测试数据，免除人工回答，使用了BLIP2模型回答问题</p><p>我参考原文的方法，使用BLIP2生成对话数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lavis.models <span class="keyword">import</span> load_model_and_preprocess <span class="comment"># BLIP2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> OpenAI <span class="keyword">import</span> request_chat</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">st,ed = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>]), <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;../dialogues/ChatGPT_BLIP2.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">images = [d[<span class="string">&quot;img&quot;</span>] <span class="keyword">for</span> d <span class="keyword">in</span> data][st:ed]</span><br><span class="line">captions = [d[<span class="string">&quot;dialog&quot;</span>][<span class="number">0</span>] <span class="keyword">for</span> d <span class="keyword">in</span> data][st:ed]</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">&quot;device&quot;</span>: <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>,</span><br><span class="line">    <span class="string">&quot;image_size&quot;</span> : <span class="number">224</span>,</span><br><span class="line">    <span class="string">&quot;sep&quot;</span>: <span class="string">&quot;, &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config[<span class="string">&quot;device&quot;</span>] == <span class="string">&quot;cuda&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Using GPU&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">image_path</span>):</span><br><span class="line">    raw_image = Image.<span class="built_in">open</span>(image_path).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">    image = vis_processors[<span class="string">&quot;eval&quot;</span>](raw_image).unsqueeze(<span class="number">0</span>).to(config[<span class="string">&quot;device&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visual_qa</span>(<span class="params">image, question, model</span>):</span><br><span class="line">    answer = model.generate(&#123;<span class="string">&quot;image&quot;</span>: image, <span class="string">&quot;prompt&quot;</span>: <span class="string">f&quot;Question: <span class="subst">&#123;question&#125;</span> Answer:&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> answer[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ask_question</span>(<span class="params">dialog</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;询问用户问题&quot;&quot;&quot;</span></span><br><span class="line">    question = request_chat(dialog)</span><br><span class="line">    <span class="keyword">return</span> question</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_dialog</span>(<span class="params">idx, model</span>):</span><br><span class="line">    image = load_image(images[idx])</span><br><span class="line">    caption = captions[idx]</span><br><span class="line">    dialog = [caption]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        question = ask_question(dialog)</span><br><span class="line">        answer = visual_qa(image, question, model)</span><br><span class="line">        dialog.append(question+answer)</span><br><span class="line">    ret = &#123;</span><br><span class="line">        <span class="string">&quot;img&quot;</span>: images[idx],</span><br><span class="line">        <span class="string">&quot;dialog&quot;</span>: dialog</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    model, vis_processors, _ = load_model_and_preprocess(</span><br><span class="line">        name=<span class="string">&quot;blip2_opt&quot;</span>, model_type=<span class="string">&quot;caption_coco_opt6.7b&quot;</span>, is_eval=<span class="literal">True</span>, device=config[<span class="string">&quot;device&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;ChatGPT4oMini_BLIP2.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(images))):</span><br><span class="line">                dialog = generate_dialog(idx, model)</span><br><span class="line">                json.dump(dialog, f)</span><br><span class="line">                f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            f.close()</span><br></pre></td></tr></table></figure><h3 id="测试日志">测试日志</h3><ol><li>由于OpenAI的token限制，我使用了讯飞星火API作为提问模型G</li><li>论文没读仔细，一开始以为生成对话数据时，代替人类回答的模型和编码用的模型一样，是BLIP</li><li>在以上基础上，测试的Hit@10结果（40%~60%）与原文（63%~80%）有较大差距</li><li>原本认为是提问模型G没有用ChatGPT的原因，微氪token，调整为ChatGPT4o-mini，但结果依然不理想（40%~67%）</li><li>注意到，40%是$D_0$，也就是只有用BLIP生成的第一句描述时的准确率，和提问模型G无关</li><li>对比原文，发现回答模型应该是另一篇paper中的BLIP2，而不是BLIP</li><li>修改数据生成代码，使用BLIP2生成对话数据，测试结果与原文接近（60%~80%）</li></ol><p>客观问题：由于硬件条件有限，跑出一条数据需要3~5分钟，因此只测试了1021条数据，对于整体性能评估可能不够准确</p><h3 id="测试结果">测试结果</h3><p>在使用ChatGPT作为提问模型G，BLIP2作为回答模型A，使用同一测试代码的情况下，测试结果和原文对比如下：</p><table><thead><tr><th style="text-align:center">length</th><th style="text-align:center">原文(2064 testcases)</th><th style="text-align:center">实现（1021 testcases）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">63.42%</td><td style="text-align:center">62.98%</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">69.43%</td><td style="text-align:center">70.62%</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">72.38%</td><td style="text-align:center">72.67%</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">74.47%</td><td style="text-align:center">74.53%</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">76.02%</td><td style="text-align:center">75.32%</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">77.47%</td><td style="text-align:center">75.42%</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">78.49%</td><td style="text-align:center">76.00%</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">79.65%</td><td style="text-align:center">76.20%</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">80.09%</td><td style="text-align:center">76.69%</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">80.43%</td><td style="text-align:center">76.98%</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">80.77%</td><td style="text-align:center">77.18%</td></tr></tbody></table><p>在第五轮对话后，对话长度增加对检索性能的提升不再明显</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 论文实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pretrained BLIP 模型调用</title>
      <link href="/posts/pretrained_BLIP.html"/>
      <url>/posts/pretrained_BLIP.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/salesforce/BLIP">Github Repo</a></p><p>BLIP全称Bootstrapping Language-Image Pre-training，是一个全新的 统一视觉语言理解与生成的预训练模型</p><p>它统一了视觉语言任务的理解与生成功能，并且通过嵌入 Captioner 和 Filter 去除网络资源中的文本噪声，提高了模型在下游视觉语言任务上的性能</p><h2 id="Colab-Notebook-运行">Colab Notebook 运行</h2><p>Salesforce在Colab NoteBook中提供了Demo，可以在云端直接运行：<a href="https://colab.research.google.com/github/salesforce/BLIP/blob/main/demo.ipynb">Colab notebook</a></p><p>第一步配置环境时出现<code>ERROR: Failed building wheel for tokenizers</code>问题，在<a href="https://github.com/salesforce/BLIP/issues/151#issuecomment-1537125671">Issue#151的评论</a>中提供了解决方案：修改transformers版本<code>4.25.1</code></p><h2 id="本地调用">本地调用</h2><p>学习在本地使用Pretrained BLIP模型，测试代码置于BLIP目录下</p><p>实验环境：</p><ul><li>Python 3.11.11 on conda</li><li>transformers 4.25.1</li><li>timm 0.4.12</li><li>fairscale 0.4.4</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms.functional <span class="keyword">import</span> InterpolationMode</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_demo_image</span>(<span class="params">image_size,device</span>):</span><br><span class="line">    img_url = <span class="string">&#x27;https://storage.googleapis.com/sfr-vision-language-research/BLIP/demo.jpg&#x27;</span> </span><br><span class="line">    raw_image = Image.<span class="built_in">open</span>(requests.get(img_url, stream=<span class="literal">True</span>).raw).convert(<span class="string">&#x27;RGB&#x27;</span>)   </span><br><span class="line"></span><br><span class="line">    w,h = raw_image.size</span><br><span class="line">    <span class="built_in">print</span>(raw_image.resize((w//<span class="number">5</span>,h//<span class="number">5</span>)))</span><br><span class="line">    </span><br><span class="line">    transform = transforms.Compose([</span><br><span class="line">        transforms.Resize((image_size,image_size),interpolation=InterpolationMode.BICUBIC),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.48145466</span>, <span class="number">0.4578275</span>, <span class="number">0.40821073</span>), (<span class="number">0.26862954</span>, <span class="number">0.26130258</span>, <span class="number">0.27577711</span>))</span><br><span class="line">        ]) </span><br><span class="line">    image = transform(raw_image).unsqueeze(<span class="number">0</span>).to(device)   </span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><h3 id="Image-Captioning-图像描述">Image Captioning 图像描述</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> models.blip <span class="keyword">import</span> blip_decoder</span><br><span class="line"></span><br><span class="line">image_size = <span class="number">384</span></span><br><span class="line">image = load_demo_image(image_size=image_size, device=device)</span><br><span class="line"></span><br><span class="line">model_url = <span class="string">&#x27;https://storage.googleapis.com/sfr-vision-language-research/BLIP/models/model_base_capfilt_large.pth&#x27;</span></span><br><span class="line">    </span><br><span class="line">model = blip_decoder(pretrained=model_url, image_size=image_size, vit=<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line">model = model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="comment"># beam search </span></span><br><span class="line">    caption = model.generate(image, sample=<span class="literal">False</span>, num_beams=<span class="number">3</span>, max_length=<span class="number">20</span>, min_length=<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># nucleus sampling</span></span><br><span class="line">    <span class="comment"># caption = model.generate(image, sample=True, top_p=0.9, max_length=20, min_length=5)  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;caption: &#x27;</span>+caption[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>The cache for model files in Transformers v4.22.0 has been updated. Migrating your old cache. This is a one-time only operation. You can interrupt this and resume the migration later on by calling `transformers.utils.move_cache()`.Moving 0 files to the new cache system0it [00:00, ?it/s]&lt;PIL.Image.Image image mode=RGB size=409x273 at 0x11139327650&gt;reshape position embedding from 196 to 576load checkpoint from https://storage.googleapis.com/sfr-vision-language-research/BLIP/models/model_base_capfilt_large.pthcaption: a woman and her dog on the beach</code></pre><h3 id="Visual-Question-Answering-视觉问答">Visual Question Answering 视觉问答</h3><p>由于存在和ImageCaptioning中的beam_search相同的版本问题，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> models.blip_vqa <span class="keyword">import</span> blip_vqa</span><br><span class="line"></span><br><span class="line">image_size = <span class="number">480</span></span><br><span class="line">image = load_demo_image(image_size=image_size, device=device)     </span><br><span class="line"></span><br><span class="line">model_url = <span class="string">&#x27;https://storage.googleapis.com/sfr-vision-language-research/BLIP/models/model_base_vqa_capfilt_large.pth&#x27;</span></span><br><span class="line">    </span><br><span class="line">model = blip_vqa(pretrained=model_url, image_size=image_size, vit=<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line">model = model.to(device)</span><br><span class="line"></span><br><span class="line">question = <span class="string">&#x27;where is the woman sitting?&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    answer = model(image, question, train=<span class="literal">False</span>, inference=<span class="string">&#x27;generate&#x27;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;answer: &#x27;</span>+answer[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>&lt;PIL.Image.Image image mode=RGB size=409x273 at 0x11139109090&gt;load checkpoint from https://storage.googleapis.com/sfr-vision-language-research/BLIP/models/model_base_vqa_capfilt_large.pthanswer: on beach</code></pre><h3 id="Image-Text-Matching-图文匹配">Image-Text Matching 图文匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> models.blip_itm <span class="keyword">import</span> blip_itm</span><br><span class="line"></span><br><span class="line">image_size = <span class="number">384</span></span><br><span class="line">image = load_demo_image(image_size=image_size,device=device)</span><br><span class="line"></span><br><span class="line">model_url = <span class="string">&#x27;https://storage.googleapis.com/sfr-vision-language-research/BLIP/models/model_base_retrieval_coco.pth&#x27;</span></span><br><span class="line">    </span><br><span class="line">model = blip_itm(pretrained=model_url, image_size=image_size, vit=<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line">model = model.to(device=device)</span><br><span class="line"></span><br><span class="line">caption = <span class="string">&#x27;a woman sitting on the beach with a dog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;text: %s&#x27;</span> %caption)</span><br><span class="line"></span><br><span class="line">itm_output = model(image,caption,match_head=<span class="string">&#x27;itm&#x27;</span>)</span><br><span class="line">itm_score = torch.nn.functional.softmax(itm_output,dim=<span class="number">1</span>)[:,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The image and text is matched with a probability of %.4f&#x27;</span>%itm_score)</span><br><span class="line"></span><br><span class="line">itc_score = model(image,caption,match_head=<span class="string">&#x27;itc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The image feature and text feature has a cosine similarity of %.4f&#x27;</span>%itc_score)</span><br></pre></td></tr></table></figure><pre><code>&lt;PIL.Image.Image image mode=RGB size=409x273 at 0x11130227FD0&gt;load checkpoint from https://storage.googleapis.com/sfr-vision-language-research/BLIP/models/model_base_retrieval_coco.pthtext: a woman sitting on the beach with a dogThe image and text is matched with a probability of 0.9960The image feature and text feature has a cosine similarity of 0.5262</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复现|手搓Transformer模型</title>
      <link href="/posts/Transformer.html"/>
      <url>/posts/Transformer.html</url>
      
        <content type="html"><![CDATA[<p>论文：<a href="https://arxiv.org/abs/1706.03762">Attention is All You Need</a></p><blockquote><p>2017年Google在论文《Attention is All You Need》中提出了Transformer模型，并成功应用到NLP领域。<br>该模型完全基于自注意力机制Attention mechanism实现，弥补了传统的RNN模型的不足。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">d_model = <span class="number">512</span> <span class="comment"># 词向量维度</span></span><br><span class="line">d_ff = <span class="number">2048</span> <span class="comment"># 前馈神经网络隐层维度</span></span><br><span class="line">src_vocab_size = <span class="number">10</span> <span class="comment"># 源语言词表大小</span></span><br><span class="line">tgt_vocab_size = <span class="number">10</span> <span class="comment"># 目标语言词表大小</span></span><br><span class="line">n_layers = <span class="number">6</span> <span class="comment"># 编码器和解码器堆叠基础块的数量</span></span><br></pre></td></tr></table></figure><h2 id="0-Transformer原理">0.Transformer原理</h2><p>宏观上，Transformer可以看作一个黑箱操作的Seq2Seq模型。<br>拆开黑箱，可以看到模型的本质是一个Encoder-Decoder结构。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Transformer/Transformer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.webp" alt="Transformer整体架构"></p><ul><li>Embedding：词嵌入层，将输入的词转换为词向量</li><li>Positional Encoding：位置编码，为了让模型学习到序列的位置信息</li><li>Multi-Head Attention：多头注意力机制，用于捕捉输入序列的全局依赖关系</li><li>Add &amp; Norm：残差连接和层归一化，用于加速训练、缓解梯度消失问题<ul><li>Add残差连接：把网络的输入和输出相加，有效解决梯度消失问题</li><li>Norm层归一化：对网络的输出进行归一化处理，加速训练</li></ul></li><li>Feed Forward：前馈神经网络，用于对特征进行非线性变换</li><li>Linear：线性变换层，用于将特征映射到输出空间</li><li>Softmax：Softmax层，用于输出概率分布</li></ul><h2 id="1-Encoder">1.Encoder</h2><p><img src="https://source.cclmsy.cc/Posts/DL/Transformer/Transformer_Encoder.webp" alt="Transformer_Encoder"></p><h3 id="1-1-Embedding-词嵌入">1.1 Embedding 词嵌入</h3><p>模型无法直接处理文本数据，需要把文本数据转换成计算机能够识别的向量形式。<br>将文本转化为向量通常有两种方式：</p><ul><li>One-hot编码：词典大小为N，每个词用一个N维向量表示，当前词对应的维度为1，其余维度为0<ul><li>优点：简单直观</li><li>缺点：向量维度高、稀疏、缺乏语义之间的联系</li></ul></li><li>Embedding词嵌入：通过训练学习到的词向量，将词映射到一个低维空间<ul><li>优点：低维、稠密、能够表达词之间的关系</li></ul></li></ul><p>输入Imput的维度是[batch_size, seq_len]，Embedding层的输出维度是[batch_size, seq_len, d_model]。</p><ul><li>batch_size：批次大小（句子个数）</li><li>seq_len：最长句子长度</li><li>d_model：词向量维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Embeddings</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, d_model</span>):</span><br><span class="line">        <span class="built_in">super</span>(Embeddings, self).__init__()</span><br><span class="line">        <span class="comment"># 调用nn.Embedding，获得实例化的词嵌入对象lut(look up table)</span></span><br><span class="line">        self.lut = nn.Embedding(vocab_size, d_model)</span><br><span class="line">        self.d_model = d_model <span class="comment"># 词嵌入维度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Embedding层的前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            x: 输入的词索引张量，形状为(batch_size, seq_len)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            词嵌入张量，形状为(batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.lut(x) * math.sqrt(self.d_model)</span><br></pre></td></tr></table></figure><h3 id="1-2-Positional-Encoding-位置编码">1.2 Positional Encoding 位置编码</h3><p>Embedding层只能表示词的语义信息，无法表示词的位置信息。<br>Transformer使用的是自注意力机制来提取信息，一个句子中的每个字/词是并行计算，虽然处理每个字的时候考虑到了所有字对其的影响，但是并没有考虑到各个字相互之间的位置信息，也就是上下文，所以需要引入位置信息</p><p>为了让模型学习到序列的位置信息，需要在Embedding层的输出上加上位置编码，得到含有位置信息的词向量$\alpha$。</p><p>Transformer中使用Positional Encoding表示每个字、词的位置信息，公式如下：</p><p>$$<br>PE_{(pos, i)} = \begin{cases}<br>sin(w_k \cdot pos), &amp; i = 2k \\<br>cos(w_k \cdot pos), &amp; i = 2k+1<br>\end{cases}<br>$$<br>$$<br>w_k = \dfrac{1}{10000^{2k/d_{model}}} \quad k = 0,1,2,…,d_{model}-1<br>$$</p><p>其中：</p><ul><li>$PE_{(pos, i)}$：表示第$pos$个字/词的Encoding向量第$i$维的编码值</li><li>$pos$：位置信息，表示句子中的第几个字/词，从0开始</li><li>$i$：位置编码的维度，从0开始</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, dropout=<span class="number">0.1</span>, max_len=<span class="number">5000</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionalEncoding, self).__init__()</span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line">        <span class="comment"># 初始化一个形状为(max_len, d_model)的位置编码矩阵</span></span><br><span class="line">        pe = torch.zeros(max_len, d_model)</span><br><span class="line">        <span class="comment"># position[i] = i</span></span><br><span class="line">        position = torch.arange(<span class="number">0</span>, max_len).unsqueeze(<span class="number">1</span>).<span class="built_in">float</span>()</span><br><span class="line">        <span class="comment"># w_k=e^(2k*-log10000/d_model)=1/(10000^(2k/d_model))</span></span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>).<span class="built_in">float</span>() * -(math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">        <span class="comment"># 偶数列使用sin函数编码，奇数列使用cos函数编码</span></span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)</span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)</span><br><span class="line">        <span class="comment"># 在第0维增加一个维度，形状变为(batch_size=1, max_len, d_model)</span></span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>)</span><br><span class="line">        self.register_buffer(<span class="string">&#x27;pe&#x27;</span>, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;位置编码层的前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            x: 输入的词嵌入张量，形状为(batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            添加了位置编码的词嵌入张量，形状为(batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        x = x + self.pe[:, :x.size(<span class="number">1</span>)].clone().detach()</span><br><span class="line">        <span class="keyword">return</span> self.dropout(x)</span><br></pre></td></tr></table></figure><h3 id="1-3-Self-Attention-自注意力机制">1.3 Self Attention 自注意力机制</h3><p>一句话中，与语义紧密相关的关键词需要予以更多的关注，而无关的连接词和辅助词则可以忽略。<br>在机器翻译时，更多的注意表现为更大的权重，越重要的词权重越大。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Transformer/Self_Attention.webp" alt="Self Attention"></p><p>包含位置信息的词向量$\alpha^i$（句子的第i+1个词的词向量）作为Self Attention的输入，分别乘以三个权重矩阵$W^Q$、$W^K$、$W^V$，得到：</p><ul><li>$q^i$：Query，查询向量</li><li>$k^i$：Key，键向量，“被查”时的向量</li><li>$v^i$：Value，值向量，“内容”的向量</li></ul><p>以4个字的句子“我是学生”为例，计算第0个字“我”的Self Attention：</p><ol><li>计算 $q^0$ 和 $k^0,k^1,k^2,k^3$ 的点积，得到4个注意力值 $\alpha_{00},\alpha_{01},\alpha_{02},\alpha_{03}$</li></ol><ul><li>经过Softmax归一化，得到4个注意力分数 $\hat{\alpha_{00}},\hat{\alpha_{01}},\hat{\alpha_{02}},\hat{\alpha_{03}}$ ，它们的和为1</li><li>将这些分数作为权重，对 $v^0,v^1,v^2,v^3$ 进行加权求和，得到Self Attention的输出</li><li>$b^0=\hat{\alpha_{00}}v^0+\hat{\alpha_{01}}v^1+\hat{\alpha_{02}}v^2+\hat{\alpha_{03}}v^3$</li></ul><p>为了加速计算，可以使用矩阵运算：</p><p><img src="https://source.cclmsy.cc/Posts/DL/Transformer/Self_Attention_Matrix.png" alt="Self Attention矩阵运算"></p><ul><li>其中$\alpha_{ij}=\dfrac{q_i * k_j^T}{\sqrt{d_k}}$，$d_k$是词向量的维度</li><li>最后计算$b^i=\sum_{j=0}^{n-1}\hat{\alpha_{ij}}v_j$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, scale_factor, dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.scale_factor = scale_factor <span class="comment"># 缩放因子</span></span><br><span class="line">        <span class="comment"># Dropout用于防止过拟合</span></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, mask=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        batch_size: 批大小</span></span><br><span class="line"><span class="string">        num_heads: 多头注意力的头数，论文默认为8</span></span><br><span class="line"><span class="string">        seq_len: 序列长度</span></span><br><span class="line"><span class="string">        d_k, d_v: 键和值的维度，默认都是64</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            Q: 查询张量，形状为(batch_size, num_heads, seq_len, d_k)</span></span><br><span class="line"><span class="string">            K: 键张量，形状为(batch_size, num_heads, seq_len, d_k)</span></span><br><span class="line"><span class="string">            V: 值张量，形状为(batch_size, num_heads, seq_len, d_v)</span></span><br><span class="line"><span class="string">            mask: 掩码张量，形状为(batch_size, seq_len, seq_len)，默认为None</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            上下文张量和注意力张量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        attn = torch.matmul(Q / self.scale_factor, K.transpose(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># K的第2和第3维转置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if mask is not None:</span></span><br><span class="line">        <span class="comment">#     scores = scores.masked_fill(mask == 0, -1e9)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Softmax计算注意力权重，Dropout减少过拟合</span></span><br><span class="line">        attn = self.dropout(torch.softmax(attn, dim=-<span class="number">1</span>))</span><br><span class="line">        output = torch.matmul(attn, V)</span><br><span class="line">        <span class="keyword">return</span> output, attn <span class="comment"># 返回上下文张量和注意力张量</span></span><br></pre></td></tr></table></figure><h3 id="1-4-Multi-Head-Attention-多头注意力机制">1.4 Multi-Head Attention 多头注意力机制</h3><p>多头注意力机制就是把$q^i, k^i, v^i$三个矩阵从特征维度（词向量长度）方向上拆分成为形状相同的小矩阵。<br>再将每个Head Attention的输出拼接起来，得到最终的Multi-Head Attention输出。</p><p>理解：多个头分别关注不同的特征子空间，最后再将这些子空间的信息融合起来。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Transformer/Multi_Head_Attention.webp" alt="Multi-Head Attention"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_head=<span class="number">8</span>, d_model=<span class="number">512</span>, d_k=<span class="number">64</span>, d_v=<span class="number">64</span>, droupout=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="comment"># 论文中，参数分别为：8、512、64、64</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.n_head = n_head</span><br><span class="line">        self.d_k = d_k</span><br><span class="line">        self.d_v = d_v</span><br><span class="line"></span><br><span class="line">        self.w_qs = nn.Linear(d_model, n_head * d_k, bias=<span class="literal">False</span>)</span><br><span class="line">        self.w_ks = nn.Linear(d_model, n_head * d_k, bias=<span class="literal">False</span>)</span><br><span class="line">        self.w_vs = nn.Linear(d_model, n_head * d_v, bias=<span class="literal">False</span>)</span><br><span class="line">        self.fc = nn.Linear(n_head * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        self.attention = ScaledDotProductAttention(scale_factor=d_k ** <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        self.dropout = nn.Dropout(droupout)</span><br><span class="line">        self.layer_norm = nn.LayerNorm(d_model, eps=<span class="number">1e-6</span>) <span class="comment"># LayerNorm层，用于归一化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, mask=<span class="literal">None</span></span>):</span><br><span class="line">        d_k, d_v, n_head = self.d_k, self.d_v, self.n_head</span><br><span class="line">        batch_size, len_q, len_k, len_v = Q.size(<span class="number">0</span>), Q.size(<span class="number">1</span>), K.size(<span class="number">1</span>), V.size(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        residual = Q <span class="comment"># 保留输入用作残差连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将Q、K、V归一化后，分别通过线性映射到多头</span></span><br><span class="line">        <span class="comment"># Q: (batch_size, len_q, d_model) -&gt; (batch_size, len_q, n_head * d_k) -&gt; (batch_size, n_head, len_q, d_k)</span></span><br><span class="line">        <span class="comment"># Q：(batch_size, len_q, 512) -&gt; (batch_size, len_q, 8*64) -&gt; (batch_size, len_q, 8, 64)</span></span><br><span class="line">        Q = self.layer_norm(Q)</span><br><span class="line">        K = self.layer_norm(K)</span><br><span class="line">        V = self.layer_norm(V)</span><br><span class="line">        Q = self.w_qs(Q).view(batch_size, len_q, n_head, d_k)</span><br><span class="line">        K = self.w_ks(K).view(batch_size, len_k, n_head, d_k)</span><br><span class="line">        V = self.w_vs(V).view(batch_size, len_v, n_head, d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转置，使得第1和第2维交换位置，进行Attention计算</span></span><br><span class="line">        <span class="comment"># Q: (batch_size, len_q, n_head, d_k) -&gt; (batch_size, n_head, len_q, d_k)</span></span><br><span class="line">        <span class="comment"># Q：(batch_size, len_q, 8, 64) -&gt; (batch_size, 8, len_q, 64)</span></span><br><span class="line">        Q, K, V = Q.transpose(<span class="number">1</span>, <span class="number">2</span>), K.transpose(<span class="number">1</span>, <span class="number">2</span>), V.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            mask = mask.unsqueeze(<span class="number">1</span>) <span class="comment"># 增加一个Head维度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Q=Softmax(Q*K/d + (1-S)σ)V，attn是QK/D</span></span><br><span class="line">        Q, attn = self.attention(Q, K, V, mask=mask) </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Q的形状：[batch_size, n_head, len_q, d_v] [2,8,5,64]</span></span><br><span class="line">        Q = Q.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(batch_size, len_q, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        Q = self.dropout(self.fc(Q))</span><br><span class="line"></span><br><span class="line">        Q += residual <span class="comment"># 残差连接Add</span></span><br><span class="line">        Q = self.layer_norm(Q) <span class="comment"># LayerNorm</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Q, attn</span><br></pre></td></tr></table></figure><h3 id="1-5-Add-Norm-残差连接和层归一化">1.5 Add &amp; Norm 残差连接和层归一化</h3><p>Add残差链接就是将网络的输入和输出直接相加，主要是为了解决梯度消失问题。</p><p>Layer Normalization是对网络的输出进行归一化处理，加速训练。<br>使$b$的每一行，也就是每个句子，归一化为标准正态分布，输出为$\hat b$，归一化公式如下：</p><ul><li>均值：$\mu_i=\dfrac{1}{d}\sum_{j=1}^{d}b_{ij}$</li><li>方差：$\sigma_i^2=\dfrac{1}{d}\sum_{j=1}^{d}(b_{ij}-\mu_i)^2$</li><li>归一化：$\hat b_{ij}=\dfrac{b_{ij}-\mu_i}{\sqrt{\sigma_i^2+\epsilon}}*\gamma+\beta$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayerNorm</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, eps=<span class="number">1e-12</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(LayerNorm, self).__init__()</span><br><span class="line">        self.gamma = nn.Parameter(torch.ones(d_model))</span><br><span class="line">        self.beta = nn.Parameter(torch.zeros(d_model))</span><br><span class="line">        self.eps = eps <span class="comment"># 防止分母为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        mean = x.mean(-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        var = x.var(-<span class="number">1</span>, unbiased=<span class="literal">False</span>, keepdim=<span class="literal">True</span>) <span class="comment"># unbiased=False表示方差计算非无偏估计（除以N而不是N-1）</span></span><br><span class="line"></span><br><span class="line">        out = (x - mean) / torch.sqrt(var + self.eps)</span><br><span class="line">        out = self.gamma * out + self.beta</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="1-6-Feed-Forward-前馈神经网络">1.6 Feed Forward 前馈神经网络</h3><p>Add &amp; Norm层后接一个全连接的前馈神经网络，用于对特征进行非线性变换</p><p>前馈神经网络的结构是两个全连接层，第一个全连接层的激活函数是ReLU，第二个全连接层没有激活函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PositionwiseFeedForward</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionwiseFeedForward, self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(d_model, d_ff, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(d_ff, d_model, bias=<span class="literal">False</span>))</span><br><span class="line">        self.layer_norm = nn.LayerNorm(d_model, eps=<span class="number">1e-6</span>) <span class="comment"># LayerNorm层，用于归一化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        resdual = inputs</span><br><span class="line">        output = self.fc(inputs)</span><br><span class="line">        output = self.layer_norm(output + resdual)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="1-7-Mask掉-停用词">1.7 Mask掉 停用词</h3><p>句子中没有意义的占位符，例如“我是学生P”中的P是停止符，没有实际意义，需要将其mask掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_pad_mask</span>(<span class="params">seq_q, seq_k</span>):</span><br><span class="line">    batch_size, len_q = seq_q.size()</span><br><span class="line">    batch_size, len_k = seq_k.size()</span><br><span class="line">    <span class="comment"># eq(zero)用于判断 seq_k 中哪些位置是填充符（通常填充符的值是 0），返回一个ByteTensor</span></span><br><span class="line">    pad_attn_mask = seq_k.data.eq(<span class="number">0</span>).unsqueeze(<span class="number">1</span>)  <span class="comment"># (N, 1, len_k)</span></span><br><span class="line">    <span class="keyword">return</span> pad_attn_mask.expand(batch_size, len_q, len_k)  <span class="comment"># (N, len_q, len_k)</span></span><br></pre></td></tr></table></figure><h3 id="1-8-EncoderLayer">1.8 EncoderLayer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(EncoderLayer, self).__init__()</span><br><span class="line">        self.enc_self_attn = MultiHeadAttention() <span class="comment"># 多头自注意力</span></span><br><span class="line">        self.pos_ffn = PositionwiseFeedForward() <span class="comment"># 前馈神经网络</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, enc_self_attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            enc_inputs: 编码器输入张量，形状为(batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">            enc_self_attn_mask: 编码器自注意力掩码，形状为(batch_size, seq_len, seq_len)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            编码器输出张量，形状为(batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        enc_outputs, attn = self.enc_self_attn(enc_inputs, enc_inputs, enc_inputs, enc_self_attn_mask)</span><br><span class="line">        enc_outputs = self.pos_ffn(enc_outputs)</span><br><span class="line">        <span class="keyword">return</span> enc_outputs, attn</span><br></pre></td></tr></table></figure><h3 id="1-9-Encoder">1.9 Encoder</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.src_emb = Embeddings(src_vocab_size, d_model)</span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)</span><br><span class="line">        self.layers = nn.ModuleList([EncoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs</span>):</span><br><span class="line">        <span class="comment"># 1. 中文字索引进行Embedding，转换为512维的词向量</span></span><br><span class="line">        enc_outputs = self.src_emb(enc_inputs)</span><br><span class="line">        <span class="comment"># 2. 加上位置编码</span></span><br><span class="line">        enc_outputs = self.pos_emb(enc_outputs)</span><br><span class="line">        <span class="comment"># 3. mask掉padding部分</span></span><br><span class="line">        enc_self_attn_mask = get_attn_pad_mask(enc_inputs, enc_inputs)</span><br><span class="line">        enc_self_attns = []</span><br><span class="line">        <span class="comment"># 4. 通过6层EncoderLayer，上一层的输出作为下一层的输入</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            enc_outputs, enc_self_attn = layer(enc_outputs, enc_self_attn_mask)</span><br><span class="line">            enc_self_attns.append(enc_self_attn)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enc_outputs, enc_self_attns</span><br></pre></td></tr></table></figure><h2 id="2-Decoder">2.Decoder</h2><p>Masked Multi-Head Attention：与MultiHead Attention类似，只是在计算Self Attention时，需要mask掉未来的信息</p><p>Multi-Head Attention：与Encoder中的MultiHead Attention相同</p><p>Decoder的输出预测：Decoder输出矩阵形状是[seq_len, word_dim]，经过nn.Linear全连接层，再通过softmax函数得到每个词的概率，然后选择概率最大的词作为预测结果。</p><h3 id="2-1-Decoder-Input-输入处理">2.1 Decoder Input 输入处理</h3><p>Decoder的输入是最后一个Encoder的输出，在训练时，同时输入目标句子的词向量，以便计算Loss。</p><p>“我是学生E”-&gt;“S I am a student”</p><ul><li>T0时刻：输入开始符“S”，输出预测的第一个词“I”</li><li>T1时刻：输入“S I”，输出预测的第二个词“am”</li><li>…</li></ul><p>输入使用上三角矩阵进行mask，避免Decoder看到未来的信息。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Transformer/Input_Mask.webp" alt="Input Mask"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_subsequent_mask</span>(<span class="params">seq</span>): <span class="comment"># seq: [batch_size, tgt_len]</span></span><br><span class="line">    attn_shape = [seq.size(<span class="number">0</span>), seq.size(<span class="number">1</span>), seq.size(<span class="number">1</span>)]</span><br><span class="line">    subsequent_mask = np.triu(np.ones(attn_shape), k=<span class="number">1</span>) <span class="comment"># 返回上三角矩阵</span></span><br><span class="line">    subsequent_mask = torch.from_numpy(subsequent_mask).byte() <span class="comment"># 转换为ByteTensor</span></span><br><span class="line">    <span class="keyword">return</span> subsequent_mask</span><br></pre></td></tr></table></figure><h3 id="2-2-DecoderLayer">2.2 DecoderLayer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DecoderLayer, self).__init__()</span><br><span class="line">        self.dec_self_attn = MultiHeadAttention()</span><br><span class="line">        self.dec_enc_attn = MultiHeadAttention() </span><br><span class="line">        self.pos_ffn = PositionwiseFeedForward()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            dec_inputs: 解码器输入张量，形状为(batch_size, tgt_len, d_model)</span></span><br><span class="line"><span class="string">            enc_outputs: 编码器输出张量，形状为(batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">            dec_self_attn_mask: 解码器自注意力掩码，形状为(batch_size, tgt_len, tgt_len)</span></span><br><span class="line"><span class="string">            dec_enc_attn_mask: 解码器-编码器注意力掩码，形状为(batch_size, tgt_len, seq_len)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            解码器输出张量，形状为(batch_size, tgt_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        dec_outputs, dec_self_attn = self.dec_self_attn(dec_inputs, dec_inputs, dec_inputs, dec_self_attn_mask)</span><br><span class="line">        dec_outputs, dec_enc_attn = self.dec_enc_attn(dec_outputs, enc_outputs, enc_outputs, dec_enc_attn_mask)</span><br><span class="line">        dec_outputs = self.pos_ffn(dec_outputs)</span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attn, dec_enc_attn</span><br></pre></td></tr></table></figure><h3 id="2-3-Decoder">2.3 Decoder</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.tgt_emb = Embeddings(tgt_vocab_size, d_model)</span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)</span><br><span class="line">        self.layers = nn.ModuleList([DecoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_inputs, enc_outputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            dec_inputs: 解码器输入张量，形状为(batch_size, tgt_len)</span></span><br><span class="line"><span class="string">            enc_inputs: 编码器输入张量，形状为(batch_size, seq_len)</span></span><br><span class="line"><span class="string">            enc_outputs: 编码器输出张量，形状为(batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            解码器输出张量，形状为(batch_size, tgt_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 英文字索引进行Embedding，转换为512维的词向量，加上位置编码</span></span><br><span class="line">        dec_outputs = self.tgt_emb(dec_inputs)</span><br><span class="line">        dec_outputs = self.pos_emb(dec_outputs)</span><br><span class="line">        <span class="comment"># mask掉padding部分</span></span><br><span class="line">        dec_self_attn_pad_mask = get_attn_pad_mask(dec_inputs, dec_inputs)</span><br><span class="line">        dec_self_attn_subsequent_mask = get_attn_subsequent_mask(dec_inputs)</span><br><span class="line">        dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequent_mask), <span class="number">0</span>)</span><br><span class="line">        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs)</span><br><span class="line">        dec_self_attns, dec_enc_attns = [], []</span><br><span class="line">        <span class="comment"># 通过6层DecoderLayer，上一层的输出作为下一层的输入</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            dec_outputs, dec_self_attn, dec_enc_attn = layer(dec_outputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask)</span><br><span class="line">            dec_self_attns.append(dec_self_attn)</span><br><span class="line">            dec_enc_attns.append(dec_enc_attn)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attns, dec_enc_attns</span><br></pre></td></tr></table></figure><h2 id="3-Transformer代码实现">3. Transformer代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Transformer, self).__init__()</span><br><span class="line">        self.encoder = Encoder()</span><br><span class="line">        self.decoder = Decoder()</span><br><span class="line">        <span class="comment"># 解码器最后的分类器，分类器的输入d_model是解码层每个token的输出维度大小</span></span><br><span class="line">        <span class="comment"># 需要将其转为词表大小，再计算softmax；计算哪个词出现的概率最大</span></span><br><span class="line">        self.projection = nn.Linear(d_model, tgt_vocab_size, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, dec_inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            enc_inputs: 编码器输入张量，形状为(batch_size, seq_len)</span></span><br><span class="line"><span class="string">            dec_inputs: 解码器输入张量，形状为(batch_size, tgt_len)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            解码器输出张量，形状为(batch_size * tgt_len, tgt_vocab_size)</span></span><br><span class="line"><span class="string">            enc_self_attns: 编码器自注意力张量列表</span></span><br><span class="line"><span class="string">            dec_self_attns: 解码器自注意力张量列表</span></span><br><span class="line"><span class="string">            dec_enc_attns: 解码器-编码器注意力张量列表</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        enc_outputs, enc_self_attns = self.encoder(enc_inputs)</span><br><span class="line"></span><br><span class="line">        dec_outputs, dec_self_attns, dec_enc_attns = self.decoder(dec_inputs, enc_inputs, enc_outputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dec_logits : [batch_size x src_vocab_size x tgt_vocab_size]</span></span><br><span class="line">        dec_logits = self.projection(dec_outputs) </span><br><span class="line">        <span class="keyword">return</span> dec_logits.view(-<span class="number">1</span>, dec_logits.size(-<span class="number">1</span>)), enc_self_attns, dec_self_attns, dec_enc_attns</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-Transformer模型训练">4. Transformer模型训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line">model = Transformer()</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 词典</span></span><br><span class="line">word2idx = &#123;</span><br><span class="line">    <span class="string">&quot;S&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;我&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;是&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;学&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;生&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;I&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;am&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="string">&quot;student&quot;</span>: <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx2word = &#123;i: w <span class="keyword">for</span> w, i <span class="keyword">in</span> word2idx.items()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入数据</span></span><br><span class="line">enc_inputs = torch.LongTensor([[word2idx[w] <span class="keyword">for</span> w <span class="keyword">in</span> [<span class="string">&quot;我&quot;</span>, <span class="string">&quot;是&quot;</span>, <span class="string">&quot;学&quot;</span>, <span class="string">&quot;生&quot;</span>, <span class="string">&quot;S&quot;</span>]]])</span><br><span class="line">dec_inputs = torch.LongTensor([[word2idx[w] <span class="keyword">for</span> w <span class="keyword">in</span> [<span class="string">&quot;S&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;student&quot;</span>]]])</span><br><span class="line">target_batch = torch.LongTensor([[word2idx[w] <span class="keyword">for</span> w <span class="keyword">in</span> [<span class="string">&quot;S&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;student&quot;</span>]]])</span><br><span class="line"><span class="built_in">print</span>(enc_inputs, dec_inputs, target_batch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    outputs, enc_self_attns, dec_self_attns, dec_enc_attns = model(enc_inputs, dec_inputs)</span><br><span class="line">    loss = criterion(outputs, target_batch.view(-<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#x27;</span>, <span class="string">&#x27;%04d&#x27;</span> % (epoch + <span class="number">1</span>), <span class="string">&#x27;cost =&#x27;</span>, <span class="string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(loss))</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型预测</span></span><br><span class="line">predict, _, _, _ = model(enc_inputs, dec_inputs)</span><br><span class="line">predict = predict.data.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(enc_inputs, <span class="string">&#x27;-&gt;&#x27;</span>, [idx2word[n.item()] <span class="keyword">for</span> n <span class="keyword">in</span> predict.squeeze()])</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>tensor([[1, 2, 3, 4, 0]]) tensor([[0, 5, 6, 7, 8]]) tensor([[0, 5, 6, 7, 8]])Epoch: 0001 cost = 2.244576Epoch: 0002 cost = 0.970345Epoch: 0003 cost = 2.741649Epoch: 0004 cost = 3.185768Epoch: 0005 cost = 4.521887Epoch: 0006 cost = 3.544580Epoch: 0007 cost = 3.160498Epoch: 0008 cost = 2.823286Epoch: 0009 cost = 0.625107Epoch: 0010 cost = 0.672708Epoch: 0011 cost = 0.561514Epoch: 0012 cost = 0.959138Epoch: 0013 cost = 0.673696Epoch: 0014 cost = 0.326180Epoch: 0015 cost = 0.268545Epoch: 0016 cost = 0.215698Epoch: 0017 cost = 0.168979Epoch: 0018 cost = 0.057510Epoch: 0019 cost = 0.087601Epoch: 0020 cost = 0.056923tensor([[1, 2, 3, 4, 0]]) -&gt; ['S', 'I', 'am', 'a', 'student']</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Pytorch </tag>
            
            <tag> 论文复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记4-循环神经网络RNN</title>
      <link href="/posts/deep_learning_4.html"/>
      <url>/posts/deep_learning_4.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-循环神经网络">4.1 循环神经网络</h2><h3 id="4-1-1-序列模型">4.1.1 序列模型</h3><p>序列模型：自然语言、音频、视频等序列数据的模型</p><ul><li>应用：语音识别、情感分类、机器翻译等</li></ul><p>为什么不使用CNN？</p><ul><li>序列数据的前后之间具有强关联性</li><li>输入输出长度不固定</li></ul><h3 id="4-1-2-循环神经网络">4.1.2 循环神经网络</h3><p>循环（递归）神经网络（Recurrent Neural Network，RNN）是神经网络的一种，将“状态”在自身网络中循环传递，可以接受时间序列结构输入</p><h4 id="4-1-2-1-RNN类型">4.1.2.1 RNN类型</h4><p><img src="https://source.cclmsy.cc/Posts/DL/Note/RNN%E7%BB%93%E6%9E%84.png" alt="RNN结构"></p><ul><li>一对一：固定输入到固定输出，如图像分类</li><li>一对多：固定输入到序列输出，如图像的文字描述</li><li>多对一：序列输入到固定输出，如情感分类</li><li>（异步）多对多：序列输入到序列输出，如机器翻译，称为Encoder-Decoder（编码-解码）结构</li><li>同步多对多：同步序列到同步输出，如文本生成、视频帧分类</li></ul><h4 id="4-1-2-2-基础循环神经网络">4.1.2.2 基础循环神经网络</h4><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E5%9F%BA%E7%A1%80RNN%E7%BB%93%E6%9E%84.png" alt="基础RNN结构"></p><ul><li>$x_t$：t时刻的输入</li><li>$o_t$：t时刻的输出</li><li>$s_t$：t时刻的隐层输出</li><li>所有单元的参数$U, V, W$共享</li></ul><p>统一公式（$f$采用TanH/RuLU，$g$采用Softmax/Sigmoid）：</p><p>$$<br>\begin{split}<br>&amp; s_0 = 0 \\<br>&amp; s_t = f(Ux_t + Ws_{t-1}) \\<br>&amp; o_t = g(Vs_t)<br>\end{split}<br>$$</p><p>输出的$o_t$受前面时刻的隐层$s_{t-1}$影响，即RNN具有记忆功能</p><h4 id="4-1-2-3-序列生成案例">4.1.2.3 序列生成案例</h4><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E5%BA%8F%E5%88%97%E4%BE%8B%E5%AD%90.png" alt="序列例子"></p><ul><li>输入到网络当中的是一个个的分词结果，每一个词的输入是一个时刻</li><li>每一个时刻有一个输出，表示最可能的下一个词</li></ul><h4 id="4-1-2-4-词的表示">4.1.2.4 词的表示</h4><p>为了能够让网络理解输入，需要将词进行向量表示。</p><ul><li>建立一个包含所有序列词的词典，每个词在词典中有唯一编号</li><li>记词典大小为$N$，任意一个词都可以用一个$N$维的One-Hot向量表示</li><li>得到一个高维稀疏矩阵</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E8%AF%8D%E5%90%91%E9%87%8F%E8%A1%A8%E7%A4%BA.png" alt="词向量表示"></p><h4 id="4-1-2-4-输出的表示-Softmax">4.1.2.4 输出的表示-Softmax</h4><p>RNN这种模型，每一个时刻的输出是下一个最可能的词，可以用概率表示，总长度为词的总数长度</p><ul><li>每个时刻的隐层输出$s_t$经过Softmax函数，得到概率分布</li></ul><h4 id="4-1-2-5-交叉熵损失">4.1.2.5 交叉熵损失</h4><p>总损失定义：一整个序列（一个句子）作为一个训练实例，总误差是各个时刻误差的和</p><p>$$<br>\begin{split}<br>&amp; E_t(y_t, \hat{y}_t) = -y_t \log(\hat{y}_t) \\<br>&amp; E(y, \hat{y}) = \sum_t E_t(y_t, \hat{y}_t) = -\sum_t y_t \log(\hat{y}_t)<br>\end{split}<br>$$</p><ul><li>$y_t$：时刻t上正确的输出</li><li>$\hat{y}_t$：时刻t上预测的输出</li></ul><h4 id="4-1-2-6-时序反向传播算法（BPTT）">4.1.2.6 时序反向传播算法（BPTT）</h4><p>Backpropagation Through Time，时序反向传播算法：对于RNN有一个时间概念，需要把梯度沿时间通道进行反向传播</p><p>需要更新的参数：$U, V, W, b_x, b_y$</p><ul><li>计算每个时间的梯度$dW_t$，相加作为每次$W$更新的梯度值</li><li>$s_t=tanh(Ux_t+Ws_{t-1}+b_x)$，$o_t=Softmax(Vs_t+b_y)$</li><li>利用链式法则，计算出每个时间下各参数的梯度</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/RNN%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%80%BB%E7%BB%93.png" alt="RNN反向传播总结"></p><h4 id="4-1-2-7-梯度消失与梯度爆炸">4.1.2.7 梯度消失与梯度爆炸</h4><p>由于RNN中也存在链式求导法则，因此也会发生梯度消失与梯度爆炸的问题</p><h3 id="4-1-8-RNN改进">4.1.8 RNN改进</h3><p>通过门控机制控制信息的流动</p><h4 id="4-1-8-1-门控循环单元GRU">4.1.8.1 门控循环单元GRU</h4><p>Gated Recurrent Unit，门控循环单元</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/GRU%E5%8D%95%E5%85%83.png" alt="GRU单元"></p><p>GRU增加了两个门，一个重置门（reset gate）和一个更新门（update gate）</p><ul><li>重置门：决定如何将新的输入和前一时刻的输出相结合</li><li>更新门：定义前面的记忆保存到当前时间的量</li><li>重置门1，更新门0，即为标准RNN模型</li></ul><p>GRU本质解决的问题：</p><ul><li>解决短期问题，每个递归单元能够自适应捕捉不同尺度的依赖关系</li><li>处理了隐层输出，$h_t=(1-z_t)<em>h_{t-1}+z_t</em>\tilde{h}_t$，解决了梯度消失问题</li></ul><h4 id="4-1-8-2-长短时记忆网络LSTM">4.1.8.2 长短时记忆网络LSTM</h4><p>Long Short Term Memory，长短记忆网络</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/LSTM.png" alt="LSTM"></p><ul><li>$h_t$：当前cell的输出</li><li>$c_t$：隐层的记忆</li><li>三个门：遗忘门f，输入门u，输出门o</li></ul><p>作用：便于记忆长更长距离的状态</p><h2 id="4-2-词嵌入与NLP">4.2 词嵌入与NLP</h2><h3 id="4-2-1-在RNN中使用one-hot表示的问题">4.2.1 在RNN中使用one-hot表示的问题</h3><ul><li>假设有n个词，每个词的one-hot表示是n维的，整体大小为$n*n$，非常稀疏</li><li>无法表示词之间的相似性，例如Apple对Banana的相似性远高于Monkey</li></ul><h3 id="4-2-2-词嵌入（Word-Embedding）">4.2.2 词嵌入（Word Embedding）</h3><p>把一个维数为$N$的高维空间嵌入到一个维数低的多的连续向量空间中，每个单词或词组被映射为实数域上的向量，例如：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Man</th><th style="text-align:center">Woman</th><th style="text-align:center">King</th><th style="text-align:center">Queen</th><th style="text-align:center">Apple</th><th style="text-align:center">Banana</th></tr></thead><tbody><tr><td style="text-align:center">Gender</td><td style="text-align:center">1</td><td style="text-align:center">-1</td><td style="text-align:center">-0.95</td><td style="text-align:center">0.97</td><td style="text-align:center">0.01</td><td style="text-align:center">-0.02</td></tr><tr><td style="text-align:center">Royal</td><td style="text-align:center">0.01</td><td style="text-align:center">0.02</td><td style="text-align:center">0.98</td><td style="text-align:center">0.99</td><td style="text-align:center">-0.03</td><td style="text-align:center">0.04</td></tr><tr><td style="text-align:center">Age</td><td style="text-align:center">0.01</td><td style="text-align:center">0.02</td><td style="text-align:center">0.75</td><td style="text-align:center">0.69</td><td style="text-align:center">0.03</td><td style="text-align:center">-0.04</td></tr><tr><td style="text-align:center">Food</td><td style="text-align:center">0.01</td><td style="text-align:center">0.02</td><td style="text-align:center">-0.03</td><td style="text-align:center">0.04</td><td style="text-align:center">0.95</td><td style="text-align:center">0.97</td></tr></tbody></table><p>词嵌入的特点：能够体现词与词之间的关系</p><p>Man-Woman≈King-?(Queen!)</p><p>算法/工具：Skip-gram、CBOW、GenSim</p><h2 id="4-3-Seq2Seq与Attention机制">4.3 Seq2Seq与Attention机制</h2><h3 id="4-3-1-Seq2Seq">4.3.1 Seq2Seq</h3><p>Seq2Seq：Sequence to Sequence，由Google Brain团队和Yoshua Bengio 两个团队各自独立的提出来</p><h4 id="4-3-1-1-定义">4.3.1.1 定义</h4><p>Seq2Seq模型是一个Encoder-Decoder结构的模型，输入是一个序列，输出也是一个序列</p><p>Encoder中将一个可变长度的信号序列变为固定长度的向量表达，<br>Decoder中将这个固定长度的向量表达变为可变长度的目标信号序列</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/seq2seq.png" alt="seq2seq"></p><ul><li>相当于把RNN模型的$s_0$输入变成一个Encoder</li></ul><h4 id="4-3-1-2-条件语言模型">4.3.1.2 条件语言模型</h4><p>Encoder编码器的作用：</p><ul><li>将一个边长输入序列输出到一个编码状态$C$</li><li>解码器输出$y_t$的条件概率基于之前的输出序列$y_1y_2…y_{t-1}$和编码状态$C$</li><li>$argmaxP(y_1,y_2,…,y_T|x_1,x_2,…,x_T)$，给定输入的序列，最大化输出序列的概率</li></ul><p>根据最大似然估计，最大化输出序列的概率</p><p>$$<br>\begin{split}<br>&amp; P(y_1,y_2,…,y_T|x_1,x_2,…,x_T) \\<br>&amp; = \prod_{t=1}^T P(y_t|y_1,y_2,…,y_{t-1},x_1,x_2,…,x_T) \\<br>&amp; = \prod_{t=1}^T P(y_t|y_1,y_2,…,y_{t-1},C)<br>\end{split}<br>$$</p><p>这个公式需要求出$P(y_1|C),P(y_2|y_1,C),…,P(y_T|y_1,y_2,…,y_{T-1},C)$，概率连乘极小，不利于存储，因此取对数进行计算，这样就将连乘式转换为累加式</p><p>$$<br>\log P(y_1,y_2,…,y_T|x_1,x_2,…,x_T) = \sum_{t=1}^T \log P(y_t|y_1,y_2,…,y_{t-1},C)<br>$$</p><p>应用场景：机器翻译（NMT）</p><h3 id="4-3-2-Attention机制">4.3.2 Attention机制</h3><h4 id="4-3-2-1-长句子问题">4.3.2.1 长句子问题</h4><p>对于长句子，Seq2Seq模型的性能会下降，无法做到准确翻译。<br>句子非常长时，BLEU（Bilingual Evaluation Understudy）评价得分会很低</p><p>本质原因：在Encoder-Decoder结构中，Encoder把所有的输入序列都编码成一个统一的语义特征$C$再解码，$C$中必须包含原始序列中的所有信息，它的长度就成了模型性能的瓶颈。<br>当需要翻译的句子很长时，一个$C$可能存不下那么多信息，就会造成翻译精度的下降。</p><h4 id="4-3-2-2-Attention机制">4.3.2.2 Attention机制</h4><ul><li>把Encoder的所有隐层输出$s_1,s_2,…,s_T$都保留下来，不再只保留最后一个隐层输出$C$</li><li>将这些信息提供给Decoder</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/Attention%E6%9C%BA%E5%88%B6.png" alt="Attention机制"></p><h4 id="4-3-2-3-Attention机制的计算">4.3.2.3 Attention机制的计算</h4><p>假设Encoder的时刻为$t$，Decoder的时刻为$t’$</p><ol><li>$c_{t’}=\sum_{t=1}^T \alpha_{t’t}s_t$<ul><li>$\alpha_{t’t}$：参数，训练得到，表示Decoder的$t’$时刻对Encoder的$t$时刻的注意力权重</li><li>理解：Encoder的每个时刻加权求和，得到Decoder的$t’$时刻的输入</li><li>$c_4=\alpha_{41}s_1+\alpha_{42}s_2+…+\alpha_{4T}s_T$</li></ul></li><li>$\alpha_{t’t}$的$N$个权重系数的由来<ul><li>权重系数通过Softmax函数得到，$\alpha_{t’t}=\frac{exp(e_{t’t})}{\sum_{k=1}^T exp(e_{t’k})}$</li><li>$e_{t’t}=g(s_{t’-1},h_t)=v^T \tanh(W_ss+W_hh)$<ul><li>$e_{t’t}$：由t时刻的编码器隐层状态输出和t’-1时刻的解码器隐层状态输出计算得到的一个值</li><li>s为Decoder的隐层输出，h为Encoder的隐层输出</li><li>$W_s, W_h, v$：参数，训练得到</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch|Dataset&amp;DataLoader</title>
      <link href="/posts/Dataset&amp;DataLoader.html"/>
      <url>/posts/Dataset&amp;DataLoader.html</url>
      
        <content type="html"><![CDATA[<h2 id="Dataset-数据集">Dataset 数据集</h2><p>Pytorch中表示数据集的抽象类//</p><p>任何自定义的数据集都需要继承这个类并覆写相关方法</p><p>Dataset的描述：</p><blockquote><p>所有表示从键到数据样本的映射的数据集都应继承它。<br>所有子类都应覆写__getitem__，以支持获取给定键的数据样本。<br>子类还可以选择性地覆盖__len__，许多~torch.utils.data.Sampler类实现和~torch.utils.data.DataLoader类的默认选项都希望它返回数据集的大小。<br>子类也可以选择实现__getitems__，以加快成批样本的加载速度。<br>此方法接受批次样本的索引列表，并返回样本列表。</p></blockquote><p>假设需要加载的是当前目录下<code>images</code>文件夹中的42张png图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path, processor=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Dataset类的初始化方法</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            path: 数据路径列表</span></span><br><span class="line"><span class="string">            processor: 数据预处理的函数，f:数据路径-&gt;目标数据</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.path = path</span><br><span class="line">        self.processor = processor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回数据集的大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据索引返回处理后的数据&quot;&quot;&quot;</span></span><br><span class="line">        data_path = self.path[idx]</span><br><span class="line">        data = self.processor(data_path)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">processor</span>(<span class="params">data_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;预处理函数，这里&quot;&quot;&quot;</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(data_path).size</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_images_path</span>(<span class="params">data_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取data_dir目录下所有png图片的路径，不含子目录&quot;&quot;&quot;</span></span><br><span class="line">    images_path = [os.path.join(data_dir,image)</span><br><span class="line">                   <span class="keyword">for</span> image <span class="keyword">in</span> os.listdir(data_dir)</span><br><span class="line">                   <span class="keyword">if</span> image.endswith(<span class="string">&#x27;.png&#x27;</span>)]</span><br><span class="line">    <span class="keyword">return</span> images_path</span><br><span class="line"></span><br><span class="line">data_dir = <span class="string">&#x27;images&#x27;</span> <span class="comment"># 数据目录</span></span><br><span class="line">images_path = get_images_path(data_dir) <span class="comment"># 获取数据路径</span></span><br><span class="line">dataset = MyDataset(images_path, processor=processor) <span class="comment"># 创建数据集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dataset[<span class="number">0</span>]) <span class="comment"># 打印第一个数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(dataset)) <span class="comment"># 打印数据集大小</span></span><br></pre></td></tr></table></figure><pre><code>(367, 126)42</code></pre><h2 id="DataLoader-数据迭代器">DataLoader 数据迭代器</h2><p>Pytorch加载和处理数据集的可迭代对象//</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">Default</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">dataset</td><td style="text-align:center">必选</td><td style="text-align:center">用于加载数据的数据集<br>必须是torch.utils.data.Dataset的子类实例</td></tr><tr><td style="text-align:center">batch_size</td><td style="text-align:center">1</td><td style="text-align:center">每个batch的样本数</td></tr><tr><td style="text-align:center">shuffle</td><td style="text-align:center">False</td><td style="text-align:center">是否在每个epoch开始时打乱数据</td></tr><tr><td style="text-align:center">sampler</td><td style="text-align:center">None</td><td style="text-align:center">定义从数据集中提取样本的策略<br>如果指定这个参数，则忽略shuffle参数</td></tr><tr><td style="text-align:center">batch_sampler</td><td style="text-align:center">None</td><td style="text-align:center">与sampler类似，但返回的是一个batch的索引<br>不能与batch_size、shuffle、sampler同时使用</td></tr><tr><td style="text-align:center">num_workers</td><td style="text-align:center">0</td><td style="text-align:center">用于数据加载的子进程数</td></tr><tr><td style="text-align:center">collate_fn</td><td style="text-align:center">None</td><td style="text-align:center">将多个样本组合成一个mini-batch的函数</td></tr><tr><td style="text-align:center">drop_last</td><td style="text-align:center">False</td><td style="text-align:center">如果数据集大小不能被batch_size整除，是否丢弃最后一个不完整的batch</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line">data_loader = DataLoader(dataset,batch_size=<span class="number">5</span>,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> data_loader:</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><pre><code>[tensor([1866,  439,  970, 1378, 1416]), tensor([660, 159, 354, 554, 498])][tensor([2018, 1116, 1720,  812, 1500]), tensor([ 968,  556, 1302,  465, 1168])][tensor([2260, 1378, 1046, 1774, 1521]), tensor([648, 612, 514, 524, 375])][tensor([ 956,  962,  412, 1700,  978]), tensor([530, 542, 640, 904, 465])][tensor([1202, 1434, 1686, 1583, 3873]), tensor([1006,  598,  540,  844, 5041])][tensor([1402, 1824, 1580, 1422, 1638]), tensor([1414, 1454,  630,  570, 1044])][tensor([1944, 1390, 1408,  367, 1320]), tensor([592, 568, 864, 126, 364])][tensor([1983, 1844,  912, 1400, 1564]), tensor([482, 866, 501, 602, 514])][tensor([1144, 1594]), tensor([718, 494])]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记3-卷积神经网络CNN</title>
      <link href="/posts/deep_learning_3.html"/>
      <url>/posts/deep_learning_3.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、卷积神经网络基础">一、卷积神经网络基础</h2><h3 id="1-1-计算机视觉（Computer-Vision，CV）">1.1 计算机视觉（Computer Vision，CV）</h3><p>在CV领域，通常要做的是用机器程序代替人眼对目标图像进行识别、分析、处理。<br>深度学习在CV领域的应用非常广泛。</p><p>假设需要处理1024x1024的彩色图像，每个像素有RGB三个通道，共有1024x1024x3=3,145,728个特征。<br>假设第一个隐藏层有10个神经元，那么第一层的权重矩阵有3,145,728x10=31,457,280个参数，计算量极大，难以达到好的效果。</p><p>相比多层神经网络，卷积神经网络（CNN）更适合处理图像数据。</p><p>1962年Hubel和Wiesel通过对猫视觉皮层细胞的研究，提出了感受野的概念。<br>Fukushima基于感受野概念提出的神经认知机(Neocognitron)可以看作是卷积神经网络的第一个实现网络。</p><p>单个感受器与许多感觉神经纤维相联系，感觉信息是通过许多感受神经纤维发放总和性的空间与时间类型不同的冲动，相当于经过编码来传递。</p><h3 id="1-2-边缘检测">1.2 边缘检测</h3><p>为了使用更少的参数检测出更多的信息，通常神经网络需要检测出物体最明显的垂直和水平边缘来区分物体。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.png" alt="边缘检测"></p><p>随着深度学习的发展，我们需要检测更复杂的图像中的边缘。<br>与其使用由人手工设计的过滤器，还可以将过滤器中的数值作为参数，通过反向传播来学习得到。</p><p>算法可以根据实际数据来选择合适的检测目标，无论是检测水平边缘、垂直边缘还是其他角度的边缘，并习得图像的低层特征。</p><h2 id="二、卷积神经网络原理">二、卷积神经网络原理</h2><h3 id="2-1-卷积神经网络的组成">2.1 卷积神经网络的组成</h3><p>CNN由一个或多个卷积层（Convolutions）、池化层（Pooling）、全连接层（Full Connection）组成。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/CNN%E7%BB%93%E6%9E%84.png" alt="CNN结构"></p><p>与其他深度学习结构相比，CNN在图像等方面能够给出更好的结果。<br>CNN也可以用反向传播算法进行训练。<br>与其他浅层或深层神经网络相比，CNN的参数更少，更容易训练。</p><h3 id="2-2-卷积层（Convolutions）">2.2 卷积层（Convolutions）</h3><ul><li>目的：提取输入的不同特征<ul><li>某些卷积层可能只能提取一些低级特征，如线条、边缘等，更多层的网络能从低级特征中提取更高级更复杂的特征。</li></ul></li><li>参数<ul><li>size：卷积核（filter）大小，如3x3、5x5等</li><li>padding：0填充，保持输出和输入的大小一致，Valid/Same</li><li>stride：步长，卷积核每次移动的距离，通常为1</li></ul></li><li>计算公式<ul><li>四个超参数：Filter数量$K$、Filter大小$F$、步长$S$、0填充大小$P$</li><li>输入体积：$H_1 \times W_1 \times D_1$</li><li>输出体积：$H_2 \times W_2 \times D_2$<ul><li>$H_2 = \dfrac{H_1-F+2P}{S}+1$</li><li>$W_2 = \dfrac{W_1-F+2P}{S}+1$</li><li>$D_2 = K$</li></ul></li></ul></li></ul><h4 id="2-2-1-卷积运算">2.2.1 卷积运算</h4><p>卷积运算（符号$\ast$）：将一个矩阵（卷积核）应用到另一个矩阵的所有位置，求出每个位置的点积，得到一个新的矩阵。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E5%8D%B7%E7%A7%AF%E8%BF%90%E7%AE%97.png" alt="卷积运算"></p><p>在这个6x6的矩阵中，左边一半都是1，右边一半都是0，中间是一条非常明显的垂直边缘。<br>经过卷积后，得到一个4x4的矩阵，中间的值非常大，其他值非常小，表明检测到了垂直边缘。</p><p>卷积运算的产生的问题：边缘像素的信息丢失、输出的图像尺寸变小</p><h4 id="2-2-2-padding-零填充">2.2.2 padding-零填充</h4><p>在图片像素的最外层加上$P$层0，使得卷积后的输出和输入的尺寸一致。</p><p>0对最终结果不产生影响，避免图片增加噪声。</p><ul><li>Valid卷积：不填充，输出尺寸减小</li><li>Same卷积（一般采用）：填充0以维持输出尺寸与原图一致</li></ul><h4 id="2-2-3-size-卷积核大小">2.2.3 size-卷积核大小</h4><p>卷积核大小$F$通常为3x3、5x5、7x7等奇数，保证能够确定一个中心点。</p><p>小卷积核可以保留更多的信息，大卷积核可以检测更大的特征。</p><h4 id="2-2-4-stride-步长">2.2.4 stride-步长</h4><p>步长$S$通常为1，即卷积核每次移动一个像素。</p><p>步长为2时，卷积核每次移动两个像素，输出尺寸减小，示例如下：</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/2%E6%AD%A5%E9%95%BF%E5%8D%B7%E7%A7%AF.png" alt="2步长卷积"></p><h4 id="2-2-5-多通道卷积">2.2.5 多通道卷积</h4><p>当输入有多个通道（Channel）时（例如图片可以有 RGB 三个通道），卷积核需要拥有相同的通道数</p><p>但最终的输出只有一个通道，其结果是多个通道的卷积结果的和。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E5%A4%9A%E9%80%9A%E9%81%93%E5%8D%B7%E7%A7%AF.png" alt="多通道卷积"></p><h4 id="2-2-6-多卷积核">2.2.6 多卷积核</h4><p>当有多个卷积核时，可以学习到多种不同的特征，输出结果的通道数等于卷积核的数量，多卷积核可以理解为多神经元</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E5%A4%9A%E5%8D%B7%E7%A7%AF%E6%A0%B8.png" alt="多卷积核"></p><h4 id="2-2-7-卷积层的运算结果">2.2.7 卷积层的运算结果</h4><p>$$<br>\begin{split}<br>&amp;Z^{[l]} = W^{[l]} \ast A^{[l-1]} + b^{[l]} \\<br>&amp;A^{[l]} = g(Z^{[l]})<br>\end{split}<br>$$</p><h3 id="2-3-池化层（Pooling）">2.3 池化层（Pooling）</h3><p>池化层主要对卷积层的输出进行下采样（Subsampling）处理，主要分为：</p><ul><li>最大池化（Max Pooling）：取池化窗口中的最大值</li><li>平均池化（Average Pooling）：取池化窗口中的平均值</li></ul><p>池化通常为2x2的filter，步长为2，即每次取2x2的窗口中的最大值或平均值。</p><p>特点：没有参数，不需要学习，只是对输入数据进行简单的处理。</p><p>目的：降低数据维度；减少计算量、提高计算速度；防止过拟合，提高了鲁棒性。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%B1%A0%E5%8C%96%E5%B1%82.png" alt="池化层"></p><h3 id="2-4-全连接层（Fully-Connected）与CNN结构">2.4 全连接层（Fully Connected）与CNN结构</h3><p>全连接层即此前提到的多层神经网络，每个神经元与上一层的所有神经元相连。</p><p>卷积层+激活层+池化层可以看成是CNN的特征学习/特征提取层，学习到的特征（Feature Map）最终应用于模型任务（分类、回归）</p><ul><li>先对所有Feature Map进行扁平化（Flatten），即转化为一维向量</li><li>再连接到一个或多个全连接层，进行分类或回归任务</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/CNN%E7%BB%93%E6%9E%842.png" alt="CNN结构2"></p><h2 id="三、经典分类网络结构">三、经典分类网络结构</h2><p>通常采用从现成的经典网络结构进行优化，而不是从头开始设计网络结构。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="经典网络结构"></p><ul><li>NIN：引入了1x1卷积核</li><li>VGG：参数量巨大（1.4亿），19层网络</li><li>GoogleNet：500万参数，22层网络<ul><li>2014年比赛冠军的model，证明了用更多的卷积、更深的层次可以得到更好的结构</li><li>引入了Inception模块，多个不同大小的卷积核</li></ul></li></ul><h3 id="3-1-LeNet-5">3.1 LeNet-5</h3><p><img src="https://source.cclmsy.cc/Posts/DL/Note/LeNet5.png" alt="LeNet-5"></p><p>LeNet-5最初的目的用于手写数字识别，当时使用的激活函数是Sigmoid和Tanh，还没有出现Relu</p><h4 id="参数形状">参数形状</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Shape</th><th style="text-align:center">Size</th><th style="text-align:center">Params</th></tr></thead><tbody><tr><td style="text-align:center">Input</td><td style="text-align:center">(32, 32, 1)</td><td style="text-align:center">1024</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Conv1(f=5,s=1)</td><td style="text-align:center">(28, 28, 6)</td><td style="text-align:center">4704</td><td style="text-align:center">5x5（卷积核大小）x3（通道数）x6（卷积核数量）+6（偏置）=456</td></tr><tr><td style="text-align:center">Pool1</td><td style="text-align:center">(14, 14, 6)</td><td style="text-align:center">1176</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Conv2(f=5,s=1)</td><td style="text-align:center">(10, 10, 16)</td><td style="text-align:center">1600</td><td style="text-align:center">5x5x6x16+16=2416</td></tr><tr><td style="text-align:center">Pool2</td><td style="text-align:center">(5, 5, 16)</td><td style="text-align:center">400</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">FC3</td><td style="text-align:center">(120, 1)</td><td style="text-align:center">120</td><td style="text-align:center">400x120+120=48120</td></tr><tr><td style="text-align:center">FC4</td><td style="text-align:center">(84, 1)</td><td style="text-align:center">84</td><td style="text-align:center">120x84+84=10164</td></tr><tr><td style="text-align:center">Output:Sofmax</td><td style="text-align:center">(10, 1)</td><td style="text-align:center">10</td><td style="text-align:center">84x10+10=850</td></tr></tbody></table><ul><li>中间特征值的大小变化不宜过大，否则会导致信息丢失</li></ul><h3 id="3-2-AlexNet">3.2 AlexNet</h3><p><img src="https://source.cclmsy.cc/Posts/DL/Note/AlexNet.png" alt="AlexNet"></p><ul><li>总参数量：6000万，8层神经网络，5个卷积层+3个全连接层</li><li>使用了非线性激活函数ReLU</li><li>使用Dropout防止过拟合，数据扩充</li><li>使用批标准化（Batch Normalization）加速训练</li></ul><h4 id="参数形状-2">参数形状</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Shape</th><th style="text-align:center">Size</th><th style="text-align:center">Params</th></tr></thead><tbody><tr><td style="text-align:center">Input</td><td style="text-align:center">(227, 227, 3)</td><td style="text-align:center">154,587</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Conv1(f=11,s=4)</td><td style="text-align:center">(55, 55, 96)</td><td style="text-align:center">290,400</td><td style="text-align:center">11×11×3×96 + 96 = 34,944</td></tr><tr><td style="text-align:center">Pool1</td><td style="text-align:center">(27, 27, 96)</td><td style="text-align:center">69,984</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Conv2(f=5,s=1)</td><td style="text-align:center">(27, 27, 256)</td><td style="text-align:center">186,624</td><td style="text-align:center">5×5×48×256 + 256 = 307,456（group卷积）</td></tr><tr><td style="text-align:center">Pool2</td><td style="text-align:center">(13, 13, 256)</td><td style="text-align:center">43,264</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Conv3(f=3,s=1)</td><td style="text-align:center">(13, 13, 384)</td><td style="text-align:center">64,896</td><td style="text-align:center">3×3×256×384 + 384 = 885,120</td></tr><tr><td style="text-align:center">Conv4(f=3,s=1)</td><td style="text-align:center">(13, 13, 384)</td><td style="text-align:center">64,896</td><td style="text-align:center">3×3×192×384 + 384 = 663,936（group卷积）</td></tr><tr><td style="text-align:center">Conv5(f=3,s=1)</td><td style="text-align:center">(13, 13, 256)</td><td style="text-align:center">43,264</td><td style="text-align:center">3×3×192×256 + 256 = 442,624（group卷积）</td></tr><tr><td style="text-align:center">Pool3</td><td style="text-align:center">(6, 6, 256)</td><td style="text-align:center">9,216</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">FC6</td><td style="text-align:center">(4096, 1)</td><td style="text-align:center">4096</td><td style="text-align:center">6×6×256×4096 + 4096 = 37,752,832</td></tr><tr><td style="text-align:center">FC7</td><td style="text-align:center">(4096, 1)</td><td style="text-align:center">4096</td><td style="text-align:center">4096×4096 + 4096 = 16,781,312</td></tr><tr><td style="text-align:center">FC8</td><td style="text-align:center">(1000, 1)</td><td style="text-align:center">1000</td><td style="text-align:center">4096×1000 + 1000 = 4,097,000</td></tr><tr><td style="text-align:center">Output:Softmax</td><td style="text-align:center">(1000, 1)</td><td style="text-align:center">1000</td><td style="text-align:center">0</td></tr></tbody></table><h3 id="3-3-Inception结构">3.3 Inception结构</h3><p>Inception结构是GoogleNet中的一个模块，由多个不同大小的卷积核组成，可以提取不同尺度的特征。</p><h4 id="3-1-MLP卷积（1x1卷积）">3.1 MLP卷积（1x1卷积）</h4><p>一种新的深度网络结构Network in Network（NIN）提出了MLP卷积取代传统线性卷积核</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/MLP%E5%8D%B7%E7%A7%AF.png" alt="MLP卷积"></p><ul><li>1x1卷积核对每个像素点的所有通道进行了线性组合</li><li>激活函数将feature map由多通道的线性组合变为非线性组合（信息整合）</li><li>提高特征抽象能力（Multilayer Perceptron，缩写MLP，就是一个多层神经网络）</li><li>主要作用：调整通道数（升维降维）、减少参数量</li></ul><h4 id="3-2-Inception层">3.2 Inception层</h4><p>也称盗梦空间结构）</p><p>目的：代替人决定，使用哪种卷积核，或是需要MaxPool层，由网络自己学习寻找合适的结构，节省计算</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/Inception%E5%B1%82.png" alt="Inception层"></p><p>提供以下4种不同的卷积核：</p><ul><li>1x1卷积核（64个）</li><li>3x3卷积核（128个），padding=same</li><li>5x5卷积核（32个），padding=same</li><li>2x2最大池化（32个），stride=1，padding=same</li><li>最终结果为这4种卷积核的拼接，27x27x256，使用更少的参数达到和AlexNet相当的效果</li></ul><h4 id="3-3-Inception改进">3.3 Inception改进</h4><p>上一节中，计算量还是太大，参数还是太多，需要进一步改进。以5x5卷积核为例：</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/Inception%E6%94%B9%E8%BF%9B.png" alt="Inception改进"></p><ul><li>上面为原方法，参数：$5\times5\times192\times32=153600$</li><li>下面为改进方法，网络缩小后再扩大，参数：$1\times1\times192\times16+5\times5\times16\times32=15872$</li></ul><h4 id="3-4-GoogleNet">3.4 GoogleNet</h4><p>Inception模块的堆叠，形成GoogleNet网络结构</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/Inception%E6%A8%A1%E5%9D%97.png" alt="Inception模块"></p><p>详细结构略</p><h2 id="四、卷积神经网络实战技巧">四、卷积神经网络实战技巧</h2><h3 id="4-1-学习特征可视化">4.1 学习特征可视化</h3><p>可以将网络学习过程中产生的特征图可视化出来，并且对比原图来看看每一层都干了什么</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/LeNet5%E4%BE%8B.webp" alt="LeNet5例"></p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E5%AD%A6%E4%B9%A0%E7%89%B9%E5%BE%81%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="学习特征可视化"></p><ul><li>Layer1,2：颜色、边缘等基本特征</li><li>Layer3：纹理、形状等中级特征</li><li>Layer4：稍复杂的特征，如狗的头部形状</li><li>Layer5：高级特征，如关键性区分特征</li></ul><h3 id="4-2-迁移学习（Transfer-Learning）">4.2 迁移学习（Transfer Learning）</h3><p>如果需要做一个具体场景的计算机视觉任务，可以使用已经训练好的模型，然后在此基础上进行微调。</p><h4 id="4-2-1-介绍">4.2.1 介绍</h4><p>迁移学习就是利用数据、任务或模型之间的相似性（例如都是图像分类任务），将在旧的领域学习过或训练好的模型，应用于新的领域的过程。</p><p>从以下两个方面考虑训练模型的现实问题：</p><ol><li>数据集大小：如果新任务的数据集很小，迁移学习可以帮助提高模型的泛化能力<ul><li>如果有海量的数据集支持，可以不需要迁移学习，直接从海量数据中训练出一个学习到一个鲁棒性很强的模型</li><li>但是，通常情况下，需要研究的领域数据集非常有限，导致模型的泛化能力极差</li></ul></li><li>训练成本：从头开始训练一个CNN模型需要大量的时间和计算资源</li></ol><h4 id="4-2-2-微调（Fine-tuning）">4.2.2 微调（Fine-tuning）</h4><p>在一个已经训练好的模型（Pre-trained Model）上进行针对性优化，以提升模型在特定任务上的性能。</p><p>假设有两个任务$A$和$B$。<br>任务$A$拥有海量数据，以$a$为条件区分1000个类别，已经训练好了一个模型。<br>目标任务为$B$，以$b$为条件区分250个类别，数据集很小。</p><p>步骤：</p><ol><li>在$A$模型的基础上，将最后一层的输出层替换为250个类别的输出层，保持前面的参数不变</li><li>根据数据量，决定是否冻结（Freeze）前面的层（权重不变），只训练最后若干层并更新参数<ul><li>数据越多，就保留越多的层，从后往前逐渐解冻</li><li>数据很少，只保留输出层，其他层全部解冻</li></ul></li><li>重新训练模型</li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DL笔记2|改善深层神经网络</title>
      <link href="/posts/deep_learning_2.html"/>
      <url>/posts/deep_learning_2.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、神经网络实践相关">一、神经网络实践相关</h2><h3 id="1-1-数据集划分">1.1 数据集划分</h3><p>数据集：</p><ul><li>训练集（Training Set）：用于模型的训练过程</li><li>验证集（Validation Set）：利用验证集（又称为简单交叉验证集，hold-out cross validation set）进行交叉验证，选择出最好的模型</li><li>测试集（Test Set）：用于评估模型的能力</li></ul><p>数据集划分比例：</p><ul><li>小数据量（小于10万）比例：无验证集7:3，有验证集6:2:2</li><li>大数据量比例：98:1:1、99.5:0.25:0.25、99.5:0.4:0.1</li></ul><h3 id="1-2-偏差和方差">1.2 偏差和方差</h3><p>“偏差-方差分解”（bias-variance decomposition）是解释学习算法泛化性能的一种重要工具。</p><p>泛化误差可分解为偏差、方差与噪声，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。</p><ul><li>偏差（Bias）：度量学习算法的期望预测与真实结果的偏离程度，反映了<strong>模型本身的拟合能力</strong></li><li>方差（Variance）：度量同样大小的训练集的变动所导致的学习性能的变化，反映了<strong>模型的稳定性</strong></li><li>噪声：当前任务下任何学习算法所能达到的期望泛化误差的下界，反映了<strong>问题本身的难度</strong></li></ul><p>偏差、方差与数据集划分的关系及解决方法：</p><ol><li>训练集错误率小、测试集错误率大：高方差，可能出现了<strong>过拟合</strong><ul><li>增大数据集，使训练尽可能包含所有情况</li><li>寻找更合适的网络结构</li><li>正则化</li></ul></li><li>训练集错误率大、测试集错误率大：高偏差，可能出现了<strong>欠拟合</strong><ul><li>扩大网络规模，例如增加隐藏层或神经元数量</li><li>寻找更合适的网络结构，使用更大的网络</li><li>增加训练时间、迭代次数</li></ul></li><li>训练集错误率小、测试集错误率小：方差和偏差都小，模型效果较好</li></ol><h3 id="1-3-逻辑回归的L1和L2正则化">1.3 逻辑回归的L1和L2正则化</h3><p><strong>正则化（Regularization）</strong>：在成本函数中加入一个正则化项（惩罚项），惩罚模型的复杂度，防止网络过拟合</p><p>逻辑回归中，参数$W$的数量由特征数决定，正则化如下：</p><ul><li>L1正则化：$J(W,b) = \dfrac{1}{m}\sum\limits_{i=1}^{m}L(\hat{y}^{(i)},y^{(i)})+\dfrac{\lambda}{2m}||W||_1$</li><li>L2正则化：$J(W,b) = \dfrac{1}{m}\sum\limits_{i=1}^{m}L(\hat{y}^{(i)},y^{(i)})+\dfrac{\lambda}{2m}||W||_2^2$<ul><li>L2范数：$\dfrac{\lambda}{2m}||W||<em>2^2 = \dfrac{\lambda}{2m}\sum\limits</em>{i=1}^{n}W_i^2=\dfrac{\lambda}{2m}W^TW$</li><li>解释：所有W参数的平方和</li></ul></li></ul><p>正则化因子$\lambda$：超参数，控制正则化项的权重，$\lambda$越大，正则化项的影响越大，模型越简单，防止过拟合。</p><p>L1正则化后，$W$的某些参数会变为0，使模型变稀疏，因此L2正则化更常用。</p><p>梯度下降的目的是减小损失函数$J(W,b)$值的大小。<br>在损失函数中增加了一项，导致$dW$增大，$W$减小的更多（多减去一项），因此L2范数也称为权重衰减（Weight Decay）。</p><h3 id="1-4-神经网络中的L2正则化、Frobenius范数">1.4 神经网络中的L2正则化、Frobenius范数</h3><p>对每一层的权重矩阵$W^{[l]}$进行正则化，每一层都有若干个权重，可以理解为矩阵</p><p>$$<br>J(W^{[1]},b^{[1]},…,W^{[L]},b^{[L]}) = \dfrac{1}{m}\sum\limits_{i=1}^{m}L(\hat{y}^{(i)},y^{(i)})+\dfrac{\lambda}{2m}\sum\limits_{l=1}^{L}||W^{[l]}||_F^2<br>$$</p><p>其中，$||W^{[l]}||_F^2$为Frobenius范数，表示矩阵的所有元素的平方和。</p><h3 id="1-5-正则化减少过拟合的原理">1.5 正则化减少过拟合的原理</h3><p>正则化因子设置的足够大的情况下，为了使损失函数最小化，权重矩阵会趋向于0，削弱隐藏层影响，使得模型变得简单。</p><p>选取一个适合的$\lambda$，可以使得模型的复杂度适中，防止过拟合。</p><h3 id="1-6-Dropout正则化">1.6 Dropout正则化</h3><p>Dropout正则化：在训练过程中，随机关闭一些神经元，减少神经元之间的依赖关系，防止过拟合。</p><p>Inverted Dropout：在训练过程中，对每一层的神经元，以概率$keep_prob$保留。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keep_prob = <span class="number">0.8</span>  <span class="comment"># 保留概率</span></span><br><span class="line">dl = np.random.rand(A.shape[<span class="number">0</span>], A.shape[<span class="number">1</span>]) &lt; keep_prob  </span><br><span class="line">A = np.multiply(A, dl)  <span class="comment"># 保留神经元</span></span><br><span class="line"></span><br><span class="line"> 部分神经元被关闭，期望值预计下降为原来的$keep_prob$，需要缩放激活值保持期望值不变</span><br><span class="line">A = A / keep_prob </span><br></pre></td></tr></table></figure><p>加入了Droupout后，输入的特征都存在被随机清除的可能，所以该神经元不会再特别依赖于任何一个输入特征。<br>通过传播过程，Dropout将产生和L2正则化相同的收缩权重的效果。</p><p>对于神经元较多的层，设置较小的keep_prob，对于神经元较少的层，设置keep_prob=1。</p><p>在CV领域，图像具有更多的特征，Dropout是一种非常有效的正则化方法。</p><p>缺点：</p><ol><li>因为每次会随机消除一部分神经元，成本函数无法被明确定义</li><li>参数无法确定具体是哪些，在反向传播的时候带来计算上的麻烦，无法保证当前网络是否损失函数下降的</li></ol><h3 id="1-7-其他正则化方法">1.7 其他正则化方法</h3><h4 id="早停止法（Early-Stopping）">早停止法（Early Stopping）</h4><p>如果训练迭代的次数过高，会发生过拟合，损失函数图像如下：</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%97%A9%E5%81%9C%E6%AD%A2%E6%B3%95.png" alt="早停止法"></p><p>早停止法：在测试集上的损失减少到一定程度后，停止训练，防止过拟合。</p><p>这种方法治标不治本，还是需要从根本上解决数据或模型的问题。</p><h4 id="数据增强（Data-Augmentation）">数据增强（Data Augmentation）</h4><p>算法在学习区分两种类别时，可能会寻找到一个最明显的特征。</p><p>例如在区分两种不同型号的车时，如果训练集中，型号1的车都朝左，型号2的车都朝右，那么模型可能会认为车的朝向是区分两种车的最重要特征。<br>在测试集中，如果出现了朝右的型号1车，模型可能认为是型号2车。<br>因此，需要减少数据集中不相关的特征的数量。</p><p>数据增强：通过对训练集进行一系列的随机变换（如剪切、旋转、翻转、缩放等），增加训练集的样本数量，提高模型的泛化能力。</p><p>在上面的例子中，可以通过水平翻转图像，以防止模型学习到不相关的模式。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA.png" alt="数据增强"></p><ul><li>离线增强：预先进行所有的必要转换，从根本上增大数据集规模（如水平翻转后，保存为新的图像，数据集增大为原来的两倍）</li><li>在线增强：在训练过程中，对即将输入模型的小批量数据进行相应变换，同一张图每次训练被随机执行一些变化操作，相当于不同数据集</li></ul><p>数据增强的效果如下</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E7%9A%84%E6%95%88%E6%9E%9C.png" alt="数据增强的效果"></p><h3 id="1-8-正则化输入">1.8 正则化输入</h3><p>对于输入数据进行正则化处理，使数据都服从同一分布，能够缓解梯度消失和梯度爆炸问题，并且加速算法的收敛。</p><ul><li>正则化公式：$X = \dfrac{X-\mu}{\sigma}$，其中$\mu$为均值，$\sigma$为标准差</li></ul><h3 id="1-9-梯度消失与梯度爆炸">1.9 梯度消失与梯度爆炸</h3><p>由于链式法则是一个连乘的过程，当层数越深时，梯度以指数速度增长传播。</p><ul><li>梯度消失：梯度小于1，多次连乘后，梯度趋近于0，导致参数几乎不更新、模型难收敛</li><li>梯度爆炸：梯度大于1，多次连乘后，梯度趋近于无穷，导致参数更新过大甚至溢出</li></ul><p>局部最优解：损失函数可能存在鞍点/局部最小值</p><ul><li>较大的神经网络，局部最优解的可能性较小</li><li>鞍点附近的平稳段会使得学习非常缓慢，需要优化算法加速学习</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E5%B1%80%E9%83%A8%E6%9C%80%E4%BC%98%E8%A7%A3.gif" alt="局部最优解"></p><p>解决方法：</p><ol><li>初始化参数策略：将权重初始化为较小的随机数</li><li>批梯度下降、Mini-batch梯度下降、随机梯度下降</li><li>梯度下降算法内部优化：动量梯度下降、RMSProp算法、Adam算法</li><li>学习率衰减</li><li>标准化输入</li></ol><h3 id="1-10-权重初始化">1.10 权重初始化</h3><p>为了避免对称性，权重初始化不能全为0，通常使用较小的随机数进行初始化。</p><p>在逻辑回归的笔记中，权重初始化为<code>np.random.randn(k, n) * 0.01</code>。</p><p>Xavier初始化：$w^{[l]} = np.random.randn(k, n) \times \sqrt{\dfrac{1}{n^{[l-1]}}}$，其中$n^{[l-1]}$为上一层的神经元数量。</p><p>如果使用ReLU激活函数，权重初始化为 $w^{[l]} = np.random.randn(k, n) \times \sqrt{\dfrac{2}{n^{[l-1]}}}$。</p><h2 id="二、优化算法">二、优化算法</h2><h3 id="2-1-批梯度下降、Mini-batch梯度下降、随机梯度下降">2.1 批梯度下降、Mini-batch梯度下降、随机梯度下降</h3><p>批梯度下降（Batch Gradient Descent）：同时处理整个训练集</p><ul><li>在更新参数前，必须先处理整个训练参数集，才能进行一步梯度下降</li><li>如果训练集很大，计算量会很大，训练速度很慢</li><li>噪声低，代价函数值平滑减小</li><li>训练样本的大小较小（小于2048）时，选择Batch梯度下降</li></ul><p>Mini-batch梯度下降：将训练集分为多个固定大小的批次，每次只处理一个批次的数据</p><ul><li>训练样本的大小较大时，选择Mini-batch梯度下降，通常为64、128、256、512等</li></ul><p>随机梯度下降（Stochastic Gradient Descent, SGD）：mini-batch大小为1，每次只处理一个样本</p><ul><li>训练速度快，但丢失了向量化编程的优势</li><li>代价函数值波动大，噪声大，总体向全局最小值靠近，但难以收敛，容易在鞍点震荡</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E5%80%BC%E5%8F%98%E5%8C%96%E8%B6%8B%E5%8A%BF.png" alt="梯度下降代价函数值变化趋势"></p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E5%80%BC%E5%8F%98%E5%8C%96%E8%B6%8B%E5%8A%BF2.png" alt="梯度下降代价函数值变化趋势2"></p><h3 id="2-2-指数加权平均">2.2 指数加权平均</h3><p>指数加权平均（Exponentially Weight Average）是一种常用的序列数据处理方式，通常用在序列场景，如金融序列分析、温度变化序列分析。</p><p>$$<br>S_t = \begin{cases}<br>x_t &amp;, t=1 \\<br>\beta S_{t-1}+(1-\beta)x_t &amp;, t&gt;1<br>\end{cases}<br>$$</p><p>理解：上一结果的权重为$\beta$，当前数据的权重为$1-\beta$。</p><p>下图，黄色$\beta=0.5$，红色$\beta=0.9$，绿色$\beta=0.98$</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87.png" alt="指数加权平均"></p><h3 id="2-3-动量梯度下降">2.3 动量梯度下降</h3><p>动量梯度下降（Momentum Gradient Descent）：利用梯度的指数加权平均来更新参数</p><p>$$<br>\begin{split}<br>&amp;S_{dW} = \beta S_{dW}+(1-\beta)dW \\<br>&amp;S_{db} = \beta S_{db}+(1-\beta)db \\<br>&amp;W = W-\alpha S_{dW} \\<br>&amp;b = b-\alpha S_{db}<br>\end{split}<br>$$</p><p>利用累加的梯度值，减少梯度下降的震荡，加速收敛</p><ul><li>前后梯度方向不一致时，梯度值减小，减少震荡</li><li>前后梯度方向一致时，梯度值增大，加速收敛</li></ul><h3 id="2-2-5-RMSProp算法">2.2.5 RMSProp算法</h3><p>RMSProp算法（Root Mean Square Propagation）：再对梯度进行指数加权平均的基础上，引入平方和平方根</p><p>$$<br>\begin{split}<br>&amp;S_{dW} = \beta S_{dW}+(1-\beta)dW^2 \\<br>&amp;S_{db} = \beta S_{db}+(1-\beta)db^2 \\<br>&amp;W = W-\alpha \dfrac{dW}{\sqrt{S_{dW}+\epsilon}} \\<br>&amp;b = b-\alpha \dfrac{db}{\sqrt{S_{db}+\epsilon}}<br>\end{split}<br>$$</p><p>其中，$\epsilon$是一个很小的数，避免分母过小导致数值不稳定。</p><p>RMSProp 有助于减少抵达最小值路径上的摆动，并允许使用一个更大的学习率$\alpha$，加快算法学习速度。</p><h3 id="2-2-6-Adam算法">2.2.6 Adam算法</h3><p>Adam算法（Adaptive Moment Estimation，自适应矩估计）：结合了Momentum和RMSProp算法，同时考虑梯度的一阶矩估计和二阶矩估计</p><p>假设用一个mini-batch计算$dW$和$db$，第$t$次迭代时，计算动量梯度结果：</p><p>$$<br>\begin{split}<br>&amp;V_{dW} = \beta_1 V_{dW}+(1-\beta_1)dW \\<br>&amp;V_{db} = \beta_1 V_{db}+(1-\beta_1)db \\<br>&amp;V_{dW}^{corrected} = \dfrac{V_{dW}}{1-\beta_1^t}<br>\end{split}<br>$$</p><p>计算RMSProp结果：</p><p>$$<br>\begin{split}<br>&amp;S_{dW} = \beta_2 S_{dW}+(1-\beta_2)dW^2 \\<br>&amp;S_{db} = \beta_2 S_{db}+(1-\beta_2)db^2 \\<br>&amp;S_{dW}^{corrected} = \dfrac{S_{dW}}{1-\beta_2^t}<br>\end{split}<br>$$</p><p>计算移动平均数时，使用系数$\dfrac{1}{1-\beta_1^t}$进行修正。<br>例如$m_0=0,m_1=0.9m_0+0.1m_1$，导致$m_1$的值过小，修正后恰好为$m_1$的值。<br>随着迭代次数增加，修正系数趋近于1，保证了移动平均数的准确性。</p><p>Adam算法更新参数：</p><p>$$<br>\begin{split}<br>&amp;W = W-\alpha \dfrac{V_{dW}^{corrected}}{\sqrt{S_{dW}^{corrected}}+\epsilon} \\<br>&amp;b = b-\alpha \dfrac{V_{db}^{corrected}}{\sqrt{S_{db}^{corrected}}+\epsilon}<br>\end{split}<br>$$</p><h3 id="2-2-7-学习率衰减">2.2.7 学习率衰减</h3><p>如果随着时间慢慢减少学习率$\alpha$的大小，在初期$\alpha$较大时，下降的步长较大，能以较快的速度进行梯度下降；而后期逐步减小$\alpha$的值，即减小步长，有助于算法的收敛，更容易接近最优解。</p><p>最常用的学习率衰减方法：$\alpha = \dfrac{1}{1+decay_ rate \times epoch_ num} \times \alpha_0$</p><ul><li>$\alpha_0$：初始学习率</li><li>$decay_ rate$：衰减率，超参数</li><li>$epoch_ num$：迭代次数</li></ul><p>一种指数衰减学习率：$\alpha = 0.95^{epoch_ num} \times \alpha_0$</p><h2 id="三、超参数调试、Batch正则化和编程框架">三、超参数调试、Batch正则化和编程框架</h2><h3 id="3-1-神经网络调优">3.1 神经网络调优</h3><p>算法层面：</p><ul><li>学习率$\alpha$</li><li>$\beta_1,\beta_2,\epsilon$：Adam算法的超参数，常用值$\beta_1=0.9,\beta_2=0.999,\epsilon=10^{-8}$</li><li>正则化参数$\lambda$</li></ul><p>模型层面：</p><ul><li>hidden units：隐藏层神经元数</li><li>layers：隐藏层层数</li></ul><p>调参技巧</p><ul><li>网格搜索：遍历所有可能的参数组合，测试每一组的效果，选择效果最好的参数组合。</li><li>尽量让每一组差别明显，避免重复测试</li><li>合理的参数设置：为超参数选择合适的范围<ul><li>学习率$\alpha$：通常设置为0.0001、0.001、0.01、0.1等</li><li>动量梯度因子$\beta$: 通常设置为0.999、0.9995、0.9999等，尽可能接近1（指数增加效应）</li></ul></li></ul><p>问题：调参过程麻烦、训练时间长</p><h3 id="2-4-2-批标准化（批标准化）">2.4.2 批标准化（批标准化）</h3><p>论文地址：<a href="https://arxiv.org/abs/1502.03167">批标准化: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></p><blockquote><p>训练深度神经网络很复杂，因为在训练期间每层输入的分布发生变化，因为前一层的参数发生了变化。<br>这通过要求较低的学习率和仔细的参数初始化来减慢训练速度，并且使得训练具有饱和非线性的模型变得非常困难。<br>我们将这种现象称为<strong>内部协变量偏移</strong>，并通过<strong>标准化层</strong>输入来解决问题。<br>我们的方法的优势在于使标准化成为模型体系结构的一部分，并为每个培训小批量执行标准化。<br>批标准化允许我们使用更高的学习率并且不太关心初始化。<br>它还可以充当调节器，在某些情况下可以消除对Dropout的需求。<br>应用于最先进的图像分类模型，批量标准化实现了相同的精度，培训步骤减少了14倍，并且显着地超过了原始模型。<br>使用批量标准化网络的集合，我们改进了ImageNet分类的最佳发布结果：达到4.9％的前5个验证错误（和4.8％的测试错误），超出了人类评估者的准确性。</p></blockquote><p>批标准化：在神经网络的每一层的<strong>激活函数之前</strong>，对每一层的<strong>输入</strong>进行标准化处理，使得每一层的输入数据服从均值为0、方差为1的正态分布。</p><p>批标准化公式：</p><p>$$<br>\begin{split}<br>&amp;\mu = \dfrac{1}{m}\sum\limits_{i=1}^{m}Z^{(i)} \\<br>&amp;\sigma^2 = \dfrac{1}{m}\sum\limits_{i=1}^{m}(Z^{(i)}-\mu)^2 \\<br>&amp;Z_{norm}^{(i)} = \dfrac{Z^{(i)}-\mu}{\sqrt{\sigma^2+\epsilon}}<br>\end{split}<br>$$</p><p>其中，$\mu$为均值，$\sigma^2$为方差，$\epsilon$为一个很小的数，避免分母为0。</p><p>如果各隐藏层的输入均值在靠近0的区域，即处于激活函数的线性区域，不利于训练非线性神经网络，从而得到效果较差的模型。<br>因此添加两个可学习的参数$\gamma$和$\beta$，对标准化后的数据进行缩放和平移。</p><p>$$<br>\tilde{Z}^{(i)} = \gamma Z_{norm}^{(i)}+\beta<br>$$</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%89%B9%E6%A0%87%E5%87%86%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="批标准化过程"></p><p>批标准化优化训练过程的原理：</p><p>数据的分布会随着不同数据集改变。<br>网络的参数会因训练集数据分布的变化而变化；测试的数据分布与训练集的数据分布不同，也会导致准确性下降。</p><p>批标准化的作用就是减小了数据分布的变化带来的影响，让模型更健壮，鲁棒性更强。<br>即使输入的值改变，由于批标准化的作用，均值和方差的变化会被消除，后续的学习更加容易。<br>批标准化减少了各层W和b之间的耦合性，让各层更加独立，实现自我训练学习的效果</p><p>批标准化也起到微弱的正则化效果，但是不能将批标准化作为正则化的手段，而是当作加速学习的方式。<br>批标准化 主要解决的还是反向传播过程中的梯度问题（梯度消失和爆炸）。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DL笔记1|神经网络和深度学习</title>
      <link href="/posts/deep_learning_1.html"/>
      <url>/posts/deep_learning_1.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、深度学习概论">一、深度学习概论</h2><h3 id="1-1-什么是深度学习">1.1 什么是深度学习</h3><p>简单来说，深度学习（Deep Learning）就是更复杂的神经网络（Neural Network）</p><p>人工神经网络包含：输入层、隐藏层、输出层，每层包含多个神经元，每个神经元包含激活函数</p><p>神经网络需要从大量的数据中学习，学习的过程就是调整网络中的参数，使得网络的输出结果与实际结果尽可能接近。</p><p>学习的目标是，建立起一个特殊的函数，输入一些数据就能输出想要的结果。</p><h3 id="1-2-深度学习的应用">1.2 深度学习的应用</h3><p>监督学习（Supervised Learning）与无监督学习本质区别就是：训练样本是否已知的输出y</p><p>不同的任务通常交给不同的神经网络：</p><ul><li>分类/回归任务：神经网络（Neural Network, NN）</li><li>图像识别任务：卷积神经网络（Convolutional Neural Network, CNN）</li><li>文本/语音等序列任务：循环神经网络（Recurrent Neural Network, RNN）</li><li>生成任务：生成对抗网络（Generative Adversarial Network, GAN）</li></ul><p>机器学习应用于结构化数据（Structured Data）和非结构化数据（Unstructured Data）</p><ul><li>结构化数据：数据的数据库，意味着每个特征都有清晰的定义，比较容易理解。</li><li>非结构化数据：通常指的是比较抽象的数据，比如音频、原始音频、图像、文本。</li></ul><p>正是因为神经网络，计算机现在能更好地解释非结构化数据，甚至在某些方面优于人类。例如，语音识别，图像识别，自然语音处理等。</p><h3 id="1-3-深度学习的优点">1.3 深度学习的优点</h3><p>深度学习兴起的原因：数据（Data）、计算（Computation）、算法（Algorithm）</p><p>深度学习的优点：</p><ul><li>不需要人工处理设计特征，只需通过神经网络输出结果</li><li>更适用于难提取特征的任务：图像、语音、自然语言处理</li><li>能够应对处理更大规模数据</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/data_performance.jpeg" alt="性能随数据量增大的变化"></p><h2 id="二、神经网络基础">二、神经网络基础</h2><h3 id="2-1-逻辑回归（Logistic-Regression-LR）">2.1 逻辑回归（Logistic Regression, LR）</h3><p>逻辑回归是一种用于解决二分类问题的分类算法，给定一个输入x，输出y=1的预测概率 $\hat{y}=P(y=1|x)$</p><p>记输入层特征数$n$，参数：</p><ul><li>输入$x \in R^{n}$，x是一个n维的特征向量</li><li>权重$w \in R^{n}$，w是一个n维的权重向量</li><li>标签$y \in {0,1}$，y是一个二分类标签</li><li>偏置$b \in R$，b是一个标量</li><li>输出$\hat{y} = \sigma(w^{T}x+b)=\sigma(w_1x_1+w_2x_2+…+w_nx_n+b)$<ul><li>激活函数：Sigmoid函数：$\sigma(t)=\dfrac{1}{1+e^{-t}}$</li><li>t非常大时，s接近1；t非常小时，s接近0；t=0时，s等于0.5</li></ul></li></ul><h3 id="2-2-与梯度下降算法（Gradient-Descent）">2.2 与梯度下降算法（Gradient Descent）</h3><p>通过迭代更新参数w和b，使成本函数$J(w,b)$找到最小值（损失函数和成本函数见2.7）</p><p>梯度下降算法：函数的梯度（gradient）指出了函数的最陡增长方向。梯度的方向走，函数增长得就越快。那么按梯度的负方向走，函数值自然就降低得最快了</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%9B%BE.png" alt="损失函数图"></p><p>参数更新：</p><ul><li>$w:=w-\alpha \dfrac{\partial J(w,b)}{\partial w}$</li><li>$b:=b-\alpha \dfrac{\partial J(w,b)}{\partial b}$</li><li>$\alpha$：学习率（Learning Rate），控制参数更新的步长，太大会导致震荡，太小会导致收敛速度慢</li></ul><h3 id="2-3-逻辑回归的梯度下降">2.3 逻辑回归的梯度下降</h3><p>以2维样本 $x_1,x_2$ 为例，参数$w_1,w_2,b$，计算梯度下降</p><p>已知：<br>$$<br>\begin{split}<br>&amp;z = w_1x_1+w_2x_2+b \\<br>&amp;记 a = \hat{y} = \sigma(z) \\<br>&amp;J(a,y) = -y\log(a)-(1-y)\log(1-a) \\<br>\end{split}<br>$$</p><p>计算J对z的导数：</p><p>$$<br>\begin{split}<br>&amp;\frac{\partial J}{\partial a} = \frac{-y}{a}+\frac{1-y}{1-a} \\<br>&amp;\frac{\partial a}{\partial z} = a(1-a) \\<br>&amp;dz = \frac{\partial J}{\partial a} \cdot \frac{\partial a}{\partial z} = a-y<br>\end{split}<br>$$</p><p>这样可以求出总损失相对于$w_1,w_2,b$的导数</p><ul><li>$dw_1 = \frac{\partial J}{\partial z} \cdot \frac{\partial z}{\partial w_1} = x_1(a-y)$</li><li>$dw_2 = \frac{\partial J}{\partial z} \cdot \frac{\partial z}{\partial w_2} = x_2(a-y)$</li><li>$db = \frac{\partial J}{\partial z} \cdot \frac{\partial z}{\partial b} = a-y = dz$</li></ul><p>然后更新参数：</p><ul><li>$w_1:=w_1-\alpha dw_1$</li><li>$w_2:=w_2-\alpha dw_1$</li><li>$b:=b-\alpha dw_1$</li></ul><h3 id="2-4-前向传播和反向传播">2.4 前向传播和反向传播</h3><ul><li>前向传播：从前往后计算梯度和损失的过程</li><li>反向传播：从后往前计算参数的更新梯度值</li></ul><h3 id="2-5-向量化-逻辑回归实现">2.5 向量化/逻辑回归实现</h3><p>向量化编程的优点：多样本下，向量计算比循环计算快的多，代码更简洁</p><ol><li>输入层$X$：形状$n \times m$，$n$为特征数，$m$为样本数</li><li>权重参数$W$：形状$n \times 1$</li><li>偏置参数$b$：标量</li><li>输出层$Z$：$Z=W^{T}X+b$，形状$(1,n) \times (n,m) + b = (1,m)$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>  <span class="comment"># 特征数</span></span><br><span class="line">m = <span class="number">100</span>  <span class="comment"># 样本数</span></span><br><span class="line">alpha = <span class="number">0.001</span>  <span class="comment"># 学习率</span></span><br><span class="line">iterations = <span class="number">1000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line"></span><br><span class="line">X = np.random.randn(n, m)  <span class="comment"># 生成特征矩阵</span></span><br><span class="line">Y = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, [<span class="number">1</span>, m])  <span class="comment"># 生成标签</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>  <span class="comment"># 损失函数值</span></span><br><span class="line"></span><br><span class="line"> 初始化权重和偏置</span><br><span class="line">W = np.random.randn(n, <span class="number">1</span>) * <span class="number">0.01</span></span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">t</span>): <span class="comment"># Sigmoid函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-t))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_loss</span>(<span class="params">A, Y</span>):  <span class="comment"># 对数损失函数</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> / m * np.<span class="built_in">sum</span>(Y * np.log(A) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - A))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_accuracy</span>(<span class="params">A, Y</span>):  <span class="comment"># 计算准确率</span></span><br><span class="line">    A = np.where(A &gt; <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> np.mean(A == Y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    Z = np.dot(W.T, X) + b</span><br><span class="line">    A = sigmoid(Z)  <span class="comment"># 激活值（预测）</span></span><br><span class="line">    J = log_loss(A, Y)  <span class="comment"># 计算损失函数值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    <span class="comment"># 计算梯度</span></span><br><span class="line">    dZ = A - Y</span><br><span class="line">    dW = <span class="number">1</span> / m * np.dot(X, dZ.T) <span class="comment"># 1/m * X * dZ</span></span><br><span class="line">    db = <span class="number">1</span> / m * np.<span class="built_in">sum</span>(dZ) <span class="comment"># 1/m * dZ</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新权重和偏置</span></span><br><span class="line">    W = W - alpha * dW</span><br><span class="line">    b = b - alpha * db</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loss:&quot;</span>, J)  <span class="comment"># 打印损失函数值</span></span><br><span class="line"></span><br><span class="line"> 训练集上的准确率</span><br><span class="line">Z = np.dot(W.T, X) + b</span><br><span class="line">A = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-Z))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy:&quot;</span>, calc_accuracy(A, Y))</span><br></pre></td></tr></table></figure><h3 id="2-6-激活函数（Activation-Function）">2.6 激活函数（Activation Function）</h3><p>涉及到网络的优化时候，会有不同的激活函数选择。<br>有一个问题是神经网络的隐藏层和输出单元用什么激活函数。<br>在逻辑回归中选用了Sigmoid函数，但有时其他函数的效果会好得多。<br>大多数结论通过实践得来，没有很好的解释性。</p><p>为什么使用非线性的激活函数：使用线性函数，在这一层上的神经元的输出仅仅是输入的线性组合，失去了效果。</p><p>$$a^{[1]} = W^{[1]}x+b^{[1]}$$</p><p>$$<br>\begin{align}<br>b^{[1]} &amp;= W^{[2]}a^{[1]}+b^{[2]} \\<br>&amp;= W^{[2]}(W^{[1]}x+b^{[1]})+b^{[2]} \\<br>&amp;= (W^{[2]}W^{[1]})x+(W^{[2]}b^{[1]}+b^{[2]}) \\<br>&amp;= Wx+b<br>\end{align}<br>$$</p><p>本节提及的几种常用激活函数：Sigmoid函数、tanH函数、ReLU函数</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0.png" alt="激活函数"></p><p>Sigmoid函数</p><p>$$<br>\begin{split}<br>&amp;\sigma(t)=\dfrac{1}{1+e^{-t}} \\<br>&amp;\sigma’(t)=\sigma(t)(1-\sigma(t)) \\<br>&amp;t\in(-\infty,+\infty), \sigma(t)\in(0,1)<br>\end{split}<br>$$</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/Sigmoid%E5%87%BD%E6%95%B0.png" alt="Sigmoid函数"></p><p>双曲正切函数（Hyperbolic Tangent, tanH）</p><p>效果比Sigmoid函数好，因为函数输出在(-1,1)之间，收敛速度更快</p><p>存在和Sigmoid函数一样的缺点：当t趋紧无穷，导数的梯度（即函数的斜率）就趋紧于 0，这使得梯度算法的速度会减慢。</p><p>$$<br>\begin{split}<br>&amp;tanh(t)=\dfrac{e^{t}-e^{-t}}{e^{t}+e^{-t}} \\<br>&amp;tanh’(t)=1-tanh^2(t)<br>\end{split}<br>$$</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/tanH%E5%87%BD%E6%95%B0.png" alt="tanH函数"></p><p>ReLU函数：修正线性单元（Rectified Linear Unit, ReLU）</p><p>当 $t&gt;0$ 时，梯度始终为1，从而提高神经网络基于梯度算法的运算速度，收敛速度远大于Sigmoid和tanH函数</p><p>$$<br>\begin{split}<br>&amp;f(t)=max(0,t) \\<br>&amp;f’(t)=\begin{cases}<br>0 &amp; \text{if } t&lt;0 \\<br>1 &amp; \text{if } t \geq 0<br>\end{cases}<br>\end{split}<br>$$</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/ReLU%E5%87%BD%E6%95%B0.png" alt="ReLU函数"></p><h3 id="2-7-损失函数（Loss-Function）与成本函数（Cost-Function）">2.7 损失函数（Loss Function）与成本函数（Cost Function）</h3><p>损失函数用于衡量预测结果与真实值之间的误差。</p><p>平方差损失函数：$L(\hat{y},y)=\frac{1}{2}(\hat{y}-y)^2$</p><ul><li>最简单的损失函数</li><li>具有多个局部最小值，不适合逻辑回归</li></ul><p>对数损失函数：$L(\hat{y},y)=-(y\log(\hat{y})+(1-y)\log(1-\hat{y}))$</p><ul><li>逻辑回归通常采用的损失函数</li><li>y=1时，损失函数为$-log(\hat{y})$，$\hat{y}$越大，损失越小</li><li>y=0时，损失函数为$log(1-\hat{y})$，$\hat{y}$越小，损失越小</li></ul><p>损失函数：衡量了在单个训练样本上的表现</p><p>成本函数（Cost Function）：$J(w,b)=\dfrac{1}{m}\sum\limits_{i=1}^{m}L(\hat{y}^{(i)},y^{(i)})$</p><ul><li>所有训练样本的损失平均值</li><li>衡量在全体训练样本上的表现、参数w和b的效果</li></ul><h2 id="三、浅层神经网络">三、浅层神经网络</h2><h3 id="3-1-浅层神经网络">3.1 浅层神经网络</h3><p>神经网络（Neural Network, NN）是一种模拟人脑神经元工作方式的计算模型，包含输入层、隐藏层、输出层，每层包含多个神经元</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png" alt="浅层神经网络"></p><p>以上图（单隐藏层神经网络）为例，输入层有$n=3$个特征，隐藏层一层，有$4$个神经元。记隐藏层 $[1]$ ，输出层 $[2]$ ，则：</p><ul><li>输入层：$x \in R^{3}$，$x$是一个$3$维的特征向量<ul><li>形状：(3, m)，$m$为样本数</li></ul></li><li>隐藏层具有4行3列的权重矩阵$W^{[1]} \in R^{4 \times 3}$，偏置向量$b^{[1]} \in R^{4}$<ul><li>隐藏层的每个神经元$i$具有权重$W^{[1]}<em>{i} \in R^{3}$，偏置$b^{[1]}</em>{i} \in R$</li><li>形状：输入(3, m) * 权重(4, 3) + 偏置(4, 1) = 输出(4, m)</li></ul></li><li>输出层具有1行4列的权重矩阵$W^{[2]} \in R^{1 \times 4}$，偏置$b^{[2]} \in R$<ul><li>形状：输入(4, m) * 权重(1, 4) + 偏置(1, 1) = 输出(1, m)、</li></ul></li></ul><p>总结：第i层的权重矩阵$W^{[i]}$的形状为$(n^{[i]}, n^{[i-1]})$，偏置$b^{[i]}$的形状为$(n^{[i]}, 1)$</p><h3 id="3-2-前向传播">3.2 前向传播</h3><p>$$<br>\begin{split}<br>&amp;Z^{[1]} = W^{[1]}X+b^{[1]} \\<br>&amp;A^{[1]} = tanh(Z^{[1]}) \\<br>&amp;Z^{[2]} = W^{[2]}A^{[1]}+b^{[2]} \\<br>&amp;A^{[2]} = \sigma(Z^{[2]})<br>\end{split}<br>$$</p><h3 id="3-3-反向传播">3.3 反向传播</h3><p>输出层以Sigmoid函数作为激活函数，根据<a href="#14-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D">逻辑回归的梯度下降</a>的推导，可以得到：</p><p>$$<br>\begin{split}<br>&amp;dZ^{[2]} = A^{[2]}-Y \\<br>&amp;dW^{[2]} = \dfrac{1}{m}dZ^{[2]}A^{[1]T} \\<br>&amp;db^{[2]} = \dfrac{1}{m}np.sum(dZ^{[2]}, axis=1)<br>\end{split}<br>$$</p><p>隐藏层以tanh函数作为激活函数，已知：</p><p>$$<br>\begin{split}<br>&amp;tanh’(t) = 1-tanh^2(t) \\<br>&amp;Z^{[1]} = W^{[1]}X+b^{[1]} \\<br>&amp;A^{[1]} = tanh(Z^{[1]}) \\<br>&amp;J(A^{[2]},Y) = -Y\log(A^{[2]})-(1-Y)\log(1-A^{[2]})<br>\end{split}<br>$$</p><p>根据链式求导法则（步骤略），可以得到：</p><p>$$<br>\begin{split}<br>&amp;dZ^{[1]} = \frac{\partial J}{\partial A^{[2]}} \cdot \frac{\partial A^{[2]}}{\partial Z^{[2]}} \cdot \frac{\partial Z^{[2]}}{\partial A^{[1]}} \cdot \frac{\partial A^{[1]}}{\partial Z^{[1]}} = W^{[2]T}dZ^{[2]} \cdot (1-A^{[1]2}) \\<br>&amp;dW^{[1]} = \dfrac{1}{m}dZ^{[1]}X^T \\<br>&amp;db^{[1]} = \dfrac{1}{m}np.sum(dZ^{[1]}, axis=1)<br>\end{split}<br>$$</p><h3 id="实践：浅层神经网络实现">实践：浅层神经网络实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>  <span class="comment"># 特征数</span></span><br><span class="line">m = <span class="number">100</span>  <span class="comment"># 样本数</span></span><br><span class="line">k = <span class="number">4</span>  <span class="comment"># 隐藏层神经元数</span></span><br><span class="line">alpha = <span class="number">0.001</span>  <span class="comment"># 学习率</span></span><br><span class="line">iterations = <span class="number">1000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line"></span><br><span class="line">X = np.random.randn(n, m)  <span class="comment"># 生成特征矩阵</span></span><br><span class="line">Y = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, [<span class="number">1</span>, m])  <span class="comment"># 生成标签</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">0</span>  <span class="comment"># 损失函数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐藏层权重和偏置（随机初始化）</span></span><br><span class="line">W1 = np.random.randn(k, n) * <span class="number">0.01</span></span><br><span class="line">b1 = np.zeros([k, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出层权重和偏置</span></span><br><span class="line">W2 = np.random.randn(<span class="number">1</span>, k) * <span class="number">0.01</span></span><br><span class="line">b2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">t</span>): <span class="comment"># Sigmoid函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-t))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">t</span>): <span class="comment"># tanH函数</span></span><br><span class="line">    <span class="keyword">return</span> (np.exp(t) - np.exp(-t)) / (np.exp(t) + np.exp(-t))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_loss</span>(<span class="params">A, Y</span>):  <span class="comment"># 对数损失函数</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> / m * np.<span class="built_in">sum</span>(Y * np.log(A) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - A))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_accuracy</span>(<span class="params">A, Y</span>):  <span class="comment"># 计算准确率</span></span><br><span class="line">    A = np.where(A &gt; <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> np.mean(A == Y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    Z1 = np.dot(W1, X) + b1 <span class="comment"># [k, m]</span></span><br><span class="line">    A1 = tanh(Z1)  <span class="comment"># 隐藏层激活值 [k, m]</span></span><br><span class="line">    Z2 = np.dot(W2, A1) + b2 <span class="comment"># [1, m]</span></span><br><span class="line">    A2 = sigmoid(Z2)  <span class="comment"># 输出层激活值（预测） [1, m]</span></span><br><span class="line">    J = log_loss(A2, Y)  <span class="comment"># 计算损失函数值 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    <span class="comment"># 输出层</span></span><br><span class="line">    dZ2 = A2 - Y <span class="comment"># [1, m]</span></span><br><span class="line">    dW2 = <span class="number">1</span> / m * np.dot(dZ2, A1.T) <span class="comment"># [1, k]</span></span><br><span class="line">    db2 = <span class="number">1</span> / m * np.<span class="built_in">sum</span>(dZ2) <span class="comment"># [1, 1]</span></span><br><span class="line">    <span class="comment"># 隐藏层</span></span><br><span class="line">    dZ1 = np.dot(W2.T, dZ2) * (<span class="number">1</span> - A1 ** <span class="number">2</span>)</span><br><span class="line">    dW1 = <span class="number">1</span> / m * np.dot(dZ1, X.T)</span><br><span class="line">    db1 = <span class="number">1</span> / m * np.<span class="built_in">sum</span>(dZ1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新权重和偏置</span></span><br><span class="line">    W1 = W1 - alpha * dW1</span><br><span class="line">    b1 = b1 - alpha * db1</span><br><span class="line">    W2 = W2 - alpha * dW2</span><br><span class="line">    b2 = b2 - alpha * db2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loss:&quot;</span>, J)  <span class="comment"># 打印损失函数值</span></span><br><span class="line"></span><br><span class="line"> 训练集上的准确率</span><br><span class="line">Z1 = np.dot(W1, X) + b1</span><br><span class="line">A1 = tanh(Z1)</span><br><span class="line">Z2 = np.dot(W2, A1) + b2</span><br><span class="line">A2 = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-Z2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy:&quot;</span>, calc_accuracy(A2, Y))</span><br></pre></td></tr></table></figure><h2 id="四、深层神经网络">四、深层神经网络</h2><h3 id="4-1-深层神经网络">4.1 深层神经网络</h3><p>为什么需要深层神经网络：</p><ul><li>神经网络从第一层开始，从原始数据中提取特征</li><li>下一层将上一层习得的信息组合起来，形成更高级的特征</li><li>随着层数增多，特征从简单到复杂，学习的能力更强</li></ul><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.jpeg" alt="深层神经网络"></p><h3 id="4-2-前向传播">4.2 前向传播</h3><p>$$<br>\begin{split}<br>&amp;x=a^{[0]} \\<br>&amp;z^{[L]}=W^{[L]}a^{[L-1]}+b^{[L]} \\<br>&amp;a^{[L]}=g^{[L]}(z^{[L]})<br>\end{split}<br>$$</p><p>输入$a^{[L-1]}$，输出$a^{[L]}$</p><h3 id="4-3-反向传播">4.3 反向传播</h3><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD.png" alt="深层神经网络反向传播"></p><p>$$<br>\begin{split}<br>&amp;dZ^{[L]} = \frac{\partial J}{\partial A^{[L]}} \cdot \frac{\partial A^{[L]}}{\partial Z^{[L]}} = dA^{[L]} \cdot g^{[L]'}(Z^{[L]}) \\<br>&amp;dW^{[L]} = \frac{\partial J}{\partial Z^{[L]}} \cdot \frac{\partial Z^{[L]}}{\partial W^{[L]}} = \frac{1}{m}dZ^{[L]}A^{[L-1]T} \\<br>&amp;db^{[L]} = \frac{1}{m}np.sum(dZ^{[L]}, axis=1) \\<br>&amp;dA^{[L]} = W^{[L+1]T}dZ^{[L+1]}<br>\end{split}<br>$$</p><h3 id="4-4-参数和超参数">4.4 参数和超参数</h3><p>参数（Parameters）：在训练过程中希望模型学习到的信息，模型自己调整的参数</p><ul><li>权重W通常使用随机初始化，避免对称性，$randn*0.01$<ul><li>对称性：如果所有的神经元都具有相同的权重，那么在反向传播过程中，所有的神经元都会学习到相同的特征</li><li>乘系数0.01：使用Sigmoid函数或者tanH函数作为激活函数时，W比较小，则Z=WX+b所得的值趋近于0，梯度较大，能够提高算法的更新速度；ReLU函数则没有这个问题</li></ul></li><li>偏置b没有对称性问题，通常初始化为0</li></ul><p>超参数（Hyper parameters）：通过人的经验判断、手动调整的网络信息，会影响最终的参数</p><ul><li>典型的超参数：学习速率$\alpha$、迭代次数$N$、隐藏层数$L$、每层神经元数$n_i$、激活函数$g^{[i]}()$的选择</li><li>开发新应用时，很难预先准确知道最佳的超参数，需要通过不同的尝试和调整来找到最佳的超参数</li></ul><h2 id="五、多分类与Softmax回归">五、多分类与Softmax回归</h2><h3 id="5-1-Softmax回归">5.1 Softmax回归</h3><p>对于多分类问题，种类个数C，则输出层的神经元个数必须为C，每个神经元的输出依次对应为每个类别的概率。</p><p><img src="https://source.cclmsy.cc/Posts/DL/Note/%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98.png" alt="多分类问题"></p><p>输出层：$Z^{[L]}=W^{[L]}A^{[L-1]}+b^{[L]}$$</p><p>Softmax公式：$a_i^{[L]} = \dfrac{e^{Z_i^{[L]}}}{\sum\limits_{j=1}^{C}e^{Z_j^{[L]}}}$，满足$\sum\limits_{i=1}^{C}a_i^{[L]}=1$</p><p>理解：$e^{z_i}$的占比</p><h3 id="5-2-交叉熵损失与One-hot编码">5.2 交叉熵损失与One-hot编码</h3><p>对于Softmax回归，使用交叉熵损失（Cross Entropy Loss）函数：</p><p>$$<br>L(\hat{y},y)=-\sum\limits_{i=1}^{C}y_i\log(\hat{y}_i)<br>$$</p><p>$C=2$时，即对应逻辑回归的对数损失函数$L(\hat{y},y)=-(y\log(\hat{y})+(1-y)\log(1-\hat{y}))$</p><p>one-hot编码（独热编码）：将标签转换为向量，只有一个元素为1，其他元素为0。</p><p>以图2.1.1为例，$y=7$，则one-hot编码对应为$y=[0,0,0,0,0,0,0,1,0,0]$。</p><p>由于除了正确类别外，其他类别$y_i=0$，因此可以简单计算交叉熵：$L(\hat{y},y)=-1\times\log(0.10)$</p><p>这一项的预测值越接近1，交叉熵越接近0，模型效果越好</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ST表</title>
      <link href="/posts/st.html"/>
      <url>/posts/st.html</url>
      
        <content type="html"><![CDATA[<h2 id="ST表">ST表</h2><p>实现的功能：固定数组询问区间最值RMQ/区间GCD</p><p>原数组v下标从0开始；ST表下标从1开始，首元素为0</p><p>洛谷模板题：<a href="https://www.luogu.com.cn/problem/P3865">Luogu P3865</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ST表</span></span><br><span class="line"><span class="comment">// 实现的功能：固定数组 区间最值询问RMQ/区间GCD</span></span><br><span class="line"><span class="comment">// 下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SparseTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt; a; <span class="comment">// 原数组</span></span><br><span class="line">    vector&lt;vector&lt;T&gt;&gt; st; <span class="comment">// st[i][j]表示[i,i+2^j-1]的最值</span></span><br><span class="line">    <span class="function">T <span class="title">op</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">max</span>(a, b); &#125; <span class="comment">// 可选：max,min,__gcd</span></span><br><span class="line">    <span class="built_in">SparseTable</span>(vector&lt;T&gt; _v)&#123;</span><br><span class="line">        a = _v;</span><br><span class="line">        n = a.<span class="built_in">size</span>();</span><br><span class="line">        st.<span class="built_in">resize</span>(n+<span class="number">5</span>);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">log2</span>(n)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) st[i].<span class="built_in">resize</span>(<span class="number">21</span>, <span class="number">0</span>); <span class="comment">// n&lt;=2e6开21</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) st[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)&#123;</span><br><span class="line">            <span class="type">int</span> len = (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; i++)&#123;</span><br><span class="line">                st[i][j] = <span class="built_in">op</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);<span class="comment">//已向下取整</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">op</span>(st[l][j], st[r - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v) cin &gt;&gt; i;</span><br><span class="line">    <span class="function">SparseTable&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">query</span>(l<span class="number">-1</span>, r<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络与通信》课程笔记</title>
      <link href="/posts/computer_networks_and_communications.html"/>
      <url>/posts/computer_networks_and_communications.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述">一、概述</h2><p>因特网服务提供者 ISP(Internet Service Provider)</p><p>ARPANET：最早的因特网，1969年，使用分组交换技术，后来TCP/IP协议成为标准协议</p><p>互联网的组成：边缘（用户）+核心（路由器、链路）</p><p>两种通信方式：客户-服务器方式 C/S(Client/Server)、对等方式 P2P(Peer-to-Peer)</p><p>三种交换方式：电路交换、分组交换、报文交换</p><ul><li>电路交换：面向连接<ul><li>三阶段：建立连接、通信、释放连接</li></ul></li><li>分组交换<ul><li>可以无连接也可以面向连接</li><li>划分成较短的、固定长度的数据段</li><li>存储转发</li></ul></li><li>报文交换<ul><li>存储转发传输整个报文</li></ul></li></ul><p>时延=传输时延+处理时延+排队时延+传播时延</p><ul><li>发送时延：数据块长度/发送速率</li><li>处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间</li><li>排队时延：结点缓存队列中分组排队所经历的时延</li><li>传播时延：信号在传输媒体上传播所需的时间（取决于信道距离）<ul><li>传输速率可以提高，但传播速率是物理特性决定的</li></ul></li></ul><p>时延带宽积：传播时延与带宽的乘积，链路上最大的比特数量</p><p>信道利用率：信道被利用的时间占比，非越高越好</p><p>网络利用率U：信道利用率加权平均值</p><p>$当前时延D=\dfrac{空闲时延D_0}{1-U}$</p><p>网络协议三要素：语法、语义、时序</p><p>实体(Entity)：任何可发送或接收信息的硬件或软件进程</p><p>协议(Protocol)：控制对等实体之间的通信的规则集</p><p>第n层协议向第n+1层提供服务，是第n-1层的用户</p><h3 id="OSI-TCP-IP">OSI/TCP-IP</h3><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/1_1.png" alt="OSI和TCP/IP"></p><h2 id="二、物理层">二、物理层</h2><p>主要任务：确定与传输媒体的接口的一些特性，包括：机械特性、电气特性、功能特性、过程特性</p><p>数据通信系统可划分为三大部分：源系统(发送端)、传输系统(传输网络)、目的系统(接收端)。</p><p>信道(channel)分类：单工通信（只能单向传输）、半双工通信（双向传输但不能同时）、全双工通信（双向传输且可以同时）</p><p>导引型传输媒体：双绞线、同轴电缆、光纤</p><p>非导引型传输媒体：无线电波、微波、红外线</p><p>宽带接入技术：非对称数字用户线ADSL(Asymmetric Digital Subscriber Line)、光纤同轴混合网HFC(Hybrid Fiber Coax)、光纤到…FTTx(Fiber To The x)</p><h3 id="2-1-调制">2.1 调制</h3><p>基本带通调制方式：调幅AM、调频FM、调相PM</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/2_2.png" alt="基本带通调制方式"></p><p>一种多元制的振幅相位混合调制方法：正交振幅调制(Quadrature Amplitude Modulation，QAM)</p><ul><li>可供选择的相位有12种，而对于每一种相位有1或2种振幅可供选择。</li><li>共有16种不同的组合，每种组合可以用4bit二进制数表示，因此这16个点中的每个点可对应于一种4bit的编码。</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/2_3.png" alt="正交振幅调制">、</p><h3 id="2-2-信道极限容量">2.2 信道极限容量</h3><p>奈氏准则-奈奎斯特：在带宽为W(Hz)的低通信道中，若不考虑噪声影响，则码元传输的最高速率是2W(码元/秒 波特Baud)</p><p>信噪比(Signal-to-Noise Ratio, SNR)：信号功率与噪声功率之比</p><p>$SNR=10\log_{10}(\dfrac{S}{N})$(单位：dB)</p><p>香农定理：$C=W\log_2(1+\dfrac{S}{N})$(单位：bps)</p><p>W为信道的带宽(Hz)，S为信道内所传信号的平均功率(数据传输速率=码元传输速率*码元携带的比特数)，N为信道内部的高斯噪声功率</p><h4 id="信道极限容量例题">信道极限容量例题</h4><ol><li>信道带宽为3000Hz，信噪比为30dB，则最大数据速率为多少？<ul><li>根据信噪比公式，$SNR=10log_{10}(\frac{S}{N})=30dB \Rightarrow \frac{S}{N}=10^3$</li><li>根据香农公式，$C=W\log_2(1+\frac{S}{N})=3000\log_2(1+10^3) \approx 3000\times9.97 \approx 30000bps$</li></ul></li><li>下列因素中,不会影响信道数据传输率的是( )<ul><li>A. 信噪比 B. 频率宽带 C. 调制速率 D. 信号传播速度</li><li>A：$\frac{S}{N}$, B：W, C：S的因子, D：不影响</li></ul></li><li>若信道在无噪声情况下的极限数据传输速率不小于信噪比为30dB条件下的极限数据传输速率，则信号状态数至少是？<ul><li>记信道带宽为W，一个码元所占位数k。</li><li>根据信噪比公式，$SNR=10log_{10}(\frac{S}{N})=30dB \Rightarrow \frac{S}{N}=10^3$</li><li>根据奈氏准则和香农公式：$2W\times k \ge W\log_2(1+10^3) \Rightarrow 2k \ge \log_2(1+10^3)\approx 10 \Rightarrow k \ge 5$</li><li>状态数至少是$2^5=32$</li></ul></li></ol><h3 id="2-3-信道复用技术">2.3 信道复用技术</h3><ul><li>复用器(multiplexer)：复用开始前，多个低速信道合成一个高速信道的设备</li><li>分用器(de-multiplexer)：复用结束后，将高速信道分解为多个低速信道的设备</li></ul><p><strong>频分复用FDM</strong>(Frequency Division Multiplexing)：将频带分成若干窄带，各路信号分别搬移到适当的频率位置，彼此互不干扰。<br>频分复用的所有用户在同样的时间占用不同的带宽资源，这里的“带宽”是频率带宽而不是数据的发送速率。</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/2_4.png" alt="频分复用"></p><p><strong>时分复用TDM</strong>(Time Division Multiplexing)：将时间分成若干时隙，每个时隙用来传输一个信号，然后把这些时隙信号叠加在一起传输。<br>时分复用可能会造成线路资源的浪费，解决方法：统计时分复用STDM（Statistical TDM）</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/2_5.png" alt="时分复用"></p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/2_6.png" alt="时分复用可能会造成线路资源的浪费"></p><p><strong>波分复用WDM</strong>(Wavelength Division Multiplexing)：光的频分复用，使用一根光纤来同时传输多个光载波信号。</p><p><strong>码分多址CDMA</strong>(Code Division Multiple Access)：多个不同地址的用户共享码分复用(CDM, Code Division Multiplexing)信道。</p><p>码片(chip)：每一个比特时间划分为m个短的间隔，称为</p><p>码片序列：每个站被指派一个唯一的m bit码片序列</p><p>以$S=00011011, T=00101110$为例</p><ul><li>S发送1：发送码片序列$S=00011011$</li><li>S发送0：发送码片序列的反码$S_x=11100100$</li><li>按照惯例，1记为+1，0记为-1，码片序列S为-1 -1 -1 +1 +1 -1 +1 +1</li><li>码片特点：<ul><li>规格化内积$S\cdot S=\frac{1}{m}\sum_{i=1}^{m}S_iS_i=1$</li><li>规格化内积$S\cdot S_x=\frac{1}{m}\sum_{i=1}^{m}S_iS_{xi}=-1$</li></ul></li></ul><p>CDMA的重要特点</p><ul><li>每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(规格化内积为0)<ul><li>S和T正交：$S\cdot T=\frac{1}{m}\sum_{i=1}^{m}S_iT_i=0$</li></ul></li><li>在实用的系统中是使用伪随机码序列</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/2_7.png" alt="码分复用"></p><h2 id="三、数据链路层">三、数据链路层</h2><p>数据链路(data link)：除了物理线路外，还必须有通信协议来控制这些数据的传输。<br>数据链路由物理链路和实现这些协议的硬件和软件构成。</p><p>数据链路层使用的信道：点对点信道、广播信道</p><p>数据链路层的三个基本问题：封装成帧、透明传输、差错检测</p><ol><li>封装成帧：在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，确定帧的界限。</li><li>透明传输：使数据链路层的协议对上层是透明的，网络层不必关心数据链路层的具体实现。</li><li>差错检测：在传输过程中可能会产生比特差错，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施</li></ol><p>使用载波监听多点接入/碰撞检测协议CSMA/CD的以太网不能进行全双工通信而只能进行双向交替通信(半双工通信)</p><ul><li>多点接入CSMA：许多计算机以多点接入的方式连接在一根总线上</li><li>碰撞检测CD：每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞</li></ul><h3 id="3-1-循环冗余校验CRC">3.1 循环冗余校验CRC</h3><p>循环冗余校验CRC(Cyclic Redundancy Check)是一种差错检测方法，通过在数据末端添加冗余位，确定数据是否在传输过程中发生变化。</p><p>模二运算：一种不考虑进位的二进制按位运算。</p><ul><li>加法/减法：相加减而不考虑进位/借位，即二进制按位异或运算</li><li>乘法：列竖式，逐位相乘，按位异或</li><li>除法：列竖式，商上余数的首位，按位相减</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/3_2.png" alt="模二乘法"><br><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/3_3.png" alt="模二除法"></p><p>CRC冗余码的计算和校验：</p><ol><li>原始二进制数据$M=1100$</li><li>将原始数据左移$r=3$位（冗余位位数）得到$M\times 2^r=1100|000$</li><li>约定一个$r+1=4$位生成多项式$G=1011$作为除数<ul><li>生成多项式的最高位和最低位都必须是1</li><li>当传输的数据X的任何一位发生错误时，被G除的余数不为0</li><li>数据X的不同位发生错误时，被G除的余数不同</li></ul></li><li>模二除法：$(M \times 2^r) \div G = Q \cdots R$<ul><li>$1100000 \div 1011 = 1110 \cdots 010$</li><li>商$Q=1100$，余数$R=010$</li><li>此时有$M \times 2^r = Q \times G + R$ 成立</li></ul></li><li>将余数R添加到原始数据M后面，得到传输的数据$X=1100|010$<ul><li>$M \times 2^r + R = Q \times G + R + R = Q \times G$</li></ul></li><li>接收端将接收到的数据X对G进行模二除法，若余数为0则无差错，否则有差错</li></ol><p>差错定位/纠正：</p><table><thead><tr><th style="text-align:center">X=A1~A7</th><th style="text-align:center">余数</th><th style="text-align:center">出错位</th></tr></thead><tbody><tr><td style="text-align:center">1100010</td><td style="text-align:center">010</td><td style="text-align:center">无差错</td></tr><tr><td style="text-align:center">110001<strong>1</strong></td><td style="text-align:center">001</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">11000<strong>0</strong>0</td><td style="text-align:center">000</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">1100<strong>1</strong>10</td><td style="text-align:center">110</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">110<strong>1</strong>010</td><td style="text-align:center">011</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">11<strong>1</strong>0010</td><td style="text-align:center">110</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1<strong>0</strong>0010</td><td style="text-align:center">111</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center"><strong>0</strong>10010</td><td style="text-align:center">101</td><td style="text-align:center">1</td></tr></tbody></table><h3 id="3-2-帧检验序列FCS">3.2 帧检验序列FCS</h3><p>帧检验序列FCS(Frame Check Sequence)是数据链路层的差错检测技术，用于检测数据在传输过程中是否发生了变化。</p><p>CRC和FCS的关系：CRC是一种常用的差错检测方法，而FCS是添加在数据后面的冗余码。FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法。</p><p>无差错接受：接收端对收到的每一帧进行CRC检验，若余数为0则无差错，接受，否则丢弃</p><p>码距：同一编码中，任意两个合法编码之间不同二进数位数的最小值。</p><ul><li>码距越大，抗干扰能力、纠错能力越强，数据冗余越大，编码效率越低</li><li>检错位数=码距//2，纠错位数=(码距-1)//2</li><li>特殊情况：码距=3，检错1纠错1，或检错2纠错0</li></ul><p>校验码中增加冗余项的目的就是为了增大码距</p><p>仅用循环冗余检验CRC差错检测技术只能做到无差错接受，要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。</p><ul><li>需要考虑的问题：帧重复、帧丢失、帧乱序</li><li>解决方法：帧编号、确认和重传</li></ul><p>OSI/RM模型的观点：数据链路层要做成无传输差错的。但这种理念目前不被接受</p><h3 id="3-2-点对点协议PPP">3.2 点对点协议PPP</h3><p>PPP是现在全世界使用的最多的数据链路层协议，用户使用拨号电话线接入互联网时，一般都是使用PPP协议。</p><p>PPP协议的组成部分（自下而上）：</p><ol><li>一个将IP数据报封装到串行链路的方法。既支持异步链路，也支持同步链路</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议LCP(Link Control Protocol)</li><li>一套网络控制协议NCP(Network Control Protocol)。允许在点到点连接上使用多种网络层协议</li></ol><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/3_5.png" alt="PPP协议的工作状态"></p><h4 id="PPP的帧格式">PPP的帧格式</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/3_4.png" alt="PPP的帧格式"></p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">长度</th><th style="text-align:center">值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">帧开始标志F</td><td style="text-align:center">1B</td><td style="text-align:center">01111110(0x7E)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">地址A</td><td style="text-align:center">1B</td><td style="text-align:center">11111111(0xFF)</td><td style="text-align:center">规定值，无作用</td></tr><tr><td style="text-align:center">控制C</td><td style="text-align:center">1B</td><td style="text-align:center">00000011(0x03)</td><td style="text-align:center">规定值，无作用</td></tr><tr><td style="text-align:center">协议P</td><td style="text-align:center">2B</td><td style="text-align:center">IP数据报：0x0021<br>PPP链路控制数据：0xC021<br>网络控制数据：0x8021</td><td style="text-align:center">表示上层协议类型</td></tr><tr><td style="text-align:center">信息字段</td><td style="text-align:center">0~1500B</td><td style="text-align:center">IP数据报等数据</td><td style="text-align:center">可变长度，不包括FCS</td></tr><tr><td style="text-align:center">帧校验序列FCS</td><td style="text-align:center">2B</td><td style="text-align:center">CRC校验码</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">帧结束标志F</td><td style="text-align:center">1B</td><td style="text-align:center">01111110(0x7E)</td><td style="text-align:center"></td></tr></tbody></table><h3 id="3-3-透明传输实现：字节填充和比特填充">3.3 透明传输实现：字节填充和比特填充</h3><p>PPP异步传输（逐字符）：字节填充</p><ul><li>字节填充转义符：0x7D</li><li>0x7E转义为0x7D 0x5E</li><li>0x7D转义为0x7D 0x5D</li><li>ASCII码小于0x20,+0x20转义。如0x03转义为0x7D 0x23</li></ul><p>字节填充例题：一个PPP帧的信息字段为 7E 7D 5E FE 27 7D 5D 7D 27 7E，求真正的信息字段</p><ul><li>标出转义字符：76 (7D 5E) FE 27 (7D 5D) (7D 27) 7E</li><li>字符转义：76 (7E) FE 27 (7D) (07) 7E</li></ul><p>PPP同步传输（逐比特位连续发送）：比特填充</p><ul><li>在发送端，只要发现有5个连续的1，则立即填入一个0</li><li>在接收端，只要发现有5个连续的1，且后面紧跟一个0，则删除这个0</li></ul><p>比特填充例题：若接收端收到的 PPP 的数据部分是0001110111110111110110 ，问删除发送端加入的零比特后变成怎样的比特串</p><ul><li>标出111110：0001110(111110)(111110)110</li><li>删除零比特：0001110(11111)(11111)110</li></ul><h3 id="3-4-使用广播信道的数据链路层">3.4 使用广播信道的数据链路层</h3><p>局域网拓扑结构</p><ul><li>总线网：所有站点共享一条总线。<ul><li>匹配电阻：避免总线有害电磁波反射</li></ul></li><li>星形网：所有站点都连接到一个中心站点。<ul><li>集线器：中心站点的功能是转发数据</li></ul></li><li>环形网：所有站点连接成一个环形。<ul><li>干线耦合器：环形网的数据传输方向是固定的（顺时针/逆时针）</li></ul></li></ul><p>媒体共享技术</p><ul><li>静态划分信道：TDM、FDM、WDM、CDM<ul><li>代价高，不适合局域网</li></ul></li><li>动态媒体接入控制（多点接入）<ul><li>随机接入：随机发送信息，要有冲突检测和冲突解决机制</li><li>受控接入：多点线路探询(polling)或轮询</li></ul></li></ul><p>局域网的数据链路层的两个子层：辑链路控制LLC(Logical Link Control)子层、媒体接入控制MAC(Media Access Control)子层</p><p>网卡的作用：进行串行/并行转换、<strong>实现以太网协议</strong>、存储MAC地址</p><h4 id="3-4-以太局域网（以太网）">3.4 以太局域网（以太网）</h4><p>以太网单程端到端时延 $\tau$ ，争用期长度 $2\tau$ ，帧长 $L(bit)$ ，数据发送速率 $C(bps)$ ，帧发送时间 $T_0=\frac{L}{C}$</p><p>发送一帧的平均时间：$k\cdot 2\tau + T_0 + \tau$（发送完成后等待一个$\tau$的传播时间）</p><p>信道利用率：$S=\dfrac{T_0}{k\cdot 2\tau + T_0+\tau}$</p><p>要提高以太网的信道利用率，就必须减小$\tau$与$T_0$之比：$a=\frac{\tau}{T_0}$。<br>a越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低</p><p>理想情况下的极限信道利用率$S_{max}=\dfrac{T_0}{T_0+\tau}=\dfrac{1}{1+a}$</p><p>以太网MAC帧格式（DIX Ethernet V2 标准）：</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/3_6.png" alt="以太网MAC帧格式"></p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">长度</th><th style="text-align:center">值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">前同步码</td><td style="text-align:center">7B</td><td style="text-align:center">固定为10101010交替</td><td style="text-align:center">调整时钟频率</td></tr><tr><td style="text-align:center">帧开始定界符</td><td style="text-align:center">1B</td><td style="text-align:center">10101011</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">目的地址</td><td style="text-align:center">6B</td><td style="text-align:center">目的MAC地址</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">源地址</td><td style="text-align:center">6B</td><td style="text-align:center">源MAC地址</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">类型</td><td style="text-align:center">2B</td><td style="text-align:center">上层协议类型</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据</td><td style="text-align:center">46~1500B</td><td style="text-align:center">IP数据报</td><td style="text-align:center">可变长度，不包括FCS</td></tr><tr><td style="text-align:center">FCS</td><td style="text-align:center">4B</td><td style="text-align:center">CRC校验码</td><td style="text-align:center"></td></tr></tbody></table><h3 id="3-5-HDLC协议">3.5 HDLC协议</h3><p>HDLC(High-level Data Link Control)是一种数据链路层协议，是ISO组织制定的一种数据链路层协议，是一种面向比特的协议。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">HDLC协议</th><th style="text-align:center">PPP协议</th></tr></thead><tbody><tr><td style="text-align:center">信道</td><td style="text-align:center">点对点</td><td style="text-align:center">点对点</td></tr><tr><td style="text-align:center">面向</td><td style="text-align:center">比特</td><td style="text-align:center">字节</td></tr><tr><td style="text-align:center">透明性</td><td style="text-align:center">0比特填充</td><td style="text-align:center">字节填充</td></tr><tr><td style="text-align:center">通信</td><td style="text-align:center">全双工、半双工</td><td style="text-align:center">全双工</td></tr><tr><td style="text-align:center">可靠性</td><td style="text-align:center">使用编号和确认机制，提供可靠传输</td><td style="text-align:center">只保证无差错接收CRC检验</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">多一个2字节的协议字段。当协议字段值为0x0021时，表示信息字段是IP数据报</td></tr></tbody></table><h2 id="四、网络层">四、网络层</h2><h3 id="4-1-网络层的基本概念">4.1 网络层的基本概念</h3><h4 id="4-1-1-网络层提供的两种服务">4.1.1 网络层提供的两种服务</h4><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">虚电路服务</th><th style="text-align:center">数据报服务</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">可靠通信应当由网络来保证</td><td style="text-align:center">通信的可靠性应当由用户主机来保证</td></tr><tr><td style="text-align:center">建立的连接</td><td style="text-align:center">必须有</td><td style="text-align:center">不需要</td></tr><tr><td style="text-align:center">终点地址</td><td style="text-align:center">仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组的转发</td><td style="text-align:center">属于同一条虚电路的分组均按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">结点出故障时</td><td style="text-align:center">所有通过出故障的结点的虚电路均不能工作</td><td style="text-align:center">出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按发送顺序到达终点</td><td style="text-align:center">到达终点时不一定按发送顺序</td></tr><tr><td style="text-align:center">端到端的差错处理和流量控制</td><td style="text-align:center">可以由网络负责，也可以由用户主机负责</td><td style="text-align:center">由用户主机负责</td></tr></tbody></table><h4 id="4-1-2-中间设备-中继系统">4.1.2 中间设备/中继系统</h4><ul><li>物理层：转发器(repeater)</li><li>数据链路层：网桥(bridge)</li><li>网络层：路由器(router)</li><li>网络层以上：网关(gateway)</li></ul><h3 id="4-2-IP协议">4.2 IP协议</h3><p>网际协议IP是TCP/IP体系中两个最主要的协议之一。与IP协议配套使用的还有三个协议：</p><ul><li>地址解析协议ARP(Address Resolution Protocol)</li><li>网际控制报文协议ICMP(Internet Control Message Protocol)</li><li>网际组管理协议IGMP(Internet Group Management Protocol)</li></ul><h4 id="4-2-1-IP地址分类">4.2.1 IP地址分类</h4><p>IP地址分为A、B、C、D、E五类，每类地址的网络号和主机号的划分不同。</p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">前缀</th><th style="text-align:center">网络号</th><th style="text-align:center">主机号</th><th style="text-align:center">第一字节范围</th><th style="text-align:center">子网掩码</th><th style="text-align:center">主机数</th><th style="text-align:center">预留私有地址网段（RFC 1918）</th></tr></thead><tbody><tr><td style="text-align:center">A类</td><td style="text-align:center">0</td><td style="text-align:center">7位</td><td style="text-align:center">24位</td><td style="text-align:center">0~127</td><td style="text-align:center">/8</td><td style="text-align:center">2^24-2=16777214</td><td style="text-align:center">10.0.0.0~10.255.255.255</td></tr><tr><td style="text-align:center">B类</td><td style="text-align:center">10</td><td style="text-align:center">14位</td><td style="text-align:center">16位</td><td style="text-align:center">128~191</td><td style="text-align:center">/16</td><td style="text-align:center">2^16-2=65534</td><td style="text-align:center">172.16.0.0~172.31.255.255</td></tr><tr><td style="text-align:center">C类</td><td style="text-align:center">110</td><td style="text-align:center">21位</td><td style="text-align:center">8位</td><td style="text-align:center">192~223</td><td style="text-align:center">/24</td><td style="text-align:center">2^8-2=254</td><td style="text-align:center">192.168.0.0~192.168.255.255</td></tr><tr><td style="text-align:center">D类</td><td style="text-align:center">1110</td><td style="text-align:center">多播地址28位</td><td style="text-align:center">-</td><td style="text-align:center">224~239</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">E类</td><td style="text-align:center">1111</td><td style="text-align:center">保留地址</td><td style="text-align:center">-</td><td style="text-align:center">240~255</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><h3 id="4-2-2-地址解析协议ARP">4.2.2 地址解析协议ARP</h3><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/4_1.png" alt="ARP工作原理"></p><p>当主机A欲向本局域网上的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。<br>如有，就可查出其对应的硬件地址，再将此硬件地址写入MAC，然后通过局域网将该MAC发往此硬件地址。<br>如没有，ARP进程在本局域网上广播发送一个ARP请求分组收到ARP响应分组后，将得到的P地址到硬件地址的映射写入ARP高速缓存。</p><h3 id="4-2-3-IP数据报的封装格式">4.2.3 IP数据报的封装格式</h3><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/4_2.png" alt="IP数据报的封装格式"></p><p>IP数据报的封装格式：</p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">长度</th><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">版本</td><td style="text-align:center">4b</td><td style="text-align:left">IPv4为4</td><td style="text-align:left">IP协议的版本号</td></tr><tr><td style="text-align:center">首部长度</td><td style="text-align:center">4b</td><td style="text-align:left">首部长度</td><td style="text-align:left">最大为1111(15)，单位为4字节，即首部最大为60字节</td></tr><tr><td style="text-align:center">区分服务</td><td style="text-align:center">8b</td><td style="text-align:left"></td><td style="text-align:left">服务类型，一般不使用</td></tr><tr><td style="text-align:center">总长度</td><td style="text-align:center">16b</td><td style="text-align:left">IP数据报的总长度</td><td style="text-align:left">单位为字节，包括首部和数据部分</td></tr><tr><td style="text-align:center">标识</td><td style="text-align:center">16b</td><td style="text-align:left">标识符</td><td style="text-align:left">用于标识发送的数据报</td></tr><tr><td style="text-align:center">标志</td><td style="text-align:center">3b</td><td style="text-align:left">标志位</td><td style="text-align:left">MF：1位，1表示还有分片<br>DF：1位，1表示不允许分片<br>保留位：1位</td></tr><tr><td style="text-align:center">片偏移</td><td style="text-align:center">13b</td><td style="text-align:left">片偏移</td><td style="text-align:left">单位为8字节，表示该片相对于原始数据报的偏移量</td></tr><tr><td style="text-align:center">生存时间</td><td style="text-align:center">8b</td><td style="text-align:left">TTL</td><td style="text-align:left">数据报在网络中可通过的路由器数的最大值，每经过一个路由器减1，为0时丢弃</td></tr><tr><td style="text-align:center">协议</td><td style="text-align:center">8b</td><td style="text-align:left">协议号</td><td style="text-align:left">指出此数据报携带的数据使用何种协议，如TCP为6，UDP为17</td></tr><tr><td style="text-align:center">首部校验和</td><td style="text-align:center">16b</td><td style="text-align:left">首部校验和</td><td style="text-align:left">只检验数据报的首部不检验数据部分<br>这里不采用CRC检验码而采用简单的计算方法</td></tr><tr><td style="text-align:center">源地址</td><td style="text-align:center">32b</td><td style="text-align:left">源IP地址</td><td style="text-align:left">发送数据报的主机的IP地址</td></tr><tr><td style="text-align:center">目的地址</td><td style="text-align:center">32b</td><td style="text-align:left">目的IP地址</td><td style="text-align:left">接收数据报的主机的IP地址</td></tr><tr><td style="text-align:center">选项</td><td style="text-align:center">可变</td><td style="text-align:left"></td><td style="text-align:left">选项字段的长度是可变的，最长为40字节</td></tr></tbody></table><p>IP数据报分片例：一数据报的总长度为3820字节，其数据部分的长度为3800字节(使用固定首部)，MTU=1420字节</p><ul><li>首部长度：20字节</li><li>分片最长数据长度：1420-20=1400字节</li><li>分片数据长度：3800=1400+1400+1000</li><li>分片1：偏移0，MF=1</li><li>分片2：偏移1400/8=175，MF=1</li><li>分片3：偏移2800/8=350，MF=0</li></ul><h3 id="4-3-IP层分组转发过程">4.3 IP层分组转发过程</h3><h4 id="4-3-1-分组转发算法">4.3.1 分组转发算法</h4><ol><li>从数据报的首部提取目的主机D的IP地址,得出目的网络地址为N</li><li>若网络N与此路由器直接相连，则把数据报直接交付目的主机D；否则是间接交付，执行下一步</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行下一步</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行下一步</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器，否则，报告转发分组出错</li></ol><h4 id="4-3-2-子网划分">4.3.2 子网划分</h4><p>借位：从主机最高位开始借位变为新的子网位，剩余部分仍为主机位</p><p>例如192.168.1.0/24可划分为：</p><ul><li>2个子网：192.168.1.0/25、192.168.1.128/25</li><li>4个子网：192.168.1.0/26、192.168.1.64/26、192.168.1.128/26、192.168.1.192/26</li></ul><p>192.168.1.55/26 的网络号：将IP地址转换为二进制，取前26位即可。<br>192.168.1.55(00|110111)=&gt;192.168.1.0</p><h4 id="4-3-3-划分子网的分组转发算法">4.3.3 划分子网的分组转发算法</h4><ol><li>从数据报的首部提取目的主机D的IP地址</li><li>先用直接相连的各网络的子网掩码和D逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付；否则就是间接交付，执行下一步</li><li>若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行下一步</li><li>对路由表中的每一行的子网掩码和 D 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行下一步</li><li>若路由表中有一个默认路由，则将分组传送给指明的默认路由器；否则，报告转发分组出错</li></ol><h4 id="4-3-4-无分类IP地址CIDR">4.3.4 无分类IP地址CIDR</h4><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</p><p>最长前缀匹配：在路由表中查找一个与目的地址最匹配的路由表项，即查找最长的前缀匹配。</p><h3 id="4-4-网际控制报文协议ICMP">4.4 网际控制报文协议ICMP</h3><p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。<br>ICMP 不是高层协议，而是IP层的协议。<br>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。</p><p>ICMP差错报文：终点不可达、时间超限、参数问题、改变路由(重定向)、源抑制</p><p>ICMP询问报文：回送请求和回答报文、时间戳请求和回答报文</p><p>ICMP应用：PING、Traceroute</p><h3 id="4-5-路由选择协议">4.5 路由选择协议</h3><p>内部网关协议 IGP:具体的协议有多种，如RIP和OSPF等</p><p>外部网关协议 EGP:目前使用的协议就是BGP</p><h4 id="4-5-1-RIP协议">4.5.1 RIP协议</h4><p>RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。</p><p>在RIP网络中，缺省情况下，设备到与它直接相连网络的跳数为0，通过一个设备可达的网络的跳数为1，其余依此类推。也就是说，度量值等于从本网络到达目的网络间的设备数量。</p><p>为限制收敛时间，RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得RIP不可能在大型网络中得到应用。</p><p>RIP路由器工作流程：</p><ul><li>RIP路由器A,B初始的路由表中只有自己的直连路由。</li><li>每30秒，向相邻路由器发送自己的路由表。</li><li>收到相邻路由器的路由表后，更新自己的路由表：<ul><li>新增：如果收到的路由表中有自己没有的路由，则添加到自己的路由表中。</li><li>更新：如果收到的路由表中有自己已有的路由，且新的跳数更小，则更新自己的路由表的跳数。</li></ul></li><li>RIP计时器：<ul><li>更新计时器：每30秒左右发送一次路由表。</li><li>失效计时器：180秒（6倍更新时间）未更新，标记为不可达。</li><li>刷新计时器：无效路由240秒未更新，从路由表中删除。</li></ul></li></ul><p>RIP协议的缺点：坏消息传播慢、收敛时间长、不适合大型网络</p><h4 id="4-5-2-OSPF协议">4.5.2 OSPF协议</h4><p>使用了 Dijkstra 提出的最短路径算法SPF(Shortest Path First)，是分布式的链路状态协议</p><p>支持可变长度的子网划分和无分类编址 CIDR</p><p>五种分组类型：问候分组Hello、数据库描述分组Database Description、链路状态请求分组Link State Request、链路状态更新分组Link State Update、链路状态确认分组Link State Acknowledgement</p><p>当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多，且没有“坏消息传播得慢”的问题</p><h4 id="4-5-3-BGP协议">4.5.3 BGP协议</h4><p>BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由</p><p>一个BGP 发言人与其他自治系统中的BGP发言人要交换路由信息就要先建立TCP连接，然后在此连接上交换BGP报文以建立BGP会话(session)，利用 BGP 会话交换路由信息。</p><p>BGP协议的特点：支持CIDR、只在发生变化时更新有变化的部分</p><p>四种BGP报文：打开报文Open（与相邻BGP发言人建立联系）、更新报文Update（发送路由信息）、通知报文Notification（发送差错）、保持报文Keepalive（确认Open和保持连接）</p><h3 id="4-6-路由器的构成">4.6 路由器的构成</h3><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/4_3.png" alt="路由器的结构"></p><p>常用交换方法：通过存储器、通过总线、通过纵横交换结构</p><h4 id="4-7-IP多播">4.7 IP多播</h4><p>TCP/IP 协议使用的以太网多播地址块的范围是：从 00-00-5E-00-00-00 到 00-00-5E-FF-FF-FF</p><p>为了使路由器知道多播组成员的信息，需要利用网际组管理协议IGMP (Internet Group Management Protocol)，同时也需要路由器多播选择协议</p><p>IGMP阶段：加入多播组、探寻成员变化</p><p>多播路由选择协议转发多播数据报时使用三种方法：洪泛与剪除（适合于较小的多播组，RPB）、隧道技术、基于核心的发现技术</p><p>反向路径广播RPB(Reverse Path Broadcasting)：路由器收到多播数据报时，检查数据报的源地址，如果数据报的源地址是最短路径树上的成员，则转发数据报，否则丢弃</p><h2 id="五、传输层-运输层">五、传输层/运输层</h2><p>运输层向它上面的应用层提供通信服务</p><p>只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能</p><p>应用进程之间的通信又称为端到端的通信，运输层提供应用进程间的逻辑通信</p><table><thead><tr><th style="text-align:center">运输层</th><th style="text-align:center">网络层</th></tr></thead><tbody><tr><td style="text-align:center">为应用进程之间提供端到端的逻辑通信</td><td style="text-align:center">为主机之间提供逻辑通信</td></tr><tr><td style="text-align:center">对报文进行差错检测</td><td style="text-align:center">对首部进行差错检测</td></tr><tr><td style="text-align:center">需要两种不同的运输协议，即面向连接的TCP和无连接的UDP</td><td style="text-align:center">无连接的IP协议</td></tr></tbody></table><p>协议端口号：用于标识主机上的应用进程，简称端口。16位，范围0~65535</p><ul><li>服务端：0~1023为熟知端口号，1024~49151为登记端口号</li><li>客户端：49152(65536/4*3)~65535为短暂端口号</li></ul><table><thead><tr><th style="text-align:center">协议</th><th style="text-align:center">FTP</th><th style="text-align:center">Telnet</th><th style="text-align:center">SMTP</th><th style="text-align:center">DNS</th><th style="text-align:center">HTTP</th><th style="text-align:center">SMTP</th><th style="text-align:center">HTTPS</th></tr></thead><tbody><tr><td style="text-align:center">熟知端口号</td><td style="text-align:center">21/20</td><td style="text-align:center">23</td><td style="text-align:center">25</td><td style="text-align:center">53</td><td style="text-align:center">80</td><td style="text-align:center">110</td><td style="text-align:center">443</td></tr></tbody></table><h3 id="5-1-用户数据报协议UDP-v-s-传输控制协议TCP">5.1 用户数据报协议UDP v.s. 传输控制协议TCP</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">用户数据报协议UDP(User Datagram Protocol)</th><th style="text-align:center">传输控制协议TCP(Transmission Control Protocol)</th></tr></thead><tbody><tr><td style="text-align:center">连接服务</td><td style="text-align:center">无连接的协议，提供无连接服务</td><td style="text-align:center">面向连接的协议，提供面向连接服务</td></tr><tr><td style="text-align:center">可靠性</td><td style="text-align:center">不可靠</td><td style="text-align:center">全双工的可靠信道</td></tr><tr><td style="text-align:center">运输协议数据单元TPDU</td><td style="text-align:center">UDP报文/用户数据报</td><td style="text-align:center">TCP报文段</td></tr><tr><td style="text-align:center">传输方式</td><td style="text-align:center">单播、多播、广播</td><td style="text-align:center">点对点单播，不支持多播和广播</td></tr><tr><td style="text-align:center">面向</td><td style="text-align:center">报文</td><td style="text-align:center">字节流</td></tr><tr><td style="text-align:center">复杂性</td><td style="text-align:center">简单</td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">应用</td><td style="text-align:center">多媒体</td><td style="text-align:center">文件传输、电子邮件、WWW</td></tr><tr><td style="text-align:center">应用层协议</td><td style="text-align:center">DNS、TFTP、SNMP、NFS</td><td style="text-align:center">HTTP、FTP、Telnet、SMTP</td></tr><tr><td style="text-align:center">拥塞控制</td><td style="text-align:center">无</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">首部开销</td><td style="text-align:center">8字节</td><td style="text-align:center">20字节</td></tr></tbody></table><h3 id="5-2-用户数据报协议UDP">5.2 用户数据报协议UDP</h3><p>只在IP数据报之上增加了复用和分用（端口）、差错检测功能</p><h4 id="5-2-1-UDP首部格式">5.2.1 UDP首部格式</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_1.png" alt="UDP首部格式"></p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">长度</th><th style="text-align:center">值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">伪首部</td><td style="text-align:center">12B</td><td style="text-align:center">源IP地址、目的IP地址、协议号、UDP长度</td><td style="text-align:center">用于计算校验和</td></tr><tr><td style="text-align:center">源端口</td><td style="text-align:center">2B</td><td style="text-align:center">0~65535</td><td style="text-align:center">标识发送方应用进程</td></tr><tr><td style="text-align:center">目的端口</td><td style="text-align:center">2B</td><td style="text-align:center">0~65535</td><td style="text-align:center">标识接收方应用进程</td></tr><tr><td style="text-align:center">长度</td><td style="text-align:center">2B</td><td style="text-align:center">8~65535</td><td style="text-align:center">UDP报文长度</td></tr><tr><td style="text-align:center">校验和</td><td style="text-align:center">2B</td><td style="text-align:center">0~65535</td><td style="text-align:center">校验UDP首部和数据</td></tr></tbody></table><h4 id="5-2-2-UDP校验和">5.2.2 UDP校验和</h4><p>要加上12字节的伪首部，包含：源IP地址、目的IP地址、协议号、UDP长度</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_2.png" alt="校验和计算"></p><ol><li>二进制反码求和：<ol><li>统计出每一位上1的个数：24135445 04247779</li><li>从末尾开始，模二进位；首位进位加到末位<ul><li>24135445 042477(7+9/2=11)1</li><li>24135445 04247(7+11/2=12)11</li><li>24135445 0424(7+12/2=13)011</li><li>…</li><li>(2+6/2=5)0010110 11001011</li><li>10010110 1100101(1+5/2=3)</li><li>10010110 110010(1+3/2=2)1</li><li>10010110 11001(0+2/2=1)01</li><li>10010110 11001101</li></ul></li></ol></li><li>取反码：01101001 00110010，即为校验和</li></ol><h3 id="5-3-传输控制协议TCP">5.3 传输控制协议TCP</h3><p>套接字(socket)：IP地址:端口号</p><p>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）确定。</p><h4 id="5-3-1-TCP首部格式">5.3.1 TCP首部格式</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_4.png" alt="TCP首部格式"></p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">长度</th><th style="text-align:center">值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">源端口</td><td style="text-align:center">2B</td><td style="text-align:center">0~65535</td><td style="text-align:center">标识发送方应用进程</td></tr><tr><td style="text-align:center">目的端口</td><td style="text-align:center">2B</td><td style="text-align:center">0~65535</td><td style="text-align:center">标识接收方应用进程</td></tr><tr><td style="text-align:center">序号</td><td style="text-align:center">4B</td><td style="text-align:center">0~4294967295</td><td style="text-align:center">每个字节都被编号，这是本报文段的第一个字节的序号</td></tr><tr><td style="text-align:center">确认号ack</td><td style="text-align:center">4B</td><td style="text-align:center">0~4294967295</td><td style="text-align:center">期望收到对方的下一个报文段的数据的第一个字节的序号，=序号+数据长度</td></tr><tr><td style="text-align:center">数据偏移</td><td style="text-align:center">4b</td><td style="text-align:center">0~15</td><td style="text-align:center">TCP首部长度，单位为4字节，最大为60字节</td></tr><tr><td style="text-align:center">保留</td><td style="text-align:center">6b</td><td style="text-align:center">0</td><td style="text-align:center">保留位</td></tr><tr><td style="text-align:center">控制位</td><td style="text-align:center">6b</td><td style="text-align:center">URG、ACK、PSH、RST、SYN、FIN</td><td style="text-align:center">URG：紧急数据优先传送<br>ACK：确认号字段有效<br>PSH：接收方尽快将累积数据交给应用层<br>RST：连接差错，重置连接<br>SYN：连接请求/接受<br>FIN：发送完毕，释放连接</td></tr><tr><td style="text-align:center">窗口rwnd</td><td style="text-align:center">16b</td><td style="text-align:center">0~65535</td><td style="text-align:center">接收窗口大小，单位为字节</td></tr><tr><td style="text-align:center">校验和</td><td style="text-align:center">16b</td><td style="text-align:center">0~65535</td><td style="text-align:center">首部和数据的校验和</td></tr><tr><td style="text-align:center">紧急指针</td><td style="text-align:center">16b</td><td style="text-align:center">0~65535</td><td style="text-align:center">紧急数据的长度（字节），紧急数据最后一位=序号+紧急指针-1</td></tr><tr><td style="text-align:center">选项</td><td style="text-align:center">可变</td><td style="text-align:center"></td><td style="text-align:center">最大报文段长度MSS、窗口扩大选项（3字节）、时间戳选项（10字节）、选择确认选项</td></tr><tr><td style="text-align:center">填充</td><td style="text-align:center">可变</td><td style="text-align:center"></td><td style="text-align:center">使首部长度为4的倍数</td></tr></tbody></table><h4 id="5-3-2-TCP可靠传输工作原理">5.3.2 TCP可靠传输工作原理</h4><p>自动重传请求ARQ(Automatic Repeat reQuest)：使用确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。<br>重传是自动进行的，不需要接收方发送重传请求。</p><p>TCP连接的每一端都必须设有两个窗口：一个发送窗口和一个接收窗口。TCP 两端的四个窗口经常处于动态变化之中。<br>TCP 的可靠传输机制用字节的序号进行控制，TCP所有的确认都是基于序号而不是基于报文段。<br>TCP连接的往返时间RTT也不是固定不变的，需要使用特定的算法估算较为合理的重传时间。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">停止等待协议</th><th style="text-align:center">连续ARQ协议</th></tr></thead><tbody><tr><td style="text-align:center">发送分组数量</td><td style="text-align:center">1</td><td style="text-align:center">多个</td></tr><tr><td style="text-align:center">控制传输</td><td style="text-align:center">停止-等待</td><td style="text-align:center">滑动窗口协议</td></tr><tr><td style="text-align:center">确认方式</td><td style="text-align:center">单独确认</td><td style="text-align:center">单独确认+累积确认</td></tr><tr><td style="text-align:center">超时定时</td><td style="text-align:center">每个发送的分组</td><td style="text-align:center">每个发送的分组</td></tr><tr><td style="text-align:center">分组编号</td><td style="text-align:center">每个分组</td><td style="text-align:center">每个分组</td></tr><tr><td style="text-align:center">重传机制</td><td style="text-align:center">一个分组</td><td style="text-align:center">回退N</td></tr></tbody></table><h4 id="5-3-3-停止等待协议">5.3.3 停止等待协议</h4><p>停止等待协议是一种简单的ARQ协议。<br>在发送完一个分组后，必须暂时保留己发送的分组的副本。<br>分组和确认分组都必须进行编号。</p><p>优点：简单、易于实现</p><p>缺点：信道利用率低 $U=\dfrac{数据发送时间T_D}{T_D+往返时间RTT+ACK读取时间T_A}$</p><ol><li>无差错<ul><li>A发送分组1，启动定时器，等待B确认（ACK）</li><li>B收到分组1，发送ACK</li><li>A收到ACK，发送分组2</li></ul></li><li>分组差错<ul><li>A发送分组1，启动定时器，等待B确认</li><li>分组1损坏丢弃/中途丢失</li><li>A超时未收到ACK，重发分组1</li><li>B收到分组1，发送ACK</li></ul></li><li>确认差错/迟到<ul><li>A发送分组1，启动定时器，等待B确认</li><li>B收到分组1，发送ACK</li><li>ACK中途丢失</li><li>A超时未收到ACK，重发分组1</li><li>B收到分组1，重复，丢弃，重发ACK</li><li>A收到重发的ACK，发送分组2</li></ul></li></ol><h4 id="5-3-4-连续ARQ协议">5.3.4 连续ARQ协议</h4><p>连续ARQ协议是一种流水线协议，允许发送方发送多个分组而不必等待接收方的确认。</p><p>确认方式：接收方累积确认：不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，表示：到这个分组为止的所有分组都已正确收到了。</p><p>累积确认的优点是：容易实现，即使确认丢失也不必重传。</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_3.png" alt="累积确认"></p><p>重传方式：回退N：5个分组，第3个出错，接收方只对前2个分组发送确认，发送方收到确认后，重传第3个分组及后面的分组。</p><h3 id="5-3-5-TCP可靠通信具体实现">5.3.5 TCP可靠通信具体实现</h3><ul><li>假定A向B发送数据，当前A收到了B发来的确认报文，其中窗口=20，确认号=31（表示期望收到A的下一个报文的序号为31，且30以前的报文都已收到）。</li><li>此时A的发送窗口[31,50]，B的接收窗口[31,50]。A发送31~41</li><li>假设B收到31~33，发送确认号34，窗口=20的ACK，同时B的接收窗口滑动至[34,53]。</li><li>A收到ACK，窗口滑动至[34,53]。</li><li>未收到的数据在超时后重传。</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_5.png" alt="TCP可靠通信具体实现"></p><ul><li>发送缓存用于存储：已发送但未收到确认的数据、准备发送的数据</li><li>接收缓存用于存储：已接收但未被使用的数据、未按序到达的数据</li></ul><h4 id="5-3-6-超时重传时间RTO的选择">5.3.6 超时重传时间RTO的选择</h4><ul><li>报文往返时间RTT：从发送方发送数据报到接收方收到确认报文的时间</li><li>加权移动平均往返时间RTTs：当监测到一个新的RTT时，计算新的RTTs<ul><li>$RTT_S=(1-\alpha)RTT_S+\alpha RTT$，其中$\alpha$一般取$\dfrac{1}{8}$</li></ul></li><li>平均偏差RTTd：初值为第一次RTT的一半，之后每次RTT的偏差为<ul><li>$RTT_D=(1-\beta)RTT_D+\beta|RTT_S-RTT|$，其中$\beta$一般取$\dfrac{1}{4}$</li></ul></li><li>超时重传时间RTO：略大于RTTs，$RTO=RTT_S+4*RTT_D$</li></ul><p>针对超时重传无法准确计算RTT的情况，可以使用Karn算法：</p><ol><li>只要报文段重传了，就不采用其往返时间RTT样本</li><li>报文段每重传一次，就把超时重传时间RTO增大一些，一般加倍</li></ol><h3 id="5-4-TCP流量控制">5.4 TCP流量控制</h3><p>端到端的问题</p><h4 id="5-4-1-滑动窗口实现流量控制">5.4.1 滑动窗口实现流量控制</h4><p>流量控制：让发送方发送速率不要太快，要让接收方来得及接收。</p><p>下图的传输流程通过3次更改接收窗口大小来实现流量控制。</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_6.png" alt="TCP流量控制"></p><p>死锁：<br>B向A发送rwnd=0的ACK后，A不再发送数据。<br>B又有了一些缓存，向A发送rwnd&gt;0的ACK，但是丢失了。<br>A等待B的ACK，B等待A的数据，形成死锁。</p><p>解决：收到rwnd=0后启动持续计时器，每次到期发送一个“零窗口探测报文段”</p><h4 id="5-4-2-控制发送时机">5.4.2 控制发送时机</h4><ol><li>缓存存放的数据达到最大报文段长度MSS字节时，发送一个TCP报文段</li><li>由发送方进程通过PSH、URG标志位控制发送时机</li><li>发送方计时器到期，发送一个报文段</li></ol><p>Nagle算法：应用逐字节发送数据时，通过延迟发送小报文段来提高网络利用率。</p><ul><li>发送方发送第一个数据字节，缓存后续字节</li><li>收到接收方的ACK后，发送缓存中的数据</li><li>当到达的数据达到发送窗口大小一半或MSS时，发送缓存中的数据</li></ul><p>糊涂窗口综合症：交换的数据段大小不是全长而是一些较小的数据。由于每个数据段的有用数据（数据部分）较少，因而消耗的资源也更多，相应的传输效率也更低。</p><p>解决：接收方等待缓存有足够空间后，再发送rwnd&gt;0的ACK</p><h3 id="5-5-TCP拥塞控制">5.5 TCP拥塞控制</h3><p>流量控制:是端到端的问题(接收端控制发送端)，点对点通信量的控制。抑制发送端发送速率，以便使接收端来得及接收。</p><p>拥塞控制:是一个全局性的过程，涉及到与降低网络传输性能有关的所有因素。防止过多数据注入到网络，使网络中的路由器或链路不致过载。</p><h4 id="5-5-1-拥塞控制的基本原理">5.5.1 拥塞控制的基本原理</h4><p>出现资源拥塞的条件：对资源需求的总和&gt;可用资源</p><p>原因：链路容量不足、资源分配不均、路由器缓存空间和流量分布不均、处理机性能不足等</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_7.png" alt="拥塞控制的作用"></p><p>开环控制：设计网络时就考虑到拥塞控制，力求避免拥塞的发生</p><p>闭环控制：基于反馈环路</p><ul><li>监测网络系统以便检测到拥塞在何时、何处发生</li><li>将拥塞发生的信息传送到可采取行动的地方</li><li>调整网络系统的运行以解决出现的问题</li></ul><p>拥塞通知的传递策略：显示拥塞通告ECN</p><h4 id="5-5-2-TCP拥塞控制算法">5.5.2 TCP拥塞控制算法</h4><p>TCP采用基于窗口的方法进行拥塞控制，属于闭环控制。</p><p>TCP发送方维持一个拥塞窗口 CWND(Congestion Window):</p><ul><li>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化</li><li>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量</li><li>网络没有出现拥塞，拥塞窗口增大一些，以便发送更多的分组，提高网络的利用率</li><li>网络出现拥塞或有可能出现拥塞，拥塞窗口减小一些，减少注入到网络中的分组数</li></ul><p>TCP拥塞判断依据：重传定时器超时</p><p>TCP进行拥塞控制的算法有4种：慢开始、拥塞避免、快重传、快恢复</p><h4 id="5-5-3-慢开始和拥塞避免">5.5.3 慢开始和拥塞避免</h4><p>发送方最大报文段SMSS(Sender Maximum Segment Size)：MTU/MSS</p><p>初始拥塞窗口cwnd大小：</p><ul><li>旧规定：1~2个SMSS</li><li>新规定RFC5681：<ul><li>$SMSS&gt;2190B$：$cwnd=2SMSS$，&lt;=2个报文段</li><li>$2190B\ge SMSS&gt;1095B$：$cwnd=3SMSS$，&lt;=3个报文段</li><li>$1095B\ge SMSS$：$cwnd=4SMSS$，&lt;=4个报文段</li></ul></li><li>慢开始门限ssthresh（状态变量）：防止cwnd增长过快引起网络拥塞<ul><li>$cwnd&lt;ssthresh$：慢开始算法</li><li>$cwnd\ge ssthresh$：拥塞避免算法</li></ul></li></ul><p>慢开始算法：cwnd从1开始，2，4，8，16指数增长，若超出ssthresh则取ssthresh</p><p>避免拥塞：cwnd&gt;=ssthresh后，线性增长，每个RTT增加1</p><p>遇到超时：ssthresh=cwnd/2，cwnd=1，慢开始</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_8.png" alt="慢开始和拥塞避免"></p><h4 id="5-5-3-快重传和快恢复">5.5.3 快重传和快恢复</h4><p>快重传FR(Fast Retransmission)算法可以让发送方尽早知道发生了个别报文段的丢失。</p><p>发送方只要一连收到三个重复确认，应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方不会误认为出现了网络拥塞。</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_9.png" alt="快重传"></p><p>快恢复算法：在快重传的基础上，将ssthresh减半，cwnd=ssthresh，然后进入拥塞避免状态</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/5_10.png" alt="TCP拥塞控制算法"></p><h3 id="5-6-TCP传输连接管理">5.6 TCP传输连接管理</h3><p>TCP协议工作流程：</p><ol><li>建立连接：三次握手<ol><li>发起方向接收方发送SYN报文，请求建立连接<ul><li>SYN=1，seq=x，表示发送方本次报文的第一个字节的序号是x</li></ul></li><li>接收方收到SYN报文后，回复SYN+ACK报文，表示同意建立连接<ul><li>SYN=1，ACK=1</li><li>seq=y，表示接收方本报文的第一个字节的序号是y</li><li>ack=x+1，表示接收方期望收到的下一个报文的序号是x+1，因为SYN报文占了一个序号</li></ul></li><li>发起方收到SYN+ACK报文后，回复ACK报文，表示连接建立成功<ul><li>ACK=1</li><li>seq=x+1，表示发送方本报文的第一个字节的序号是x+1</li><li>ack=y+1，表示发送方期望收到的下一个报文的序号是y+1，因为SYN+ACK报文占了一个序号</li></ul></li><li>三次握手完成，连接建立成功</li></ol></li><li>数据传输：数据传输阶段</li><li>断开连接：四次挥手<ol><li>发起方向接收方发送FIN报文，请求断开连接<ul><li>FIN=1，seq=u</li></ul></li><li>接收方收到FIN报文后，回复ACK报文，表示收到断开请求<ul><li>ACK=1，seq=v，ack=u+1</li></ul></li><li>接收方向发起方发送FIN+ACK报文，请求断开连接<ul><li>FIN=1，ACK=1，seq=w，ack=u+1</li></ul></li><li>发起方收到FIN+ACK报文后，回复ACK报文，表示收到断开请求，等待2MSL后断开连接<ul><li>ACK=1，seq=u+1，ack=w+1</li></ul></li><li>四次挥手完成，连接断开成功</li></ol></li></ol><ul><li>谁想建立或断开连接，谁就是发起方。发起方就是客户端，接收方就是服务器端。</li><li>MSL(Maximum Segment Lifetime)：报文最大生存时间，2MSL是为了保证网络中的所有报文都已经消失，不会再次出现在网络中，保证TCP协议的全双工连接能够可靠关闭</li></ul><p>TCP四个计时器：超时重传计时器、持续计时器(0窗口报文探测计时器)、时间等待计时器(2MSL关闭连接)、保活计时器、TCP发送报文计时器。</p><h2 id="六、应用层">六、应用层</h2><h3 id="6-1-域名系统DNS">6.1 域名系统DNS</h3><p>域名服务器类型：</p><ol><li>根域名服务器：管理顶级域名的服务器</li><li>顶级域名服务器：管理在该顶级域名服务器注册的二级域名服务器</li><li>权威域名服务器：管理自己的域名</li><li>本地域名服务器：提供域名解析服务，也称默认域名服务器</li></ol><p>域名查询方式：</p><ol><li>递归查询：主机向本地域名服务器发出查询请求，本地域名服务器不知道答案，则以DNS客户身份向根域名服务器发出查询请求</li><li>迭代查询：本地域名服务器向根域名服务器发出查询请求，根域名服务器告知本地域名服务器下一步应该向哪个域名服务器查询，本地域名服务器再向下一级域名服务器发出查询请求</li></ol><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications/6_1.png" alt="DNS查询过程"></p><h3 id="6-2-文件传输协议FTP">6.2 文件传输协议FTP</h3><p>文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议</p><p>实现了通过网络实现异构计算机间的文件“拷贝”、提供交互式的访问、屏蔽了各计算机系统的细节</p><p>FTP使用2个TCP连接：控制连接和数据连接</p><ul><li>控制连接（TCP21）：用于传送请求，在整个会话期间保持打开状态</li><li>数据连接（TCP20）：用于传送文件内容，每次传送文件时打开，传送完毕后关闭</li><li>端口号：服务器使用熟知端口TCP21/20，客户端使用其他端口号&gt;1023</li></ul><p>FTP传输模式：文本模式/ASCII模式、二进制模式/Binary模式</p><h3 id="6-3-简单文件传输协议TFTP">6.3 简单文件传输协议TFTP</h3><p>TFTP(Trivial File Transfer Protocol)是一个很小易于实现的文件传输协议</p><p>只支持传输文件，不支持交互，使用UDP数据报传输，端口号UDP69</p><p>文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据PDU</p><h3 id="6-4-远程终端协议Telnet">6.4 远程终端协议Telnet</h3><p>C/S模式，TCP连接，NVT格式，端口号默认TCP23</p><p>Telnet协议的缺点：明文传送</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Telnet</th><th style="text-align:center">SSH</th></tr></thead><tbody><tr><td style="text-align:center">功能</td><td style="text-align:center">远程登录</td><td style="text-align:center">远程登录</td></tr><tr><td style="text-align:center">运输层协议</td><td style="text-align:center">TCP</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">加密</td><td style="text-align:center">明文</td><td style="text-align:center">RSA加密、支持压缩</td></tr><tr><td style="text-align:center">端口号</td><td style="text-align:center">23</td><td style="text-align:center">22</td></tr></tbody></table><h3 id="6-5-万维网WWW">6.5 万维网WWW</h3><p>超文本传输协议HTTP(HyperText Transfer Protocol)是万维网的应用层协议，面向事务，本身无连接，是可靠交换文件的基础</p><p>HTTP协议永远都是客户端发起请求，服务器端响应请求，是无状态的协议，默认端口：TCP80</p><p>URL：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>HTTP报文：</p><ul><li>请求报文：请求行、请求头、空行、请求体</li><li>响应报文：状态行、响应头、空行、响应体</li></ul><p>状态码：三位数字</p><ul><li>1xx：信息性状态码，接收到请求，继续处理</li><li>2xx：成功状态码，请求成功接收、理解、接受</li><li>3xx：重定向状态码，需要进一步操作</li><li>4xx：客户端错误状态码，请求包含语法错误或无法完成</li><li>5xx：服务器错误状态码，服务器无法完成明显有效的请求</li></ul><h3 id="6-6-电子邮件">6.6 电子邮件</h3><p>两个重要标准：简单邮件传送协议、互联网报文交换格式(Internet Message Format)</p><p>三个主要构件：用户代理、邮件服务器、SMTP和POP3协议</p><p>发送邮件流程：</p><ol><li>发件人UA向发件人邮件服务器发送邮件<ul><li>SMTP，TCP25</li></ul></li><li>发件人邮件服务器以客户的身份向收件人邮件服务器发送邮件<ul><li>SMTP，TCP25</li></ul></li><li>收件人从收件人邮件服务器接收邮件<ul><li>POP3，TCP110</li></ul></li></ol><p>SMTP三阶段：握手、传输、结束</p><p>POP3：仅客户端内读取</p><p>IMAP：客户端与邮件更新同步</p><h3 id="6-7-DHCP协议">6.7 DHCP协议</h3><ol><li>DHCP Discover报文<ul><li>客户端启动时，客户主机-&gt;DHCP服务器：谁能给我一个IP地址？</li><li>源地址：0.0.0.0</li><li>源端口：UDP 68</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 67</li></ul></li><li>DHCP Offer报文<ul><li>服务器接收到广播数据包后，DHCP服务器-&gt;客户主机：我能给你分配IP地址192.168.1.2</li><li>源地址：服务器IP地址</li><li>源端口：UDP 67</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 68</li></ul></li><li>DHCP Request报文<ul><li>客户端接收到DHCP服务器分配的IP地址后，客户主机-&gt;DHCP服务器：好的，我接受你分配的IP地址192.168.1.2，请求确认</li><li>源地址：0.0.0.0</li><li>源端口：UDP 68</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 67</li></ul></li><li>DHCP ACK报文<ul><li>服务器接收到广播数据包后，DHCP服务器-&gt;客户主机：好的，我已经确认分配给你IP地址</li><li>源地址：服务器IP地址</li><li>源端口：UDP 67</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 68</li></ul></li></ol><p>DHCP端口号：UDP 67(服务器)和UDP 68(客户端)</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络与通信-实验》课程笔记</title>
      <link href="/posts/computer_networks_and_communications_lab.html"/>
      <url>/posts/computer_networks_and_communications_lab.html</url>
      
        <content type="html"><![CDATA[<h2 id="零-概述">零. 概述</h2><h3 id="0-1-网络分层OSI参考模型">0.1 网络分层OSI参考模型</h3><p>OSI参考模型是国际标准化组织(ISO)制定的一个用于计算机网络体系结构的标准框架。</p><p>OSI分为7层，自上而下分别是：</p><ul><li>7.应用层：应用软件</li><li>6.表示层：数据格式转换</li><li>5.会话层：决定采用哪种传输方式</li><li>4.传输层：提供端到端的通信，主机连接建立和断开，保证数据传输的可靠性</li><li>3.网络层：根据目标地址实现通信</li><li>2.数据链路层：根据物理地址实现数据的传输</li><li>1.物理层：传输介质</li></ul><h3 id="0-2-TCP-IP参考模型">0.2 TCP/IP参考模型</h3><p>TCP/IP参考模型是实际应用最广泛的网络协议体系结构，它只有4层，自上而下分别是：</p><ul><li>4.应用层(包含了OSI的应用层、表示层、会话层)<ul><li>数据</li><li>协议：HTTP、HTTPS、SSH、DNS、FTP、POP3、SMTP…</li></ul></li><li>3.传输层<ul><li>TCP首部+数据</li><li>TCP：面向连接的可靠传输协议，支持应用层所有协议</li><li>UDP：无连接的不可靠传输协议，支持DNS、DHCP、SMB等</li></ul></li><li>2.网络层<ul><li>IP首部+TCP首部+数据</li><li>IP：负责数据包的传输</li><li>ICMP：负责网络故障诊断</li><li>ARP：负责地址解析</li></ul></li><li>1.网络接口层(包含了OSI的数据链路层、物理层)<ul><li>数据链路层<ul><li>MAC首部+LLC首部+IP首部+TCP首部+数据+FCS(帧校验序列)</li><li>MAC子层协议：将数据包封装成帧，通过物理层传输</li></ul></li><li>物理层<ul><li>传输介质</li></ul></li></ul></li></ul><h3 id="0-3-网络层">0.3 网络层</h3><p>网络层关注的问题：如何找到合适的网络路径，将数据包从源主机传输到目的主机。</p><h4 id="0-3-1-数据包分组与封装">0.3.1 数据包分组与封装</h4><p>网络层主要协议：IP、ICMP、ARP</p><ul><li>分组交换：以分组为单位的<strong>存储转发</strong>的传输方式，将长的报文分割成若干短分组进行多次传输。</li><li>路由转发：源与目的主机之间可能存在多条相通的路径，网络层选择一条“最佳”路径完成数据转发。</li><li>拥塞控制：合理分配数据包的转发路径，提高转发效率。当产生网络拥塞时，及时更换传输路径。</li><li>异种网络的互连：当源主机和目标主机的网络不属于同一种网络类型时，为了解决不同网络在寻址、分组大小、协议等方面的差异，要求在不同种类网络交界处的路由器能够对分组进行处理，使得分组能够在不同网络上传输。不同的网络类型对分组大小要求不一样，需要重新分组。</li></ul><h4 id="0-3-2-网络层与数据链路层的关系">0.3.2 网络层与数据链路层的关系</h4><ul><li>通信双方：<ul><li>数据链路层实现在同一局域网内利用MAC地址进行通信</li><li>网络层实现在不同局域网内利用IP地址进行通信</li></ul></li><li>解决的问题：<ul><li>数据链路层实现的是保证两端链路的连通性，可以说数据链路层不能分辨异构的网络</li><li>网络层要解决异构网络互联的问题，按照不同网络协议的格式完成数据的重新封装</li></ul></li></ul><h4 id="0-3-3-IP地址、子网掩码（Subnet-Mask）、网关（Gateway）">0.3.3 IP地址、子网掩码（Subnet Mask）、网关（Gateway）</h4><p>IP地址：主机在Internet上的一个全世界范围内唯一32位标识符，用点分十进制表示，如192.168.0.1。</p><p>子网掩码：用来划分网络和主机的32位二进制数，用来指明一个IP地址的哪些位标识网络地址，哪些位标识主机地址。</p><p>表示方法：</p><ul><li>CIDR表示法：/子网掩码位数，如/24表示前24位是1，其余8位是0</li><li>点分十进制：<a href="http://xxx.xxx.xxx.xxx">xxx.xxx.xxx.xxx</a>，如255.255.255.0</li><li>转换例：255.255.254.0 -&gt; 11111111.11111111.11111110.00000000 -&gt; /23</li></ul><p>网关：一个网络的出口。当一个主机要将数据发送给其他网络的主机时，通常首先将数据发往网关。</p><h4 id="0-3-4-IP地址分类">0.3.4 IP地址分类</h4><p>IP地址分为A、B、C、D、E五类，每类地址的网络号和主机号的划分不同。</p><table><thead><tr><th>类别</th><th>前缀</th><th>网络号</th><th>主机号</th><th>第一字节范围</th><th>子网掩码</th><th>主机数</th><th>预留私有地址网段（RFC 1918）</th></tr></thead><tbody><tr><td>A类</td><td>0</td><td>7位</td><td>24位</td><td>0~127</td><td>/8</td><td>2^24-2=16777214</td><td>10.0.0.0~10.255.255.255</td></tr><tr><td>B类</td><td>10</td><td>14位</td><td>16位</td><td>128~191</td><td>/16</td><td>2^16-2=65534</td><td>172.16.0.0~172.31.255.255</td></tr><tr><td>C类</td><td>110</td><td>21位</td><td>8位</td><td>192~223</td><td>/24</td><td>2^8-2=254</td><td>192.168.0.0~192.168.255.255</td></tr><tr><td>D类</td><td>1110</td><td>多播地址28位</td><td>-</td><td>224~239</td><td>-</td><td>-</td><td>-</td></tr><tr><td>E类</td><td>1111</td><td>保留地址</td><td>-</td><td>240~255</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h4 id="0-3-5-子网划分">0.3.5 子网划分</h4><p>借位：从主机最高位开始借位变为新的子网位，剩余部分仍为主机位</p><p>例如192.168.1.0/24可划分为：</p><ul><li>2个子网：192.168.1.0/25、192.168.1.128/25</li><li>4个子网：192.168.1.0/26、192.168.1.64/26、192.168.1.128/26、192.168.1.192/26</li></ul><div STYLE="page-break-after: always;"></div><h2 id="一-传输介质">一. 传输介质</h2><h3 id="1-1-传输介质分类">1.1 传输介质分类</h3><h4 id="1-1-1-有线传输介质">1.1.1 有线传输介质</h4><p>有线传输介质是指在两个通信设备之间实现的物理连接部分，它能将信号从一方传输到另一方。</p><p>有线传输介质主要有<strong>双绞线</strong>、同轴电缆和光纤。双绞线和同轴电缆传输电信号，光纤传输光信号。</p><h4 id="1-1-2-无线传输介质">1.1.2 无线传输介质</h4><p>在自由空间传输的电磁波根据频谱可将其分为无线电波、微波、红外线、激光等，信息被加载在电磁波上进行传输。在局域网中，通常只使用无线电波和红外线作为传输介质。</p><h4 id="1-1-3-直连线和交叉线的区别">1.1.3 直连线和交叉线的区别</h4><p>直连线：两端的线序相同，用于连接不同设备。</p><ul><li>PC&lt;-&gt;Hub/Switch</li></ul><p>交叉线：两端的线序不同，用于连接相同设备。</p><h3 id="1-2-双绞线制作">1.2 双绞线制作</h3><h4 id="1-2-1-双绞线制作标准：EIA-TIA-568">1.2.1 双绞线制作标准：EIA/TIA 568</h4><ul><li>A：白绿/绿/白橙/蓝/白蓝/橙/白棕/棕</li><li>B：白橙/橙/白绿/蓝/白蓝/绿/白棕/棕</li></ul><h4 id="1-2-2-双绞线制作步骤">1.2.2 双绞线制作步骤</h4><ol><li>剥线：用压线钳将双绞线一端的外皮剥去3cm，露出8根线。</li><li>理线：将4对导线分别绕开，8根导线按EIA/TIA 568B标准顺序排列，将线芯撸直并拢。</li><li>剪线：将芯线放到压线钳切刀处，8根线芯要在同一平面上并拢，而且尽量直，留下一定的线芯长度约1.5CM处剪齐。</li><li>插线：将双绞线插入RJ45水晶头中，插入过程均衡力度直到插到尽头。检查8根线芯是否已经全部充分、整齐地排列在水晶头里面。</li><li>压线：用压线钳用力压紧水晶头，抽出即可。</li></ol><h4 id="1-2-3-双绞线测试">1.2.3 双绞线测试</h4><p>直连线(两端都是568B标准)：12345678</p><p>交叉线(一端是568A标准，一端是568B标准)：36145278</p><p>100Mbps以太网线实际使用的线：白绿/绿/白橙/橙</p><div STYLE="page-break-after: always;"></div><h2 id="二-DHCP">二. DHCP</h2><h3 id="2-1-DHCP工作原理">2.1 DHCP工作原理</h3><p>DHCP(Dynamic Host Configuration Protocol)是一种动态主机配置协议，它是一种自动分配IP地址的协议。</p><h4 id="DHCP工作原理">DHCP工作原理</h4><ol><li>DHCP Discover报文<ul><li>客户端启动时，客户主机-&gt;DHCP服务器：谁能给我一个IP地址？</li><li>源地址：0.0.0.0</li><li>源端口：UDP 68</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 67</li></ul></li><li>DHCP Offer报文<ul><li>服务器接收到广播数据包后，DHCP服务器-&gt;客户主机：我能给你分配IP地址192.168.1.2</li><li>源地址：服务器IP地址</li><li>源端口：UDP 67</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 68</li></ul></li><li>DHCP Request报文<ul><li>客户端接收到DHCP服务器分配的IP地址后，客户主机-&gt;DHCP服务器：好的，我接受你分配的IP地址192.168.1.2，请求确认</li><li>源地址：0.0.0.0</li><li>源端口：UDP 68</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 67</li></ul></li><li>DHCP ACK报文<ul><li>服务器接收到广播数据包后，DHCP服务器-&gt;客户主机：好的，我已经确认分配给你IP地址</li><li>源地址：服务器IP地址</li><li>源端口：UDP 67</li><li>目的地址：255.255.255.255(广播)</li><li>目的端口：UDP 68</li></ul></li></ol><p>DHCP端口号：UDP 67(服务器)和UDP 68(客户端)</p><h3 id="2-2-DHCP配置">2.2 DHCP配置</h3><ol><li>网络拓扑图<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/2_1.png" alt="网络拓扑图2"></li></ul></li><li>设置DHCP服务器和PC机的TCP/IP属性<ul><li>DHCP服务器：192.168.1.1/24</li><li>PC1/PC2：自动获取IP地址</li></ul></li><li>配置DHCP服务器<ul><li>设置IP池为192.168.1.10-20</li></ul></li></ol><h3 id="2-3-验证DHCP配置">2.3 验证DHCP配置</h3><ol><li>使用ipconfig /all命令查看各机器的TCP/IP配置<ul><li>PC1: 192.168.0.10</li><li>PC2: 192.168.0.11</li></ul></li><li>使用ping命令测试连通性<ul><li>PC1&lt;-&gt;PC2：连通</li></ul></li></ol><div STYLE="page-break-after: always;"></div><h2 id="三-DNS及Web服务">三. DNS及Web服务</h2><h3 id="3-1-DNS工作原理">3.1 DNS工作原理</h3><p>DNS(Domain Name System，域名系统)是一个分布式数据库，用于域名和IP地址之间的映射。</p><ul><li>IPv4：32位二进制数，可写作点分十进制</li><li>IPv6：128位二进制数，可写作冒号分隔的8组16进制数</li></ul><p>DNS工作流程：</p><ol><li>PC机-&gt;首选DNS服务器：<a href="http://xn--www-st5fu45oo2cory.baidu.com">我要访问www.baidu.com</a></li><li>首选DNS服务器-&gt;根域名’.'DNS服务器：www.baidu.com对应的IP地址是多少？</li><li>根域名’.'DNS服务器-&gt;首选DNS服务器：www.baidu.com归’com’DNS服务器管</li><li>首选DNS服务器-&gt;'com’DNS服务器：www.baidu.com对应的IP地址是多少？</li><li>'com’DNS服务器-&gt;首选DNS服务器：www.baidu.com归’<a href="http://baidu.com">baidu.com</a>’DNS服务器管</li><li>首选DNS服务器-&gt;'<a href="http://baidu.com">baidu.com</a>’DNS服务器：www.baidu.com对应的IP地址是多少？</li><li>'<a href="http://baidu.com">baidu.com</a>’DNS服务器-&gt;首选DNS服务器：<a href="http://www.baidu.xn--comIPXXX-xb7n6eu54cyshkv0aji6c.XXX.XXX.XXX">www.baidu.com对应的IP地址是XXX.XXX.XXX.XXX</a></li><li>首选DNS服务器-&gt;PC机：<a href="http://www.baidu.xn--comIPXXX-xb7n6eu54cyshkv0aji6c.XXX.XXX.XXX">www.baidu.com对应的IP地址是XXX.XXX.XXX.XXX</a></li><li>PC机-&gt;Web服务器：<a href="http://xn--XXX-st5fu45oo2cory.XXX.XXX.XXX">我要访问XXX.XXX.XXX.XXX</a></li><li>Web服务器-&gt;PC机：返回相关的数据</li></ol><ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/3_1.png" alt="DNS工作原理"></li></ul><p>递归查询：递归查询是一种DNS服务器的查询模式。在该模式下，DNS服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS服务器本地没有存储查询DNS信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p><p>迭代查询：DNS服务器会向客户机提供其他能够解析查询请求的DNS服务器地址。当客户机发送查询请求时，DNS服务器并不直接回复查询结果，而是告诉客户机另一台DNS服务器地址，客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。</p><p>DNS端口号：UDP 53</p><h3 id="3-2-HTTP工作原理">3.2 HTTP工作原理</h3><p>HTTP(HyperText Transfer Protocol，超文本传输协议)是一种用于传输超文本的协议。</p><p>HTTP工作流程：<br>1. 客户端浏览器解析URL<br>2. 客户端浏览器生产HTTP请求信息<br>3. 服务器发送响应HTTP页面<br>4. 客户端浏览器解析响应页面</p><h3 id="3-3-DNS配置">3.3 DNS配置</h3><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/3_2.png" alt="网络拓扑图3"></li></ul></li><li>配置DNS服务器<ul><li>jike.com配置Host IP：192.168.0.20(对应Web服务器)</li><li>ruanjian.com配置Host IP：192.168.0.70(没有对应的Web服务器)</li></ul></li></ol><h3 id="3-4-验证DNS配置">3.4 验证DNS配置</h3><ol><li>使用ipconfig /all命令查看各机器的TCP/IP配置</li><li>在客户端PC上使用ping命令测试连通性<ul><li><a href="http://jike.com">jike.com</a>：Reply from 192.168.0.20: bytes=32 time&lt;1ms TTL=128(来自192.168.0.20的回复：字节=32 时间&lt;1ms TTL=128)</li><li><a href="http://ruanjian.com">ruanjian.com</a>：Request timed out(来自192.168.0.10的回复：无法访问目标主机)</li><li><a href="http://anquan.com">anquan.com</a>：Unknown host &lt;<a href="http://www.anquan.com">www.anquan.com</a>(<a href="http://xn--Pinganquan-wj2piry83btt9cs3ox4ssg7j.com">Ping请求找不到主机anquan.com</a>。请检查该名称，然后重试)&gt;</li></ul></li></ol><h3 id="3-5-FTP服务配置">3.5 FTP服务配置</h3><ol><li>在控制面板中启用IIS(Internet Information Services，Internet信息服务)</li><li>打开IIS，网站名称改为jike，选择物理路径。在路径下新建index.html文件，用ANSI编码保存，并在默认文档中添加该文档。<a href="http://xn--jingke-2o2mv27a7m7e4jva.com/index.html%E5%BA%94%E8%AF%A5%E8%83%BD%E7%9C%8B%E5%88%B0index.html%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82">此时访问jingke.com/index.html应该能看到index.html的内容。</a></li><li>新建一个FTP站点，名称为jikeFTP，选择物理路径(在该位置新建几个文件夹测试)，绑定IP地址为192.168.0.20，选择无SSL，允许所有用户访问。此时使用FTP客户端连接，应该能看到FTP站点的内容。</li></ol><div STYLE="page-break-after: always;"></div><h2 id="四-交换机工作原理及基本配置">四. 交换机工作原理及基本配置</h2><h3 id="4-1-交换机">4.1 交换机</h3><p>交换机(Switch)是一种网络设备，用于在计算机网络中连接多个设备，实现设备之间的通信。</p><p>最常见的以太网交换机工作于OSI网络参考模型的第二层(即数据链路层)，是一种基于MAC地址识别、完成以太网数据帧转发的网络设备。</p><h4 id="4-1-1-MAC地址">4.1.1 MAC地址</h4><p>MAC地址(Media Access Control Address，介质访问控制地址)是一个用来识别网络设备的地址，又称物理地址。</p><p>由48位二进制数组成，通常以12位十六进制数表示，如00-0C-29-3D-2E-7C，也写作000C.293D.2E7C、00:0C:29:3D:2E:7C。</p><p>前24位是厂商识别码，后24位是设备识别码(供应商对网卡的唯一编号)。</p><ul><li>单播地址：MAC地址的第一个字节的最低位为0，可作为目的地址和源地址。</li><li>组播地址：MAC地址的第一个字节的最低位为1，仅能作为目的地址。</li><li>广播地址：MAC地址全为1，即FF-FF-FF-FF-FF-FF，用于向同一网络中的所有设备发送数据。</li></ul><h4 id="4-1-2-MAC地址表">4.1.2 MAC地址表</h4><p>交换机内部用于存放物理地址与交换机端口映射关系的数据库，交换机依靠MAC地址表实现数据帧的转发。<br>- Static MAC Address：静态MAC地址，由管理员手动配置。<br>- Dynamic MAC Address：动态MAC地址，由交换机自动学习。</p><p>动态MAC地址学习过程</p><ol><li>主机A-&gt;交换机：我要发送数据帧给主机B。 交换机：记录主机A的MAC地址和端口映射。</li><li>交换机-&gt;广播：主机A的数据帧发送给所有端口。</li><li>主机B-&gt;交换机：我收到数据帧了，回复。 交换机：记录主机B的MAC地址和端口映射。</li></ol><h4 id="4-1-3-数据帧">4.1.3 数据帧</h4><ul><li>数据帧(Data Frame)是数据链路层的协议数据单元，包括：帧头、数据、帧尾。</li><li>在以太网链路上的数据单元称为以太网帧，现在最常见的以太网帧是Ethernet II，包括：目的MAC地址(6B)、源MAC地址(6B)、类型/长度(2B)、数据(46-1500B)、FCS帧校验序列(4B)。</li></ul><p>帧转发/过滤：单播帧依靠MAC地址表进行转发/过滤，组播帧向指定端口转发，广播帧向所有端口转发</p><p>帧转发方式：</p><ul><li>直通转发：交换机收到帧头(通常只检查14个字节)后立刻察看目的MAC地址并进行转发。</li><li>存储转发：接收完整的帧，执行完校验后，转发正确的帧而丢弃错误的帧。</li><li>无碎片直通转发：交换机读取前64个字节后开始转发。</li></ul><h3 id="4-2-交换机本地配置-MAC地址绑定">4.2 交换机本地配置-MAC地址绑定</h3><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/4_1.png" alt="网络拓扑图4"></li></ul></li><li>计算机串口或USB口与交换机的Console端口连接；打开计算机Win系统的“超级终端”或其他串口通信客户端软件；Serial Port按交换机要求设置，一般默认<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/4_2.png" alt="终端配置"></li></ul></li><li>常用命令/模式切换命令<ul><li>Switch&gt;   //(初始)用户模式</li><li>Switch&gt;enable  //进入特权模式</li><li>Switch#configure terminal  //进入全局配置模式</li><li>Switch(config)#interface fa0/1  //进入接口fa0/1配置模式</li><li>Switch(config-if)#end //退出配置模式，返回特权模式</li><li>Switch#show clock  //查看交换机时间</li><li>Switch#show version  //查看交换机版本信息</li><li>修改交换机主机名<ul><li>Switch#configure terminal</li><li>Switch(config)#hostname jike</li><li>jike(config)#</li></ul></li></ul></li><li>MAC地址表管理命令<ul><li>Switch#show mac-address-table  //查看MAC地址表</li><li>Switch#show mac-address-table aging-time  //查看MAC地址表老化时间</li><li>交换机上添加MAC地址绑定<ul><li>Switch(config)#mac-address-table static aaaa.aaaa.aaaa vlan 1 interface fa0/1</li><li>Switch(config)#mac-address-table static aaaa.aaaa.aaab vlan 1 interface fa0/2</li><li>Switch(config)#mac-address-table static aaaa.aaaa.aaac vlan 1 interface fa0/3</li></ul></li><li>交换机上删除MAC地址绑定<ul><li>Switch(config)#no mac-address-table static aaaa.aaaa.aaac vlan 1 interface fa0/3</li></ul></li></ul></li></ol><h3 id="4-3-验证交换机配置">4.3 验证交换机配置</h3><p>以绑定了fa0/1、fa0/2的交换机为例，在以下端口连接情况下，使用ping命令测试连通性：</p><ol><li>PC1至1号端口，PC2至2号端口，PC3至3号端口<ul><li>PC1&lt;-&gt;PC2：连通</li><li>PC1&lt;-&gt;PC3：连通</li><li>PC2&lt;-&gt;PC3：连通</li><li>MAC地址表：fa0/1-PC1、fa0/2-PC2、fa0/3-PC3</li></ul></li><li>PC1至2号端口，PC2至1号端口，PC3至10号端口<ul><li>PC1&lt;-&gt;PC2：不连通</li><li>PC1&lt;-&gt;PC3：不连通</li><li>PC2&lt;-&gt;PC3：不连通</li><li>MAC地址表：fa0/1-PC2、fa0/2-PC1、fa0/10-PC3</li></ul></li><li>PC1至5号端口，PC2至2号端口，PC3至3号端口<ul><li>PC1&lt;-&gt;PC2：不连通</li><li>PC1&lt;-&gt;PC3：不连通</li><li>PC2&lt;-&gt;PC3：连通</li><li>MAC地址表：fa0/1-PC2、fa0/2-PC1、fa0/3-PC3</li></ul></li></ol><ul><li>总结：静态MAC地址绑定后，主机与端口连线必须一一对应才能传输数据；如果是动态MAC地址，主机连任意一个端口均可正常收发数据。</li></ul><div STYLE="page-break-after: always;"></div><h2 id="五-交换机VLAN">五. 交换机VLAN</h2><h3 id="5-1-VLAN">5.1 VLAN</h3><p>交换网络是平面网络结构，必须依赖广播，广播域过大会导致网络拥塞。</p><p>VLAN(Virtual Local Area Network，虚拟局域网)是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样。</p><p>VLAN的特点：</p><ul><li>基于逻辑的分组，不受物理位置限制。</li><li>在同一VLAN内和真实局域网相同。</li><li>不同VLAN内用户要通信需要借助三层设备。</li></ul><p>基于端口的VLAN：交换机端口可以划分到不同的VLAN中，不同VLAN之间的通信需要通过路由器。</p><h4 id="5-1-1-IEEE-802-1Q标准">5.1.1 IEEE 802.1Q标准</h4><p>定义了基于端口的VLAN模型，规定如何标识带有 VLAN 成员信息的以太帧，定义VLAN标签格式。</p><p>在以太网帧中增加了一个4字节的802.1Q帧头，用于标识VLAN信息：目的MAC地址(6B)、源MAC地址(6B)、802.1Q帧头(4B)、类型/长度(2B)、数据(46-1500B)、FCS帧校验序列(4B)。</p><p>802.1Q帧头格式：TPID(2B)+PCP(3b)+DEI(1b)+VID(12b)</p><ul><li>TPID：标识802.1Q帧头，取值0x8100</li><li>PCP：优先级，取值0-7，0最低，7最高</li><li>DEI：丢弃标志，用于QoS</li><li>VID：VLAN ID，取值1-4094</li></ul><h4 id="5-1-2-交换机端口类型">5.1.2 交换机端口类型</h4><table><thead><tr><th></th><th>Access端口</th><th>Trunk端口</th></tr></thead><tbody><tr><td>Tag</td><td>UnTagged端口（接入端口）</td><td>Tag Aware端口（干道端口）</td></tr><tr><td>VLAN</td><td>只能属于一个VLAN</td><td>可以允许多个VLAN通过</td></tr><tr><td>数据帧</td><td>发送的数据帧不带VLAN标签</td><td>发送的数据帧带有VLAN标签</td></tr><tr><td>用途</td><td>一般用于连接终端设备（PC机）</td><td>一般用于交换机之间的连接</td></tr><tr><td>默认</td><td>交换机上的默认端口</td><td>-</td></tr></tbody></table><h3 id="5-2-交换机VLAN配置">5.2 交换机VLAN配置</h3><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/5_1.png" alt="网络拓扑图5"></li></ul></li><li>创建VLAN<ul><li>Switch(config)#vlan 10</li><li>Switch(config-vlan)#exit</li><li>Switch(config)#vlan 20</li><li>Switch(config-vlan)#exit</li></ul></li><li>配置Access端口/划分VLAN<ul><li>Switch(config)#interface fa0/1-5</li><li>Switch(config-if-range)#switchport mode access</li><li>Switch(config-if-range)#switchport access vlan 10</li><li>Switch(config-if-range)#exit</li><li>Switch(config)#interface fa0/6-10</li><li>Switch(config-if-range)#switchport mode access</li><li>Switch(config-if-range)#switchport access vlan 20</li><li>Switch(config-if-range)#exit</li></ul></li><li>配置Trunk端口<ul><li>Switch(config)#interface fa0/24</li><li>Switch(config-if)#switchport mode trunk</li></ul></li></ol><h3 id="5-3-验证交换机VLAN配置">5.3 验证交换机VLAN配置</h3><ol><li>显示交换机VLAN配置<ul><li>Switch#show vlan brief</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/5_2.png" alt="交换机VLAN配置"></li></ul></li><li>连通性测试<ul><li>PC1&lt;-&gt;PC4：连通</li><li>PC2&lt;-&gt;PC3：连通</li><li>其余PC之间不连通</li></ul></li><li>总结：同一VLAN内可以直接相互通信，不同VLAN内不能直接相互通信。</li></ol><div STYLE="page-break-after: always;"></div><h2 id="六-VLAN间通信">六. VLAN间通信</h2><h3 id="6-1-路由">6.1 路由</h3><p>VLAN是广播域（二层概念），而两个广播域之间通常由路由器连接，广播域之间来往的数据包都是由路由（三层概念）转发的。路由的主要功能由路由器和三层交换机提供。</p><p>VLAN间通信一般有以下3种实施方案：</p><ol><li>路由器多端口方式</li><li>单臂路由方式</li><li>三层交换机方式</li></ol><h3 id="6-2-路由器多端口方式">6.2 路由器多端口方式</h3><p>与路由器连接不同子网通信的方法一样，为路由器端口设置一个IP地址作为对应VLAN的网关，有几个VLAN就需要在几个端口设置IP地址。</p><p>缺点：<br>一般中大型局域网，VLAN数量可以很多，而路由器端口数量较少，路由器会成为局域网性能瓶颈。<br>路由器采用软件对IP报文进行转发，占用CPU和内存资源，效率比较低，无法胜任通信数据量较大的局域网。</p><h4 id="6-2-1-配置">6.2.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_1_1.png" alt="网络拓扑图6_1"></li></ul></li><li>二层交换机配置<ul><li>创建VLAN10和VLAN20</li><li>配置Access端口/划分VLAN<ul><li>VLAN10: fa0/1,fa0/10</li><li>VLAN20: fa0/2,fa0/20</li></ul></li><li>查看VLAN配置: Switch#show vlan brief</li></ul></li><li>路由器配置<ul><li>Router(config)#interface fa0/0</li><li>Router(config-if)#no shutdown //激活接口</li><li>Router(config-if)#ip address 192.168.1.1 255.255.255.0 //设置接口IP地址</li><li>Router(config-if)#exit</li><li>Router(config)#interface fa0/1</li><li>Router(config-if)#no shutdown</li><li>Router(config-if)#ip address 192.168.2.1 255.255.255.0</li><li>Router(config-if)#exit</li></ul></li></ol><h4 id="6-2-2-验证路由器配置">6.2.2 验证路由器配置</h4><ol><li>显示路由表<ul><li>Router#show ip route</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_1_2.png" alt="路由表"></li></ul></li><li>显示IP接口信息<ul><li>Router#show ip interface brief</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_1_3.png" alt="IP接口"></li></ul></li><li>连通性测试<ul><li>PC1&lt;-&gt;PC2：连通</li></ul></li></ol><h3 id="6-3-单臂路由方式">6.3 单臂路由方式</h3><p>在路由器的一个物理接口上配置多个子接口，作为不同VLAN的默认网关，实现原来相互隔离的不同VLAN之间的通信。</p><p>缺点：<br>路由器转发速度有限，无法满足VLAN间通信数据量大的需求，并且容易造成单点故障。<br>数据在物理链路上往返传输，会有转发延迟，很可能成为局域网性能瓶颈。</p><h4 id="6-3-1-配置">6.3.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_2_1.png" alt="网络拓扑图6_2"></li></ul></li><li>二层交换机配置<ul><li>创建VLAN10和VLAN20</li><li>配置Access端口/划分VLAN<ul><li>VLAN10: fa0/1</li><li>VLAN20: fa0/2</li></ul></li><li>配置Trunk端口<ul><li>Switch(config)#interface fa0/24</li><li>Switch(config-if)#switchport mode trunk</li><li>Switch(config-if)#exit</li></ul></li><li>查看VLAN配置: Switch#show vlan brief</li></ul></li><li>路由器配置<ul><li>Router(config)#interface fa0/0</li><li>Router(config-if)#no shutdown //激活接口</li><li>Router(config-if)#exit</li><li>Router(config)#interface fa0/0.10 //创建虚拟子接口10</li><li>Router(config-subif)#encapsulation dot1Q 10 //封装VLAN协议（802.1Q）</li><li>Router(config-subif)#ip address 192.168.1.1 255.255.255.0 //设置子接口IP地址</li><li>Router(config-subif)#exit</li><li>Router(config)#interface fa0/0.20 //创建虚拟子接口20</li><li>Router(config-subif)#encapsulation dot1Q 20</li><li>Router(config-subif)#ip address 192.168.2.1 255.255.255.0</li><li>Router(config-subif)#exit</li></ul></li></ol><h4 id="6-3-2-验证路由器配置">6.3.2 验证路由器配置</h4><ol><li>显示路由表<ul><li>Router#show ip route</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_2_2.png" alt="路由表"></li></ul></li><li>显示IP接口信息<ul><li>Router#show ip interface brief</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_2_3.png" alt="IP接口"></li></ul></li><li>显示Trunk端口<ul><li>Switch#show interfaces trunk</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_2_4.png" alt="Trunk端口"></li></ul></li><li>连通性测试<ul><li>PC1&lt;-&gt;PC2：连通</li></ul></li></ol><h3 id="6-4-三层交换机虚拟接口SVI">6.4 三层交换机虚拟接口SVI</h3><p>三层交换机实现VLAN间通信的方法是在已有的VLAN上创建虚接口，它同样可以配置IP地址，借助虚接口三层交换机能够实现路由转发功能。</p><p>优点：<br>VLAN间流量不必经过路由器，网络延时和抖动都很小，同时也极大程度的减轻上层接入路由器的负载。<br>三层交换机的VLAN间路由由交换机的三层转发引擎完成，其性能取决于交换机的背板转发速率，可以在多个端口上轻松实现线速转发，可以获得很好的性能。</p><h4 id="6-4-1-配置">6.4.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_3_1.png" alt="网络拓扑图6_3"></li></ul></li><li>二层交换机配置<ul><li>创建VLAN10和VLAN20</li><li>配置Access端口/划分VLAN<ul><li>VLAN10: fa0/1</li><li>VLAN20: fa0/2</li></ul></li><li>配置Trunk端口：fa0/24</li><li>查看VLAN配置: Switch#show vlan brief</li><li>查看Trunk端口: Switch#show interfaces trunk</li></ul></li><li>三层交换机配置<ul><li>创建VLAN10和VLAN20</li><li>配置SVI的ip地址<ul><li>Switch(config)#interface vlan 10</li><li>Switch(config-if)#ip address 192.168.1.1 255.255.255.0</li><li>Switch(config-if)#exit</li><li>Switch(config)#interface vlan 20</li><li>Switch(config-if)#ip address 192.168.2.1 255.255.255.0</li><li>Switch(config-if)#exit</li></ul></li><li>开启路由功能<ul><li>Switch(config)#ip routing</li></ul></li></ul></li></ol><h4 id="6-4-2-验证三层交换机配置">6.4.2 验证三层交换机配置</h4><ol><li>显示路由表<ul><li>Switch#show ip route</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/6_3_2.png" alt="路由表"></li></ul></li><li>连通性测试：4台主机之间均可相互通信</li></ol><div STYLE="page-break-after: always;"></div><h2 id="七-静态路由">七. 静态路由</h2><h3 id="7-1-路由器">7.1 路由器</h3><p>路由器（Router）：连接两个或多个网络的硬件设备，在网络间起网关的作用，是读取每一个IP数据包中的地址然后决定如何传送的专用智能性的网络设备。</p><ul><li>直连网络（邻村）：直接连接在某个路由器上的网络，称为该路由器的直连网络。每个路由器接口的IP作为所连直连网络的网关（村口）。</li><li>非直连网络：不直接连接在某个路由器上的网络（通常间隔多个路由器）。</li></ul><h4 id="7-1-1-路由表">7.1.1 路由表</h4><p>路由器依靠路由表来选择转发路径。<br>路由表中包含有该路由器掌握的所有目的网络地址，以及通过此路由器到达这些网络中最佳路径，这个最佳路径指的是路由器的某个接口或下一条路由器的地址。</p><h4 id="7-1-2-静态路由">7.1.2 静态路由</h4><p>静态路由：由系统管理员事先设置好固定的路由信息。</p><ul><li>优点：简单、高效、可靠。优先级最高。</li><li>缺点：不能动态地适用网络状况的变化。</li></ul><h3 id="7-2-静态路由配置">7.2 静态路由配置</h3><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/7_1.png" alt="网络拓扑图7_1"></li></ul></li><li>路由器配置（Router1为例）<ul><li>Router1(config)#interface fa0/0</li><li>Router1(config-if)#no shutdown  //激活接口</li><li>Router1(config-if)#ip address 192.168.1.1 255.255.255.0 //设置接口IP地址为所在网络的网关</li><li>Router1(config-if)#exit</li><li>Router1(config)#interface fa0/1</li><li>Router1(config-if)#no shutdown</li><li>Router1(config-if)#ip address 192.168.2.1 255.255.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#ip route 192.168.3.0 255.255.255.0 192.168.2.2 //设置静态路由：ip route &lt;目的网络&gt; &lt;子网掩码&gt; &lt;下一跳地址&gt;</li></ul></li></ol><h3 id="7-3-验证静态路由配置">7.3 验证静态路由配置</h3><ol><li>显示路由表<ul><li>Router1#show ip route</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/7_2.png" alt="路由表"></li></ul></li><li>连通性测试：3台主机之间均可相互通信</li></ol><h3 id="7-4-静态路由配置补充">7.4 静态路由配置补充</h3><ul><li>通过192.168.0.1的端口，访问所有24位子网掩码的目的网络<ul><li>Router1(config)#ip route 0.0.0.0 255.255.255.0 192.168.0.1</li></ul></li><li>通过192.168.0.1的端口，访问所有网络<ul><li>Router1(config)#ip route 0.0.0.0 0.0.0.0 192.168.0.1</li></ul></li></ul><div STYLE="page-break-after: always;"></div><h2 id="八-动态路由RIP">八. 动态路由RIP</h2><h3 id="8-1-动态路由">8.1 动态路由</h3><p>动态路由：路由器根据网络系统的运行情况而自动调整的路由信息。路由器根据路由选择协议（Routing Protocol）提供的功能，自动学习和记忆网络运行情况，在需要时自动计算数据传输的最佳路径。</p><ul><li>优点：动态路由可以自动学习网络的拓朴结构，并更新路由表。</li><li>缺点：路由广播更新信息将占据大量的网络带宽。</li></ul><h4 id="8-1-1-动态路由分类">8.1.1 动态路由分类</h4><ul><li>按照使用的区域不同<ul><li>内部网关协议IGP（Interior Gateway Protocol）域内协议。如RIP、EIGRP、OSPF、ISIS</li><li>外部网关协议EGP（Exterior Gateway Protocol）域间协议。如BGP</li></ul></li><li>按照算法不同<ul><li>距离矢量协议（Distance Vector）。如RIPV1、RIPV2、BGP</li><li>链路状态路由协议（Link State）。如OSPF、ISIS</li></ul></li><li>按是否携带子网掩码<ul><li>有类路由协议。如RIPV1</li><li>无类路由协议。如RIPV2、OSPF、ISIS、BGP</li></ul></li></ul><h4 id="8-1-2-RIP协议">8.1.2 RIP协议</h4><p>RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。</p><p>在RIP网络中，缺省情况下，设备到与它直接相连网络的跳数为0，通过一个设备可达的网络的跳数为1，其余依此类推。也就是说，度量值等于从本网络到达目的网络间的设备数量。</p><p>为限制收敛时间，RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得RIP不可能在大型网络中得到应用。</p><p>RIP路由器工作流程：</p><ul><li>RIP路由器A,B初始的路由表中只有自己的直连路由。</li><li>每30秒，向相邻路由器发送自己的路由表。</li><li>收到相邻路由器的路由表后，更新自己的路由表：<ul><li>新增：如果收到的路由表中有自己没有的路由，则添加到自己的路由表中。</li><li>更新：如果收到的路由表中有自己已有的路由，且新的跳数更小，则更新自己的路由表的跳数。</li></ul></li><li>RIP计时器：<ul><li>更新计时器：每30秒左右发送一次路由表。</li><li>失效计时器：180秒（6倍更新时间）未更新，标记为不可达。</li><li>刷新计时器：无效路由240秒未更新，从路由表中删除。</li></ul></li></ul><p>路由毒化：当一个路由器发现一个网络不可达时，会向其他路由器发送一个度量值为16的路由，以传播路由失效的消息，这个过程称为路由毒化。</p><h4 id="8-1-3-RIP协议版本">8.1.3 RIP协议版本</h4><p>RIPv1</p><ul><li>使用广播的方式发送路由更新</li><li>路由更新信息中不携带子网掩码，为有类路由协议，不支持 VLSM 和 CIDR</li><li>不支持认证</li></ul><p>RIPv2</p><ul><li>发送更新报文的方式为组播，组播地址为224.0.0.9</li><li>路由信息中加入了子网掩码，为无类路由协议，支持 VLSM，支持路由聚合与 CIDR</li><li>支持明文认证和 MD5 密文认证</li></ul><p>VLSM：可变长子网掩码Variable Length Subnet Mask</p><p>CIDR：无类域间路由聚合Classless Inter-Domain Routing</p><h3 id="8-2-RIPV1">8.2 RIPV1</h3><h4 id="8-2-1-配置">8.2.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/8_1_1.png" alt="网络拓扑图8_1"></li></ul></li><li>路由器配置（以Router1为例）<ul><li>Router1(config)#interface lo0  //创建Loopback接口，用于模拟网络</li><li>Router1(config-if)#ip address 1.1.1.1 255.255.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#interface fa0/0</li><li>Router1(config-if)#no shutdown  //激活接口</li><li>Router1(config-if)#ip address 12.1.1.1 255.55.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#router rip  //进入RIP协议配置模式</li><li>Router1(config-router)#version 1  //设置RIP版本为1</li><li>Router1(config-router)#network 1.1.1.0 //设置RIP协议的网络地址</li><li>Router1(config-router)#network 12.1.1.0</li></ul></li></ol><h4 id="8-2-2-验证RIPV1配置">8.2.2 验证RIPV1配置</h4><ol><li>显示路由表<ul><li>Router1#show ip route</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/8_1_2.png" alt="路由表"></li></ul></li><li>连通性测试：Router1和Router3的lo0接口之间可以相互通信</li></ol><h3 id="8-3-RIPV2">8.3 RIPV2</h3><h4 id="8-3-1-配置">8.3.1 配置</h4><ol><li>网络拓扑图（完成TCP/IP配置）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/8_2_1.png" alt="网络拓扑图8_2"></li></ul></li><li>路由器配置（以Router1为例）<ul><li>Router1(config)#interface lo0</li><li>Router1(config-if)#ip address 10.1.1.1 255.255.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#interface fa0/0</li><li>Router1(config-if)#no shutdown</li><li>Router1(config-if)#ip address 12.1.1.1 255.255.255.0</li><li>Router1(config-if)#exit</li><li>Router1(config)#router rip</li><li>Router1(config-router)#version 2 //设置RIP版本为2</li><li>Router1(config-router)#network 10.1.1.0</li><li>Router1(config-router)#network 12.1.1.0</li><li>Router1(config-router)#no auto-summary //关闭自动汇总</li></ul></li></ol><h4 id="8-3-2-验证RIPV2配置">8.3.2 验证RIPV2配置</h4><ol><li>显示路由表<ul><li>Router1#show ip route</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/8_2_2.png" alt="路由表"></li></ul></li><li>连通性测试：Router1和Router3的lo0接口之间可以相互通信</li></ol><div STYLE="page-break-after: always;"></div><h2 id="九-NAT">九. NAT</h2><h3 id="9-1-NAT">9.1 NAT</h3><p>NAT(Network Address Translation，网络地址转换)是一种将私有地址（RFC 1918）转换为公有地址的技术，用于解决IP地址不足的问题。</p><h4 id="9-1-1-NAT术语">9.1.1 NAT术语</h4><ul><li>内部本地IP地址：分配给内部网络中的主机的IP地址，通常这种地址来自RFC1918指定的私有地址空间。</li><li>内部全局IP地址：内部全局IP地址，对外代表一个或多个内部本地IP地址，通常这种地址来自全局惟一的地址空间，通常由ISP提供。</li><li>外部本地IP地址：在内部网络中看到的外部主机的IP地址，通常来自RFC 1918定义的私有地址空间。</li><li>外部全局IP地址：外部网络中的主机的IP地址，通常来自全局可路由的地址空间。</li></ul><h4 id="9-1-2-NAT分类">9.1.2 NAT分类</h4><ul><li>静态NAT：一对一映射，将一个内部IP地址映射到一个外部IP地址。</li><li>动态NAT：将内部IP地址动态转换为一组外部IP地址（IP地址池）中的一个。<ul><li>超载NAT：动态NAT的一种实现形式，利用不同端口号将多个内部IP地址转换为一个外部IP地址，也称为PAT、NAPT或端口复用NAT。</li></ul></li></ul><h3 id="9-2-NAT配置">9.2 NAT配置</h3><h4 id="9-2-1-网路拓扑图">9.2.1 网路拓扑图</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/9_0.png" alt="网络拓扑图"></p><p>完成PC机和服务器的TCP/IP配置</p><h4 id="9-2-2-路由器基础配置">9.2.2 路由器基础配置</h4><ol><li>Router1配置<ul><li>Router1(config)#interface fa0/0</li><li>Router1(config-if)#no shutdown</li><li>Router1(config-if)#ip address 10.1.1.1 255.255.255.0</li><li>Router1(config-if)#ip nat inside //内网接口</li><li>Router1(config-if)#exit</li><li>Router1(config)#interface fa0/1</li><li>Router1(config-if)#no shutdown</li><li>Router1(config-if)#ip address 2.2.2.1 255.255.255.0</li><li>Router1(config-if)#ip nat outside //外网接口</li><li>Router1(config-if)#exit</li><li>Router1(config)#ip route 0.0.0.0 0.0.0.0 2.2.2.2 //设置静态路由：内网主机可以通过Router1访问外网</li></ul></li><li>Router2配置<ul><li>fa0/0: 2.2.2.2/24</li><li>fa0/1: 1.1.1.1/24</li><li>外网不允许访问内网，无需配置静态路由</li></ul></li></ol><h4 id="9-2-3-静态NAT">9.2.3 静态NAT</h4><p>在Router1上设置静态NAT，使外网PC可以使用外网地址2.2.2.10访问内部服务器Server0的Web服务（仅80端口）</p><h5 id="配置静态NAT">配置静态NAT</h5><ul><li>Router1(config)#ip nat inside source static tcp 10.1.1.20 80 2.2.2.10 80 //设置静态NAT：内网服务器的80端口映射到外网地址的80端口</li></ul><h5 id="验证静态NAT">验证静态NAT</h5><ol><li>外网PC使用外网地址2.2.2.10访问内部服务器Server0的Web服务<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/9_1_2.png" alt="访问Web服务"></li></ul></li><li>显示NAT转换表<ul><li>Router1#show ip nat translations</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/9_1_1.png" alt="NAT转换表"></li></ul></li></ol><h4 id="9-2-4-动态NAT">9.2.4 动态NAT</h4><p>在Router1上设置动态NAT，使内网PC可以通过外网地址2.2.2.11-2.2.2.12访问外网服务器Server1的Web服务（仅80端口）</p><h5 id="配置动态NAT">配置动态NAT</h5><ul><li>Router1(config)#access-list 1 permit any //创建访问控制列表 1</li><li>Router1(config)#ip nat pool pool1 2.2.2.11 2.2.2.12 netmask 255.255.255.0 //创建IP地址池：ip nat pool &lt;名称&gt; &lt;起始地址&gt; &lt;结束地址&gt; netmask &lt;子网掩码&gt;</li><li>Router1(config)#ip nat inside source list 1 pool pool1 //设置动态NAT：ip nat inside source list &lt;访问控制列表&gt; pool &lt;IP地址池&gt;</li></ul><h5 id="验证动态NAT">验证动态NAT</h5><ol><li>内网PC使用外网地址1.1.1.10访问外网服务器Server1的Web服务<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/9_2_1.png" alt="访问Web服务"></li><li>由于IP地址池中只有2个地址，第3个内网主机无法访问外网</li></ul></li><li>显示NAT转换表<ul><li>Router1#show ip nat translations</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/9_2_2.png" alt="NAT转换表"></li></ul></li></ol><h3 id="9-3-NAPT">9.3 NAPT</h3><p>在Router1上设置动态NAPT。使内网PC可以通过外网地址2.2.2.15访问外网服务器</p><h4 id="配置NAPT">配置NAPT</h4><ul><li>Router1(config)#ip nat pool pool2 2.2.2.15 2.2.2.15 netmask 255.255.255.0</li><li>Router1(config)#ip nat inside source list 1 pool pool2 overload //overload: 超载，即NAPT</li></ul><h4 id="验证NAPT">验证NAPT</h4><ol><li>内网PC使用外网地址1.1.1.10访问外网服务器Server1的Web服务<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/9_3_1.png" alt="访问Web服务"></li></ul></li><li>显示NAT转换表<ul><li>Router1#show ip nat translations</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/9_3_2.png" alt="NAT转换表"></li></ul></li></ol><div STYLE="page-break-after: always;"></div><h2 id="十-ARP协议分析">十. ARP协议分析</h2><h3 id="10-1-ARP协议">10.1 ARP协议</h3><p>ARP（Address Resolution Protocol，地址解析协议）主要用于根据 IP 地址求出主机所对应的物理地址（MAC 地址）。</p><p>在网络通信中，主机和主机之间的通信需要根据 OSI 模型进行数据包的封装和解封装，这里面不仅需要封装源目的 IP 地址，也需要源目的 MAC 地址。</p><p>一般情况下，上层应用只知道 IP 地址，而并不关心 MAC 地址，所以就需要通过一个协议来获知目的 MAC 地址，完成数据的封装，这个协议就是 ARP 协议。</p><h4 id="ARP协议工作原理">ARP协议工作原理</h4><p>主机A已知目标主机B的IP地址，向主机B发送数据包时，需要知道目标主机B的MAC地址。</p><p>ARP协议工作原理如下：</p><ol><li>主机A在自己的ARP缓存表中查找目标主机B的MAC地址，如果找到则直接发送数据包。</li><li>如果ARP缓存表中没有目标主机B的MAC地址，则主机A向本地网络广播ARP请求报文，请求目标主机B的MAC地址。</li><li>目标主机B收到ARP请求报文后，向主机A发送ARP响应报文，包含自己的MAC地址。</li><li>主机A收到ARP响应报文后，将目标主机B的MAC地址存入ARP缓存表，并发送数据包。</li></ol><h3 id="10-2-ARP协议分析">10.2 ARP协议分析</h3><p>以管理员身份启动cmd：</p><ul><li>查看ARP缓存表：arp -a</li><li>清空ARP缓存表：arp -d</li><li>删除指定ARP缓存：arp -d &lt;IP地址&gt;</li></ul><ol><li>打开Wireshark，在捕获选项中设置过滤器为“arp”。</li><li>开始抓取数据。</li><li>以管理员身份启动cmd，清空ARP缓存表并等待一段时间。</li><li>结束抓取数据。</li><li>选择一对ARP请求和响应报文，进行分析。</li></ol><p>以ARP请求报文为例，具体数据包如下图：</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/10_1.png" alt="ARP请求报文"></p><p>数据链路层数据帧：</p><table><thead><tr><th>字段</th><th>长度(bit)</th><th>说明</th><th>ARP Request</th><th>ARP Reply</th></tr></thead><tbody><tr><td>Destination</td><td>48</td><td>目的MAC地址</td><td>ff:ff:ff:ff:ff:ff(广播地址)</td><td>08:xx:xx:xx:xx:ae(发送方MAC地址)</td></tr><tr><td>Source</td><td>48</td><td>源MAC地址</td><td>08:xx:xx:xx:xx:ae(发送方MAC地址)</td><td>d8:xx:xx:xx:xx:d5(目标MAC地址)</td></tr><tr><td>Type</td><td>16</td><td>类型</td><td>0x0806(ARP)</td><td>0x0806(ARP)</td></tr></tbody></table><p>ARP数据帧：</p><table><thead><tr><th>字段</th><th>长度(bit)</th><th>说明</th><th>ARP Request</th><th>ARP Reply</th></tr></thead><tbody><tr><td>Hardware Type</td><td>16</td><td>硬件类型，标识链路层协议</td><td>0x0001(以太网)</td><td>0x0001(以太网)</td></tr><tr><td>Protocol Type</td><td>16</td><td>协议类型，标识网络层协议</td><td>0x0800(IPv4)</td><td>0x0800(IPv4)</td></tr><tr><td>Hardware Size</td><td>8</td><td>硬件地址大小，标识MAC地址长度</td><td>0x06(6B=48bit)</td><td>0x06(6B=48bit)</td></tr><tr><td>Protocol Size</td><td>8</td><td>协议地址大小，标识IP地址长度</td><td>0x04(4B=32bit)</td><td>0x04(4B=32bit)</td></tr><tr><td>Opcode</td><td>16</td><td>操作码，标识ARP请求或响应</td><td>0x0001(ARP Request)</td><td>0x0002(ARP Reply)</td></tr><tr><td>Sender MAC Address</td><td>48</td><td>发送方MAC地址</td><td>08:xx:xx:xx:xx:ae</td><td>d8:xx:xx:xx:xx:d5(目标MAC地址)</td></tr><tr><td>Sender IP Address</td><td>32</td><td>发送方IP地址</td><td>10.234.172.214</td><td>10.234.0.1</td></tr><tr><td>Target MAC Address</td><td>48</td><td>目标MAC地址</td><td>00:00:00:00:00:00(待填充)</td><td>08:xx:xx:xx:xx:ae(发送方MAC地址)</td></tr><tr><td>Target IP Address</td><td>32</td><td>目标IP地址</td><td>10.234.0.1</td><td>10.234.172.214</td></tr></tbody></table><div STYLE="page-break-after: always;"></div><h2 id="十一-TCP协议分析">十一. TCP协议分析</h2><h3 id="11-1-TCP协议">11.1 TCP协议</h3><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>UDP（User Datagram Protocol，用户数据报协议）是一种无连接的、不可靠的、基于数据报的传输层通信协议。</p><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠传输，使用流量控制和拥塞控制</td><td>不可靠传输，不使用拥塞控制</td></tr><tr><td>连接对象个数</td><td>一对一</td><td>一对一、一对多、多对多</td></tr><tr><td>传输方式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>首部开销</td><td>20字节~60字节</td><td>8字节</td></tr><tr><td>适用场景</td><td>需要可靠传输的场景，例如文件传输</td><td>传输速度、实时性要求高的场景</td></tr></tbody></table><p>TCP协议工作流程：</p><ol><li>建立连接：三次握手<ol><li>发起方向接收方发送SYN报文，请求建立连接</li><li>接收方收到SYN报文后，回复SYN+ACK报文，表示同意建立连接</li><li>发起方收到SYN+ACK报文后，回复ACK报文，表示连接建立成功</li><li>三次握手完成，连接建立成功</li></ol></li><li>数据传输：数据传输阶段</li><li>断开连接：四次挥手<ol><li>发起方向接收方发送FIN报文，请求断开连接</li><li>接收方收到FIN报文后，回复ACK报文，表示收到断开请求</li><li>接收方向发起方发送FIN报文，请求断开连接</li><li>发起方收到FIN报文后，回复ACK报文，表示收到断开请求</li><li>四次挥手完成，连接断开成功</li></ol></li></ol><ul><li>谁想建立或断开连接，谁就是发起方。发起方可以是客户端，也可以是服务器端，</li></ul><h3 id="11-2-TCP协议分析">11.2 TCP协议分析</h3><p>以访问10.21.11.21为例，分析TCP协议的工作流程。</p><ol><li>打开Wireshark，在捕获选项中设置过滤器为“http and ip.addr==10.21.11.21”。</li><li>开始抓取数据。</li><li>打开浏览器，在地址栏中输入“10.21.11.21”，回车访问，等待加载完成后关闭浏览器。</li><li>结束抓取数据。</li><li>选中一条访问10.21.11.21的HTTP记录，右键，追踪TPC流。</li><li>观察TPC流是否包含完整的TPC访问过程（三次握手，四次挥手）。</li></ol><p>TCP数据包示例如下：</p><p><img src="https://source.cclmsy.cc/Posts/Course/computer_networks_and_communications_lab/11_1.png" alt="TCP数据包"></p><h4 id="TCP报文格式">TCP报文格式</h4><table><thead><tr><th>字段</th><th>长度(bit)</th><th>说明</th></tr></thead><tbody><tr><td>Source Port</td><td>16</td><td>源端口号</td></tr><tr><td>Destination Port</td><td>16</td><td>目的端口号</td></tr><tr><td>Sequence Number</td><td>32</td><td>本报文段发送的数据组的第一个字节的序号</td></tr><tr><td>ACK Number</td><td>32</td><td>确认号，期望收到对方下一个报文段的第一个字节的序号，表明该序号之前的所有数据已经正确无误的收到</td></tr><tr><td>Header Length</td><td>4</td><td>报文头长度，指示TCP头部的长度，即数据区在报文段中的起始偏移值（字节）。偏移值=4*Header Length</td></tr><tr><td>Reserved</td><td>6</td><td>保留字段，未使用</td></tr><tr><td>Flags</td><td>6</td><td>标志位，按顺序为：URG、ACK、PSH、RST、SYN、FIN</td></tr><tr><td>Window Size</td><td>16</td><td>窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制</td></tr><tr><td>TCP Checksum</td><td>16</td><td>校验和，用于检验TCP头部和数据的完整性</td></tr><tr><td>Urgent Pointer</td><td>16</td><td>紧急指针，TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</td></tr><tr><td>Options</td><td>0-320</td><td>可选字段，用于扩展TCP头部。最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size）（在第一个TCP报文）。选项长度不一定是32位的整数倍，所以要加填充位</td></tr></tbody></table><h4 id="TCP三次握手">TCP三次握手</h4><table><thead><tr><th>字段</th><th>第一次握手[SYN]</th><th>第二次握手[SYN, ACK]</th><th>第三次握手[ACK]</th></tr></thead><tbody><tr><td>Source Port</td><td>0xcf75(53109)</td><td>0x0050(80)</td><td>0xcf75(53109)</td></tr><tr><td>Destination Port</td><td>0x0050(80)</td><td>0xcf75(53109)</td><td>0x0050(80)</td></tr><tr><td>Sequence Number</td><td>0xc01d24d3(0)</td><td>0xabbe9051(0)</td><td>0xc01d24d4(1)</td></tr><tr><td>ACK Number</td><td>0x00000000(0)</td><td>0xc01d24d4(1)</td><td>0xabbe9052(1)</td></tr><tr><td>Header Length</td><td>0x8(32)</td><td>0x8(32)</td><td>0x5(20)</td></tr><tr><td>Reserved</td><td>0x00</td><td>0x00</td><td>0x00</td></tr><tr><td>Flags</td><td>0x002(SYN)</td><td>0x012(SYN, ACK)</td><td>0x010(ACK)</td></tr><tr><td>Window Size</td><td>0xfaf0(64240)</td><td>0x4000(16384)</td><td>0x0201(513)</td></tr></tbody></table><h4 id="TCP四次挥手">TCP四次挥手</h4><table><thead><tr><th>字段</th><th>第一次挥手[FIN, ACK]</th><th>第二次挥手[ACK]</th><th>第三次挥手[FIN, ACK]</th><th>第四次挥手[ACK]</th></tr></thead><tbody><tr><td>Source Port</td><td>0x0050(80)</td><td>0xcf75(53109)</td><td>0x0050(80)</td><td>0xcf75(53109)</td></tr><tr><td>Destination Port</td><td>0xcf75(53109)</td><td>0x0050(80)</td><td>0xcf75(53109)</td><td>0x0050(80)</td></tr><tr><td>Sequence Number</td><td>0xabbe9194(323)</td><td>0xc01d26e6(531)</td><td>0xc01d26e6(531)</td><td>0xabbe9195(324)</td></tr><tr><td>ACK Number</td><td>0xc01d26e6(531)</td><td>0xabbe9195(324)</td><td>0xabbe9195(324)</td><td>0xc01d26e7(532)</td></tr><tr><td>Header Length</td><td>0x5(20)</td><td>0x5(20)</td><td>0x5(20)</td><td>0x5(20)</td></tr><tr><td>Reserved</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td></tr><tr><td>Flags</td><td>0x011(FIN, ACK)</td><td>0x010(ACK)</td><td>0x011(FIN, ACK)</td><td>0x010(ACK)</td></tr><tr><td>Window Size</td><td>0xfeed(65005)</td><td>0x0200(513)</td><td>0x0200(513)</td><td>0xfeed(65005)</td></tr></tbody></table><div STYLE="page-break-after: always;"></div><h2 id="附录-实验涉及命令行汇总">附录. 实验涉及命令行汇总</h2><h3 id="1-PC机-终端">1. PC机 终端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all # 查看IP配置</span><br><span class="line">ping &lt;IP地址&gt; # 测试连通性</span><br></pre></td></tr></table></figure><h3 id="2-交换机Switch-命令行">2. 交换机Switch 命令行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Switch&gt;enable # 进入特权模式</span><br><span class="line">Switch#configure terminal # 进入全局配置模式</span><br><span class="line">Switch(config)#hostname Switch # 设置交换机主机名</span><br><span class="line">Switch(config)#exit # 退回上一级模式</span><br><span class="line">Switch(config)#end # 退回特权模式</span><br><span class="line"></span><br><span class="line"># 显示</span><br><span class="line">Switch#show vlan brief # 显示VLAN信息</span><br><span class="line">Switch#show interfaces # 显示接口信息</span><br><span class="line">Switch#show interfaces trunk # 显示trunk接口信息</span><br><span class="line"></span><br><span class="line"># VLAN</span><br><span class="line">Switch(config)#vlan &lt;VLAN号&gt; # 创建VLAN并进入VLAN配置模式</span><br><span class="line">Switch(config)#interface vlan &lt;VLAN号&gt; # 进入VLAN配置模式</span><br><span class="line"></span><br><span class="line"># 接口</span><br><span class="line">Switch(config)#interface &lt;接口号&gt; # 进入接口配置模式</span><br><span class="line">Switch(config)#interface &lt;接口号&gt;-&lt;接口号&gt; # 进入接口范围配置模式</span><br><span class="line">Switch(config-if)#switchport mode access # 设置接口为access</span><br><span class="line">Switch(config-if)#switchport access vlan &lt;VLAN号&gt; # 设置access接口所属VLAN</span><br><span class="line">Switch(config-if)#switchport mode trunk # 设置接口为trunk</span><br><span class="line"></span><br><span class="line"># MAC地址绑定</span><br><span class="line">Switch#show mac-address-table # 查看MAC地址表</span><br><span class="line">Switch#show mac-address-table aging-time # 查看MAC地址表老化时间</span><br><span class="line">Switch(config-if)#mac-address-table static &lt;MAC地址&gt; vlan &lt;VLAN号&gt; interface &lt;接口号&gt; # 设置静态MAC地址绑定</span><br><span class="line">Switch(config-if)#no mac-address-table static &lt;MAC地址&gt; vlan &lt;VLAN号&gt; interface &lt;接口号&gt; # 删除静态MAC地址绑定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-路由器Router-命令行">3. 路由器Router 命令行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;enable # 进入特权模式</span><br><span class="line">Router#configure terminal # 进入全局配置模式</span><br><span class="line">Router(config)#hostname Router # 设置路由器主机名</span><br><span class="line">Router(config)#exit # 退回上一级模式</span><br><span class="line">Router(config)#end # 退回特权模式</span><br><span class="line"></span><br><span class="line"># 显示</span><br><span class="line">Router#show ip route # 显示路由表</span><br><span class="line">Router#show ip interface brief # 显示接口IP信息</span><br><span class="line">Router#show ip interface &lt;接口号&gt; # 显示指定接口信息</span><br><span class="line">Router#show ip nat translations # 显示NAT转换表</span><br><span class="line"></span><br><span class="line"># 接口</span><br><span class="line">Router(config)#interface &lt;接口号&gt; # 进入接口配置模式</span><br><span class="line">Router(config-if)#no shutdown # 激活接口</span><br><span class="line">Router(config-if)#ip address &lt;IP地址&gt; &lt;子网掩码&gt; # 设置接口IP地址</span><br><span class="line"></span><br><span class="line"># VLAN</span><br><span class="line">Router(config)#interface &lt;接口号&gt;.&lt;子接口号&gt; # 进入子接口配置模式（接口需激活）</span><br><span class="line">Router(config-subif)#encapsulation dot1Q &lt;VLAN号&gt; # 封装VLAN协议（802.1Q），设置子接口所属VLAN</span><br><span class="line">Router(config-subif)#ip address &lt;IP地址&gt; &lt;子网掩码&gt; # 设置子接口IP地址</span><br><span class="line"></span><br><span class="line"># 路由</span><br><span class="line">Router(config)#ip route &lt;目的网络&gt; &lt;子网掩码&gt; &lt;下一跳地址&gt; # 设置静态路由</span><br><span class="line"></span><br><span class="line">Router(config)#router rip # 进入RIP协议配置模式</span><br><span class="line">Router(config-router)#version &lt;版本号&gt; # 设置RIP版本</span><br><span class="line">Router(config-router)#network &lt;网络地址&gt; # 设置RIP协议的网络地址</span><br><span class="line"></span><br><span class="line"># NAT</span><br><span class="line">Router(config)#ip nat inside source static tcp &lt;内网IP地址&gt; &lt;内网端口&gt; &lt;外网IP地址&gt; &lt;外网端口&gt; # 设置静态NAT</span><br><span class="line"></span><br><span class="line">Router(config)#access-list &lt;访问控制列表号&gt; permit any # 创建访问控制列表</span><br><span class="line">Router(config)#ip nat pool &lt;IP地址池名称&gt; &lt;起始地址&gt; &lt;结束地址&gt; netmask &lt;子网掩码&gt; # 创建IP地址池</span><br><span class="line">Router(config)#ip nat inside source list &lt;访问控制列表号&gt; pool &lt;IP地址池名称&gt; # 设置动态NAT</span><br><span class="line">Router(config)#ip nat inside source list &lt;访问控制列表号&gt; pool &lt;IP地址池名称&gt; overload # 设置NAPT</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树（最值）</title>
      <link href="/posts/seg_tree_bv.html"/>
      <url>/posts/seg_tree_bv.html</url>
      
        <content type="html"><![CDATA[<h2 id="线段树（最值）">线段树（最值）</h2><p>实现的功能：区间加、区间赋最值、区间和查询、区间最值查询</p><p>时间复杂度：单次操作O(log^2(n))</p><p>N5e5,Q5e5-&gt;LOJ 1.2s/200MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MxSegTree</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data</span>&#123;</span><br><span class="line">        ll mx,mx2,cntmax,lazymax; <span class="comment">//最大值，次大值，最大值个数，最大值标记</span></span><br><span class="line">        ll mn,mn2,cntmin,lazymin; <span class="comment">//最小值，次小值，最小值个数，最小值标记</span></span><br><span class="line">        ll lazyadd,sum; <span class="comment">// 增加标记，区间和</span></span><br><span class="line">        <span class="built_in">data</span>()&#123;mx=mx2=-INF;mn=mn2=INF;cntmax=cntmin=<span class="number">0</span>;lazymax=-INF;lazymin=INF;lazyadd=<span class="number">0</span>;sum=<span class="number">0</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;data&gt; tree;</span><br><span class="line">    vector&lt;ll&gt; *arr;</span><br><span class="line">    <span class="type">long</span> n,n5,root,end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_add</span><span class="params">(ll cl, ll cr, ll p,ll v)</span></span>&#123;</span><br><span class="line">        tree[p].sum += (cr - cl + <span class="number">1</span>) * v;</span><br><span class="line">        tree[p].mx += v, tree[p].mn += v;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].mx2 != -INF) tree[p].mx2 += v;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].mn2 != INF) tree[p].mn2 += v;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].lazymax != -INF) tree[p].lazymax += v;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].lazymin != INF) tree[p].lazymin += v;</span><br><span class="line">        tree[p].lazyadd += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_min</span><span class="params">(ll p, ll tg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].mx &lt;= tg) <span class="keyword">return</span>;</span><br><span class="line">        tree[p].sum += (tg * <span class="number">1ll</span> - tree[p].mx) * tree[p].cntmax;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].mn2 == tree[p].mx) tree[p].mn2 = tg;  </span><br><span class="line">        <span class="keyword">if</span> (tree[p].mn == tree[p].mx) tree[p].mn = tg;  </span><br><span class="line">        <span class="keyword">if</span> (tree[p].lazymax &gt; tg) tree[p].lazymax = tg; </span><br><span class="line">        tree[p].mx = tg, tree[p].lazymin = tg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_max</span><span class="params">(ll p, ll tg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].mn &gt; tg) <span class="keyword">return</span>;</span><br><span class="line">        tree[p].sum += (tg * <span class="number">1ll</span> - tree[p].mn) * tree[p].cntmin;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].mx2 == tree[p].mn) tree[p].mx2 = tg;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].mx == tree[p].mn) tree[p].mx = tg;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].lazymin &lt; tg) tree[p].lazymin = tg;</span><br><span class="line">        tree[p].mn = tg, tree[p].lazymax = tg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用子节点维护当前节点信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">        tree[p].sum = tree[p * <span class="number">2</span>].sum + tree[p * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line">        <span class="keyword">if</span> (tree[p * <span class="number">2</span>].mx == tree[p * <span class="number">2</span> + <span class="number">1</span>].mx) &#123;</span><br><span class="line">            tree[p].mx = tree[p * <span class="number">2</span>].mx, tree[p].cntmax = tree[p * <span class="number">2</span>].cntmax + tree[p * <span class="number">2</span> + <span class="number">1</span>].cntmax;</span><br><span class="line">            tree[p].mx2 = <span class="built_in">max</span>(tree[p * <span class="number">2</span>].mx2, tree[p * <span class="number">2</span> + <span class="number">1</span>].mx2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree[p * <span class="number">2</span>].mx &gt; tree[p * <span class="number">2</span> + <span class="number">1</span>].mx) &#123;</span><br><span class="line">            tree[p].mx = tree[p * <span class="number">2</span>].mx, tree[p].cntmax = tree[p * <span class="number">2</span>].cntmax;</span><br><span class="line">            tree[p].mx2 = <span class="built_in">max</span>(tree[p * <span class="number">2</span>].mx2, tree[p * <span class="number">2</span> + <span class="number">1</span>].mx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tree[p].mx = tree[p * <span class="number">2</span> + <span class="number">1</span>].mx, tree[p].cntmax = tree[p * <span class="number">2</span> + <span class="number">1</span>].cntmax;</span><br><span class="line">            tree[p].mx2 = <span class="built_in">max</span>(tree[p * <span class="number">2</span>].mx, tree[p * <span class="number">2</span> + <span class="number">1</span>].mx2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[p * <span class="number">2</span>].mn == tree[p * <span class="number">2</span> + <span class="number">1</span>].mn) &#123;</span><br><span class="line">            tree[p].mn = tree[p * <span class="number">2</span>].mn, tree[p].cntmin = tree[p * <span class="number">2</span>].cntmin + tree[p * <span class="number">2</span> + <span class="number">1</span>].cntmin;</span><br><span class="line">            tree[p].mn2 = <span class="built_in">min</span>(tree[p * <span class="number">2</span>].mn2, tree[p * <span class="number">2</span> + <span class="number">1</span>].mn2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree[p * <span class="number">2</span>].mn &lt; tree[p * <span class="number">2</span> + <span class="number">1</span>].mn) &#123;</span><br><span class="line">            tree[p].mn = tree[p * <span class="number">2</span>].mn, tree[p].cntmin = tree[p * <span class="number">2</span>].cntmin;</span><br><span class="line">            tree[p].mn2 = <span class="built_in">min</span>(tree[p * <span class="number">2</span>].mn2, tree[p * <span class="number">2</span> + <span class="number">1</span>].mn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tree[p].mn = tree[p * <span class="number">2</span> + <span class="number">1</span>].mn, tree[p].cntmin = tree[p * <span class="number">2</span> + <span class="number">1</span>].cntmin;</span><br><span class="line">            tree[p].mn2 = <span class="built_in">min</span>(tree[p * <span class="number">2</span>].mn, tree[p * <span class="number">2</span> + <span class="number">1</span>].mn2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下放标记</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(ll cl, ll cr, ll p)</span> </span>&#123; </span><br><span class="line">        ll cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].lazyadd) <span class="built_in">push_add</span>(cl, cm, p * <span class="number">2</span>, tree[p].lazyadd), <span class="built_in">push_add</span>(cm + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>, tree[p].lazyadd);</span><br><span class="line">        <span class="keyword">if</span>(tree[p].lazymax != -INF) <span class="built_in">push_max</span>(p * <span class="number">2</span>, tree[p].lazymax), <span class="built_in">push_max</span>(p * <span class="number">2</span> + <span class="number">1</span>, tree[p].lazymax);</span><br><span class="line">        <span class="keyword">if</span>(tree[p].lazymin != INF) <span class="built_in">push_min</span>(p * <span class="number">2</span>, tree[p].lazymin), <span class="built_in">push_min</span>(p * <span class="number">2</span> + <span class="number">1</span>, tree[p].lazymin);</span><br><span class="line">        tree[p].lazyadd = <span class="number">0</span>, tree[p].lazymax = -INF, tree[p].lazymin = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll s, ll t, ll p)</span> </span>&#123;</span><br><span class="line">        tree[p].lazymax = -INF, tree[p].lazymin = INF;</span><br><span class="line">        <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">            tree[p].sum = tree[p].mx = tree[p].mn = (*arr)[s];</span><br><span class="line">            tree[p].mx2 = -INF, tree[p].mn2 = INF;</span><br><span class="line">            tree[p].cntmax = tree[p].cntmin = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll m = s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(s, m, p * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_add</span><span class="params">(ll l, ll r, ll v, ll cl, ll cr, ll p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cl &gt; r || cr &lt; l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> <span class="built_in">push_add</span>(cl, cr, p, v);</span><br><span class="line">        ll cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push_down</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cm) <span class="built_in">range_add</span>(l, r, v, cl, cm, p * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; cm) <span class="built_in">range_add</span>(l, r, v, cm + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_min</span><span class="params">(ll l, ll r, ll v, ll cl, ll cr, ll p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cl &gt; r || cr &lt; l || tree[p].mx &lt;= v) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r &amp;&amp; tree[p].mx2 &lt; v) <span class="keyword">return</span> <span class="built_in">push_min</span>(p, v);</span><br><span class="line">        ll cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push_down</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cm) <span class="built_in">range_min</span>(l, r, v, cl, cm, p * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; cm) <span class="built_in">range_min</span>(l, r, v, cm + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_max</span><span class="params">(ll l, ll r, ll v, ll cl, ll cr, ll p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cl &gt; r || cr &lt; l || tree[p].mn &gt;= v) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r &amp;&amp; tree[p].mn2 &gt; v) <span class="keyword">return</span> <span class="built_in">push_max</span>(p, v);</span><br><span class="line">        ll cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push_down</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cm) <span class="built_in">range_max</span>(l, r, v, cl, cm, p * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; cm) <span class="built_in">range_max</span>(l, r, v, cm + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ll <span class="title">query_sum</span><span class="params">(ll l, ll r, ll cl, ll cr, ll p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cl &gt; r || cr &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">        ll cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">push_down</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cm) sum += <span class="built_in">query_sum</span>(l, r, cl, cm, p * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; cm) sum += <span class="built_in">query_sum</span>(l, r, cm + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query_max</span><span class="params">(ll l, ll r, ll cl, ll cr, ll p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cl &gt; r || cr &lt; l) <span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> tree[p].mx;</span><br><span class="line">        ll cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        ll mx = -INF;</span><br><span class="line">        <span class="built_in">push_down</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cm) mx = <span class="built_in">max</span>(mx, <span class="built_in">query_max</span>(l, r, cl, cm, p * <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; cm) mx = <span class="built_in">max</span>(mx, <span class="built_in">query_max</span>(l, r, cm + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query_min</span><span class="params">(ll l, ll r, ll cl, ll cr, ll p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cl &gt; r || cr &lt; l) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> tree[p].mn;</span><br><span class="line">        ll cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        ll mn = INF;</span><br><span class="line">        <span class="built_in">push_down</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cm) mn = <span class="built_in">min</span>(mn, <span class="built_in">query_min</span>(l, r, cl, cm, p * <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; cm) mn = <span class="built_in">min</span>(mn, <span class="built_in">query_min</span>(l, r, cm + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> mn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MxSegTree</span><span class="params">(vector&lt;ll&gt; v)</span> </span>&#123;</span><br><span class="line">        n = v.<span class="built_in">size</span>();</span><br><span class="line">        n5 = n * <span class="number">5</span>;</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        root = <span class="number">1</span>;</span><br><span class="line">        arr = &amp;v;</span><br><span class="line">        tree.<span class="built_in">resize</span>(n5);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">0</span>, end, <span class="number">1</span>);</span><br><span class="line">        arr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间加，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_add</span><span class="params">(ll l, ll r, ll v)</span> </span>&#123; <span class="built_in">range_add</span>(l, r, v, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">    <span class="comment">// 区间内和k取min，O(log^2(n))</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_min</span><span class="params">(ll l, ll r, ll v)</span> </span>&#123; <span class="built_in">range_min</span>(l, r, v, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">    <span class="comment">// 区间内和k取max，O(log^2(n))</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_max</span><span class="params">(ll l, ll r, ll v)</span> </span>&#123; <span class="built_in">range_max</span>(l, r, v, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">    <span class="comment">// 查询区间和，O(logn)</span></span><br><span class="line">    <span class="function">ll <span class="title">query_sum</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query_sum</span>(l, r, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">    <span class="comment">// 查询区间最大值，O(logn)</span></span><br><span class="line">    <span class="function">ll <span class="title">query_max</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query_max</span>(l, r, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">    <span class="comment">// 查询区间最小值，O(logn)</span></span><br><span class="line">    <span class="function">ll <span class="title">query_min</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query_min</span>(l, r, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ll n,q;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:v) cin &gt;&gt; i;</span><br><span class="line">    <span class="function">MxSegTree <span class="title">st</span><span class="params">(v)</span></span>;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    ll op,x,y,k;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            st.<span class="built_in">range_add</span>(x<span class="number">-1</span>,y<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            st.<span class="built_in">range_max</span>(x<span class="number">-1</span>,y<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            st.<span class="built_in">range_min</span>(x<span class="number">-1</span>,y<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; st.<span class="built_in">query_sum</span>(x<span class="number">-1</span>,y<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; st.<span class="built_in">query_max</span>(x<span class="number">-1</span>,y<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; st.<span class="built_in">query_min</span>(x<span class="number">-1</span>,y<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树（加/乘/改）</title>
      <link href="/posts/seg_tree_plus.html"/>
      <url>/posts/seg_tree_plus.html</url>
      
        <content type="html"><![CDATA[<h2 id="线段树（加-乘-改）">线段树（加/乘/改）</h2><p>实现的功能：（取模）区间加、区间乘、区间直接修改、区间和查询</p><p>时间复杂度：单次操作O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegTree</span>&#123;</span><br><span class="line">    vector&lt;ll&gt; tree, lazyadd, lazymul, lazyset;</span><br><span class="line">    <span class="comment">//lazy标记：打上Lazy标记的节点，值已经被更新，只是还没有更新到子节点</span></span><br><span class="line">    vector&lt;ll&gt; *arr;</span><br><span class="line">    <span class="type">int</span> n, root, n4, end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护当前节点的信息和Lazy，O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> cl, <span class="type">int</span> cr, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl != cr) &#123;<span class="comment">//cl==cr：叶子节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(lazymul[p]!=<span class="number">1</span>)&#123; <span class="comment">//区间乘法</span></span><br><span class="line">                <span class="built_in">multo</span>(lazymul[p * <span class="number">2</span>],lazymul[p]); <span class="comment">//lazymul[p * 2] *= lazymul[p];</span></span><br><span class="line">                <span class="built_in">multo</span>(lazymul[p * <span class="number">2</span> + <span class="number">1</span>],lazymul[p]); <span class="comment">//lazymul[p * 2 + 1] *= lazymul[p];</span></span><br><span class="line">                <span class="built_in">multo</span>(lazyadd[p * <span class="number">2</span>],lazymul[p]); <span class="comment">//lazyadd[p * 2] *= lazymul[p];</span></span><br><span class="line">                <span class="built_in">multo</span>(lazyadd[p * <span class="number">2</span> + <span class="number">1</span>],lazymul[p]); <span class="comment">//lazyadd[p * 2 + 1] *= lazymul[p];</span></span><br><span class="line">                <span class="built_in">multo</span>(tree[p * <span class="number">2</span>],lazymul[p]); <span class="comment">//tree[p * 2] *= lazymul[p];</span></span><br><span class="line">                <span class="built_in">multo</span>(tree[p * <span class="number">2</span> + <span class="number">1</span>],lazymul[p]); <span class="comment">//tree[p * 2 + 1] *= lazymul[p];</span></span><br><span class="line">                lazymul[p] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(lazyadd[p])&#123; <span class="comment">//区间增量</span></span><br><span class="line">                <span class="built_in">addto</span>(lazyadd[p * <span class="number">2</span>],lazyadd[p]); <span class="comment">//lazyadd[p * 2] += lazyadd[p];</span></span><br><span class="line">                <span class="built_in">addto</span>(lazyadd[p * <span class="number">2</span> + <span class="number">1</span>],lazyadd[p]); <span class="comment">//lazyadd[p * 2 + 1] += lazyadd[p];</span></span><br><span class="line">                <span class="built_in">addto</span>(tree[p * <span class="number">2</span>],lazyadd[p] * (cm - cl + <span class="number">1</span>)); <span class="comment">//tree[p * 2] += lazyadd[p] * (cm - cl + 1);</span></span><br><span class="line">                <span class="built_in">addto</span>(tree[p * <span class="number">2</span> + <span class="number">1</span>],lazyadd[p] * (cr - cm)); <span class="comment">//tree[p * 2 + 1] += lazyadd[p] * (cr - cm);</span></span><br><span class="line">                lazyadd[p] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(lazyset[p])&#123; <span class="comment">//区间直接修改</span></span><br><span class="line">                lazyset[p * <span class="number">2</span>] = <span class="built_in">Get_Mod</span>(lazyset[p]); <span class="comment">//lazyset[p * 2] = lazyset[p];</span></span><br><span class="line">                lazyset[p * <span class="number">2</span> + <span class="number">1</span>] = <span class="built_in">Get_Mod</span>(lazyset[p]); <span class="comment">//lazyset[p * 2 + 1] = lazyset[p];</span></span><br><span class="line">                tree[p * <span class="number">2</span>] = <span class="built_in">Get_Mod</span>(lazyset[p] * (cm - cl + <span class="number">1</span>)); <span class="comment">//tree[p * 2] = lazyset[p] * (cm - cl + 1);</span></span><br><span class="line">                tree[p * <span class="number">2</span> + <span class="number">1</span>] = <span class="built_in">Get_Mod</span>(lazyset[p] * (cr - cm)); <span class="comment">//tree[p * 2 + 1] = lazyset[p] * (cr - cm);</span></span><br><span class="line">                lazyset[p] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [l, r] 为查询区间, [cl, cr] 为当前节点包含的区间, p 为当前节点的编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间乘法，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_mul</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll val, <span class="type">int</span> cl, <span class="type">int</span> cr, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) &#123;</span><br><span class="line">            <span class="built_in">multo</span>(lazyadd[p],val); <span class="comment">//lazyadd[p] *= val;</span></span><br><span class="line">            <span class="built_in">multo</span>(tree[p],val); <span class="comment">//tree[p] *= val;</span></span><br><span class="line">            <span class="built_in">multo</span>(lazymul[p],val); <span class="comment">//lazymul[p] *= val;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">maintain</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) <span class="built_in">range_mul</span>(l, r, val, cl, m, p * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) <span class="built_in">range_mul</span>(l, r, val, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tree[p] = <span class="built_in">add</span>(tree[p * <span class="number">2</span>],tree[p * <span class="number">2</span> + <span class="number">1</span>]); <span class="comment">//tree[p] = tree[p * 2] + tree[p * 2 + 1];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间增量，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll val, <span class="type">int</span> cl, <span class="type">int</span> cr, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) &#123;</span><br><span class="line">            <span class="built_in">addto</span>(lazyadd[p],val); <span class="comment">//lazyadd[p] += val;</span></span><br><span class="line">            <span class="built_in">addto</span>(tree[p],(cr - cl + <span class="number">1</span>) * val); <span class="comment">//tree[p] += (cr - cl + 1) * val;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">maintain</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) <span class="built_in">range_add</span>(l, r, val, cl, m, p * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) <span class="built_in">range_add</span>(l, r, val, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tree[p] = <span class="built_in">add</span>(tree[p * <span class="number">2</span>],tree[p * <span class="number">2</span> + <span class="number">1</span>]); <span class="comment">//tree[p] = tree[p * 2] + tree[p * 2 + 1];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间直接修改，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_set</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll val, <span class="type">int</span> cl, <span class="type">int</span> cr, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) &#123;</span><br><span class="line">            lazyset[p] = <span class="built_in">Get_Mod</span>(val); <span class="comment">//lazyset[p] = val;</span></span><br><span class="line">            tree[p] = <span class="built_in">Get_Mod</span>(val * (cr - cl + <span class="number">1</span>)); <span class="comment">//tree[p] = val * (cr - cl + 1);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">maintain</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) <span class="built_in">range_set</span>(l, r, val, cl, m, p * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) <span class="built_in">range_set</span>(l, r, val, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tree[p] = <span class="built_in">add</span>(tree[p * <span class="number">2</span>],tree[p * <span class="number">2</span> + <span class="number">1</span>]); <span class="comment">//tree[p] = tree[p * 2] + tree[p * 2 + 1];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询区间和，O(logn)</span></span><br><span class="line">    <span class="function">ll <span class="title">range_sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> cl, <span class="type">int</span> cr, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="type">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">maintain</span>(cl, cr, p);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) <span class="comment">//sum += range_sum(l, r, cl, m, p * 2);</span></span><br><span class="line">            sum = <span class="built_in">add</span>(sum,<span class="built_in">range_sum</span>(l, r, cl, m, p * <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) <span class="comment">//sum += range_sum(l, r, m + 1, cr, p * 2 + 1);</span></span><br><span class="line">            sum = <span class="built_in">add</span>(sum,<span class="built_in">range_sum</span>(l, r, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建树，O(n)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">            tree[p] = <span class="built_in">Get_Mod</span>((*arr)[s]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(s, m, p * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tree[p] = <span class="built_in">add</span>(tree[p * <span class="number">2</span>],tree[p * <span class="number">2</span> + <span class="number">1</span>]); <span class="comment">//tree[p] = tree[p * 2] + tree[p * 2 + 1];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SegTree</span><span class="params">(vector&lt;ll&gt; v)</span> </span>&#123;</span><br><span class="line">        n = v.<span class="built_in">size</span>();</span><br><span class="line">        n4 = n * <span class="number">4</span>;</span><br><span class="line">        tree = <span class="built_in">vector</span>&lt;ll&gt;(n4, <span class="number">0</span>);</span><br><span class="line">        lazyadd = <span class="built_in">vector</span>&lt;ll&gt;(n4, <span class="number">0</span>);</span><br><span class="line">        lazymul = <span class="built_in">vector</span>&lt;ll&gt;(n4, <span class="number">1</span>);</span><br><span class="line">        lazyset = <span class="built_in">vector</span>&lt;ll&gt;(n4, <span class="number">0</span>);</span><br><span class="line">        arr = &amp;v;</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        root = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">0</span>, end, <span class="number">1</span>);</span><br><span class="line">        arr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询区间和，O(logn)</span></span><br><span class="line">    <span class="function">ll <span class="title">range_sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">range_sum</span>(l, r, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">    <span class="comment">// 区间乘法，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_mul</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll val)</span> </span>&#123; <span class="built_in">range_mul</span>(l, r, val, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">    <span class="comment">// 区间增量，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll val)</span> </span>&#123; <span class="built_in">range_add</span>(l, r, val, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">    <span class="comment">// 区间直接修改，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">range_set</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll val)</span> </span>&#123; <span class="built_in">range_set</span>(l, r, val, <span class="number">0</span>, end, root); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0); cout.tie(0);</span></span><br><span class="line">    ll n,q,t;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:v) cin &gt;&gt; i;</span><br><span class="line">    <span class="function">SegTree <span class="title">st</span><span class="params">(v)</span></span>;</span><br><span class="line">    ll op,x,y,k;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            st.<span class="built_in">range_mul</span>(x<span class="number">-1</span>,y<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            st.<span class="built_in">range_add</span>(x<span class="number">-1</span>,y<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            st.<span class="built_in">range_set</span>(x<span class="number">-1</span>,y<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; st.<span class="built_in">range_sum</span>(x<span class="number">-1</span>,y<span class="number">-1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二类Stirling数</title>
      <link href="/posts/stirling.html"/>
      <url>/posts/stirling.html</url>
      
        <content type="html"><![CDATA[<h2 id="第二类Stirling数">第二类Stirling数</h2><p>把n个不同元素划分成m个集合（不能有空集）的方法数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Get_Stirling</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ll t=<span class="built_in">mul</span>(<span class="built_in">C</span>(m,i),<span class="built_in">qcpow</span>(m-i,n));</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>) t=MOD-t;</span><br><span class="line">        <span class="built_in">addto</span>(ans,t);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/posts/bit.html"/>
      <url>/posts/bit.html</url>
      
        <content type="html"><![CDATA[<h2 id="树状数组">树状数组</h2><p>解决的问题：单点修改区间查询/区间修改单点查询</p><p>算符要求：满足结合律和可差分</p><p>单次时间复杂度：O(logn)</p><p>fl=0: 维护原数组，实现单点修改，区间查询</p><p>fl=1: 维护差分数组，实现区间修改，单点查询</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x) &amp; (-(x))) <span class="comment">// 取最后一个1所在位置的权值</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll N=<span class="number">5e5</span>+<span class="number">5</span>; <span class="comment">//单个数据数组最大长度</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTree</span>&#123;</span><br><span class="line">    vector&lt;ll&gt; data; <span class="comment">// 树状数组</span></span><br><span class="line">    <span class="type">int</span> fl;</span><br><span class="line">    ll n; <span class="comment">// 当前数组长度</span></span><br><span class="line">    <span class="built_in">BiTree</span>():<span class="built_in">data</span>(N*<span class="number">2</span>+<span class="number">5</span>,<span class="number">0</span>),<span class="built_in">fl</span>(<span class="number">0</span>),<span class="built_in">n</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">// 建立树状数组，v下标从1开始，v[0]=0</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;ll&gt;&amp; v,<span class="type">int</span> fl=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">clear</span>(); <span class="keyword">this</span>-&gt;fl=fl; n=v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(fl)&#123; <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">update</span>(i,v[i]-v[i<span class="number">-1</span>]); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">update</span>(i,v[i]); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询前缀和sum[i]，O(logn)</span></span><br><span class="line">    <span class="function">ll <span class="title">presum</span><span class="params">(ll i)</span></span>&#123;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            sum+=data[i];</span><br><span class="line">            i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置树状数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n*<span class="number">2</span>+<span class="number">1</span>;i++) data[i]=<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给予v[i]增量dif,维护树状数组，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll i,ll dif)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;data.<span class="built_in">size</span>())&#123;</span><br><span class="line">            data[i]+=dif;</span><br><span class="line">            i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询[l,r]</span></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(fl==<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">presum</span>(r)-<span class="built_in">presum</span>(l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给予区间[l,r]增量dif,维护树状数组，O(logn)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll l,ll r,ll dif)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(fl==<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">update</span>(l,dif);</span><br><span class="line">        <span class="built_in">update</span>(r+<span class="number">1</span>,-dif);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询v[i]</span></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll i)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(fl==<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">presum</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ll n,q;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) cin &gt;&gt; v[i];</span><br><span class="line">    ll op,x,y,k;</span><br><span class="line">    <span class="comment">// P3374</span></span><br><span class="line">    bt.<span class="built_in">build</span>(v,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">            bt.<span class="built_in">update</span>(x,k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; bt.<span class="built_in">query</span>(x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// P3368</span></span><br><span class="line">    <span class="comment">// bt.build(v,1);</span></span><br><span class="line">    <span class="comment">// for(ll i=0;i&lt;q;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cin &gt;&gt; op;</span></span><br><span class="line">    <span class="comment">//     if(op==1)&#123;</span></span><br><span class="line">    <span class="comment">//         cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span></span><br><span class="line">    <span class="comment">//         bt.update(x,y,k);</span></span><br><span class="line">    <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//         cin &gt;&gt; x;</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; bt.query(x) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校10</title>
      <link href="/posts/ACM_2024Summer_HDU10.html"/>
      <url>/posts/ACM_2024Summer_HDU10.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A810%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（10）</a></p><h1>(1008)HDU7548.SunBian</h1><h2 id="题意">题意</h2><p>有排成环形的 $n$ 个横着的笋，Alice 和 Bob 轮流执行如下操作，Alice 先手：</p><ul><li>选择 [1,k] 个连续的横着的笋，把它们变成竖着的</li></ul><p>不能操作者输。</p><p>给定 $n,k$ ，求谁会赢。</p><h2 id="解题思路">解题思路</h2><ul><li>当 $k=1$ 时，根据奇偶性判断赢家</li><li>当 $k\ge n$ 时，先手直接将笋全部竖置，必胜</li><li>其余情况下，后手每次都可以尽可能保证剩余区域数为偶数，最终必胜</li></ul><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=k) cout &lt;&lt; <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">1</span>) cout &lt;&lt; (n%<span class="number">2</span>?<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1009)HDU7549.不基本子串结构</h1><h2 id="题意-2">题意</h2><p>给定2个字符串 $a,b$ ，找到一个最小长度的字符串 $c$ ，使得 $a$ 和 $b$ 在 $c$ 中出现的次数相等且不为0，输出最小长度。</p><h2 id="解题思路-2">解题思路</h2><p>分类讨论，不妨假设 $len(a)\le len(b)$</p><ul><li>若 $a$ 在 $b$ 中出现的次数大于 $1$ ，则不存在满足条件的 $c$</li><li>若 $a$ 在 $b$ 中出现的次数为 $1$ ，则 $c=b$ ，输出 $len(b)$</li><li>若 $a$ 在 $b$ 中没有出现：<ul><li>记 $l_1$ 为 最大满足 $a[0:l]=b[len(b)-l:len(b)]$ 的 $l$</li><li>记 $l_2$ 为 最大满足 $a[len(a)-l:len(a)]=b[0:l]$ 的 $l$</li><li>答案为 $len(a)+len(b)-max(l_1,l_2)$</li></ul></li></ul><p>可以用字符串哈希进行检查和计数。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">if</span>(s1.<span class="built_in">length</span>()&lt;s2.<span class="built_in">length</span>()) <span class="built_in">swap</span>(s1,s2);</span><br><span class="line">    <span class="function">strHash <span class="title">h1</span><span class="params">(s1)</span>,<span class="title">h2</span><span class="params">(s2)</span></span>;</span><br><span class="line">    ll n=s1.<span class="built_in">length</span>(),m=s2.<span class="built_in">length</span>();</span><br><span class="line">    ll cnt=h1.<span class="built_in">count</span>(h2);</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=m+n;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(len,m<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.<span class="built_in">findz</span>(n-len+<span class="number">1</span>,n)==h2.<span class="built_in">findz</span>(<span class="number">1</span>,len))&#123;</span><br><span class="line">            <span class="built_in">chmin</span>(ans,n+m-len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(len,m<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.<span class="built_in">findf</span>(<span class="number">1</span>,len)==h2.<span class="built_in">findf</span>(m-len+<span class="number">1</span>,m))&#123;</span><br><span class="line">            <span class="built_in">chmin</span>(ans,n+m-len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1011）HDU7551.NOI2024</h1><h2 id="题意-3">题意</h2><p>$m$ 名选手进行 $n$ 场比赛，排名定义为分数严格大于你的人数+1。<br>第 $i$ 场比赛的分数上限为 $b_i$ ，你的排名为 $a_i$ 。<br>最终按照每场比赛的总分排名，前 $k$ 名选手将获得金牌。<br>问在给定条件下不管怎么比赛，是否一定能获得金牌。</p><h2 id="解题思路-3">解题思路</h2><p>用最坏情况考虑：你始终为 $0$ 分，在你前面的选手都有分数。<br>最终最坏排名为 $\min(\sum_{i=1}^{n}a_i,m)$ 。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,n);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cnt+=<span class="built_in">max</span>(<span class="number">0ll</span>,a[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">chmin</span>(cnt,m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=k) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校09</title>
      <link href="/posts/ACM_2024Summer_HDU09.html"/>
      <url>/posts/ACM_2024Summer_HDU09.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A89%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（9）</a></p><h1>(1005)HDU7533.怪物猎人</h1><h2 id="题意">题意</h2><p>攻击生命值为 $k$ 的怪物，每回合可选择造成 $x$ 或 $y$ 点伤害。<br>分别回答是否有一种攻击序列，可以恰好在第奇数回合/第偶数回合击杀怪物。</p><h2 id="解题思路">解题思路</h2><p>最边缘的情况即为全用 $x$ 和 全用 $y$ ，分别需要 $\lceil \frac{k}{x}\rceil$ 和 $\lceil \frac{k}{y}\rceil$ 回合。</p><p>这两个回合数相等，只有一种可能，否则都可以。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,a,b;cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ta,tb;</span><br><span class="line">    ta=(n+a<span class="number">-1</span>)/a;</span><br><span class="line">    tb=(n+b<span class="number">-1</span>)/b;</span><br><span class="line">    <span class="keyword">if</span>(ta==tb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ta%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7535.小猫钓鱼</h1><h2 id="题意-2">题意</h2><p>有 $2n$ 张牌，点数 $1\sim n$ 各出现2次。<br>两人各分到 $n$ 张牌，已知每个人手中牌的点数。<br>两人轮流放牌到牌堆顶，若牌堆中此前已经有相同点数的牌，则将这两张牌以及中间的所有牌拿回手中。<br>先打完的人输。</p><h2 id="解题思路-2">解题思路</h2><p>称手牌中成对的牌为双牌，单独的牌为单牌。</p><p>当自己打出单牌时，对方必定能打出一样的单牌收回，且先后手不变，这样是不优的。<br>因此，贪心的打法是先手打双牌，后手打双牌，先手打上次打的双牌。<br>这样的结果是：后手失去一个双牌，交换先后手。</p><p>观察到两人手牌中的双牌的数量相同，因此有双牌的情况下，后手先失去所有双牌，先手获胜。<br>否则，后手可以稳定收取先手打出的牌，后手获胜。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mp[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">size</span>()&lt;n) cout &lt;&lt; <span class="string">&quot;shuishui&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;sha7dow&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校10</title>
      <link href="/posts/ACM_2024Summer_NCD10.html"/>
      <url>/posts/ACM_2024Summer_NCD10.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81605">2024牛客暑期多校训练营10</a></p><h1>A.Surrender to My Will</h1><h2 id="题意">题意</h2><p>给定一个长度为 $5$ 的字符串，<code>Y</code>代表投降，<code>N</code>代表不投降，<code>-</code>代表未投票。<br>投降人数不小于4人即可投降。<br>问字符串表示的投降结果。</p><h2 id="解题思路">解题思路</h2><p>计数判断</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) mp[c]++;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="string">&#x27;Y&#x27;</span>]&gt;=<span class="number">4</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="string">&#x27;N&#x27;</span>]&gt;=<span class="number">2</span>) &#123;cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.std::pair</h1><h2 id="题意-2">题意</h2><p>基础合法类型<code>int</code>和<code>double</code>。<br>对于任意2个合法类型<code>A</code>和<code>B</code>，<code>pair&lt;A,B&gt;</code>是合法的，可以通过<code>.first</code>和<code>.second</code>分别访问<code>A</code>和<code>B</code>成员。<br>声明变量的格式为<code>pair&lt;A,B&gt; 变量名;</code>。</p><p>给定 $n$ 个字符串表示变量声明，变量名不重复。<br>再给定 $q$ 个字符串表示访问变量，返回被查询的成员类型。</p><h2 id="解题思路-2">解题思路</h2><p>模拟题，对每个变量类型构建二叉树，查询在二叉树上进行。<br>具体实现方式可以参考代码。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">pll v[N]; <span class="comment">//pair的树，x表示左子树，y表示右子树</span></span><br><span class="line">map&lt;string,ll&gt; dict; <span class="comment">//变量二叉树的根所在下标</span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function">pll <span class="title">parse_type</span><span class="params">(string s)</span></span>&#123; <span class="comment">//解析类型，构建树</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">&quot;int&quot;</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">//int</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">&quot;double&quot;</span>) <span class="keyword">return</span> &#123;<span class="number">-2</span>,<span class="number">-2</span>&#125;; <span class="comment">//double</span></span><br><span class="line">    s=s.<span class="built_in">substr</span>(<span class="number">5</span>,s.<span class="built_in">length</span>()<span class="number">-6</span>); </span><br><span class="line">    ll cntp=<span class="number">0</span>,cntd=<span class="number">0</span>,pos;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123; <span class="comment">//找到当前pair对应的逗号位置pos</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;p&#x27;</span>) cntp++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cntp==cntd) &#123;pos=i;<span class="keyword">break</span>;&#125; </span><br><span class="line">            cntd++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ltype=s.<span class="built_in">substr</span>(<span class="number">0</span>,pos),rtype=s.<span class="built_in">substr</span>(pos+<span class="number">1</span>,s.<span class="built_in">length</span>()-pos<span class="number">-1</span>);</span><br><span class="line">    ll lidx=cnt++,ridx=cnt++;</span><br><span class="line">    v[lidx]=<span class="built_in">parse_type</span>(ltype);</span><br><span class="line">    v[ridx]=<span class="built_in">parse_type</span>(rtype);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(lidx,ridx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">get_type</span><span class="params">(ll idx)</span></span>&#123; <span class="comment">//重组类型字符串</span></span><br><span class="line">    <span class="keyword">if</span>(v[idx].x==<span class="number">-1</span>) <span class="keyword">return</span> <span class="string">&quot;int&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[idx].x==<span class="number">-2</span>) <span class="keyword">return</span> <span class="string">&quot;double&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pair&lt;&quot;</span>+<span class="built_in">get_type</span>(v[idx].x)+<span class="string">&quot;,&quot;</span>+<span class="built_in">get_type</span>(v[idx].y)+<span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,q;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string type,name;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; type &gt;&gt; name;</span><br><span class="line">        name.<span class="built_in">pop_back</span>();</span><br><span class="line">        dict[name]=cnt++;</span><br><span class="line">        v[dict[name]]=<span class="built_in">parse_type</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; name;</span><br><span class="line">        ll j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;name.<span class="built_in">length</span>()&amp;&amp;name[j]!=<span class="string">&#x27;.&#x27;</span>) j++;</span><br><span class="line">        string main_name=name.<span class="built_in">substr</span>(<span class="number">0</span>,j); j++;</span><br><span class="line">        ll idx=dict[main_name];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;name.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(name[j]==<span class="string">&#x27;f&#x27;</span>)&#123; <span class="comment">//first</span></span><br><span class="line">                idx=v[idx].x;</span><br><span class="line">                j+=<span class="number">6</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name[j]==<span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//second</span></span><br><span class="line">                idx=v[idx].y;</span><br><span class="line">                j+=<span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">get_type</span>(idx) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F.Collinear Exception</h1><h2 id="题意-3">题意</h2><p>有一 $n\times n$ 的点阵列，每个点的坐标为 $(i,j)$ ，$1\leq i,j\leq n$ 。<br>按给定序列对点进行标记，要求标记后不能存在三个被标记点共线，否则标记失败。<br>按给定序列顺序输出每个点是否标记成功。</p><h2 id="解题思路-3">解题思路</h2><p>每当加入一个新的点时，和已有的点连线，标记线上的所有点。<br>被标记的点不能再被加入。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vis</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    vector&lt;pll&gt; points;</span><br><span class="line">    ll ub=n*n,xx,yy,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; xx &gt;&gt; yy;</span><br><span class="line">        <span class="keyword">if</span>(vis[xx][yy])&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>[tx,ty]:points)&#123; <span class="comment">//标记线上的点</span></span><br><span class="line">            <span class="keyword">if</span>(xx==tx)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n) vis[xx][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ll dx=xx-tx,dy=yy-ty;</span><br><span class="line">                ll g=__gcd(dx,dy);</span><br><span class="line">                dx/=g;dy/=g;</span><br><span class="line">                ll ttx=tx,tty=ty;</span><br><span class="line">                <span class="keyword">while</span>(ttx&lt;=n&amp;&amp;ttx&gt;=<span class="number">1</span>&amp;&amp;tty&lt;=n&amp;&amp;tty&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    vis[ttx][tty]=<span class="number">1</span>;</span><br><span class="line">                    ttx+=dx; tty+=dy;</span><br><span class="line">                &#125;</span><br><span class="line">                ttx=tx; tty=ty;</span><br><span class="line">                <span class="keyword">while</span>(ttx&lt;=n&amp;&amp;ttx&gt;=<span class="number">1</span>&amp;&amp;tty&lt;=n&amp;&amp;tty&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    vis[ttx][tty]=<span class="number">1</span>;</span><br><span class="line">                    ttx-=dx; tty-=dy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        points.<span class="built_in">emplace_back</span>(xx,yy);</span><br><span class="line">        vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.All-in at the Pre-flop</h1><h2 id="题意-4">题意</h2><p>两名玩家初始分别有 $a,b$ 的筹码，每轮游戏各有 $\frac{1}{2}$ 的概率获胜。<br>假设当前轮两名玩家分别有 $x,y$ 的筹码，那么输家需要付给赢家 $\min(x,y)$ 的筹码。<br>问两名玩家获胜的概率。</p><h2 id="解题思路-4">解题思路</h2><p>打个表，观察到答案是 $\frac{a}{a+b},\frac{b}{a+b}$ 。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll c=<span class="built_in">inv</span>(<span class="built_in">add</span>(a,b));</span><br><span class="line">    cout &lt;&lt; <span class="built_in">mul</span>(a,c) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">mul</span>(b,c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校09</title>
      <link href="/posts/ACM_2024Summer_NCD09.html"/>
      <url>/posts/ACM_2024Summer_NCD09.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81604">2024牛客暑期多校训练营9</a></p><h1>A.Image Scaling</h1><h2 id="题意">题意</h2><p>给定由 <code>.</code> 和 <code>x</code> 组成的 $n\times m$ 的 $n\times m$ 矩阵，$x$ 部分是一个子矩阵。<br>提取并在长宽比不变的情况下，将子矩阵尽可能缩小并输出。</p><h2 id="解题思路">解题思路</h2><p>模拟，缩小到 $1/gcd$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll fl=<span class="number">0</span>,st=<span class="number">-1</span>;</span><br><span class="line">    ll nn=<span class="number">-1</span>,mm,idx;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(fl) <span class="keyword">if</span>(s[idx]!=<span class="string">&#x27;x&#x27;</span>) &#123;nn=i-st;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">                    fl=<span class="number">1</span>; st=i; idx=j;</span><br><span class="line">                    ll t=j;</span><br><span class="line">                    <span class="keyword">while</span>(t&lt;m&amp;&amp;s[t]==<span class="string">&#x27;x&#x27;</span>) t++;</span><br><span class="line">                    mm=t-j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nn==<span class="number">-1</span>) nn=n-st;</span><br><span class="line">    ll g=__gcd(nn,mm);</span><br><span class="line">    nn/=g; mm/=g;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,nn<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,mm<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        &#125;cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.Kill The Monsters</h1><h2 id="题意-2">题意</h2><p>$n$ 个怪兽，第 $i$ 个怪兽的体力为 $a_i$ 。</p><p>每次可以进行一种操作：</p><ol><li>所有怪兽体力 $-1$</li><li>选择一个怪兽 $i$ 使得 $a_i\leftarrow \lfloor \dfrac{a_i}{k} \rfloor$</li></ol><p>问最少多少次操作可以使所有怪兽的体力都为 $0$ 。</p><h2 id="解题思路-2">解题思路</h2><p>贪心的，先连续对最大体力的怪兽进行第二种操作，再进行第一种操作。<br>用优先队列维护最大体力。<br>记当前已经操作了 $cnt$ 次，用 $a_{max}+cnt$ 维护最小操作次数。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k,t;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    priority_queue&lt;ll&gt; pq;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) &#123;cin &gt;&gt; t;pq.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">    ll cur=<span class="number">0</span>,ans=pq.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) &#123;cout &lt;&lt; ans &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">top</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        t=pq.<span class="built_in">top</span>();pq.<span class="built_in">pop</span>();</span><br><span class="line">        t/=k; cur++;</span><br><span class="line">        pq.<span class="built_in">push</span>(t);</span><br><span class="line">        <span class="built_in">chmin</span>(ans,pq.<span class="built_in">top</span>()+cur);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校08</title>
      <link href="/posts/ACM_2024Summer_HDU08.html"/>
      <url>/posts/ACM_2024Summer_HDU08.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A88%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（8）</a></p><h1>(1004)HDU7520.cats 的重力拼图</h1><h2 id="题意">题意</h2><p>有一个 $n\times m$ 的方格阵列，物块初始位于 $(x,y),1\le x\le n,1\le y\le m$。<br>每次操作可以改变重力方向：向上、向下、向左、向右，物块会沿重力方向移动，直到碰到边界。<br>求任意操作下物块最多经过的格子数。</p><h2 id="解题思路">解题思路</h2><p>有2种最贪心的操作序列：</p><ol><li>向左、向右、再沿边缘一周</li><li>向上、向下、再沿边缘一周</li></ol><p>特判 $n=1$ 或 $m=1$ 或初始在边缘的情况。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b;cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>||m&lt;=<span class="number">2</span>)&#123; cout &lt;&lt; n*m &lt;&lt; endl; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    ll ans=<span class="number">2</span>*(n+m<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>||a==n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>||b==m) cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans+n<span class="number">-2</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">1</span>||b==m) cout &lt;&lt; ans+m<span class="number">-2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans+<span class="built_in">max</span>(&#123;<span class="number">0ll</span>,n<span class="number">-2</span>,m<span class="number">-2</span>&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1006）HDU7522.cats 的最小生成树</h1><h2 id="题意-2">题意</h2><p>给定一个有 $n$ 个节点，可能含重边的带权无向图， $m$ 条边按顺序给出，第 $i$ 条边的权值为 $i$。<br>每次删去当前图的最小生成树的所有边，直到图不连通。</p><p>求每条边是在第几次被删除去的。</p><h2 id="解题思路-2">解题思路</h2><p>根据Kruskal算法思想，最小生成树加边是从小到大加入的。<br>开若干个并查集，遍历边，每次二分查找当前边最早可以加入第几个并查集。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll ub=m/(n<span class="number">-1</span>);</span><br><span class="line">    <span class="function">vector&lt;DSU&gt; <span class="title">dsu</span><span class="params">(ub+<span class="number">2</span>,DSU(n))</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">cnt</span><span class="params">(ub+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        ll l=<span class="number">1</span>,r=ub+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            ll mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">bool</span> fl=(dsu[mid].<span class="built_in">find</span>(u)==dsu[mid].<span class="built_in">find</span>(v));</span><br><span class="line">            <span class="keyword">if</span>(fl) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll tar=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">1ll</span>,l<span class="number">-3</span>),<span class="built_in">min</span>(ub+<span class="number">1</span>,l+<span class="number">3</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(dsu[i].<span class="built_in">find</span>(u)!=dsu[i].<span class="built_in">find</span>(v))&#123;</span><br><span class="line">                tar=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tar==ub+<span class="number">1</span>) &#123; ans[i]=<span class="number">-1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        dsu[tar].<span class="built_in">merge</span>(u,v);</span><br><span class="line">        cnt[tar]++; ans[i]=tar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]!=<span class="number">-1</span>&amp;&amp;cnt[ans[i]]==n<span class="number">-1</span>) cout &lt;&lt; ans[i];</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">Presentation</span>(i,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7523.cats 的 k-xor</h1><h2 id="题意-3">题意</h2><p>给定2个十进制整数 $a,b,c$ ， $a,b$ 进行 $k(k\ge 2)$ 进制不进位加法后的结果是 $c$。<br>求 $k$ 有多少种可能。</p><h2 id="解题思路-3">解题思路</h2><p>不进位加法下，丢失的进位信息 $a+b-c$ 是 $k$ 的倍数。<br>枚举 $a+b-c$ 的因子作为 $k$ ，check是否满足条件。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll a,ll b,ll c,ll k)</span></span>&#123;</span><br><span class="line">    ll dif=a+b-c;</span><br><span class="line">    ll cur=<span class="number">1</span>,nxt=k,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a/cur||b/cur)&#123;</span><br><span class="line">        ll ta=a/cur%k,tb=b/cur%k;</span><br><span class="line">        s+=(ta+tb)/k*nxt;</span><br><span class="line">        cur*=k; nxt*=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s==dif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll dif=a+b-c;</span><br><span class="line">    <span class="keyword">if</span>(dif==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>,ub=<span class="built_in">sqrt</span>(dif)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,ub) <span class="keyword">if</span>(dif%i==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i*i&gt;dif) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(a,b,c,i)) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(i*i!=dif&amp;&amp;<span class="built_in">check</span>(a,b,c,dif/i)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(a,b,c,dif)) cnt++;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>（1012）HDU7528.cats 的电脑中毒</h1><h2 id="题意-4">题意</h2><p>给定 $3$ 个长度为 $n$ 的二进制串 $a,b,c$ ， 表示病毒的初始位置。<br>每过一秒，病毒会感染相邻的所有二进制编码。（当且仅当两个二进制编码仅有一个位置不同时，这两个编码为相邻）<br>问所有的 $2^n$ 个二进制编码都被感染需要多少时间。</p><h2 id="解题思路-4">解题思路</h2><p>考虑最后一秒被感染的二进制串，它的 距离三个初始位置的最小汉明距离 最大，找到这个串。<br>设这个串为 $s$ ，枚举每一位。若三个初始位置的这一位上，1的数量较多，则设为0；否则设为1。<br>然后进行微调，使得 $s$ 到三个初始位置的最小汉明距离 最大。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ll n;</span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(string s1,string s2)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cnt+=(s1[i]!=s2[i]);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s[<span class="number">3</span>],<span class="built_in">ns</span>(n,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">2</span>) cin &gt;&gt; s[i];</span><br><span class="line">    ll cnta=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> cnt1=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">if</span>(s[j][i]==<span class="string">&#x27;1&#x27;</span>) cnt1++;</span><br><span class="line">        ns[i]=(cnt1&gt;=<span class="number">2</span>)?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll dis0=<span class="built_in">dis</span>(s[<span class="number">0</span>],ns),dis1=<span class="built_in">dis</span>(s[<span class="number">1</span>],ns),dis2=<span class="built_in">dis</span>(s[<span class="number">2</span>],ns);</span><br><span class="line">    <span class="keyword">while</span>(dis0&lt;dis1<span class="number">-1</span>&amp;&amp;dis0&lt;dis2<span class="number">-1</span>)&#123; dis0++; dis1--; dis2--; &#125;</span><br><span class="line">    <span class="keyword">while</span>(dis1&lt;dis0<span class="number">-1</span>&amp;&amp;dis1&lt;dis2<span class="number">-1</span>)&#123; dis1++; dis0--; dis2--; &#125;</span><br><span class="line">    <span class="keyword">while</span>(dis2&lt;dis0<span class="number">-1</span>&amp;&amp;dis2&lt;dis1<span class="number">-1</span>)&#123; dis2++; dis0--; dis1--; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(&#123;dis0,dis1,dis2&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校07</title>
      <link href="/posts/ACM_2024Summer_HDU07.html"/>
      <url>/posts/ACM_2024Summer_HDU07.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A87%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（7）</a></p><h1>(1010)HDU7514.故障机器人想活下去</h1><h2 id="题意">题意</h2><p>故障机器人有 $x$ 点血量。<br>他将按顺序进行 $n$ 场战斗，第 $i$ 场战斗会受到 $a_i$ 点伤害。<br>故障机器人还有 $k$ 个烟雾弹，每个烟雾弹可以让他跳过一场战斗而不受伤害。</p><p>问故障机器人最多能活到第几场战斗结束。</p><h2 id="解题思路">解题思路</h2><p>维护当前最高的 $k$ 个伤害，作为被跳过的伤害。<br>统计受伤量，直到受伤量超过 $x$ 为止。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,k;cin &gt;&gt; n &gt;&gt; x &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;,less&lt;ll&gt;&gt; pq;</span><br><span class="line">    ll S=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        S+=v[i];</span><br><span class="line">        pq.<span class="built_in">push</span>(v[i]);</span><br><span class="line">        <span class="keyword">while</span>(S&gt;=x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=k)&#123;</span><br><span class="line">                cout &lt;&lt; pq.<span class="built_in">size</span>()+cnt<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            S-=pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7515.蛋糕上的草莓是蛋糕的灵魂</h1><h2 id="题意-2">题意</h2><p>有 $x$ 个相同的草莓和 $y$ 个相同的蛋糕。<br>每次可以将当前所有草莓或蛋糕放在一起切 $m$ 刀，即份数变为此前的 $2m$ 倍。<br>在满足条件的情况下切草莓的次数尽可能少。<br>求出最终草莓和蛋糕的数量。</p><h2 id="解题思路-2">解题思路</h2><p>贪心的，观察到蛋糕是不用切的，将草莓切到 $\gcd(x,y)$ 份即可。<br>若 $\gcd$ 是 $x$ 的奇数倍，需要多来一刀。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    ll g=__gcd(x,y);</span><br><span class="line">    <span class="keyword">if</span>(y/g&gt;<span class="number">1</span>&amp;&amp;(y/g)%<span class="number">2</span>) cout &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x/g*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x/g &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校08</title>
      <link href="/posts/ACM_2024Summer_NCD08.html"/>
      <url>/posts/ACM_2024Summer_NCD08.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81603">2024牛客暑期多校训练营8</a></p><h1>A.Haitang and Game</h1><h2 id="题意">题意</h2><p>给定一个包含 $n$ 个数的正整数集合 $S$ ，每次可以从中选择两个数 $x,y$ 满足 $x,y\in S,\gcd(x,y)\notin S$，将 $\gcd(x,y)$ 加入 $S$ 。<br>最多加入数的个数是奇数输出<code>dXqwq</code>，否则输出<code>Haitang</code>。</p><h2 id="解题思路">解题思路</h2><p>考虑最终集合中的数 $d$ ，一定满足原集合中，它的所有倍数的 $gcd$ 等于它。<br>从小到大枚举 $d$ ，如果 $d$ 满足上述条件且不在原集合中，计数。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;ll&gt; s;</span><br><span class="line">    ll mx=<span class="number">-1</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        s.<span class="built_in">insert</span>(t);</span><br><span class="line">        <span class="built_in">chmax</span>(mx,t);</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,mx)&#123;</span><br><span class="line">        ll fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=mx;j+=i)</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">count</span>(j)) fl=__gcd(fl,j);</span><br><span class="line">        <span class="keyword">if</span>(fl==i&amp;&amp;!s.<span class="built_in">count</span>(i)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;dXqwq\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Haitang\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.Haitang and Triangle</h1><h2 id="题意-2">题意</h2><p>构造一个长度为 $n$ 的排列，它恰有 $m$ 个长度为 $3$ 的子区间满足子区间的三个数能构成非退化三角形。</p><h2 id="解题思路-2">解题思路</h2><p>构造一个长度为 $n-m$ 的排列，它不含能够构成非退化三角形的长度为 $3$ 的子区间。<br>我使用的方法是把 $1\sim n-m$ 从大到小均分成三组，第1组降序，其他组升序，按321的顺序放置。<br>假设 $n-m=7$ ，分成 $[2,1],[3,4],[5,6,7]$ ，排列为 $5,3,2,\ 6,4,1,\ 7$ 。</p><p>剩下 $m$ 个数降序放在排列的前面，和上面的排列合并形成 $m$ 个合法区间。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll t = n-m;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;ll&gt; v[<span class="number">3</span>];</span><br><span class="line">    ll t1=t/<span class="number">3</span>,t2=t%<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,t1) v[<span class="number">0</span>].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,t1+<span class="number">1</span>,t1*<span class="number">2</span>+(t2&gt;<span class="number">1</span>)) v[<span class="number">1</span>].<span class="built_in">emplace_front</span>(i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,t1*<span class="number">2</span>+(t2&gt;<span class="number">1</span>)+<span class="number">1</span>,t) v[<span class="number">2</span>].<span class="built_in">emplace_front</span>(i);</span><br><span class="line">    <span class="comment">// FORLL(i,0,2) print_vec(v[i]);</span></span><br><span class="line">    vector&lt;ll&gt; ans;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">2</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">2</span>][i]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">1</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">1</span>][i]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v[<span class="number">0</span>].<span class="built_in">size</span>()) ans.<span class="built_in">emplace_back</span>(v[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,t+<span class="number">1</span>) cout &lt;&lt; i &lt;&lt; <span class="built_in">Presentation</span>(i,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t<span class="number">-1</span>) cout &lt;&lt; ans[i] &lt;&lt; <span class="built_in">Presentation</span>(i,t<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.Haitang and Ava</h1><h2 id="题意-3">题意</h2><p>判断给定字符串是否仅由若干个 <code>ava</code> 和 <code>avava</code> 组成。</p><h2 id="解题思路-3">解题思路</h2><p>从 $i=1$ 开始，对于当前位置开头，先检查长度为 $5$ 的子串是否是 <code>avava</code> ，再检查长度为 $3$ 的子串是否是 <code>ava</code> ，如果是，就跳过这个子串；否则输出<code>NO</code>。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pat1 = <span class="string">&#x27;ava&#x27;</span></span><br><span class="line">pat2 = <span class="string">&#x27;avava&#x27;</span></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">5</span>&lt;=<span class="built_in">len</span>(s) <span class="keyword">and</span> s[i:i+<span class="number">5</span>] == pat2:</span><br><span class="line">            i += <span class="number">5</span></span><br><span class="line">        <span class="keyword">elif</span> i+<span class="number">3</span>&lt;=<span class="built_in">len</span>(s) <span class="keyword">and</span> s[i:i+<span class="number">3</span>] == pat1:</span><br><span class="line">            i += <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校07</title>
      <link href="/posts/ACM_2024Summer_NCD07.html"/>
      <url>/posts/ACM_2024Summer_NCD07.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81702">2024牛客暑期多校训练营7</a></p><h1>I.Fight Against the Monster</h1><h2 id="题意">题意</h2><p>瓶子换水问题。 $m$ 个空瓶可以换 $k$ 瓶水， 求一共要喝 $h$ 瓶水，初始最少需要多少瓶水。</p><h2 id="解题思路">解题思路</h2><p>二分check。</p><p>设初始有 $x$ 瓶水，换水次数为 $\dfrac{x-m}{m-k}+1=\dfrac{x-k}{m-k}$。<br>每次换水产生 $k$ 瓶水，总共 $x+k\cdot \dfrac{x-k}{m-k}$ 瓶水。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(ll m,ll k,ll h,ll x)</span></span>&#123;</span><br><span class="line">    ll t=(x-k)/(m-k)*k+x;   </span><br><span class="line">    <span class="keyword">if</span>(t&gt;=h) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,k,h;cin &gt;&gt; m &gt;&gt; k &gt;&gt; h;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;=m)&#123;cout &lt;&lt; h &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//不用换</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=k)&#123;cout &lt;&lt; m &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//生生不息</span></span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        ll mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(m,k,h,mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">0ll</span>,l<span class="number">-10</span>),r+<span class="number">10</span>) <span class="keyword">if</span>(<span class="built_in">check</span>(m,k,h,i)) &#123;cout &lt;&lt; i &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.Ball</h1><h2 id="题意-2">题意</h2><p>给定一根左端点为 $(0,0)$ 垂直于y轴长度为 $l$ 的棍子。<br>在上面找一个支点使得棍子绕支点旋转可以碰到位于 $(x,y)$ 的小球。</p><h2 id="解题思路-2">解题思路</h2><p>支点位于两端时扫过的面积可覆盖所有情况。<br>判断小球到两端的距离。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,x,y;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    ll dis1,dis2;</span><br><span class="line">    dis1=x*x+y*y;</span><br><span class="line">    dis2=(l-x)*(l-x)+y*y;</span><br><span class="line">    <span class="keyword">if</span>(dis1&gt;l*l&amp;&amp;dis2&gt;l*l) &#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(dis1&lt;dis2) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校06</title>
      <link href="/posts/ACM_2024Summer_HDU06.html"/>
      <url>/posts/ACM_2024Summer_HDU06.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A86%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（6）</a></p><h1>(1001)HDU7494 造花（简单版）</h1><h2 id="题意">题意</h2><p>给定一棵 $n$ 个节点的树，问能否通过删去一个节点，使得剩下的节点组成2个连通块，且每个连通块都是一个菊花图。</p><p>菊花图是一棵树，且存在唯一中心点与其他所有节点之间有一条边。特殊的，只有一个节点的树也是菊花图。</p><h2 id="解题思路">解题思路</h2><p>一棵树删去一个点得到两个连通块，那么删去的点的度必定为2。</p><p>这个删去的点 $u$ 和得到的两个菊花图的中心点 $v_1,v_2$ 有三种情况：</p><ol><li>$u$ 和 $v_1,v_2$ 直接相连</li><li>$u$ 和 $v_1$ 直接相连，和 $v_2$ 的距离为2</li><li>$u$ 和 $v_1,v_2$ 的距离都为2</li></ol><p>记录度大于1的节点，这些点是关键节点，可能是中心点，也可能是删去的点。</p><p>度大于1的节点数最多的情况是第三种，最多有5个度大于1的节点，形如：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  8       9</span><br><span class="line">  |       |</span><br><span class="line">1<span class="string">-2</span><span class="string">-3</span><span class="string">-4</span><span class="string">-5</span><span class="string">-6</span><span class="string">-7</span></span><br><span class="line">  |       |</span><br><span class="line">  10      11</span><br></pre></td></tr></table></figure><p>删去点 $u$ 后，剩余度大于1的节点必定是中心点，个数不大于 $2-t$ 即满足。<br>其中， $t$ 是删点后仅由不多于$2$个点组成的连通块的个数。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; crit; <span class="comment">//关键点</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(G[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>) crit.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(crit.<span class="built_in">size</span>()&gt;<span class="number">5</span>) &#123;cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:crit) <span class="keyword">if</span>(G[u].<span class="built_in">size</span>()==<span class="number">2</span>)&#123; <span class="comment">//枚举删除的点</span></span><br><span class="line">        ll cnt2=<span class="number">0</span>,cnt1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u])&#123; <span class="comment">//相邻的2个点</span></span><br><span class="line">            <span class="keyword">if</span>(G[v].<span class="built_in">size</span>()==<span class="number">2</span>)&#123; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> w:G[v])  <span class="comment">//w==u:这一端的连通块只有2个节点</span></span><br><span class="line">                <span class="keyword">if</span>(w!=u) <span class="keyword">if</span>(G[w].<span class="built_in">size</span>()&gt;<span class="number">1</span>) cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(G[v].<span class="built_in">size</span>()==<span class="number">1</span>) cnt1++; <span class="comment">//这一端的连通块只有1个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        ll t=crit.<span class="built_in">size</span>()<span class="number">-1</span>-cnt2;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=<span class="number">2</span>-cnt1) &#123; cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1003)HDU7496 飞车狂飙</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的字符串，包含：</p><ol><li><code>L</code> ：表示左转的方块</li><li><code>R</code> ：表示右转的方块</li><li><code>S</code> ：表示直行的方块</li></ol><p>从原点开始，按照字符串给定的顺序，先放置，再按照给定的方向移动。</p><p>合法的字符串满足：</p><ol><li>不在同一位置放置两个方块</li><li>所有方块形成一个环</li></ol><p>问给定的字符串是否合法。</p><h2 id="解题思路-2">解题思路</h2><p>模拟。<br>每走一步更新沿途放置了方块的坐标和当前方向。<br>中途检查是否有重复放置的方块，最后检查是否回到原点、方向是否回正。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        0 1 2 3</span></span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pll cur=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir=<span class="number">0</span>; <span class="comment">//0:up 1:left 2:down 3:right</span></span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    map&lt;pll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(cur))&#123;  cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        mp[cur]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;L&#x27;</span>) dir=(dir+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>) dir=(dir+<span class="number">3</span>)%<span class="number">4</span>;</span><br><span class="line">        cur.first+=dx[dir];</span><br><span class="line">        cur.second+=dy[dir];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.first==<span class="number">0</span>&amp;&amp;cur.second==<span class="number">0</span>&amp;&amp;dir==<span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1004)HDU7497 不醒人室</h1><h2 id="题意-3">题意</h2><p>给定 $n$ 个上课时间段， $m$ 个睡觉时间段。</p><p>初始状态是不清醒。<br>每个睡觉时间段 $[s,t]$ 能使接下来 $2(t-s)$ 的时间，也就是 $[t,t+2(t-s)]$ 时间段内保持清醒。<br>睡觉提供的清醒时间段不会叠加，以此前最后一个睡觉时间段为准。</p><p>问给定的时间段能否满足以下条件：</p><ol><li>上课时间保持清醒</li><li>上课时间不能睡觉</li></ol><h2 id="解题思路-3">解题思路</h2><p>将所有时间段排序，从左往右遍历：</p><ol><li>当前是上课时间段，检查：<ol><li>上课开始时间是否晚于最后一个睡觉时间段的结束时间</li><li>上课结束时间是否早于最后一次睡觉提供的清醒时间段的结束时间</li></ol></li><li>当前是睡觉时间段，检查睡觉时间是否晚于上一节课的结束时间</li></ol><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;pair&lt;pll,<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m+n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; v[i].first.first &gt;&gt; v[i].first.second;</span><br><span class="line">        v[i].second = <span class="number">0</span>; <span class="comment">//上课</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,n,n+m<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; v[i].first.first &gt;&gt; v[i].first.second;</span><br><span class="line">        v[i].second = <span class="number">1</span>; <span class="comment">//睡觉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll b,e,s,t; <span class="comment">//上次上课时间[b,e]，上次睡觉时间[s,t]</span></span><br><span class="line">    b=e=s=t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [tp,op]:v)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x,y] = tp;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>)&#123; <span class="comment">//上课</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;t)&#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//上课开始还在睡觉</span></span><br><span class="line">            <span class="keyword">if</span>(t+<span class="number">2</span>*(t-s)&lt;y) &#123;cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//上次没睡够支撑不到下课</span></span><br><span class="line">            b=x;e=y;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(x&lt;e)&#123; cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;<span class="keyword">return</span>;&#125; <span class="comment">//还没下课就睡觉</span></span><br><span class="line">            s=x;t=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1005)HDU7498 交通管控</h1><h2 id="题意-4">题意</h2><p>有 $k$ 盏红绿灯，每盏灯有三种状态：绿色<code>A</code>、黄色<code>B</code>、红色<code>C</code>。</p><p>一个操作用一个长度为 $k$ 的字符串表示，一个字符对应一盏灯。<br>字符串中包含：</p><ol><li><code>+</code>：红变绿、绿变黄、黄变红</li><li><code>-</code>：绿变红、黄变绿、红变黄</li><li><code>0</code>：不变</li></ol><p>交警有一个长度为 $n$ 的操作序列，他可以按顺序对每个操作选择执行或不执行。</p><p>问最后能达到哪些状态，以及每种状态对应的 操作序列种数。</p><h2 id="解题思路-4">解题思路</h2><p>状态压缩DP。</p><p>用一个 $k$ 位3进制数表示 $k$ 盏灯的状态，每一位表示一盏灯的状态：0绿、1黄、2红。<br>记：</p><ul><li>$dp[i][x]$ 表示前 $i$ 个操作，状态为 $x$ 的方案数。</li><li>$op(x,i)$ 表示状态 $x$ 经过第 $i$ 个操作后的状态。</li></ul><p>状态转移方程：$dp[i][x]=dp[i-1][x]+\sum\limits_{j}^{st\in stat[i-1],op(st,i)=j} dp[i-1][st]$<br>其中，$stat[i-1]$ 表示第 $i-1$ 个操作后的所有状态。</p><p>利用滚动数组可以实现空间优化。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; pow3;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pow3.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">20</span>) pow3.<span class="built_in">emplace_back</span>(pow3.<span class="built_in">back</span>()*<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">ll n,k;</span><br><span class="line"><span class="comment">//在x的3进制，第idx位，+d再对3取模</span></span><br><span class="line"><span class="function">ll <span class="title">opadd</span><span class="params">(ll x,ll idx,ll d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    ll t = x/pow3[idx]%<span class="number">3</span>;</span><br><span class="line">    t = (t+d+<span class="number">3</span>)%<span class="number">3</span>-t;</span><br><span class="line">    <span class="keyword">return</span> x + t*pow3[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0A1B2C</span></span><br><span class="line"><span class="function">string <span class="title">trans</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">        s += <span class="built_in">char</span>(<span class="string">&#x27;A&#x27;</span>+x%<span class="number">3</span>);</span><br><span class="line">        x /= <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cin &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:v) cin &gt;&gt; s;</span><br><span class="line">    map&lt;ll,ll&gt; dp[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">    dp[fl].<span class="built_in">insert</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;); fl^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:v)&#123;</span><br><span class="line">        dp[fl]=dp[fl^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,cnt]:dp[fl^<span class="number">1</span>])&#123;</span><br><span class="line">            ll t=v;</span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>) t=<span class="built_in">opadd</span>(t,i,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>) t=<span class="built_in">opadd</span>(t,i,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">addto</span>(dp[fl][t],cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        fl^=<span class="number">1</span>;</span><br><span class="line">    &#125;fl^=<span class="number">1</span>;</span><br><span class="line">    map&lt;string,ll&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,cnt]:dp[fl]) ans.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">trans</span>(v),(ll)cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [s,cnt]:ans) cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校05</title>
      <link href="/posts/ACM_2024Summer_HDU05.html"/>
      <url>/posts/ACM_2024Summer_HDU05.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A85%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（5）</a></p><h1>(1002)HDU7482 Array-Gift</h1><h2 id="题意">题意</h2><p>给定一个长度为 $n$ 的正整数数组 $a$ ，提供以下2种操作：</p><ol><li>选择两个不同的下标 $i,j$ ，$a_i\leftarrow a_i\ mod\ a_j$</li><li>选择一个下标 $i$ 和一个任意正整数 $x$ ，$a_i\leftarrow a_i+x$</li></ol><p>求使得数组仅有1个非0元素的最小操作次数。</p><h2 id="解题思路">解题思路</h2><p>add：做之前先对数组去重，因为重复的数可以在开始就通过操作1变为0。</p><p>考虑最坏情况的操作次数：<br>选定两个不同的下标 $i,j$ ，不妨设 $a_i&lt;=a_j$ 。（1次）<br>做操作2使得 $a_i=a_j+1$ ，再做操作1使得 $a_i=1$ 。（1次）<br>最后对每个 $k\neq i$ 做操作1：$a_k\leftarrow a_k\ mod\ a_i=0$ 。（$n-1$次）<br>最坏情况的操作次数为 $n+1$ 。</p><p>最好的情况：存在一个下标 $i$ 使得 $a_i$ 能够整除数组中所有元素。<br>满足这个条件的 $a_i$ 一定是数组中的最小值。<br>这种情况只需对每个 $k\neq i$ 做操作1：$a_k\leftarrow a_k\ mod\ a_i=0$ ，操作次数为 $n-1$ 。</p><p>由于最坏情况难以确定，考虑操作次数为 $n$ 的情况：</p><ol><li>数组 $a$ 中的最小值经过操作2 ，$\min(a)\leftarrow\min(a)+x$ ，能够整除数组中所有元素。</li><li>某个元素经过操作1，能够整除数组中所有元素。</li></ol><p>对于第二种情况，维护gcd前缀/后缀（似乎不维护也能过？）。<br>枚举被修改的数 $a_i$ 和模数 $a_j$ ，若 $a_i\ mod\ a_j=\gcd\limits_k^{k\neq i}a_k$ ，则最少操作次数为 $n$ 。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    vector&lt;ll&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)&#123;</span><br><span class="line">        <span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m:tmp) <span class="keyword">if</span>(x%m==<span class="number">0</span>) &#123;fl=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(fl) tmp.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ll on=n; v=tmp; n=v.<span class="built_in">size</span>(); <span class="comment">//on是原数组大小</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(),<span class="number">0</span>); v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(),<span class="number">0</span>); <span class="comment">//起始下标改为1</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; on<span class="number">-1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">preg</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span>,<span class="title">sufg</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>; </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) preg[i]=__gcd(preg[i<span class="number">-1</span>],v[i]);</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>) sufg[i]=__gcd(sufg[i+<span class="number">1</span>],v[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sufg[<span class="number">2</span>]&gt;v[<span class="number">1</span>]&amp;&amp;sufg[<span class="number">2</span>]&lt;=v[<span class="number">2</span>]) &#123;cout &lt;&lt; on &lt;&lt; endl;<span class="keyword">return</span>;&#125; <span class="comment">//剩下的数模（v1+x）为0</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123; <span class="comment">//被修改的数</span></span><br><span class="line">        ll g=__gcd(preg[i<span class="number">-1</span>],sufg[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)&#123;<span class="comment">//模数</span></span><br><span class="line">            ll t=v[i]%v[j];</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g%t==<span class="number">0</span>) &#123;cout &lt;&lt; on &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; on+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1006)HDU7486 猫罐头游戏</h1><h2 id="题意-2">题意</h2><p>有三堆猫罐头，每堆猫罐头的数量分别为 $a,b,c$ 。<br>两只猫猫进行博弈，每次可以选择一堆猫罐头全部吃掉，然后再从剩下的两堆中选择一堆猫罐头分成两份（每份至少一罐）。<br>不能操作的猫猫输掉游戏。</p><p>问先手是否有必胜策略。</p><h2 id="解题思路-2">解题思路</h2><p>最终必败态是 $a=b=c=1$ 。</p><p>当开局有3个奇数时，不论怎么操作，结果都是2奇数1偶数；<br>当开局有1个或2个偶数时，可以控制结果为3个奇数。<br>三个奇数的尽头就是3个1必败，因此开局3奇数必败，开局1或2偶数必胜。</p><p>开局全偶数的情况，可以从lowbit的角度考虑。<br>当开局三个数lowbit位于同一位时，不论怎么操作都不能使lowbit相等。<br>当开局三个数lowbit位于不同位时，可以通过操作控制lowbit相等，整个过程lowbit减小。<br>lowbit相等的尽头是三个数的lowbit都等于$1$也就是三奇数的必败态。</p><p>因此，开局三个数lowbit相等必败。<br>观察到三个数不全是偶数的情况也可以归并到这个结论中，2行秒了。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lowbit</span>(a)==<span class="built_in">lowbit</span>(b)&amp;&amp;<span class="built_in">lowbit</span>(b)==<span class="built_in">lowbit</span>(c))  NO; <span class="keyword">else</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7491 开关灯</h1><h2 id="题意-3">题意</h2><p>有 $n$ 盏灯排成一排，编号为 $1\sim n$ ，初始状态为全灭。<br>每次操作可以选择一盏灯，反转这盏灯和与之相邻的灯的状态（开变关，关变开）。<br>求任意操作后，这排灯可以到达多少种不同的状态。</p><h2 id="解题思路-3">解题思路</h2><p>观察样例发现答案满足 $2^n$ 。<br>手玩发现只有 $n\equiv2(mod\ 3)$ 时达不到全亮状态，是 $2^{n-1}$ 。</p><p>如果发现力不够，还可以考虑以下方法：<br>对位置1,2分别做一次操作，可以单独反转3；再对4,5分别做一次操作，可以单独反转6。<br>以此类推，正着做可以单独反转所有 $i\equiv0(mod\ 3)$，反着做可以单独反转所有 $i\equiv n-2(mod\ 3)$ 。<br>如果可以单独任意反转连续2个灯，则与它们相邻的灯也可以单独任意反转，以达到所有 $2^n$ 种状态。</p><p>当且仅当 $n\equiv2(mod\ 3)$ 时，正着做和反着做反转的都是同一批灯，无法通过以上操作任意反转所有的灯。<br>由于无法到达全亮状态，答案少一半，为 $2^{n-1}$ 。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">2</span>) cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,n<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1013)HDU7493 飞行棋</h1><h2 id="题意-4">题意</h2><p>$0\sim n$ 号格子排成一排，棋子初始在 $0$ 号格，目标是精确到达第 $n$ 格。<br>每次随机从 $1\sim n$ 中均匀随机一个正整数 $x$ ，然后向前移动 $x$ 步，若移动到第 $n$ 格还有剩余步数，则会往回走。<br>如果随机到 $n$ 且最终没有精确到达第 $n$ 格，则可以再从 $1\sim n-1$ 中均匀随机一个正整数并行动。</p><p>求精确到达第 $n$ 格的期望步数。</p><h2 id="解题思路-4">解题思路</h2><p>从 $0$ 号格子一次到达第 $n$ 格的概率是 $\dfrac{1}{n}$ 。<br>从 $1\sim n-1$ 号格子一次到达第 $n$ 格的概率都是 $\dfrac{1}{n}(1+\dfrac{1}{n-1})=\dfrac{1}{n-1}$ ，期望为 $n-1$<br>如果没有到达终点，棋子只会落在 $1\sim n-1$ 号格子上。</p><p>因此答案为 $\dfrac{1}{n}+\dfrac{n-1}{n}\times ((n-1)+1)=n+1+\dfrac{1}{n}$ 。<br>（式子中 $(n-1)+1$ 是加上了从0开始的第一步）</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sub</span>(<span class="built_in">add</span>(<span class="built_in">inv</span>(n),n),<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校06</title>
      <link href="/posts/ACM_2024Summer_NCD06.html"/>
      <url>/posts/ACM_2024Summer_NCD06.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81601">2024牛客暑期多校训练营6</a></p><h1>A.Cake</h1><h2 id="题意">题意</h2><p>给定一棵 $n$ 个节点，以 $1$ 为根的树，每条边有一个权值 0 或 1。<br>棋子初始在节点 $1$ ，Alice先手，Bob后手。<br>每回合，玩家可以将棋子移动到当前节点的一个子节点。<br>直到棋子达到叶子节点，游戏结束。</p><p>棋子经过的路径的权值按顺序构成一个01序列，记它的长度为 $m$ 。<br>接下来，Bob可以把 $1$ 块蛋糕任意分成 $m$ 份（某份蛋糕可以为0//空盘子）。<br>然后根据01序列决定取蛋糕的次序：0代表Bob取，1代表Alice取。</p><p>问两人都以最优策略行动和切蛋糕，问Alice最多能拿到多少蛋糕。</p><h2 id="解题思路">解题思路</h2><p>先考虑在路径确定的情况下，Bob会怎么分蛋糕：<br>Bob会找到一个前缀pre，这个前缀的“0占比”是所有前缀中最大的。<br>pre的长度记为 $t$，0占比记为 $p$。<br>Bob会将蛋糕平均分为 $t$ 份，剩下 $m-t$ 份为空。<br>这样，Bob可以保证他拿到最多的，大小为 $p$ 的蛋糕。</p><p>对于每个节点 $i$ ，先DFS一次，处理出从 $1$ 到 $i$ 这条路径上所有前缀的最大0占比。<br>那么在每个结点处。</p><p>再DFS一次，假设根节点 $1$ 的深度是1，那么：<br>深度为奇数的节点是Alice的回合，Alice会希望前缀的“0的占比”最小化；<br>深度为偶数的节点是Bob的回合，Bob会希望前缀的“0的占比”最大化。</p><p>从叶子到根更新，得到最终0占比 $p$ ，按照上面的方法分蛋糕，最终答案为 $1-p$ 。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ll n;</span><br><span class="line">vector&lt;vector&lt;pll&gt;&gt; G;</span><br><span class="line">vector&lt;ld&gt; pref; <span class="comment">//前缀中0的最大占比</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u=<span class="number">1</span>,ll fa=<span class="number">0</span>,ll cnt0=<span class="number">0</span>,ll cnt1=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>) <span class="built_in">chmax</span>(pref[u],(ld)cnt0/(cnt0+cnt1));<span class="comment">//用当前节点的0占比更新前缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">            pref[v]=pref[u];<span class="comment">//继承父节点的pref</span></span><br><span class="line">            <span class="built_in">dfs</span>(v,u,cnt0+(w==<span class="number">0</span>),cnt1+(w==<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;ld&gt; dp; <span class="comment">//节点对执棋手的最优解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_dp</span><span class="params">(ll u=<span class="number">1</span>,ll fa=<span class="number">0</span>, ll dep=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    dp[u]=dep%<span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>&amp;&amp;G[u].<span class="built_in">size</span>()==<span class="number">1</span>) dp[u]=pref[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u]) <span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">        <span class="built_in">dfs_dp</span>(v,u,dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dep%<span class="number">2</span>) <span class="built_in">chmin</span>(dp[u],dp[v]); <span class="comment">//先手求pref小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">chmax</span>(dp[u],dp[v]); <span class="comment">//后手求pref大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    pref.<span class="built_in">clear</span>(); pref.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dp.<span class="built_in">clear</span>(); dp.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v,w);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(); <span class="built_in">dfs_dp</span>();</span><br><span class="line">    <span class="built_in">print_float</span>(<span class="number">1.</span>-dp[<span class="number">1</span>],<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Cake2</h1><h2 id="题意-2">题意</h2><p>给定正整数 $n,k$ ，蛋糕的形状是正 $n$ 边形，顶点编号为 $0$ 到 $n-1$ 。<br>对于每个顶点 $i$ ，沿着由 顶点 $i$ 和 $(i+k)mod\ n$ 确定的直线切一刀。<br>求最后蛋糕的块数。</p><p>以$n=6,k=2$为例，蛋糕的形状如下：<br><img src="https://source.cclmsy.cc/Posts/ACM/2024Summer_NCD06_B.png" alt=""></p><h2 id="解题思路-2">解题思路</h2><p>手画几个图，发现当且仅当 $n=k\times2$ 时，蛋糕的块数为 $n$ 。<br>其余情况下，发现每个交点仅由2条直线，蛋糕的块数为 $n\times k+1$ 。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n/<span class="number">2</span>) k=n-k;</span><br><span class="line">    <span class="keyword">if</span>(k*<span class="number">2</span>!=n) cout &lt;&lt; k*n+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Genshin Impact’s Fault</h1><h2 id="题意-3">题意</h2><p>给定一个字符串，包含以下字符：</p><ul><li><code>3</code>：三星卡</li><li><code>4</code>：四星卡</li><li><code>5</code>：普通五星卡</li><li><code>U</code>：特殊五星卡</li></ul><p>满足以下条件的字符串是合法的：</p><ol><li>每10个连续的字符不能都是<code>3</code></li><li>每90个连续的字符至少有1个<code>U</code>或<code>5</code></li><li>相邻两张五星卡不能都是<code>5</code></li></ol><p>判断给定字符串是否合法。</p><h2 id="解题思路-3">解题思路</h2><p>按照题意模拟判断。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;3&#x27;</span>) cnt++;</span><br><span class="line">        <span class="keyword">else</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">10</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="string">&#x27;5&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;U&#x27;</span>) cnt++;</span><br><span class="line">        <span class="keyword">else</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">90</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> pre=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;5&#x27;</span>||c==<span class="string">&#x27;U&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="string">&#x27;0&#x27;</span>) pre=c;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pre==<span class="string">&#x27;5&#x27;</span>&amp;&amp;c==<span class="string">&#x27;5&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> pre=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check1</span>()&amp;&amp;<span class="built_in">check2</span>()&amp;&amp;<span class="built_in">check3</span>()) cout &lt;&lt; <span class="string">&quot;valid\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;invalid\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校05</title>
      <link href="/posts/ACM_2024Summer_NCD05.html"/>
      <url>/posts/ACM_2024Summer_NCD05.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81600">2024牛客暑期多校训练营5</a></p><blockquote><p>玲珑骰子安红豆，入骨相思知不知。  ——温庭筠</p></blockquote><h1>B.珑</h1><h2 id="题意">题意</h2><p>使用若干个 $1\times 2$ 的小矩形，恰好覆盖一个 $n\times m$ 的大矩形（即不允许重叠、不允许有部分超出大矩形范围）</p><p>对于任意两个小矩形，可能存在以下两种限制（中的0种、1种或2种）：</p><ol><li>边长为1的边不能相贴</li><li>边长为2的边不能相贴，即使相贴部分的长度仅为1</li></ol><p>问是否存在一种方案，在满足给定限制的条件下，恰好覆盖大矩形。</p><h2 id="解题思路">解题思路</h2><p>不妨令 $n&lt;m$ ：</p><ol><li>小矩形的面积是2，所以 $n\times m$ 必须是偶数</li><li>只有 $n=1$ 的情况满足条件2</li><li>只有 $n=1且m&gt;2$ 的情况不满足条件1</li></ol><p><img src="https://source.cclmsy.cc/Posts/ACM/2024Summer_NCD05_B.png" alt="image"></p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>&amp;&amp;m%<span class="number">2</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 面积是奇数</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">2</span>) &#123;YES;<span class="keyword">return</span> ;&#125; <span class="comment">// 1*2只需要一块</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>&amp;&amp;n!=<span class="number">1</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 只有1*m时能满足b</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;n==<span class="number">1</span>) &#123;NO;<span class="keyword">return</span> ;&#125; <span class="comment">// 只有1*m时不能满足a</span></span><br><span class="line">    YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.安</h1><h2 id="题意-2">题意</h2><p>May和Ray各有 $n$ 个骑士，分别按顺序排成一排，编号为 $1\sim n$ 。<br>May的骑士的生命值为 $a_i$ ，Ray的骑士的生命值为 $b_i$ 。</p><p>玩家每次操作可以选择一个双方骑士都存活的序号 $i$ ，命自己的骑士 $i$ 攻击对方的骑士 $i$ （使对方的骑士 $i$ 的生命值减少 $1$ ）。</p><p>May先行，两人都执行最优策略，直到无法操作。</p><p>问May最终剩余多少个骑士。</p><h2 id="解题思路-2">解题思路</h2><p>考虑最优策略：</p><ol><li>$a_i&gt;b_i$ ：优势，在这个位置只需要在对方攻击后反击，就能保证消灭对方。</li><li>$a_i&lt;b_i$ ：根据上一条，这个位置的骑士无法存活。</li><li>$a_i=b_i$ ：先攻击的棋子存活，一半的棋子存活，先手可以向上取整。</li></ol><p>按照最优策略，答案为 $cnt(a_i&gt;b_i)+\lceil cnt(a_i=b_i)/2 \rceil$ 。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,n);</span><br><span class="line">    ll ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[i]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[i]) ans++;</span><br><span class="line">    &#125;cout &lt;&lt; ans+(cnt+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.入</h1><h2 id="题意-3">题意</h2><p>给定一个 $n$ 个点 $m$ 条边的无向图，每个点带唯一点权 $w_i$ 。</p><p>棋子初始被放在一个点上，每次会移动到相邻的点中点权最小的一个点。</p><p>现在点权和初始位置可以自己决定，问最多能经过多少个点。</p><h2 id="解题思路-3">解题思路</h2><p>若从点 $i$ 走到点 $j$ ，其他和 $i$ 相邻的点的权值一定大于点 $j$ 的权值，因此之后都不会再走到这些点。</p><p>换句话说，走到下一个点之后，就可以把上一步的点和它的相邻点删掉了。</p><p>建图，按照以上思路，从每个点出发各一次，DFS找到最长路径长度。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ll n,m;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">ll ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll cur=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">chmax</span>(ans,cur);</span><br><span class="line">    vector&lt;ll&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[u]) <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">        tmp.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        vis[v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt+=tmp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n-cnt+cur&gt;=ans)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:tmp) <span class="built_in">dfs</span>(v,cur+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:tmp) vis[v]=<span class="number">0</span>;</span><br><span class="line">    cnt-=tmp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll u,v;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    vis.<span class="built_in">clear</span>(); vis.<span class="built_in">resize</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        vis[i]=<span class="number">1</span>; cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>L.知</h1><h2 id="题意-4">题意</h2><p>给定一个长度为 $n$ 的序列 $a$ ，每次操作可以选择一个下标 $i&lt;n$ ，执行：$a_i=a_i+1,a_{i+1}=a_{i+1}-1$ 。</p><p>求任意次操作后，序列 $a$ 的积的最大值 $mod\ 998244353$ 。</p><h2 id="解题思路-4">解题思路</h2><p>小学老师教过我们，当和一定时，数越平均，积越大。</p><p>观察到操作的特性：后面的大数字可以匀到前面，但是前面的数字不能匀给后面。</p><p>从前往后处理，把第 $i$ 个数 $a_i$ 加入答案时，<br>从当前的 前 $i-1$ 个数中，从小到大依次选取尽可能多的数（记为 $b_1\sim b_k$ ），<br>满足：$max{b_1\cdots b_k}&lt; avg{b_1 \cdots b_k,a_i}$</p><p>然后可以将 ${b_1 \cdots b_k,a_i}$ 平均化，是最优的平均方法。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// ll n=5;</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span>,vans</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    vans.<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;vans[<span class="number">0</span>])&#123;</span><br><span class="line">            ll tsum=v[i],j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;i)&#123; <span class="comment">//取出需要被匀的数</span></span><br><span class="line">                <span class="keyword">if</span>(vans[j]&gt;=tsum/(j+<span class="number">1</span>)) <span class="keyword">break</span>;  </span><br><span class="line">                <span class="comment">//如果当前的数已经大于等于平均值，就不需要被平均了</span></span><br><span class="line">                tsum+=vans[j]; j++;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;ll&gt; temp;</span><br><span class="line">            <span class="built_in">FORLL</span>(k,j,i<span class="number">-1</span>) temp.<span class="built_in">emplace_back</span>(vans[k]);</span><br><span class="line">            ll avg=tsum/(j+<span class="number">1</span>),tt=tsum%(j+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">insert</span>(temp.<span class="built_in">end</span>(),tt,avg+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">insert</span>(temp.<span class="built_in">end</span>(),j+<span class="number">1</span>-tt,avg);</span><br><span class="line">            vans=temp;</span><br><span class="line">        &#125;<span class="keyword">else</span> vans.<span class="built_in">emplace_back</span>(v[i]);</span><br><span class="line">        <span class="built_in">SORT</span>(vans);</span><br><span class="line">    &#125; <span class="comment">// print_vec(ans);</span></span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:vans) <span class="built_in">multo</span>(ans,x);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校04</title>
      <link href="/posts/ACM_2024Summer_HDU04.html"/>
      <url>/posts/ACM_2024Summer_HDU04.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A84%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（4）</a></p><h1>1003</h1><p>//TODO</p><h1>(1005)HDU7473.多层血条</h1><h2 id="题意">题意</h2><p>Boss血条的尺寸为 $n$ 行 $m$ 列，外层有边框。<br>行数仅代表血条的高度，不代表血量。<br>每列代表 $1$ 点血量， $m$ 列代表了 $m$ 点血量，即一层血条。</p><p>血条自底向上、从左往右平铺，最底下没有血量的部分为空格。<br>第一层血量用 <code>A</code> 表示，第二层血量用 <code>B</code> 表示，…，第五层血量用 <code>E</code> 表示，第六层血量用 <code>A</code> 表示，五层一循环，以此类推。</p><p>$n=2,m=10$ 且血量为$12$时，血条如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">|BBAAAAAAAA|</span><br><span class="line"><span class="section">|BBAAAAAAAA|</span></span><br><span class="line"><span class="section">+----------+</span></span><br></pre></td></tr></table></figure><p>为了加强打击反馈，当Boss受到伤害时，即将扣减的血量将短暂显示为<code>.</code>，然后再显示为对应的血条。</p><p>如上面的血条，当受到 $3$ 点伤害时，血条将变为：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">|..AAAAAAA.|</span><br><span class="line"><span class="section">|..AAAAAAA.|</span></span><br><span class="line"><span class="section">+----------+</span></span><br></pre></td></tr></table></figure><p>给定 $n,m$ ，血量 $hp$，即将受到的伤害 $dmg$ ，求受到伤害时的血条。</p><h2 id="解题思路">解题思路</h2><p>计算血条层数决定填充当前层（和下一层）的字符。<br>计算当前最后一个血的位置，然后根据伤害对血条进行修改。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,hp,dmg;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; hp &gt;&gt; dmg;</span><br><span class="line">    string ul=<span class="string">&#x27;+&#x27;</span>+<span class="built_in">string</span>(m,<span class="string">&#x27;-&#x27;</span>)+<span class="string">&#x27;+&#x27;</span>; <span class="comment">//边框</span></span><br><span class="line">    cout &lt;&lt; ul &lt;&lt; endl;</span><br><span class="line">    string s=<span class="string">&quot;|&quot;</span>;</span><br><span class="line">    ll k=(hp+m<span class="number">-1</span>)/m; <span class="comment">//层数</span></span><br><span class="line">    <span class="type">char</span> c=(k+<span class="number">4</span>)%<span class="number">5</span>+<span class="string">&#x27;A&#x27;</span>; <span class="comment">//当前层字符</span></span><br><span class="line">    ll cur = (hp<span class="number">-1</span>)%m+<span class="number">1</span>; <span class="comment">//当前层血量位置</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,cur) s+=c;</span><br><span class="line">    <span class="type">char</span> c1=(k<span class="number">-1</span>)&gt;<span class="number">0</span>?(k<span class="number">-2</span>)%<span class="number">5</span>+<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27; &#x27;</span>; <span class="comment">//下一层字符</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,cur+<span class="number">1</span>,m) s+=c1;</span><br><span class="line">    s+=<span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    <span class="built_in">chmin</span>(dmg,m);</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,cur,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dmg==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dmg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,m,cur+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dmg==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        dmg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ul &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>1007</h1><p>//TODO</p><h1>(1009)HDU7477.昵称检索</h1><h2 id="题意-2">题意</h2><p>给定 $n$ 个字符串表示名字。<br>一个昵称由两部分组成：一个给定的名字+4位数字。<br>其中，4位数字表示一个日期。</p><p>注：日期格式为 <code>MMDD</code> ，即月份和日期，0229也算。</p><p>给定一个长度为 $m$ 的字符串，计算所有子序列中能构成不同的昵称的个数。</p><h2 id="解题思路-2">解题思路</h2><p>昵称和日期分开考虑。</p><p>要求计不同的昵称的个数，因此每种名字、日期只需要考虑一次。</p><p>名字只需要选取最早完整出现的子序列，因为早出现一定比晚出现匹配的日期个数多。<br>日期只需要选取最晚完整出现的子序列，因为晚出现一定比早出现匹配的名字个数多。</p><p>记录每种字符出现的位置，先匹配日期。<br>用 $date_i$ 表示下标为 $i$ 的位置开头的不同日期数。<br>对 $date$ 做一个后缀和， $date_i$ 就表示到当前位置开始，往后的不同日期数。</p><p>再匹配名字。<br>找到名字 $name$ 的最早出现位置 $j$ ，它能组合出的最多不同昵称数为 $date_{j+1}$，加入答案。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; days = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">toint</span><span class="params">(<span class="type">char</span> c1,<span class="type">char</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c1-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+c2-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;string&gt; names;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        names.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">char</span>,vector&lt;ll&gt;&gt; posc,posint;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>) posc[s[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> posint[s[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">date</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> d2=<span class="string">&#x27;0&#x27;</span>;d2&lt;=<span class="string">&#x27;9&#x27;</span>;d2++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(posint[d2].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">        <span class="keyword">auto</span> posd2 = posint[d2].<span class="built_in">back</span>(); <span class="comment">//最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d1=<span class="string">&#x27;0&#x27;</span>;d1&lt;=<span class="string">&#x27;3&#x27;</span>;d1++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> day=<span class="built_in">toint</span>(d1,d2);</span><br><span class="line">            <span class="keyword">if</span>(day&gt;<span class="number">31</span>||day&lt;<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//不可能的天数</span></span><br><span class="line">            <span class="keyword">if</span>(posint[d1].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">            <span class="keyword">auto</span> itposd1 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[d1]),posd2); <span class="comment">//找比posd2小的最大的位置</span></span><br><span class="line">            <span class="keyword">if</span>(itposd1==posint[d1].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posd2小的</span></span><br><span class="line">            <span class="keyword">auto</span> posd1 = *(--itposd1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> m2=<span class="string">&#x27;0&#x27;</span>;m2&lt;=<span class="string">&#x27;9&#x27;</span>;m2++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(posint[m2].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">                <span class="keyword">auto</span> itposm2 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[m2]),posd1); <span class="comment">//找比posd1小的最大的位置</span></span><br><span class="line">                <span class="keyword">if</span>(itposm2==posint[m2].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posd1小的</span></span><br><span class="line">                <span class="keyword">auto</span> posm2 = *(--itposm2);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> m1=<span class="string">&#x27;0&#x27;</span>;m1&lt;=<span class="string">&#x27;1&#x27;</span>;m1++)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> month=<span class="built_in">toint</span>(m1,m2);</span><br><span class="line">                    <span class="keyword">if</span>(month&gt;<span class="number">12</span>||month&lt;<span class="number">1</span>) <span class="keyword">continue</span>;; <span class="comment">//不可能的月份</span></span><br><span class="line">                    <span class="keyword">if</span>(day&gt;days[month]) <span class="keyword">continue</span>;; <span class="comment">//不可能的日期</span></span><br><span class="line">                    <span class="keyword">if</span>(posint[m1].<span class="built_in">empty</span>()) <span class="keyword">continue</span>; <span class="comment">//没有这个数字</span></span><br><span class="line">                    <span class="keyword">auto</span> itposm1 = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(posint[m1]),posm2); <span class="comment">//找比posm2小的最大的位置</span></span><br><span class="line">                    <span class="keyword">if</span>(itposm1==posint[m1].<span class="built_in">begin</span>()) <span class="keyword">continue</span>; <span class="comment">//没有比posm2小的</span></span><br><span class="line">                    <span class="keyword">auto</span> posm1 = *(--itposm1);</span><br><span class="line">                    date[posm1]++;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; month &lt;&lt; &#x27; &#x27; &lt;&lt; day &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,m<span class="number">-1</span>,<span class="number">0</span>) date[i]+=date[i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// print_vec(date);</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;name:names)&#123;</span><br><span class="line">        ll curi=<span class="number">-1</span>,len=name.<span class="built_in">length</span>();</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> c=name[i];</span><br><span class="line">            <span class="keyword">auto</span> it=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(posc[c]),curi);</span><br><span class="line">            <span class="keyword">if</span>(it==posc[c].<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            curi=*it;</span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>) ans+=date[curi+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校03</title>
      <link href="/posts/ACM_2024Summer_HDU03.html"/>
      <url>/posts/ACM_2024Summer_HDU03.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A83%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（3）</a></p><h1>(1001)HDU7457.深度自同构</h1><h2 id="题意">题意</h2><p>求由 $n$ 个节点构成，且满足“深度相同的节点，度相同”的森林的方案数。</p><h2 id="解题思路">解题思路</h2><p>先考虑 $i$ 个节点的合法的树，这棵树每个节点的子树形态相同。<br>去掉根节点，每个部分的子树形态相同，那么每个子树的节点数是 $i-1$ 的约数。<br>设 $f(i)$ 表示 $i$ 个节点满足上述条件的树的方案数，那么有：$f(i)=\sum_{d|(i-1)} f(d)$</p><p>再考虑 $n$ 个节点的合法的森林，每个树的节点数是 $n$ 的约数。<br>设 $g(n)$ 表示 $n$ 个节点满足上述条件的森林的方案数，那么有：$g(n)=\sum_{d|n} f(d)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    ll n=<span class="number">1e6</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=n;j+=i)</span><br><span class="line">            <span class="built_in">addto</span>(f[j+<span class="number">1</span>],f[i]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=n;j+=i)</span><br><span class="line">            <span class="built_in">addto</span>(g[j],f[i]);</span><br><span class="line">    <span class="comment">//寄巧：对于从约数i到倍数j的转移，可以枚举倍数k，以调和级数复杂度求</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; g[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7463.单峰数列</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的数列 $a$ ，$q$ 次操作：</p><ol><li><code>1 l r x</code>：$a[l,r]$ 每个数加 $x$</li><li><code>2 l r</code>：判断 $a[l,r]$ 是否相同</li><li><code>3 l r</code>：判断 $a[l,r]$ 是否严格单调递增，$l=r$ 时也算</li><li><code>4 l r</code>：判断 $a[l,r]$ 是否严格单调递减，$l=r$ 时也算</li><li><code>5 l r</code>：判断 $a[l,r]$ 是否单峰数列</li></ol><p>长度为 $m$ 的数列 $b$ 被称为单峰数列，当且仅当存在唯一位置 $1\lt i\lt m$ ，使得 $b[1,i]$ 严格单调递增，$b[i,m]$ 严格单调递减。</p><h2 id="解题思路-2">解题思路</h2><p>暴力判断<br>维护差分序列更直观</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; v;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">range_add</span><span class="params">(ll l,ll r,ll val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l<span class="number">-1</span>,r<span class="number">-1</span>) v[i]+=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_same</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i]!=v[l<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_up</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;=v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_down</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>) <span class="keyword">if</span>(v[i<span class="number">-1</span>]&lt;=v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_mountain</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>; <span class="comment">//up</span></span><br><span class="line">    <span class="keyword">if</span>(v[l<span class="number">-1</span>]&gt;v[l]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i<span class="number">-1</span>]==v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(fl==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i<span class="number">-1</span>]&gt;v[i]) fl=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fl==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i<span class="number">-1</span>]&lt;v[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fl==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    v.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll q;cin &gt;&gt; q;</span><br><span class="line">    ll op,l,r,val;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">            <span class="built_in">range_add</span>(l,r,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_same</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_up</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_down</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">check_mountain</span>(l,r) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1008)HDU7464.比特跳跃</h1><h2 id="题意-3">题意</h2><p>给定一个 $n$ 个点 $m$ 条边（不保证连通，可能有重边）的无向图。<br>每条边 $E(u,v)$ 有一个权值 $w$ ，表示从 $u$ 到 $v$ 的代价。<br>此外，对于任意两点 $u,v$ ，可以付出 $k\times(u|v)$ （按位或）的代价从 $u$ 跳到 $v$ 。<br>分别求从节点 $1$ 到所有其他点 $2$ ~ $n$ 的最小代价。</p><h2 id="解题思路-3">解题思路</h2><p>最暴力的想法肯定是把直接跳跃也看作边加入图中，然后跑单源最短路。<br>但是这样边的数量是 $n^2$ ，显然不可取。<br>因此考虑哪些边是有必要加的。</p><p>$1$ 直接跳到其他节点的方案是很优的：<br>若节点 $i$ 不在节点 $1$ 所在的连通块内，那么 $1$ 直接跳到 $i$ 的代价只可能是 $i$ （$i$ 为奇数）或 $i+1$ （$i$ 为偶数）。</p><p>但如果存在 $E(1,2,0)$ ，对于 $x=2,6,10…$ 这一类满足 $x%4=2$ 的节点， $1$ 直接跳到 $x$ 的代价为 $x+1$ ，但先走到 $2$ 再跳到 $x$ 的代价仅为 $x$ 。</p><p>因此，对于 $x%4=2$ 的节点，需要加入 $E(2,x,k(x|2))$ 。</p><p>同理，对于 $x%2^{i+1}=2^i$ 的节点，需要加入 $E(2,x,k(x|2^i))$ 。</p><p>最后，跑一遍单调队列优化的单源最短路，求出答案。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">pow2</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">60</span>;i++) pow2.<span class="built_in">emplace_back</span>(pow2.<span class="built_in">back</span>()*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="function">Dijkstra <span class="title">dij</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ll u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        dij.<span class="built_in">addedge</span>(u,v,w);</span><br><span class="line">        dij.<span class="built_in">addedge</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n) dij.<span class="built_in">addedge</span>(<span class="number">1</span>,i,k*(<span class="number">1</span>|i));</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">60</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pow2[i]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll j=pow2[i]*<span class="number">2</span>;j&lt;=n;j+=pow2[i]) <span class="keyword">if</span>(pow2[i]&amp;j)</span><br><span class="line">            dij.<span class="built_in">addedge</span>(pow2[i],j,k*(pow2[i]|j));</span><br><span class="line">    &#125;</span><br><span class="line">    dij.<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n) cout &lt;&lt; dij[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7467.抓拍</h1><h2 id="题意-4">题意</h2><p>$n$ 个人，第 $i$ 个人初始在 $(x_i,y_i)$ 。<br>每个人有一个行进方向：东（E,+x方向）、西（W,-x方向）、南（S,-y方向）、北（N,+y方向），每秒移动一个距离。<br>散步无限长时间、不改变方向、忽略碰撞。</p><p>求一个周长最小的矩形满足：</p><ol><li>上下边平行于 $x$ 轴，左右边平行于 $y$ 轴</li><li>存在一个时刻，所有人都在矩形内部</li></ol><h2 id="解题思路-4">解题思路</h2><p>每个时刻的最小周长矩形只由 最上面、最下面、最左边、最右边 的四个人决定，那么就考虑可能成为这四个人的人。</p><p>左右移动的人占据的y区间，上下移动的人占据的x区间，不会改变。<br>记录：左右走的人里最靠上、最靠下的人，上下走的人里最靠左、最靠右的人。</p><p>因为时间无限长，最后在最上面的人，一定是向上走的人中初始点最靠上的，其他方向同理。<br>记录：向上走的人里最靠上的、向下走的人里最靠下的，向左走的人里最靠左的、向右走的人里最靠右的。</p><p>开始最靠下的人如果是向左/右/下走的，已经记录了，只要在向上走的人中找到最靠下的，其他方向同理。<br>记录：向上走的人里最靠下的、向下走的人里最靠上的、向左走的人里最靠右的、向右走的人里最靠左的。</p><p>有了这12个值，就可以计算出任何一个时刻的 $x_{min},x_{max},y_{min},y_{max}$ ，从而计算出最小周长。</p><p>模拟可知，周长对时间的函数，要么是单调增的，要么是一个开口向上的二次函数（因为最后人一定越走越散）。因此可以三分找到极小值点，即为答案。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           E W S N</span></span><br><span class="line"><span class="comment">//           R L D U</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pll a,pll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second==b.second) <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">&#125;</span><br><span class="line">ll yLRmax,yLRmin,xUDmax,xUDmin;</span><br><span class="line">ll xLmin,xLmax,xRmin,xRmax,yUmin,yUmax,yDmin,yDmax;</span><br><span class="line"><span class="function">ll <span class="title">getC</span><span class="params">(ll t)</span></span>&#123;</span><br><span class="line">    ll xmin = <span class="built_in">min</span>(&#123;xLmin-t,xRmin+t,xUDmin&#125;);</span><br><span class="line">    ll xmax = <span class="built_in">max</span>(&#123;xLmax-t,xRmax+t,xUDmax&#125;);</span><br><span class="line">    ll ymin = <span class="built_in">min</span>(&#123;yDmin-t,yUmin+t,yLRmin&#125;);</span><br><span class="line">    ll ymax = <span class="built_in">max</span>(&#123;yDmax-t,yUmax+t,yLRmax&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*((xmax-xmin)+(ymax-ymin));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    vector&lt;pll&gt; L,R,U,D;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;E&#x27;</span>) R.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) L.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;N&#x27;</span>) U.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) D.<span class="built_in">emplace_back</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右移动的最上和最下两个人，上下移动的最左和最右两个人</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(L),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(R),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(U)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(D));</span><br><span class="line">    yLRmax = xUDmax = -INF;</span><br><span class="line">    yLRmin = xUDmin = INF;</span><br><span class="line">    <span class="keyword">if</span>(L.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(yLRmax,L.<span class="built_in">back</span>().second);<span class="built_in">chmin</span>(yLRmin,L.<span class="built_in">front</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(R.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(yLRmax,R.<span class="built_in">back</span>().second);<span class="built_in">chmin</span>(yLRmin,R.<span class="built_in">front</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(U.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(xUDmax,U.<span class="built_in">back</span>().first);<span class="built_in">chmin</span>(xUDmin,U.<span class="built_in">front</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(D.<span class="built_in">size</span>()) &#123;<span class="built_in">chmax</span>(xUDmax,D.<span class="built_in">back</span>().first);<span class="built_in">chmin</span>(xUDmin,D.<span class="built_in">front</span>().first);&#125;</span><br><span class="line">    <span class="comment">//初始状态，向左的最左最右，向右的最左最右，向上的最上最下，向下的最上最下</span></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(L)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(R)); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(U),cmp); <span class="built_in">sort</span>(<span class="built_in">ALL</span>(D),cmp);</span><br><span class="line">    xLmin = xRmin = yUmin = yDmin = INF;</span><br><span class="line">    xLmax = xRmax = yUmax = yDmax = -INF;</span><br><span class="line">    <span class="keyword">if</span>(L.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(xLmin,L.<span class="built_in">front</span>().first);<span class="built_in">chmax</span>(xLmax,L.<span class="built_in">back</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(R.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(xRmin,R.<span class="built_in">front</span>().first);<span class="built_in">chmax</span>(xRmax,R.<span class="built_in">back</span>().first);&#125;</span><br><span class="line">    <span class="keyword">if</span>(U.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(yUmin,U.<span class="built_in">front</span>().second);<span class="built_in">chmax</span>(yUmax,U.<span class="built_in">back</span>().second);&#125;</span><br><span class="line">    <span class="keyword">if</span>(D.<span class="built_in">size</span>()) &#123;<span class="built_in">chmin</span>(yDmin,D.<span class="built_in">front</span>().second);<span class="built_in">chmax</span>(yDmax,D.<span class="built_in">back</span>().second);&#125;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">2e9</span>;</span><br><span class="line">    <span class="comment">//三分找到getC最小的t</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        ll m1 = l+(r-l)/<span class="number">3</span>;</span><br><span class="line">        ll m2 = r-(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getC</span>(m1)&lt;<span class="built_in">getC</span>(m2)) r=m2;</span><br><span class="line">        <span class="keyword">else</span> l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mnans=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r) <span class="built_in">chmin</span>(mnans,<span class="built_in">getC</span>(i));</span><br><span class="line">    cout &lt;&lt; mnans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1012)HDU7468.死亡之组</h1><h2 id="题意-5">题意</h2><p>给定一个长度为 $n$ 的数组 $a$ （$n$ 是4的倍数），$a_i$ 表示第 $i$ 个队伍的实力。<br>每4个队伍一组，“死亡之组”至少符合以下条件之一：</p><ol><li>至少有2个队伍的实力 $&gt; L$</li><li>最大实力和最小实力之差 $\le D$</li></ol><p>问是否存在一种分组方案使得第 $1$ 组所在的小组不是“死亡之组”。</p><h2 id="解题思路-5">解题思路</h2><p>为了不满足条件1，存在至少3个队伍的实力 $\le L$ 即可。<br>然后把这3个队伍 $t_1,t_2,t_3$ 拿出来。<br>为了不满足条件2，所有队伍的实力中，最大值和最小值之差 $&gt; D$ 即可。<br>然后把实力最大的队伍 $t_4$ 拿出来。</p><p>对队伍1（$a_1$）进行讨论：</p><ul><li>如果 $a_1&gt;L$，替换 $t4$ ，重新判定</li><li>如果 $a_1\le L$，替换 $t3$</li></ul><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,l,d;cin &gt;&gt; n &gt;&gt; l &gt;&gt; d;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll t1 = v[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll cntll=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) <span class="keyword">if</span>(x&lt;l) cntll++;</span><br><span class="line">    <span class="keyword">if</span>(cntll&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t1&gt;=l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1-v.<span class="built_in">front</span>()&lt;=d) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">back</span>()-v.<span class="built_in">front</span>()&lt;=d) cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校04</title>
      <link href="/posts/ACM_2024Summer_NCD04.html"/>
      <url>/posts/ACM_2024Summer_NCD04.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81599">2024牛客暑期多校训练营4</a></p><h1>A.LCT</h1><h2 id="题意">题意</h2><p>给定一棵有根树，问按顺序给定的前 $i$ 条边组成的森林中，以 $c_i$ 为根的树的深度。</p><h2 id="解题思路">解题思路</h2><p>按步骤生成森林的过程，与并查集合并的过程一致。<br>因此用带权并查集，维护每个点的深度和答案，利用路径压缩降低时间复杂度。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">    vector&lt;ll&gt; parents, size, dep, ans;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DSU</span><span class="params">(ll n)</span> : parents(n + <span class="number">1</span>), size(n + <span class="number">1</span>, <span class="number">1</span>), dep(n + <span class="number">1</span>, <span class="number">0</span>), ans(n + <span class="number">1</span>, <span class="number">0</span>) &#123;</span> <span class="built_in">iota</span>(parents.<span class="built_in">begin</span>(), parents.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == parents[x]) <span class="keyword">return</span> x;</span><br><span class="line">        ll px = <span class="built_in">find</span>(parents[x]);</span><br><span class="line">        dep[x]+=dep[parents[x]]; </span><br><span class="line">        <span class="keyword">return</span> parents[x]=px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// merge b into a</span></span><br><span class="line">        ll pa = <span class="built_in">find</span>(a);</span><br><span class="line">        parents[b] = a;</span><br><span class="line">        dep[b] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="built_in">chmax</span>(ans[pa],ans[b]+dep[b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> ans[x];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll a,b,q;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(a,b);</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        cout &lt;&lt; dsu.<span class="built_in">query</span>(q) &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Sort4</h1><h2 id="题意-2">题意</h2><p>给定一个长度为 $n$ 的排列 $p$ （即序列中 $1$ ~ $n$ 的每个数恰好出现一次）。<br>每次操作可以选择4个元素，并任意交换它们的位置。<br>求使得排列变为升序的最少操作次数。</p><h2 id="解题思路-2">解题思路</h2><p>把排列看作由 $i\rightarrow p_i$（下标从1开始） 构成的图，这个图中有若干个环，表示这个环中的元素可以通过交换回到原来的位置。</p><p>长度为 $3,4$ 的环，可以通过一次操作还原；<br>长度为 $2$ 的环，可以 $2$ 个环一组通过一次操作还原；<br>长度大于 $4$ 的环，每次操作可以让 $3$ 个元素回到原来的位置，使得环的长度减少 $3$，直到环的长度小于等于 $4$。</p><p>根据这个原则，计算最终答案。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    ll ans=<span class="number">0</span>,of=<span class="number">0</span>; <span class="comment">//of:最终长度为2的环的数量</span></span><br><span class="line">    map&lt;ll,ll&gt; mp;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        ll cnt=<span class="number">1</span>,cur=v[i];</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=i)&#123;</span><br><span class="line">            vis[cur]=<span class="number">1</span>;</span><br><span class="line">            cur = v[cur];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">1</span>) ans+=(cnt<span class="number">-1</span>)/<span class="number">3</span>; <span class="comment">//最终长度为4的环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt%<span class="number">3</span>==<span class="number">2</span>)&#123; <span class="comment">//最终长度为2的环</span></span><br><span class="line">            ans+=(cnt<span class="number">-2</span>)/<span class="number">3</span>;</span><br><span class="line">            of++;</span><br><span class="line">        &#125;<span class="keyword">else</span> ans+=cnt/<span class="number">3</span>; <span class="comment">//最终长度为3的环</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans+(of+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Yet Another Origami Problem</h1><h2 id="题意-3">题意</h2><p>给定一个长度为 $n$ 的序列 $a$，每次可以选择一个元素 $a_i$，执行以下操作之一：</p><ol><li>所有原来比 $a_i$ 小的数 $a_j$ ： $a_j=a_i+2(a_i-a_j)$ ，即原来 $a_j$ 比 $a_i$ 小多少，现在就比 $a_i$ 大多少。</li><li>所有原来比 $a_i$ 大的数 $a_j$ ： $a_j=a_i-2(a_j+a_i)$ ，即原来 $a_j$ 比 $a_i$ 大多少，现在就比 $a_i$ 小多少。</li></ol><p>问任意次操作后，序列 $a$ 中最大元素和最小元素之差 $max(a)-min(a)$ 的最小值。</p><h2 id="解题思路-3">解题思路</h2><p>每次操作：</p><ol><li>对序列 $a$ 排序去重，求出差分数组 $d$ 。</li><li>选定次小元素 $a_2$ ，执行操作 $1$ ，使得最小元素 $a_1 = a_2 - d_1$ 变成 $a_1’ = a_2 + d_1$ 。</li></ol><p>假设重新排序去重后，新的 $a_1’$ 相邻的两项为 $a_j,a_{j+1}$ ，步骤1中这两项的差分是 $d_j=a_{j+1}-a_j$ 。<br>那么当 $a_i’$ 插到中间时，新的差分数组的变化如下：</p><ol><li>第1项 $d_1$ 删去（因为 $a_1$ 变成了 $a_1’$ 后移）</li><li>原本的 $d_j$ 被替换为 $d_j’=d_1-\sum\limits_{k=2}^{j-1}d_k$ ，$d’_{j+1}=d_j-d_j’$ 。</li></ol><p>第2点变化可能比较难理解，给出如下例子：</p><ul><li>$a = [1,6,8,10,13,15]$ （原序列排序去重）</li><li>$d = [5,2,2,3,2]$ （差分数组）</li><li>$a_1=1,a_2=6,d_1=5$ （选定次小元素做操作1）</li><li>$a_1’=a_2+d_1=11$</li><li>$a’ = [6,8,10,11,13,15]$ （新序列排序去重，$a_1’$ 位于第4位）</li><li>$d’ = [2,2,1,2,2]$ （新差分数组）</li></ul><p>差分数组的变化：</p><ol><li>第1项 $d_1=5$ 删去</li><li>第4项 $3$ 变为：$d_1-d_2-d_3=1$ 和 $3-1=2$</li></ol><p>这个变化的意义就在于，它证明了任意次操作后的差分数组中的元素，是原差分数组中元素的线性组合，且随着操作次数增加，$\sum d_i$ 逐渐减小，直到 $a$ 仅剩2个元素。<br>线性组合能达到的最小值为 $\gcd\limits_{i=1}^{n-1}d_i$ 。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">        ans = __gcd(ans,v[i]-v[i<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.Horse Drink Water</h1><h2 id="题意-4">题意</h2><p>将军饮马问题，将军在第一象限的整点 $(x_0,y_0)$ ，河流由 $x$ 正半轴和 $y$ 正半轴组成。<br>问将军碰到河流再前往 $(x_1,y_1)$ 的最短路径长度。</p><h2 id="解题思路-4">解题思路</h2><p>将起点以 $x$ 轴、 $y$ 轴为对称轴，分别对称到第四、二象限，比较这两个点和终点的距离，取最小值。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ld xx1,xx2,yy1,yy2;</span><br><span class="line">    cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;</span><br><span class="line">    ld ans1,ans2;</span><br><span class="line">    ans1 = <span class="built_in">sqrt</span>((xx1-xx2)*(xx1-xx2)+(yy1+yy2)*(yy1+yy2));</span><br><span class="line">    ans2 = <span class="built_in">sqrt</span>((xx1+xx2)*(xx1+xx2)+(yy1-yy2)*(yy1-yy2));</span><br><span class="line">    <span class="built_in">print_float</span>(<span class="built_in">min</span>(ans1,ans2),<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I</h1><p>// TODO</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校03</title>
      <link href="/posts/ACM_2024Summer_NCD03.html"/>
      <url>/posts/ACM_2024Summer_NCD03.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81598">2024牛客暑期多校训练营3</a></p><h1>A.Bridging the Gap 2</h1><h2 id="题意">题意</h2><p>$n$个人过河，第 $i$ 个人初始有 $h_i$ 点体力。<br>由于船的限制，每次过河（或返回）至少需要乘坐 $l$ 人（来划船），至多可以乘坐 $r$ 人，<strong>每个</strong>乘船的人都会消耗 $1$ 点体力。体力为 $0$ 的人无法乘船。<br>求对于给定的条件，是否能够使所有人过河。</p><h2 id="解题思路">解题思路</h2><p>假设初始所有人在左岸，考虑一种贪心模拟的做法：</p><ul><li>从在左岸的所有人中选取 $l$ 个体力最大的人划船，带 $r-l$ 个体力最小的人去右岸。</li><li>从在右岸的所有人中选取 $l$ 个体力最大的人划船返回左岸。</li><li>重复以上步骤，直到所有人都到达右岸，或者无法继续。</li></ul><p>这个过程中，除去最后一次划到右岸的 $r$ 个人，每次能运输的人数为 $r-l$ 。<br>最低<strong>往返</strong>的次数为 $turn = \lceil \dfrac{n-r}{r-l}\rceil$ ，且最优，因为往返越少对体力的要求越低。</p><p>对于个人，除自己前往右岸的1点体力，多余的体力可以用于划船带人，往返一次需要2点体力。<br>因此第 $i$ 个人能够参与的往返次数为 $\lfloor \dfrac{h_i-1}{2}\rfloor$ 。<br>由于只存在 $turn$ 次往返，因此第 $i$ 个人能够参与的往返次数为 $\min(\lfloor \dfrac{h_i-1}{2}\rfloor,turn)$ 。</p><p>计算所有人能够参与的往返次数之和，如果大于等于 $turn*l$ ，则按照上述贪心模拟的方法，可以使所有人过河。</p><h2 id="参考程序">参考程序</h2><blockquote><p>程序是副机长根据解题思路写的，居然A了()</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,l,r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll turn = (n-r)/(r-l) + ((n-r)%(r-l)!=<span class="number">0</span>);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) sum += <span class="built_in">min</span>((x<span class="number">-1</span>)/<span class="number">2</span>,turn);</span><br><span class="line">    cout &lt;&lt; (sum&gt;=turn*l?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Crash Test</h1><h2 id="题意-2">题意</h2><p>初始距离墙壁的距离为 $d$ 。<br>每次前进有 $n$ 种长度可以选择：$h_1,h_2,\cdots,h_n$。每次前进的长度可以是任意一种长度。<br>如果选择的长度 $h_i$ 大于当前与墙壁的距离 $d’$ ，将会退后多余的距离，即新的距离为 $h_i - d’$ 。<br>求在任意次（包括0次）前进后，与墙壁的最小距离。</p><h2 id="解题思路-2">解题思路</h2><p><a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593">裴蜀定理</a>：对于非0整数 $a,b$ ，对任意整数 $x,y$ 有 $gcd(a,b)|ax+by$ 成立，即 $gcd(a,b)$ 是所有 $a,b$ 的线性组合中，绝对值最小的非0整数。</p><p>裴蜀定理扩展到多整数的情况仍然成立。</p><p>因此计算出 $g=\gcd\limits_{i=1}^n(h_i)$ ，$g$ 的意义是通过对 $h_i$ 的某种线性组合，能够得到的最小前进距离。</p><p>然后每一步视为走 $g$ ，以此求得不撞墙答案 $d%g$ 与撞墙答案 $g-d%g$ ，取较小值即可。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,d; cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll g = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) g = __gcd(g,x);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(d%g,g-d%g) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Dominoes!</h1><p>//TODO</p><h1>J.Rigged Games</h1><p>//TODO</p><h1>L.Sudoku and Minesweeper</h1><h2 id="题意-3">题意</h2><p>经典数独在 $9\times 9$ 大小的棋盘格内进行，每一行、每一列、$9$ 个 $3\times 3$ 的小方块内，数字 $1-9$ 恰好出现一次。</p><p>扫雷是一款在棋盘格内进行的游戏，中心数字表示周围 $8$ 格包含地雷的数量。</p><p>现给定一个 $9\times 9$ 数字矩阵表示一个已经完成的合法经典数独，可以将里面的数字替换成地雷，但必须保留至少 $1$ 个数字，求一个合法的扫雷游戏布局。</p><h2 id="解题思路-3">解题思路</h2><p>除了边缘之外，中间 $7\times 7$ 范围内必然出现数字 $8$ 。<br>这是一个特殊的数字，只需要把它保留，其余所有数字全部替换成地雷，就是一个合法的扫雷游戏布局。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">vs</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;s:vs) cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> fl=<span class="number">0</span>,i8,i8;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">7</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vs[i][j]==<span class="string">&#x27;8&#x27;</span>)&#123;</span><br><span class="line">                i8=i; i8=j; fl=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(fl) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==i8&amp;&amp;j==i8) cout &lt;&lt; <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校02</title>
      <link href="/posts/ACM_2024Summer_HDU02.html"/>
      <url>/posts/ACM_2024Summer_HDU02.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A82%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（2）</a></p><h1>(1001)HDU7445.鸡爪</h1><p><strong>构造</strong></p><h2 id="题意">题意</h2><p>一个鸡爪由一个中心节点和3条（不含端点的）边构成。如下图中，三条边和节点 $1$ 构成一个鸡爪，节点 $2,3,4$ 不属于这个鸡爪。<br><img src="https://source.cclmsy.cc/Posts/ACM//2024Summer_HDU02_1001_1.png" alt="image"></p><p>给定正整数 $n$ ，允许使用 $n$ 条边和任意个节点。要求构造一张图，在包含尽可能最多的鸡爪的条件下，按顺序输出图的 $n$ 条边时的字典序最小。</p><h2 id="解题思路">解题思路</h2><p>不限制节点数的情况下，想要构造最多$n/3$（整除）个的鸡爪是很容易的，问题的关键是如何构造使得字典序最小。</p><p>先讨论 $n$ 是3的倍数的情况。<br>由于一个中心点只能被一个鸡爪使用，贪心的想法便是让节点 $1$~$n/3$ 成为中心点，且依次尽量让节点 $1,2,3$ 连接更多的点。</p><p>$4$~$n/3$ 这些点首先作为中心点和 $1,2,3$ 相连。<br>$1,2,3$ 三个点互相连接后，无法构成以 $1,2,3$ 为中心的鸡爪，因此需要借助 $n/3+1, n/3+2, n/3+3$ 这三个点进行构造。</p><p>连接图如下：<br><img src="https://source.cclmsy.cc/Posts/ACM/2024Summer_HDU02_1001_2.png" alt="image"></p><p>其他情况：<br>对于 $n$ 不是3的倍数的情况，将多余的1或2个点连接到节点1上。<br>$n\le 6$时，由于节点数太少，需要单独构造。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;pll&gt;&gt; ans=&#123;</span><br><span class="line">    &#123;&#125;, <span class="comment">// 0</span></span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;&#125;, <span class="comment">// 1</span></span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">6</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#125;, <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:ans[n])&#123;</span><br><span class="line">            cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pll&gt; edges;</span><br><span class="line">    ll cnt = n/<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,cnt+<span class="number">3</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">1</span>,i); </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">3</span>,cnt+<span class="number">2</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">2</span>,i);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">4</span>,cnt+<span class="number">1</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">3</span>,i); </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n%<span class="number">3</span>) edges.<span class="built_in">emplace_back</span>(<span class="number">1</span>,cnt+<span class="number">3</span>+i);</span><br><span class="line">    <span class="built_in">SORT</span>(edges);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:edges)&#123;</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Test:&quot; &lt;&lt; edges.size() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1003)HDU7447.绝对不模拟的简单魔方</h1><h2 id="题意-2">题意</h2><p>给定一个三阶魔方，用$1$~$6$表示6个面的颜色。<br>魔方从初始还原状态起，侧面被扭转了不超过3次，且有一个角上的两片颜色贴纸可能贴错。<br>确定魔方的贴纸是否被贴错。如果有贴错，输出贴错那个角的三个颜色。</p><h2 id="解题思路-2">解题思路</h2><p>扭转三次的操作对于魔方的角来说没有任何影响，只是虚晃一枪（题目中也提示了“绝对不模拟”）。</p><blockquote><p>但是赛时还是有神速度写模拟而且一遍过了%%%%</p></blockquote><p>只需要先把正常状态的魔方的8个角按同一顺序（如顺时针）记录下来，统一以$1,6$开头以唯一确定三元组。<br>再把输入的魔方的8个角按同一顺序（顺时针）记录下来，统一以$1,6$开头，然后在正常状态的记录中查找，找不到的就是被贴错贴纸的角。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cor</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">cor</span>(<span class="type">int</span> _a,<span class="type">int</span> _b,<span class="type">int</span> _c):<span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b),<span class="built_in">c</span>(_c)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(cor t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==t.a&amp;&amp;b==t.b&amp;&amp;c==t.c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">srt</span><span class="params">()</span></span>&#123; <span class="comment">//按大小排序</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(b&gt;c) <span class="built_in">swap</span>(b,c);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mkstd</span><span class="params">()</span></span>&#123; <span class="comment">//把三元组化为以1或6开头的形式</span></span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">1</span>&amp;&amp;a!=<span class="number">6</span>)&#123;</span><br><span class="line">            t=a; a=b; b=c; c=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//原始魔方八个角，顺时针</span></span><br><span class="line">vector&lt;cor&gt; std_cor = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">mf</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:mf) cin &gt;&gt; s;</span><br><span class="line">    vector&lt;cor&gt; corners=&#123;<span class="comment">//给定魔方的八个角，顺时针</span></span><br><span class="line">        &#123;mf[<span class="number">0</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">11</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">8</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">11</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">8</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">9</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">0</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">5</span>][<span class="number">8</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">8</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">9</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">6</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">2</span>][<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">6</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">5</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;mf[<span class="number">3</span>][<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">2</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>,mf[<span class="number">3</span>][<span class="number">5</span>]-<span class="string">&#x27;0&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cor:corners) cor.<span class="built_in">mkstd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; cor:corners)&#123;</span><br><span class="line">        <span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; st:std_cor) <span class="keyword">if</span>(st==cor) &#123;fl=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(fl) <span class="keyword">continue</span>;</span><br><span class="line">        cor.<span class="built_in">srt</span>();</span><br><span class="line">        cout &lt;&lt; cor.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cor.b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cor.c &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No problem&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1006)HDU7450.传奇勇士小凯</h1><h2 id="题意-3">题意</h2><p>一棵以 $1$ 为根， $n$ 个节点的树，在第 $i$ 个节点处，每天有 $\dfrac{p_i}{15}$ 的概率可以离开当前节点，并选择一个子节点走一步。<br>从根节点 $1$ 走到任意叶子节点的最大天数的期望。</p><h2 id="解题思路-3">解题思路</h2><p>在第 $i$ 个节点处，记停留在该节点的期望天数为 $x$ ，有 $\dfrac{p_i}{15}$ 的概率可以离开（停留 $1$ 天），有 $1-\dfrac{p_i}{15}$ 的概率停留在当前节点（停留 $x+1$ 天）。<br>有 $x = \dfrac{p_i}{15} + \dfrac{15-p_i}{15} \cdot (1+x)$ 成立，解得 $x = \dfrac{15}{p_i}$ 。</p><p>问题转换为选择一条以节点 $1$ 开头，以叶子节点结尾的路径，使得路径上的每个节点的期望天数 $\dfrac{15}{p_i}$ 之和最大。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">form</span><span class="params">(pll&amp; p)</span></span>&#123; <span class="comment">//化简</span></span><br><span class="line">    ll g = __gcd(p.first,p.second);</span><br><span class="line">    p.first/=g;</span><br><span class="line">    p.second/=g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">smaller</span><span class="params">(pll a,pll b)</span></span>&#123; <span class="comment">//a&lt;b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span>*a.first/a.second&lt;<span class="number">1.</span>*b.first/b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addto</span><span class="params">(pll&amp; a,pll b)</span></span>&#123; <span class="comment">//a+=b</span></span><br><span class="line">    a.first=a.first*b.second+a.second*b.first;</span><br><span class="line">    a.second*=b.second;</span><br><span class="line">    form(a);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;ll&gt; vdfs; <span class="comment">//dfs序列</span></span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;ll&gt; fa;</span><br><span class="line">vector&lt;pll&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x,ll f)</span></span>&#123;</span><br><span class="line">    fa[x]=f;</span><br><span class="line">    vdfs.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) <span class="keyword">if</span>(y!=f) <span class="built_in">dfs</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    G.<span class="built_in">clear</span>(); G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    fa.<span class="built_in">clear</span>(); fa.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    ans.<span class="built_in">clear</span>(); ans.<span class="built_in">resize</span>(n+<span class="number">1</span>,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    vdfs.<span class="built_in">clear</span>();</span><br><span class="line">    ll u,v,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125; <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ans[i]=&#123;<span class="number">15</span>,t&#125;; <span class="comment">//直接存入第i个节点的期望</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(vdfs));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> cur:vdfs)&#123; <span class="comment">//逆DFS序遍历</span></span><br><span class="line">        pll mx=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[cur]) <span class="keyword">if</span>(y!=fa[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">smaller</span>(mx,ans[y])) mx=ans[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ans[cur],mx);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans[<span class="number">1</span>].first &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; ans[<span class="number">1</span>].second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1007)HDU7451.URL划分</h1><h2 id="题意-4">题意</h2><p>给定字符串URL，形如：<code>s3://hdu-oj-bucket/problem=1/type=data/</code><br>从中提取出：</p><ul><li>传输协议：<code>://</code>之前的内容，如<code>s3</code></li><li>网络位置：<code>://</code>之后，第一个<code>/</code>之前的内容，如<code>hdu-oj-bucket</code></li><li>环境变量：由<code>/</code>分割，形如<code>A=B</code>的内容，如<code>problem=1</code>，<code>type=data</code></li></ul><h2 id="解题思路-4">解题思路</h2><p>按题目要求提取即可</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    string protocol;</span><br><span class="line">    string location;</span><br><span class="line">    vector&lt;string&gt; var;</span><br><span class="line">    string varname,val;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>(),i=<span class="number">0</span>,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;:&#x27;</span>)&#123;</span><br><span class="line">            protocol = s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">    &#125; i+=<span class="number">3</span>;</span><br><span class="line">    ll j=i;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            location = s.<span class="built_in">substr</span>(j,i-j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; i++;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123; <span class="comment">//匹配varname=val，以/分隔</span></span><br><span class="line">        j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">&#x27;=&#x27;</span>&amp;&amp;s[j]!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">        <span class="keyword">if</span>(s[j]==<span class="string">&#x27;/&#x27;</span>)&#123; <span class="comment">//跳过</span></span><br><span class="line">            i=j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            varname=s.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            i=j+<span class="number">1</span>; j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">            val=s.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            var.<span class="built_in">emplace_back</span>(varname+<span class="string">&quot;=&quot;</span>+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; protocol &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; location &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:var) cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写完python才发现hduOJ不支持python…</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    url = <span class="built_in">input</span>()</span><br><span class="line">    protocol, location, *path = re.split(<span class="string">r&quot;://|/&quot;</span>, url)</span><br><span class="line">    variables = [p <span class="keyword">for</span> p <span class="keyword">in</span> path <span class="keyword">if</span> <span class="string">&quot;=&quot;</span> <span class="keyword">in</span> p]</span><br><span class="line">    <span class="built_in">print</span>(protocol)</span><br><span class="line">    <span class="built_in">print</span>(location)</span><br><span class="line">    <span class="keyword">for</span> variable <span class="keyword">in</span> variables:</span><br><span class="line">        <span class="built_in">print</span>(variable)</span><br></pre></td></tr></table></figure><h1>(1010)HDU7454.女神的睿智</h1><h2 id="题意-5">题意</h2><p>给定长度为$8$的字符串，由<code>R,G,B</code>三种字符组成。<br>进行以下三轮操作，每轮操作从左往右两两合并：</p><ol><li>颜色相同时，合并为该颜色；颜色不同时，合并为左侧颜色</li><li>颜色相同时，合并为该颜色；颜色不同时，合并为左侧颜色</li><li>颜色相同时，合并为该颜色；颜色不同时，比较两种颜色在初始字符串中的数量，合并为数量多的一种；数量相同时，合并为随机颜色</li></ol><p>求最终合并后的颜色：<code>R,G,B</code>或不确定颜色<code>N</code></p><h2 id="解题思路-5">解题思路</h2><p>按题目要求模拟即可</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,s2; cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) mp[c]++;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i+=<span class="number">2</span>) s2.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i+=<span class="number">2</span>) s.<span class="built_in">push_back</span>(s2[i]);</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==s[<span class="number">1</span>]) cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mp[s[<span class="number">0</span>]]!=mp[s[<span class="number">1</span>]]) cout &lt;&lt; s[mp[s[<span class="number">0</span>]]&lt;mp[s[<span class="number">1</span>]]] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;N&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1011)HDU7455.在 A 里面找有 C 的 B</h1><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期杭电多校01</title>
      <link href="/posts/ACM_2024Summer_HDU01.html"/>
      <url>/posts/ACM_2024Summer_HDU01.html</url>
      
        <content type="html"><![CDATA[<p>比赛题单：<a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=2024%A1%B0%B6%A4%B0%D2%B1%E0%B3%CC%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A81%A3%A9&amp;source=1&amp;searchmode=source">2024“钉耙编程”中国大学生算法设计超级联赛（1）</a></p><h1>(1001)HDU7433.循环位移</h1><p><strong>字符串</strong></p><h2 id="题意">题意</h2><p>给定两个字符串 $A,B$ 。<br>定义 $[A]$ 为字符串 $A$ 的循环位移任意次可以得到的所有字符串的集合。<br>求 $B$ 包含 $[A]$ 中元素的个数。</p><h2 id="解题思路">解题思路</h2><p>利用字符串Hash快速匹配。<br>将 $[A]$ 中所有元素的Hash记录到一个set：计算 $A+A$ 的Hash前缀和，以快速得到所有长度为 $|A|$ 的子串的Hash值，并加入set中。<br>枚举 $B$ 的所有长度为 $|A|$ 的子串，计算Hash值，判断是否在set中，计数。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll n=a.<span class="built_in">length</span>(),m=b.<span class="built_in">length</span>();</span><br><span class="line">    set&lt;pll&gt; st;</span><br><span class="line">    <span class="function">strHash <span class="title">sa</span><span class="params">(a+a)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        st.<span class="built_in">insert</span>(sa.<span class="built_in">findz</span>(i,i+n<span class="number">-1</span>));</span><br><span class="line">    <span class="function">strHash <span class="title">sb</span><span class="params">(b)</span></span>;</span><br><span class="line">    ll ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m-n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">count</span>(sb.<span class="built_in">findz</span>(i,i+n<span class="number">-1</span>))) ans++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1002)HDU7434.星星</h1><p><strong>背包DP</strong></p><h2 id="题意-2">题意</h2><p>小A要进行n次选择，每次可以选择一项：</p><ol><li>不执行操作</li><li>付出$a_i$点代价得到1颗星星</li><li>付出$b_i$点代价得到2颗星星</li><li>付出$c_i$点代价得到3颗星星</li><li>付出$d_i$点代价得到4颗星星</li></ol><p>求恰好得到$k$颗星星的最小代价。</p><h2 id="解题思路-2">解题思路</h2><p>一眼顶针鉴定为背包DP的分组背包问题。</p><p>$dp_x$表示选x个物品的最低cost。<br>在第$i$组时，从大到小遍历作出选择后有$j$个星星。<br>遍历这一步的选择（ $l$ 个星星），从 $dp_{j-l}$ 更新到 $dp_j$ ，这样更新保证了一次操作只生效一项。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;array&lt;ll,5&gt;&gt; <span class="built_in">cost</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(k+<span class="number">1</span>,INF)</span></span>; dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//选i个物品的最低cost</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; cost[i][<span class="number">1</span>] &gt;&gt; cost[i][<span class="number">2</span>] &gt;&gt; cost[i][<span class="number">3</span>] &gt;&gt; cost[i][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123; <span class="comment">//第i步</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,k,<span class="number">1</span>)&#123; <span class="comment">//选择后的个数</span></span><br><span class="line">            <span class="built_in">FORLL</span>(l,<span class="number">0</span>,<span class="number">4</span>)&#123; <span class="comment">//这一步选择l个</span></span><br><span class="line">                <span class="keyword">if</span>(j-l&gt;=<span class="number">0</span>) <span class="built_in">chmin</span>(dp[j],dp[j-l]+cost[i][l]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1008)HDU7440.位运算</h1><h2 id="题意-3">题意</h2><p>给定整数$n,k$，求满足 $((a\otimes b)\oplus c)\ominus d=n$ 的四元组 $(a,b,c,d)，0\le a,b,c,d\lt 2^k$ 的个数。</p><p>其中，$\otimes$ 表示按位与，$\oplus$ 表示按位异或，$\ominus$ 表示按位或。</p><h2 id="解题思路-3">解题思路</h2><p>转为二进制，按位考虑。</p><p>若 $n$ 的某一位上是 $0$ ， $d$ 在这一位上必须为 $0$ ，$c$ 在这一位上由 $a,b$ 决定（控制这一位为 $0$），$a,b$ 在这一位上任选，即 $1\times 1\times 2\times 2=4$ 种可能。</p><p>若 $n$ 的某一位上是 $1$ ：</p><ol><li>若 $d$ 在这一位上为 $0$ ，则 $c$ 在这一位上由 $a,b$ 决定（控制这一位为 $1$），$a,b$ 在这一位上任选，即 $1\times 1\times 2\times 2=4$ 种可能。</li><li>若 $d$ 在这一位上为 $1$ ，则 $a,b,c$ 在这一位上任选，即 $1\times 2\times 2\times 2=8$ 种可能。</li></ol><p>综上，$n$ 的一位上是 $1$ 时有 $12$ 种可能，是 $0$ 时有 $4$ 种可能。</p><p>答案为 $4^k\times 3^{cnt1}$ 。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll cnt1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) cnt1++;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qcpow</span>(<span class="number">2</span>,k*<span class="number">2</span>)*<span class="built_in">qcpow</span>(<span class="number">3</span>,cnt1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>(1012)HDU7444.并</h1><h2 id="题意-4">题意</h2><p>给定 $n$ 个矩形，对 $k=1\to n$ 分别求随机取 $k$ 个矩形的面积并的期望。</p><h2 id="解题思路-4">解题思路</h2><p>平面可以被矩形边界分割成若干个小区域，考虑每个区域对答案的贡献。</p><p>因为要求期望，被“相同数量矩形覆盖”的小区域 对答案的贡献是相同的，因此按照 覆盖矩形数量 将这些小区域分组，统计出恰好被 $i$ 个矩形覆盖的区域的面积 $S_i$。</p><p>我的求法就是从左到右扫描，在每条竖线的位置，更新 $i$ 个矩形覆盖的y轴长度 $yval_i$ ，到下一条竖线再乘经过的x轴长度，得到这一部分的面积（类似于积分？），加入 $S_i$</p><p>然后考虑贡献的权重。<br>从 $n$ 个矩形中随机选取 $k$ 个，对于被 $i$ 个矩形覆盖的区域，只要选取的 $k$ 个矩形中，存在这 $i$ 个矩形之一，那么这个面积就会被计入。<br>在上述条件下的贡献权重是 $val_{k,i}=\frac{C_{n}^{k}-C_{n-i}^{k}}{C_{n}^{k}}$ ，即从 $n$ 个矩形中选取 $k$ 个方案数，减去从 $n-i$ 个矩形中选取 $k$ 个方案数。</p><p>最后答案$ans_k$是 $\sum\limits_{i=1}^{n}val_{k,i}\times S_i$ 。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    MOD = <span class="number">998244353</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getval</span><span class="params">(ll n,ll i,ll j)</span></span>&#123;</span><br><span class="line">    ll ret=C[n][i],sb;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n-j) sb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> sb = C[n-j][i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sub</span>(ret,sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll xx1,xx2,yy1,yy2;</span><br><span class="line">    vector&lt;tuple&lt;ll,ll,ll,ll&gt;&gt; xlines;</span><br><span class="line">    vector&lt;ll&gt; ylines;</span><br><span class="line">    <span class="comment">// xline:(y,x1,x2,flag) # 横线 flag:0上边界1下边界</span></span><br><span class="line">    <span class="comment">// yline:(x) # 竖线x坐标</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; xx1 &gt;&gt; yy1 &gt;&gt; xx2 &gt;&gt; yy2;</span><br><span class="line">        xlines.<span class="built_in">emplace_back</span>(yy1,xx1,xx2,<span class="number">0</span>);</span><br><span class="line">        xlines.<span class="built_in">emplace_back</span>(yy2,xx1,xx2,<span class="number">1</span>);</span><br><span class="line">        ylines.<span class="built_in">emplace_back</span>(xx1);</span><br><span class="line">        ylines.<span class="built_in">emplace_back</span>(xx2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(xlines); <span class="built_in">SORT</span>(ylines);</span><br><span class="line"></span><br><span class="line">    map&lt;ll,ll&gt; S,yval;</span><br><span class="line">    ll prex=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// S[i]:重叠i次部分的面积</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xx:ylines)</span><br><span class="line">    &#123;</span><br><span class="line">        ll difx = xx-prex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [pl,val]:yval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// S[pl]+=difx*val;</span></span><br><span class="line">            <span class="built_in">addto</span>(S[pl],<span class="built_in">mul</span>(difx,val));</span><br><span class="line">        &#125;</span><br><span class="line">        yval.<span class="built_in">clear</span>();</span><br><span class="line">        ll cur = <span class="number">0</span>, prey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [yy,xx1,xx2,flag]:xlines)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(xx1&lt;=xx&amp;&amp;xx&lt;xx2)</span><br><span class="line">            &#123;</span><br><span class="line">                yval[cur]+=yy-prey;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) cur++;</span><br><span class="line">                <span class="keyword">else</span> cur--;</span><br><span class="line">                prey=yy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prex = xx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(auto x:S) cout &lt;&lt; x.first &lt;&lt; &#x27; &#x27; &lt;&lt; x.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            ll val = <span class="built_in">getval</span>(n,i,j);</span><br><span class="line">            ans = <span class="built_in">add</span>(ans,<span class="built_in">mul</span>(val,S[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">divto</span>(ans,C[n][i]);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校02</title>
      <link href="/posts/ACM_2024Summer_NCD02.html"/>
      <url>/posts/ACM_2024Summer_NCD02.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81597">2024牛客暑期多校训练营2</a></p><h1>C.Red Walking on Grid</h1><h2 id="题意">题意</h2><p>一个2行 $n$ 列的网格上，有些格子是红色的，有些格子是白色的。<br>你可以最初选择一个红色的格子，然后每一步都可以选择上下左右相邻的红色格子。离开一个格子时，这个格子立即变成白色。问最多可以走多少步。<br>最初没有红色的格子，输出0。</p><h2 id="解题思路">解题思路</h2><p>总体思路就是找连通块，在每个连通块内部找到能走最多格的路径，然后所有连通块的答案取最大值。<br>由于无法走回头路，形如以下样式的连通块将无法走遍全部红色格子：</p><p><img src="https://source.cclmsy.cc/Posts/ACM/2024Summer_NCD02_C.png" alt="image"></p><p>先从头到尾扫一遍，有以上2种形式的连通块，将打×的部分预先涂成白色。这样就能保证每个红色格子都会被经过，计算到答案中。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string, 2&gt; s;</span><br><span class="line">ll n,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function">ll <span class="title">getstat</span><span class="params">(ll col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getcnt</span><span class="params">(ll col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][col]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[<span class="number">1</span>][col]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preprocess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>,pre=<span class="number">0</span>,cur;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getcnt</span>(<span class="number">0</span>)==<span class="number">1</span>) pre=<span class="built_in">getstat</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur = <span class="built_in">getcnt</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">            cur=<span class="built_in">getstat</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(pre&amp;&amp;cur&amp;&amp;cnt)&#123;</span><br><span class="line">                <span class="keyword">if</span>((cnt%<span class="number">2</span>==<span class="number">0</span>)&amp;&amp;((pre&amp;cur)==<span class="number">0</span>)) s[cur<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>((cnt%<span class="number">2</span>)&amp;&amp;((pre&amp;cur))) s[cur<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="number">2</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cnt=<span class="number">0</span>; pre=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="built_in">getcnt</span>(<span class="number">0</span>),pre=<span class="built_in">getstat</span>(<span class="number">0</span>),cur;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur = <span class="built_in">getstat</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(cur&amp;pre)&#123;</span><br><span class="line">            cnt+=<span class="built_in">getcnt</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">chmax</span>(ans,cnt);</span><br><span class="line">            cnt=<span class="built_in">getcnt</span>(i);</span><br><span class="line">        &#125;pre=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">chmax</span>(ans,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s[<span class="number">0</span>] &gt;&gt; s[<span class="number">1</span>];</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">preprocess</span>();</span><br><span class="line">    <span class="built_in">getans</span>();</span><br><span class="line">    cout &lt;&lt; ans<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.GCD VS XOR</h1><h2 id="题意-2">题意</h2><p>给定一个正整数 $x$ ，找到一个严格小于 $x$ 的正整数 $y$ ，使得 $gcd(x,y)=x\oplus y$ ，其中 $\oplus$ 表示按位异或。</p><h2 id="解题思路-2">解题思路</h2><p>首先观察到，对于一个正整数 $x$ ，$lowbit(x)$ 一定是 $x$ 的因子。<br>那么令 $y = x - lowbit(x)$ ，则 $gcd(x,y)=lowbit(x)$ ，$x\oplus y = lowbit(x)$ ，满足题意。</p><blockquote><p>有时候灵感就来源于一瞬间</p></blockquote><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll ans=n-<span class="built_in">lowbit</span>(n);</span><br><span class="line">    cout &lt;&lt; (ans?ans:<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.Instructions Substring</h1><h2 id="题意-3">题意</h2><p>你初始位于原点 $(0,0)$ 。<br>给定一串动作指令，包含<code>W</code>、<code>A</code>、<code>S</code>、<code>D</code>，分别表示向上（$y+=1$）、向左（$x-=1$）、向下（$y-=1$）、向右（$x+=1$）。<br>你需要选择一个连续的子串，使得执行这个子串的指令后，你能经过给定得一点 $(x,y)$ 。<br>计算符合条件的子串的个数。</p><h2 id="解题思路-3">解题思路</h2><p>假设选择了子串 $s_{ij}$ ，恰好能到达 $(x,y)$ ，那么 $s_j$ 之后任意增加指令都已经满足了“经过 $(x,y)$”的条件。</p><p>最暴力的做法就是枚举开头指令 $i$ ，枚举恰好到达 $(x,y)$ 的最小结尾指令 $j$ ，以位置 $i$ 开头的方案数就是 $n-j+1$ 。时间复杂度 $O(n^2)$ ，包TLE的，需要优化搜索过程。</p><p>我们可以先从头到尾执行（即做一个前缀和），每一步都记录到达当前位置 $(x_i,y_i)$ 时执行的指令编号 $i$ 。<br>再重新从头到尾执行一边，对于每一步到达的位置 $(x_i,y_i)$ ，将它视作起点（即假设之前的步骤都没有执行），那么需要经过的点变为 $(x_i+x,y_i+y)$ 。二分找到在 $i$ 之后到达过 $(x_i+x,y_i+y)$ 的最小指令编号 $j$ ，以位置 $i$ 开头的方案数就是 $n-j+1$ 。</p><p>$x=0,y=0$ 的情况比较特殊，特判一下即可。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                W  S  D  A</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">conv</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;D&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; n*(n+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;pll,vector&lt;ll&gt;&gt; mp;</span><br><span class="line">    ll cx,cy,dir; cx=cy=<span class="number">0</span>;</span><br><span class="line">    mp[&#123;cx,cy&#125;].<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        dir = <span class="built_in">conv</span>(c);</span><br><span class="line">        cx += dx[dir];</span><br><span class="line">        cy += dy[dir];</span><br><span class="line">        mp[&#123;cx,cy&#125;].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cx=cy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = mp[&#123;cx+x,cy+y&#125;];</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),i);</span><br><span class="line">        <span class="keyword">if</span>(it!=v.<span class="built_in">end</span>()) ans+=n-(*it);</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        dir = <span class="built_in">conv</span>(c);</span><br><span class="line">        cx += dx[dir];</span><br><span class="line">        cy += dy[dir];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> v = mp[&#123;cx+x,cy+y&#125;];</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),n);</span><br><span class="line">    <span class="keyword">if</span>(it!=v.<span class="built_in">end</span>()) ans+=n-(*it);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024暑期牛客多校01</title>
      <link href="/posts/ACM_2024Summer_NCD01.html"/>
      <url>/posts/ACM_2024Summer_NCD01.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/81596">2024牛客暑期多校训练营1</a></p><h1>A.A Bit Common</h1><p><strong>组合数学</strong></p><h2 id="题意">题意</h2><p><strong>题目概括：</strong><br>给定两个整数 $n$ 和 $m$，我们需要计算所有包含 $n$ 个非负整数且每个整数都小于 $2^m$ 的序列中，满足<strong>存在一个</strong>非空子序列使得这些整数的按位与（bitwise AND）为 1 的序列的数量。</p><p>注意：一个序列的非空子序列是指从序列中删除零个或多个元素后得到的子序列，并保持剩余元素的原始顺序。</p><p>由于结果可能非常大，请输出结果对一个正整数 $q$ 取模后的值。</p><h2 id="解题思路">解题思路</h2><p>序列 $A$ 中的每个整数可以看作一个 $m$ 位的二进制数。</p><p>符合条件的序列中，所有末位为 1 的元素的&amp;和一定为 1（因为剩余的元素末位都是0，&amp;入答案会消灭末位1）。</p><p>枚举序列包含的 末位为 1 的元素个数 $k$ ，把这些数一行一个写成二进制，按位对齐。</p><p>对于这 $k$ 个元素，要满足除末位外每一个二进制位不全为 1 ，这 $k$ 个数每个二进制位（按列看）上的方案数为 $2^{k}-1$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $a=(2^{k}-1)^{m-1}$ 。</p><p>对于剩余的 $n-k$ 个元素，只需要保证末位为 0 ，其他位不加限制，因此这 $n-k$ 个数每个二进制位（按列看）上的方案数为 $2^{n-k}$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $b=(2^{n-k})^{m-1}$ 。</p><p>综合两部分，方案数为 $a\times b\times C_n^k$ 。<br>$C_n^k$ 表示序列的 $n$ 个位置中选取 $k$ 个用于顺序放置末位为 1 的 $k$ 个数。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    ll tmp,a,b,ans1=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)&#123;</span><br><span class="line">        a = <span class="built_in">qcpow</span>(<span class="built_in">qcpow</span>(<span class="number">2</span>,k)<span class="number">-1</span>,m<span class="number">-1</span>); <span class="comment">// a = (2^k-1)^(m-1)</span></span><br><span class="line">        b = <span class="built_in">qcpow</span>(<span class="number">2</span>,<span class="built_in">mul</span>(n-k,m<span class="number">-1</span>)); <span class="comment">// b = 2^(n-k)^(m-1)</span></span><br><span class="line">        tmp = <span class="built_in">mul</span>(C[n][k],<span class="built_in">mul</span>(a,b)); <span class="comment">// tmp = C(n,k)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans1,tmp); <span class="comment">// 加入答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; <span class="built_in">Get_Mod</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.A Bit More Common</h1><h2 id="题意-2">题意</h2><p>给定两个整数 $n$ 和 $m$，我们需要计算所有包含 $n$ 个非负整数且每个整数都小于 $2^m$ 的序列中，满足<strong>存在两个</strong>非空子序列使得这些整数的按位与（bitwise AND）为 1 的序列的数量。</p><p>注意：一个序列的非空子序列是指从序列中删除零个或多个元素后得到的子序列，并保持剩余元素的原始顺序。</p><p>由于结果可能非常大，请输出结果对一个正整数 $q$ 取模后的值。</p><h2 id="解题思路-2">解题思路</h2><p>和A题的区别在于，需要满足存在两个非空子序列。</p><p>因此除A题中 “由所有末位为1的元素” 构成的&amp;和为1的子序列外，还要另考虑一个。<br>贪心的想法就是从上述子序列中删去某个元素，剩下的元素的&amp;和仍然为1。</p><p>枚举序列包含的 末位为 1 的元素个数 $k$ ，把这些数一行一个写成二进制，按位对齐。</p><p>正向考虑难以枚举，可以从反面考虑，即：从 这$k$个&amp;和为1的元素 中，删去任一元素，剩下的元素的&amp;和都不能为1。<br>要满足这一特性，每个元素都至少要有一位“特殊位0” 。</p><p>“特殊位0” ：即有且仅有唯一元素，在这个二进制位（按列看）上是 0 ，其他元素的这个二进制位上都为 1 。<br>这样，当删去这个元素后，其他元素这一位上的&amp;和将变成1，从而不满足条件。</p><p>记$dp(k,j)$： $k$ 个末位为 1 的数，每个数至少有 1 个“特殊位0” ，且它们共有 $j$ “特殊位0” 的方案数。<br>如果从这 $k$ 个数中选取 1 个，去掉它的 1 个特殊位，则有可能会导致一个数没有特殊位。<br>转移到：</p><ul><li>$k$ 个数，每个数至少有 1 个“特殊位0” ，且它们共有 $j-1$ 个“特殊位0”</li><li>$k-1$ 个数，每个数至少有 1 个“特殊位0” ，且它们共有 $j-1$ “特殊位0”</li></ul><p>得到转移方程： $dp(k,j)=k\times(dp(k,j-1)+dp(k-1,j-1))$ ，预处理dp数组。</p><p>对于这 $k$ 个元素，要满足除末位1外每一个二进制位不全为 1 ，且每个元素至少有 1 个“特殊位0” 。<br>对于每个 $k$ ，枚举特殊位个数 $j:k\rightarrow m-1$ :</p><ul><li>末位为1但没有特殊位的元素，每个 非“特殊位0” 二进制位（按列看）上的方案数为 $2^{k}-1-k$ （除：全1的1种和“特殊位0”k种），除末位外有 $m-1-j$ 个 非“特殊位0” 二进制位，（有序）方案数为 $t=(2^{k}-1)^{m-1}$ 。</li><li>特殊位：方案数 $dp(k,j)$</li></ul><p>综上，这 $k$ 个末位为1的元素的（有序）方案数为 $a = \sum\limits_{j=k}^{m-1} t\times dp(k,j)\times C(m-1,j)$</p><p>对于剩余的 $n-k$ 个元素，只需要保证末位为 0 ，其他位不加限制，因此这 $n-k$ 个数每个二进制位（按列看）上的方案数为 $2^{n-k}$ （即除全1外）。<br>除末位外有 $m-1$ 个二进制位，（有序）方案数为 $b=(2^{n-k})^{m-1}$ 。</p><p>综合两部分，方案数为 $a\times b\times C_n^k$ 。</p><p>用A题的答案减去得到的数字，则为本题所求的答案。</p><p>本题复杂度较高，常规的取模操作做的多的，可能会因为常数太大TLE。<br>可以通过预处理乘方数组、逐步求乘方数、减少取模次数、优化取模等方法解决。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m &gt;&gt; MODULE::MOD;</span><br><span class="line">    <span class="built_in">Prepare_Combination</span>(<span class="number">5005</span>);</span><br><span class="line">    vector&lt;ll&gt; pow2;</span><br><span class="line">    pow2.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*m) pow2.<span class="built_in">emplace_back</span>(<span class="built_in">mul</span>(pow2.<span class="built_in">back</span>(),<span class="number">2</span>));</span><br><span class="line">    ll t,tt,powt,a,b,ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        a = pow2[<span class="built_in">mul</span>(m<span class="number">-1</span>,n-i)]; <span class="comment">// a = 2^(m-1)^(n-i)</span></span><br><span class="line">        b = <span class="built_in">qcpow</span>(pow2[i]<span class="number">-1</span>,m<span class="number">-1</span>); <span class="comment">// b = (2^i-1)^(m-1)</span></span><br><span class="line">        t = <span class="built_in">mul</span>(C[n][i],<span class="built_in">mul</span>(a,b)); <span class="comment">// t = C(n,i)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans1,t);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(m+<span class="number">1</span>,<span class="number">0</span>)); <span class="comment">//dp_i,j表示j个特殊位覆盖了i个数的方案数</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m<span class="number">-1</span>)&#123; </span><br><span class="line">            dp[i][j] = <span class="built_in">mul</span>(<span class="built_in">add</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]),i); <span class="comment">// i*(dp[i][j-1]+dp[i-1][j-1])</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">2</span>,n)&#123; <span class="comment">// 末位为1的数的个数</span></span><br><span class="line">        t = <span class="built_in">sub</span>(pow2[k],k+<span class="number">1</span>); <span class="comment">// 2^k-k-1</span></span><br><span class="line">        powt = <span class="number">1</span>;</span><br><span class="line">        a = pow2[<span class="built_in">mul</span>(n-k,m<span class="number">-1</span>)]; <span class="comment">// a = 2^(m-1)^(n-k)</span></span><br><span class="line">        b = <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,m<span class="number">-1</span>,k)&#123; <span class="comment">// k个元素有j个特殊位</span></span><br><span class="line">            tt = <span class="built_in">mul</span>(powt,dp[k][j]); <span class="comment">// t^(m-1-j)*dp[k][j]</span></span><br><span class="line">            tt = <span class="built_in">mul</span>(tt,C[m<span class="number">-1</span>][j]); <span class="comment">// C(m-1,j)*t^(m-1-j)*dp[k][j]</span></span><br><span class="line">            <span class="built_in">addto</span>(b,tt); </span><br><span class="line">            powt = <span class="built_in">mul</span>(powt,t); <span class="comment">// t^(m-1-j)</span></span><br><span class="line">        &#125;</span><br><span class="line">        tt = <span class="built_in">mul</span>(C[n][k],<span class="built_in">mul</span>(a,b)); <span class="comment">// C(n,k)*a*b</span></span><br><span class="line">        <span class="built_in">addto</span>(ans2,tt); </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sub</span>(ans1,ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.Sum of Suffix Sums</h1><h2 id="题意-3">题意</h2><p>给定一个初始为空的数组，你需要进行 <code>q</code> 次操作：</p><ul><li>对于每次操作，给定两个非负整数 <code>t</code> 和 <code>v</code>，先从数组末尾取出 <code>t</code> 个元素，然后将 <code>v</code> 添加到数组末尾。保证 <code>t</code> 不会超过操作前数组的长度。</li></ul><p>每次操作后，假设当前数组为 <code>a1, a2, ..., an</code>，计算 <code>s1, s2, ..., sn</code> 的总和，其中 <code>si = ai + ai+1 + ... + an</code> 是从位置 <code>i</code> 开始的后缀和。</p><p>由于结果可能非常大，输出时需对 <code>1000000007</code> 取模。</p><h2 id="解题思路-3">解题思路</h2><p>考虑每个元素的贡献：第 $i$ 个元素对答案的贡献为 $i*a_i$ 。</p><p>在加入元素时，直接将其贡献加入答案。</p><p>同时对这个序列维护一个前缀和，以便快速移除元素和减去贡献。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll q,t,rm;cin &gt;&gt; q;</span><br><span class="line">    ll n=<span class="number">1</span>;</span><br><span class="line">    vector&lt;ll&gt; v,s;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    s.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    ll tm;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; rm &gt;&gt; t;</span><br><span class="line">        sum = <span class="built_in">Get_Mod</span>(sum-<span class="built_in">Get_Mod</span>(s[n<span class="number">-1</span>]-s[n-rm<span class="number">-1</span>]));</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">end</span>()-rm,s.<span class="built_in">end</span>());</span><br><span class="line">        v.<span class="built_in">erase</span>(v.<span class="built_in">end</span>()-rm,v.<span class="built_in">end</span>());</span><br><span class="line">        n-=rm;</span><br><span class="line"></span><br><span class="line">        tm = t;</span><br><span class="line">        tm = <span class="built_in">Get_Mod</span>(tm*n); <span class="comment">// 元素贡献</span></span><br><span class="line">        sum = <span class="built_in">Get_Mod</span>(sum+tm);</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(tm);</span><br><span class="line">        s.<span class="built_in">emplace_back</span>(sum);</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.World Finals</h1><h2 id="题意-4">题意</h2><p>两场ICPC比赛，已知（预测的）两场比赛的所有队伍的解题数和罚时。</p><p>如果一支队伍同时具有两场比赛的资格，只能参加其中一场。</p><p>现在，<code>lzr010506</code>可以决定 同时具有两场比赛的资格 的队伍具体参加哪一场，根据预测数据求<code>lzr010506</code>可以得到的最高名次。</p><h2 id="解题思路-4">解题思路</h2><p>开2个map分别记录两场比赛情况。</p><p>假设<code>lzr010506</code>参加其中一场，去掉那一场所有的 同时具有两场比赛的资格 的队伍，排序即可得到这一场的最佳名次。</p><p>如此求出两场比赛的最佳名次，取最小值即可。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line">string me=<span class="string">&quot;lzr010506&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> pair&lt;string,pll&gt; &amp;a,<span class="type">const</span> pair&lt;string,pll&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pll pa,pb;</span><br><span class="line">    pa=a.second; pb=b.second;</span><br><span class="line">    <span class="keyword">if</span>(pa.first==pb.first) <span class="keyword">return</span> pa.second&lt;pb.second;</span><br><span class="line">    <span class="keyword">return</span> pa.first&gt;pb.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,pll&gt; v1,v2;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string ts; ll t1,t2;</span><br><span class="line">    ll ans1,ans2;ans1=ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; ts &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        v1[ts]=<span class="built_in">make_pair</span>(t1,t2);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; ts &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        v2[ts]=<span class="built_in">make_pair</span>(t1,t2);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;string,pll&gt; tmp;</span><br><span class="line">    tmp = v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">count</span>(x.first)&amp;&amp;x.first!=me)&#123;</span><br><span class="line">            tmp.<span class="built_in">erase</span>(x.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> tv = vector&lt;pair&lt;string,pll&gt;&gt;(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(tv),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv)&#123;</span><br><span class="line">        ans1++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==me) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">count</span>(x.first)&amp;&amp;x.first!=me)&#123;</span><br><span class="line">            tmp.<span class="built_in">erase</span>(x.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tv = vector&lt;pair&lt;string,pll&gt;&gt;(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">ALL</span>(tv),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv)&#123;</span><br><span class="line">        ans2++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==me) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(ans1,ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I.Mirror Maze</h1><p><strong>DFS</strong></p><h2 id="题意-5">题意</h2><p>在一个 $n \times m$ 的镜子迷宫中，每个格子都有一面镜子。镜子的类型有以下四种：</p><ol><li><code>-</code>：来自上方或下方的光线将被反射回去，来自左方或右方的光线则继续前进而不会被反射。</li><li><code>|</code>：来自左方或右方的光线将被反射回去，来自上方或下方的光线则继续前进而不会被反射。</li><li><code>/</code>：来自左方、右方、上方、下方的光线将分别被反射到上方、下方、左方、右方。</li><li><code>\</code>：来自左方、右方、上方、下方的光线将分别被反射到下方、上方、右方、左方。</li></ol><p>现在有 $q$ 个光源（给定位置和方向）。光的信徒小G想知道，对于每个光源，在足够长的时间内，发出的光线会被反射经过的不同镜子的数量。</p><h2 id="解题思路-5">解题思路</h2><p>对于一个光源，如果它的传播路径没有首尾相连成环，那么这个路径就只可能是一条链。<br>（证明：光的路径是可逆的，假设一条传播路径在某一点突然形成了环，那回溯时在这个点就可以有两条路径，这显然是不合理的）</p><p>对于给定的镜子阵列，我们可以直接处理出每个点向每个方向的答案，对最后的询问打表。</p><p>只要是一条链，它的最初起点和最后终点一定在阵列的边缘位置。我们可以从边缘位置开始向内DFS，直到遇到边缘位置，这样就可以得到一条链的路径，路径上的答案都可以处理得到。</p><p>没有遍历到的点，说明它们是环的一部分，我们可以通过时间戳来寻找和处理环上的答案。</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                D  U  R  L</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c0[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// -</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c1[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;; <span class="comment">// |</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c2[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;; <span class="comment">// /</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c3[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// \&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> d, <span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> c0[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>: <span class="keyword">return</span> c1[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> c2[d];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: <span class="keyword">return</span> c3[d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q,tms,cnt; <span class="comment">//tms:timestamp</span></span><br><span class="line">vector&lt;string&gt; mp;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vis;</span><br><span class="line">vector&lt;vector&lt;array&lt;<span class="type">int</span>,4&gt;&gt;&gt; ans,visd;</span><br><span class="line">vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_line</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    buf.<span class="built_in">push_back</span>(&#123;x,y,dir&#125;);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=n||y&lt;<span class="number">0</span>||y&gt;=m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> nd=<span class="built_in">conv</span>(dir,mp[x][y]); <span class="comment">//new direction</span></span><br><span class="line">    <span class="built_in">dfs_line</span>(x+dx[nd],y+dy[nd],nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_line</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> sd)</span></span>&#123;</span><br><span class="line">    buf.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">dfs_line</span>(sx,sy,sd);</span><br><span class="line">    <span class="built_in">reverse</span>(buf.<span class="built_in">begin</span>(),buf.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>; tms++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;buf.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123; <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">auto</span> [x,y,d]=buf[i];</span><br><span class="line">        <span class="keyword">if</span>(i)&#123;</span><br><span class="line">            <span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[x][y]==<span class="string">&#x27;-&#x27;</span>&amp;&amp;(d&amp;<span class="number">2</span>)||mp[x][y]==<span class="string">&#x27;|&#x27;</span>&amp;&amp;!(d&amp;<span class="number">2</span>)) fl=<span class="number">0</span>; <span class="comment">// 通过</span></span><br><span class="line">            <span class="keyword">if</span>(fl)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[x][y]!=tms) res+=fl; <span class="comment">// 反射</span></span><br><span class="line">                vis[x][y]=tms;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visd[x+dx[d^<span class="number">1</span>]][y+dy[d^<span class="number">1</span>]][d]=tms;</span><br><span class="line">        ans [x+dx[d^<span class="number">1</span>]][y+dy[d^<span class="number">1</span>]][d]=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_loop</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    visd[x][y][dir]=tms;</span><br><span class="line">    x += dx[dir];</span><br><span class="line">    y += dy[dir];</span><br><span class="line">    <span class="type">int</span> nd = <span class="built_in">conv</span>(dir,mp[x][y]);</span><br><span class="line">    <span class="keyword">if</span>(nd!=dir)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[x][y]!=tms) cnt++;</span><br><span class="line">        vis[x][y]=tms;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visd[x][y][nd]!=tms) <span class="built_in">dfs_loop</span>(x,y,nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mk_loop</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    ans[x][y][dir] = cnt;</span><br><span class="line">    visd[x][y][dir] = tms;</span><br><span class="line">    x+=dx[dir];</span><br><span class="line">    y+=dy[dir];</span><br><span class="line">    <span class="type">int</span> nd=<span class="built_in">conv</span>(dir,mp[x][y]);</span><br><span class="line">    <span class="keyword">if</span>(visd[x][y][nd]!=tms) <span class="built_in">mk_loop</span>(x,y,nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_loop</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> sd)</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>; tms++;</span><br><span class="line">    <span class="built_in">dfs_loop</span>(sx,sy,sd);</span><br><span class="line">    tms++;</span><br><span class="line">    <span class="built_in">mk_loop</span>(sx,sy,sd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    mp.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:mp) cin &gt;&gt; s;</span><br><span class="line">    ans.<span class="built_in">resize</span>(n,vector&lt;array&lt;<span class="type">int</span>,<span class="number">4</span>&gt;&gt;(m,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">    visd.<span class="built_in">resize</span>(n,vector&lt;array&lt;<span class="type">int</span>,<span class="number">4</span>&gt;&gt;(m,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">    vis.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">f_line</span>(i,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">f_line</span>(i,m<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">f_line</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">f_line</span>(n<span class="number">-1</span>,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visd[i][j][d]==<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">f_loop</span>(i,j,d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,d;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;</span><br><span class="line">        x--,y--;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;b&#x27;</span>) d=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>) d=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;r&#x27;</span>) d=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;l&#x27;</span>) d=<span class="number">3</span>;</span><br><span class="line">        cout &lt;&lt; ans[x][y][d] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目文档|基于科大讯飞星火大模型的Nonebot2插件</title>
      <link href="/posts/nonebot_plugin_sparkapi.html"/>
      <url>/posts/nonebot_plugin_sparkapi.html</url>
      
        <content type="html"><![CDATA[<div align="center">  <a href="https://v2.nonebot.dev/store"><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/nbp_logo.png" width="180" height="180" alt="NoneBotPluginLogo"></a>  <br>  <p><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/NoneBotPlugin.svg" width="240" alt="NoneBotPluginText"></p></div><div align="center"><h2 id="nonebot-plugin-sparkapi">nonebot-plugin-sparkapi</h2><p><em>✨ 科大讯飞星火大模型官方 API 聊天机器人 ✨</em></p><a href="./LICENSE">    <img src="https://img.shields.io/github/license/CCLMSY/nonebot-plugin-sparkapi.svg" alt="license"></a><a href="https://pypi.python.org/pypi/nonebot-plugin-sparkapi">    <img src="https://img.shields.io/pypi/v/nonebot-plugin-sparkapi.svg" alt="pypi"></a><img src="https://img.shields.io/badge/python-3.10+-blue.svg" alt="python"></div><h2 id="📖-介绍">📖 介绍</h2><p>基于 Nonebot2 平台/科大讯飞星火大模型官方 API 的 AI 聊天机器人插件</p><p>适用于所有模型版本（默认当前最新 <code>v4.0</code>），同时支持自定义人物预设、会话管理，兼具 AI 绘图、AI 生成 PPT 等功能</p><p>开发环境：<code>Python3.11.8 on Conda, Windows 11</code></p><blockquote><p>[!important]</p><p>为了方便的直接阅读存储的文件，<code>v2.0.5</code> 版本起，信息编码方式更改为 <code>UTF-8</code>。从旧版本更新到 <code>v2.0.5</code> 以上版本时，请务必删除 BOT 项目文件夹下的<code>SparkApi</code>文件夹，即清除所有缓存文件，否则可能产生错误。由此带来不便敬请谅解！QwQ</p><p>项目正在准备重写更新到3.x，期望集成绝大部分星火大模型的能力</p></blockquote><h3 id="📦-项目地址">📦 项目地址</h3><ul><li>Github: <a href="https://github.com/CCLMSY/nonebot-plugin-sparkapi">https://github.com/CCLMSY/nonebot-plugin-sparkapi</a></li><li>Pypi: <a href="https://pypi.org/project/nonebot-plugin-sparkapi">https://pypi.org/project/nonebot-plugin-sparkapi</a></li><li>NoneBot: <a href="https://registry.nonebot.dev/plugin/nonebot-plugin-sparkapi:nonebot_plugin_sparkapi">https://registry.nonebot.dev/plugin/nonebot-plugin-sparkapi:nonebot_plugin_sparkapi</a></li><li>作者主页: <a href="https://cclmsy.cc">https://cclmsy.cc</a></li><li>觉得好用的话，请给个 Star⭐️ 谢谢喵~</li></ul><h3 id="💬-功能">💬 功能</h3><ul><li>[x] 支持 AI 对话（已适配星火 4.0API）</li><li>[x] 支持上下文关联</li><li>[x] 支持自定义预设、预设管理</li><li>[x] 支持会话存储和加载、会话管理</li><li>[x] 支持预设和历史记录持久化（基于 json）</li><li>[x] 完善配置项（有其他需求请发 issue）</li><li>[x] 支持 AI 绘图（Image Generation）</li><li>[x] 支持 AI 生成 PPT（PPT Generation）</li><li>[ ] 文档问答（Document QA）</li><li>[ ] 用户权限与功能区分（超级用户、普通用户）</li></ul><h2 id="💿-安装">💿 安装</h2><details open><summary>使用 nb-cli 安装</summary>在 nonebot2 项目的根目录下打开命令行, 输入以下指令即可安装<pre><code>nb plugin install nonebot-plugin-sparkapi</code></pre></details><details><summary>使用包管理器安装</summary>在 nonebot2 项目的插件目录下, 打开命令行, 根据你使用的包管理器, 输入相应的安装命令<details><summary>pip</summary><pre><code>pip install nonebot-plugin-sparkapi</code></pre></details><details><summary>pdm</summary><pre><code>pdm add nonebot-plugin-sparkapi</code></pre></details><details><summary>poetry</summary><pre><code>poetry add nonebot-plugin-sparkapi</code></pre></details><details><summary>conda</summary><pre><code>conda install nonebot-plugin-sparkapi</code></pre></details><p>打开 nonebot2 项目根目录下的 <code>pyproject.toml</code> 文件, 在 <code>[tool.nonebot]</code> 部分追加写入</p><pre><code>plugins = [&quot;nonebot_plugin_sparkapi&quot;]</code></pre></details><h2 id="⚙️-配置项">⚙️ 配置项</h2><p>在 nonebot2 项目的<code>.env</code>文件中添加下列配置项中的必填配置（SPARKAPI_APP_ID, SPARKAPI_API_SECRET, SPARKAPI_API_KEY）</p><p>服务接口认证信息 app_id, api_secret, api_key 请前往 <a href="https://console.xfyun.cn/">讯飞开放平台控制台</a> 获取</p><p>AI 绘图、AI 生成 PPT 功能的 API 信息在同一应用下与对话 API 信息相同，开启相应功能前需要在讯飞开放平台申请相应的服务用量</p><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">必填</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SPARKAPI_APP_ID</td><td style="text-align:center">是</td><td style="text-align:center">/</td><td style="text-align:center">APPID</td></tr><tr><td style="text-align:center">SPARKAPI_API_SECRET</td><td style="text-align:center">是</td><td style="text-align:center">/</td><td style="text-align:center">APISecret</td></tr><tr><td style="text-align:center">SPARKAPI_API_KEY</td><td style="text-align:center">是</td><td style="text-align:center">/</td><td style="text-align:center">APIKey</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_VERSION</td><td style="text-align:center">否</td><td style="text-align:center"><code>&quot;&quot;</code></td><td style="text-align:center">星火大模型的版本，默认为当前最新。<br>可选值：“default”, “v4.0”, “v3.5”, “v3.0”, “v2.0”, “v1.5”</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_TOP_K</td><td style="text-align:center">否</td><td style="text-align:center"><code>4</code></td><td style="text-align:center">平衡生成文本的质量和多样性。<br>较小的 k 值会减少随机性，使得输出更加稳定；<br>而较大的 k 值会增加随机性，产生更多新颖的输出。<br>取值范围[1, 6]</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_TEMPERATURE</td><td style="text-align:center">否</td><td style="text-align:center"><code>0.5</code></td><td style="text-align:center">控制结果随机性，取值越高随机性越强，即相同的问题得到的不同答案的可能性越高。<br>取值范围 (0，1]</td></tr><tr><td style="text-align:center">SPARKAPI_MODEL_MAXLENGTH</td><td style="text-align:center">否</td><td style="text-align:center"><code>8000</code></td><td style="text-align:center">单次上下文最大 token 长度，v2.0 以上建议取值范围：[4000,8000]。<br>详细说明见下文</td></tr><tr><td style="text-align:center">SPARKAPI_PRIORITY</td><td style="text-align:center">否</td><td style="text-align:center"><code>80</code></td><td style="text-align:center">本插件响应事件的优先级，建议设置较大的值。可选值：1~97。<br>详细说明见下文</td></tr><tr><td style="text-align:center">SPARKAPI_COMMAND_CHAT</td><td style="text-align:center">否</td><td style="text-align:center"><code>&quot;&quot;</code></td><td style="text-align:center">机器人对话指令，默认为&quot;&quot;可直接对话</td></tr><tr><td style="text-align:center">SPARKAPI_FL_NOTICE</td><td style="text-align:center">否</td><td style="text-align:center"><code>True</code></td><td style="text-align:center">收到对话请求时是否提示“已收到请求”</td></tr><tr><td style="text-align:center">SPARKAPI_FL_PRIVATE_CHAT</td><td style="text-align:center">否</td><td style="text-align:center"><code>True</code></td><td style="text-align:center">是否允许私聊使用</td></tr><tr><td style="text-align:center">SPARKAPI_FL_GROUP_PUBLIC</td><td style="text-align:center">否</td><td style="text-align:center"><code>False</code></td><td style="text-align:center">群聊启用公共会话<br>True：所有人共享同一会话<br>False：每个人的会话各自独立</td></tr><tr><td style="text-align:center">SPARKAPI_FL_INTERFLOW</td><td style="text-align:center">否</td><td style="text-align:center"><code>False</code></td><td style="text-align:center">对于同一用户，群聊与私聊数据互通（公共会话启用时，群聊仍独立）</td></tr><tr><td style="text-align:center">SPARKAPI_FL_GROUP_AT</td><td style="text-align:center">否</td><td style="text-align:center"><code>True</code></td><td style="text-align:center">群聊回复消息时是否需要@提问者</td></tr><tr><td style="text-align:center">SPARKAPI_FL_IMGGEN</td><td style="text-align:center">否</td><td style="text-align:center"><code>False</code></td><td style="text-align:center">是否启用 AI 绘图功能</td></tr><tr><td style="text-align:center">SPARKAPI_FL_PPTGEN</td><td style="text-align:center">否</td><td style="text-align:center"><code>False</code></td><td style="text-align:center">是否启用 AI 生成 PPT 功能</td></tr><tr><td style="text-align:center">SPARKAPI_IG_SIZE</td><td style="text-align:center">否</td><td style="text-align:center"><code>[1280,720]</code></td><td style="text-align:center">AI 绘图的图片尺寸，[宽,高]。<br>可选值和 API 消耗见下文</td></tr><tr><td style="text-align:center">SPARKAPI_BOT_NAME</td><td style="text-align:center">否</td><td style="text-align:center"><code>&quot;&quot;</code></td><td style="text-align:center">机器人的名字</td></tr></tbody></table><h3 id="SPARKAPI-MODEL-MAXKLENGTH">SPARKAPI_MODEL_MAXKLENGTH</h3><ul><li>单次上下文最大 token 长度</li><li>该值越大，对话历史记录保留越长，单次请求消耗 token 的最大值越大</li><li>1token≈1.5 个中文字 ≈1 个英文单词。保守起见，在本插件中 1token 取 1.25 个字符</li><li>v1.5 建议取值：4000（API 限制不能超过 4000token）</li><li>v2.0 以上建议取值范围：[4000,8000]（API 限制不能超过 8000token）</li><li>QQ 单条消息上限 4500 个字符（计 3600token），消息超过最大长度可能导致响应不正确</li></ul><h3 id="SPARKAPI-PRIORITY">SPARKAPI_PRIORITY</h3><ul><li>响应事件的优先级，该值越小，事件越先被本插件响应。可选值：1~97</li><li>本插件中事件的优先级顺序：私聊阻断（=priority）&lt; 功能（=priority+1）&lt; 对话（=priority+2）</li><li>若触发本插件事件，所有插件中优先级大于此值的事件都将被阻断，因此本插件建议设置较大的值。</li></ul><h3 id="SPARKAPI-IG-SIZE">SPARKAPI_IG_SIZE</h3><table><thead><tr><th style="text-align:center">分辨率（可选值）</th><th style="text-align:center">消耗图点数</th></tr></thead><tbody><tr><td style="text-align:center">[512,512]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,360]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,480]</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">[640,640]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[680,512]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[512,680]</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">[768,768]</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">[720,1280]</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">[1280,720]</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">[1024,1024]</td><td style="text-align:center">14</td></tr></tbody></table><h3 id="命令相关：sparkapi-commands、sparkapi-commands-info">命令相关：sparkapi_commands、sparkapi_commands_info</h3><ul><li><p>如有需要，以下命令相关配置项请在<code>./.venv/Lib/nonebot_plugin_sparkapi/config.py</code>修改：</p><ol><li>sparkapi_commands：指令表</li><li>sparkapi_commands_info：指令表说明（用于生成帮助信息）</li></ol></li><li><p>在<code>config.py</code>文件中，已经用缩进表示了命令之间的从属关系。一级命令为主命令，二级命令为子命令。</p></li><li><p>命令格式由 NoneBot 机器人项目下的配置文件<code>.env</code>中的<code>COMMAND_START</code>和<code>COMMAND_SEP</code>决定（请参考 NoneBot 文档）。默认情况下，<code>COMMAND_START</code>为<code>[&quot;/&quot;]</code>，<code>COMMAND_SEP</code>为<code>[&quot;.&quot;]</code>。</p></li><li><p>一级命令帮助信息会出现在<code>help</code>中，二级命令帮助信息在单独使用一级命令时出现。</p></li><li><p>以二级命令<code>preset_create</code>为例，默认配置下：</p><ul><li>预设管理命令<code>preset</code>、二级命令<code>create</code>。</li><li>完整命令格式为<code>/preset.create</code>。</li><li>这个命令不会出现在<code>/help</code>的帮助信息中，但会在发送<code>/preset</code>时告知用户命令和用法。</li></ul></li></ul><h2 id="🎉-使用">🎉 使用</h2><h3 id="指令表（默认）">指令表（默认）</h3><p>以下所有指令均可在 <a href="http://config.py">config.py</a> 中修改，且无需重写菜单/指令生成函数</p><table><thead><tr><th style="text-align:center">指令（默认配置下）</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">直接发送对话内容<br>SPARKAPI_COMMAND_CHAT（若不为空）+对话内容</td><td style="text-align:center">与机器人进行对话</td></tr><tr><td style="text-align:center">/help</td><td style="text-align:center">显示帮助信息</td></tr><tr><td style="text-align:center">/preset</td><td style="text-align:center">显示人物预设菜单和预设相关命令项</td></tr><tr><td style="text-align:center">/preset.create</td><td style="text-align:center">创建自定义人物预设</td></tr><tr><td style="text-align:center">/preset.set</td><td style="text-align:center">选择人物预设并切换</td></tr><tr><td style="text-align:center">/preset.show</td><td style="text-align:center">显示自定义人物预设详情</td></tr><tr><td style="text-align:center">/preset.delete</td><td style="text-align:center">删除自定义人物预设</td></tr><tr><td style="text-align:center">/session</td><td style="text-align:center">显示保存的对话记录和会话管理相关命令项</td></tr><tr><td style="text-align:center">/session.save</td><td style="text-align:center">保存当前对话上下文</td></tr><tr><td style="text-align:center">/session.load</td><td style="text-align:center">加载保存的对话上下文</td></tr><tr><td style="text-align:center">/session.show</td><td style="text-align:center">显示保存的对话记录</td></tr><tr><td style="text-align:center">/session.delete</td><td style="text-align:center">删除保存的对话记录</td></tr><tr><td style="text-align:center">/clear</td><td style="text-align:center">清除当前对话上下文</td></tr><tr><td style="text-align:center">/image</td><td style="text-align:center">AI 绘图</td></tr><tr><td style="text-align:center">/ppt</td><td style="text-align:center">AI 生成 PPT</td></tr></tbody></table><h3 id="自带人物预设">自带人物预设</h3><ol><li>智能助手（默认）</li><li>李白</li></ol><h3 id="效果图">效果图</h3><details> <summary>效果图</summary><p><img src="https://source.cclmsy.cc/Images/nbp_Sparkapi/demo.png" alt="Demo"><br><a href="https://source.cclmsy.cc/Images/nbp_Sparkapi/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E6%98%9F%E7%81%AB%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%8A%A5.pptx">DemoPPT: 科大讯飞星火语言模型项目汇报.pptx</a></p></details><h2 id="📝-更新日志">📝 更新日志</h2><ul><li>2024.8.21 v2.0.8<ul><li>感谢开发者<a href="https://github.com/wyf7685">wyf7685</a>为本项目整体重写，提供优化功能实现、多平台适配等帮助！</li><li>修复了FL_IMGGEN和FL_PPTGEN配置项无效的问题</li><li>新增对 Spark Pro-128K 模型的支持</li></ul></li><li>2024.7.12 v2.0.5<ul><li>信息存储改为 UTF-8 编码</li></ul></li><li>2024.7.11 v2.0.2<ul><li>尝试通过不验证 SSL 证书规避 SSL 证书验证问题</li></ul></li><li>2024.7.10 v2.0.0<ul><li>项目重写</li><li>支持会话存储和加载、会话管理</li><li>支持预设和历史记录持久化（基于 json）</li><li>优化命令、功能的实现方式</li><li>调整了配置项和指令表</li></ul></li><li>2024.6.30 v1.5.0<ul><li>适配星火 4.0API</li></ul></li><li>2024.6.25 v1.4.5<ul><li><s>使用默认的 SSL 证书</s></li></ul></li><li>2024.6.9 v1.4.4<ul><li>优化项目结构</li><li>优化部分功能的实现方式</li></ul></li><li>2024.5.30 v1.4.1<ul><li>新增 AI 生成 PPT 功能</li></ul></li><li>2024.5.29 v1.4.0<ul><li>项目重构</li><li>新增 AI 绘图功能</li></ul></li><li>2024.5.17 v1.2.0<ul><li>简化了初始命令</li><li>模块结构优化</li></ul></li><li>2024.5.16 v1.1.0<ul><li><s>存储和加载单次会话（基于 pickle）</s></li><li>改用异步方式请求 API</li></ul></li><li>2024.5.15 v1.0.0<ul><li>支持 AI 对话</li><li>支持上下文关联</li><li>支持自定义预设、预设管理</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoneBot2 </tag>
            
            <tag> 项目文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数字图像处理》课程笔记</title>
      <link href="/posts/digital_image_processing.html"/>
      <url>/posts/digital_image_processing.html</url>
      
        <content type="html"><![CDATA[<h2 id="二、数字图像处理基础">二、数字图像处理基础</h2><h3 id="2-1-数字图像采集">2.1.数字图像采集</h3><ol><li>当前普遍采用的图像传感器：CCD、CMOS<ul><li>共同点：利用感光二极管进行光电转换，获取图像并转换为数字数据</li></ul></li><li>采样：空间坐标离散化<ul><li>均匀采样：等间隔划分成$N$行$M$列的网格</li></ul></li><li>量化：灰度值离散化<ul><li>均匀量化：将灰度值划分为$L$（通常为$2^k$）个等间隔的区间</li><li>通常取$k=8,L=256$，灰度从小到大，像素从暗到亮</li></ul></li></ol><h3 id="2-2-数字图像表示">2.2.数字图像表示</h3><ol><li>通常采用$N\times M$大小的矩阵表示具有$N$行$M$列的数字图像</li><li>左上角坐标为$(0,0)$，每个坐标的函数值$f(x,y)$表示该点的灰度值</li><li>像素：每个坐标表示的单元格</li></ol><h3 id="2-3-分辨率与图像存储">2.3.分辨率与图像存储</h3><ol><li>空间分辨率：一般指数字图像的阵列大小$N\times M$</li><li>灰度分辨率：指数字图像的灰度级别$L$（通常为$2^k$）<ul><li>灰度：图像中每个像素的亮度值，通常用0-255表示。灰度级别越多，图像越清晰。</li></ul></li><li>图像存储：长×宽×位数×通道数/8<ul><li>一幅空间分辨率为$N\times M$，灰度分辨率为$2^k$的RGB数字图像，需要$N\times M\times k\times 3 / 8 B$存储（$1B=8bit$）</li></ul></li></ol><h3 id="2-4-像素间关系">2.4.像素间关系</h3><ol><li>相邻与邻域（以$p(x,y)$为例）<ul><li>4邻域：上下左右四个像素，记为$N_4§$</li><li>对角邻域：上左、上右、下左、下右四个像素，记为$N_D§$</li><li>8邻域：九宫格，记为$N_8§$</li></ul></li><li>像素的邻接性<ul><li>4邻接：$p$与$N_4§$中的像素相邻</li><li>8邻接：$p$与$N_8§$中的像素相邻</li><li>m邻接（混合邻接）：先进行4邻接，若存在四宫格中仅对角存在像素，则对角连接</li></ul></li><li>像素的连通性<ul><li>按照对应邻接性连接像素，形成连通块</li></ul></li><li>像素的距离<ul><li>欧几里得距离（欧氏距离，范数2）：$d(p_1,p_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$</li><li>曼哈顿距离（街区距离，范数1）：$d(p_1,p_2)=|x_1-x_2|+|y_1-y_2|$</li><li>棋盘距离（范数$\infty$）：$d(p_1,p_2)=\max(|x_1-x_2|,|y_1-y_2|)$</li><li>$D_m$距离：m邻接后，$p_1$到$p_2$的最短路径长度</li></ul></li></ol><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/08.png" alt="像素间关系"></p><h3 id="2-5-习题">2.5. 习题</h3><ol><li>数字图像处理的五个经典应用领域：媒体通信、宇宙探索、气象预报、侦缉破案、考古</li><li>二值图像：具有两种灰度值的图像，但不一定是0和1。黑白图像一定是二值图像，但二值图像不一定是黑白图像。</li><li>视觉适应性：人眼对突然的亮度变化需要时间适应，亮适应性的时间比暗适应性短得多。</li><li>马赫带效应：人眼对两个颜色之间的边界，亮度感知受影响。较暗的色块靠近边界的一侧看起来更暗。</li><li>为什么在某些图像处理中，需要对图像的灰度进行对数运算？<ul><li>大量实验表明人的视觉感知到的主观亮度与进入人眼的光强度成对数关系。如此处理可以达到更好的视觉效果。</li></ul></li></ol><h2 id="三、数字图像的基本运算">三、数字图像的基本运算</h2><h3 id="3-1-矩阵统计量">3.1.矩阵统计量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean, stddev = cv2.meanStdDev(img) <span class="comment"># 均值、标准差</span></span><br><span class="line">minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(img) <span class="comment"># 最小值、最大值、最小值位置、最大值位置</span></span><br><span class="line">coeff = stddev / mean <span class="comment"># 变异系数</span></span><br></pre></td></tr></table></figure><h3 id="3-2-灰度直方图">3.2.灰度直方图</h3><ul><li>$H§=[h(r_0),h(r_1),\cdots,h(r_{L-1})]$</li><li>$h(r_i)=n_i$</li><li>统计图像中每个灰度级别的像素个数</li><li>用于分析图像的对比度、亮度等信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 计算直方图</span></span><br><span class="line"><span class="comment">## 参数：</span></span><br><span class="line"><span class="comment">## images: list[MatLike]  图像列表</span></span><br><span class="line"><span class="comment">## channels : list[int]  通道</span></span><br><span class="line"><span class="comment">## mask : MatLike 掩码，大小与输入图像相同，1表示统计，0表示不统计</span></span><br><span class="line"><span class="comment">## histSize : list[int] 直方图中bin的个数（柱的个数）</span></span><br><span class="line"><span class="comment">## ranges : list[int] 灰度值范围，通常为[0, 256]，表示0-255的灰度值范围</span></span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>//<span class="number">8</span>], [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 计算binwidth=8的直方图</span></span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>//<span class="number">8</span>, [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 绘制直方图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li>对比度越小，直方图中像素分布越集中；对比度越大，直方图中像素分布越分散均匀<ul><li>对比度：最亮与最暗像素之间的差异，可以表示为最大灰度和最小灰度的比值</li></ul></li><li>亮度越低，直方图中像素分布越靠近左侧</li></ul><h4 id="灰度直方图的特征">灰度直方图的特征</h4><ol><li>所有函数值的总和是MN</li><li>只反映每种像素值出现的次数，不反映像素的空间分布</li><li>一幅图像的直方图是唯一的，但不同图像的直方图可以相同（由第二点决定）</li></ol><h4 id="归一化直方图">归一化直方图</h4><ul><li>$P(r_k)=\dfrac{h(r_k)}{MN}$</li><li>将直方图中的像素个数转换为频率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h3 id="3-3-图像的几何运算">3.3.图像的几何运算</h3><p>修改像素之间的空间关系，由两种基本操作组成：</p><ol><li>空间变换：改变像素之间的空间关系</li><li>灰度级插值：确定空间变换后的像素灰度值</li></ol><h4 id="3-3-1-空间变换">3.3.1.空间变换</h4><h5 id="3-3-1-1-平移变换">3.3.1.1.平移变换</h5><p>$$<br>\begin{cases}<br>x_1=x_0+\Delta x\\<br>y_1=y_0+\Delta y<br>\end{cases}<br>$$</p><h5 id="3-3-1-2-旋转变换">3.3.1.2.旋转变换</h5><p>记旋转前（角坐标系）：</p><p>$$<br>\begin{cases}<br>x_0=r\cos\theta\\<br>y_0=r\sin\theta<br>\end{cases}<br>$$</p><p>顺时针旋转$\alpha$角度：</p><p>$$<br>\begin{cases}<br>x_1=r\cos(\theta-\alpha)\\<br>y_1=r\sin(\theta-\alpha)<br>\end{cases}\\<br>=\begin{cases}<br>x_1=r\cos\theta\cos\alpha+r\sin\theta\sin\alpha\\<br>y_1=r\sin\theta\cos\alpha-r\cos\theta\sin\alpha<br>\end{cases}\\<br>=\begin{cases}<br>x_1=x_0\cos\alpha+y_0\sin\alpha\\<br>y_1=-x_0\sin\alpha+y_0\cos\alpha<br>\end{cases}<br>$$</p><h5 id="3-3-1-3-镜像变换">3.3.1.3.镜像变换</h5><ol><li>水平镜像：$x_1=M-x_0,y_1=y_0$</li><li>垂直镜像：$x_1=x_0,y_1=N-y_0$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_flip = cv2.flip(img, <span class="number">1</span>) <span class="comment"># 1水平镜像，0垂直镜像，-1水平+垂直镜像</span></span><br></pre></td></tr></table></figure><h5 id="3-3-1-4-缩放变换">3.3.1.4.缩放变换</h5><p>$$<br>\begin{cases}<br>x_1=kx_0 \\<br>y_1=ky_0<br>\end{cases}<br>$$</p><h5 id="3-3-1-5-转置变换">3.3.1.5.转置变换</h5><p>$$<br>\begin{cases}<br>x_1=y_0\\<br>y_1=x_0<br>\end{cases}<br>$$</p><h4 id="3-3-2-灰度级插值">3.3.2.灰度级插值</h4><h5 id="3-3-2-0-前向映射与反向映射">3.3.2.0.前向映射与反向映射</h5><ol><li>前向映射：原图像的一个像素映射到目标图像的多个像素（放大）</li><li>反向映射：原图像的多个像素映射到目标图像的一个像素（缩小）</li></ol><h5 id="3-3-2-1-最近邻插值-零阶内插">3.3.2.1.最近邻插值/零阶内插</h5><p>取前向映射变换所得位置，最近的的整数像素位置作为灰度值。<br>计算简单，容易产生锯齿。</p><h5 id="3-3-2-2-双线性插值">3.3.2.2.双线性插值</h5><p>记：原像素位置$(0,0),(0,1),(1,0),(1,1)$，反向映射变换所得位置$(x,y)$在它们中间。</p><p>根据像素相对四点的位置，求取算术平均值作为灰度值。</p><p>$$<br>f(x,0)=(1-x)f(0,0)+xf(1,0)\\<br>f(x,1)=(1-x)f(0,1)+xf(1,1)\\<br>f(x,y)=(1-y)f(x,0)+yf(x,1)<br>$$</p><h2 id="四、空间域图像增强">四、空间域图像增强</h2><p>图像增强技术可以分为两大类：空间域方法和频率域方法。<br>空间域方法以对图像的像素进行直接处理为基础，基于点运算的方法，在单个像素层面上进行。<br>统一表示：$g(x,y)=T[f(x,y)]$，其中算子T是一种点操作。</p><h3 id="4-1-基于点运算的图像增强方法">4.1.基于点运算的图像增强方法</h3><h4 id="4-1-1-对比度拉伸-分段线性变换">4.1.1.对比度拉伸/分段线性变换</h4><p>一种通过增强图像的对比度来改善图像质量的方法。</p><ul><li>一种典型处理：压缩最暗和最亮部分，拉伸中间部分。</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/01.png" alt="一种典型处理"></p><ul><li>均匀变亮/均匀变暗：与原始灰度成线性关系。</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/02.png" alt="均匀变亮/均匀变暗"></p><h4 id="4-1-2-窗切片">4.1.2.窗切片</h4><p>一种强制某区间的灰度值为给定值的方法。</p><ul><li>区外灰度值不变</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/03.png" alt="窗切片"></p><h4 id="4-1-3-修剪变换">4.1.3.修剪变换</h4><p>去除较暗和较亮部分，拉伸中间部分，特殊的对比度拉伸。</p><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/04.png" alt="修剪变换"></p><h4 id="4-1-4-其他变换">4.1.4.其他变换</h4><ul><li>对数变换：$s=c\log(1+r)$</li><li>幂次变换：$s=cr^\gamma$</li><li>离散化：$s=0\ if\ r&lt;b\ else\ L-1$</li></ul><h3 id="4-2-基于直方图的图像增强方法">4.2.基于直方图的图像增强方法</h3><h4 id="4-2-1-直方图均衡化">4.2.1.直方图均衡化</h4><p>将一副已知图像变换成灰度具有均匀概率分布的图像，通过增大灰度值范围和对比度实现图像增强。</p><ul><li>记原图像$f$的灰度级为$L$，对原图像$f$进行直方图均衡化得到的新图像为$g$。图像直方图均衡化的步骤如下：</li></ul><ol><li>统计原图像$f$中各个灰度级的像素个数，得到原图像的直方图$H(f)$。<ul><li>给定 $16\times16$的图像$f$灰度级$L=8$</li><li>给定 $H(f)=[29,40,32,27,13,10,6,3]$</li></ul></li><li>对原图像的直方图$H(f)$进行归一化处理，得到归一化直方图$P(f)$。<ul><li>归一化直方图$P(f)=[0.18,0.25,0.20,0.17,0.08,0.06,0.04,0.02]$</li></ul></li><li>计算归一化直方图$P(f)$的累积分布函数$C(f)$（前缀和）。<ul><li>累积分布函数$C(f)=[0.18,0.43,0.63,0.80,0.88,0.94,0.98,1.00]$</li></ul></li><li>计算新灰度级$t_i=round((L-1)c(i))$（四舍五入）<ul><li>$[1,3,4,6,6,7,7,7]$</li></ul></li><li>将原图像$f$中的灰度级$i$替换为新灰度级$t_i$，得到直方图均衡化后的新图像$g$。</li><li>统计新图像$g$中各个灰度级的像素个数，得到新图像的直方图$H(g)$。<ul><li>$H(g)=[0,29,0,40,32,0,40,19]$</li></ul></li><li>对新图像的直方图$H(g)$进行归一化处理，得到新图像的归一化直方图$P(g)$。<ul><li>$P(g)=[0.00,0.18,0.00,0.25,0.20,0.00,0.25,0.12]$</li></ul></li></ol><ul><li>通过直方图均衡化，可以使得图像的灰度值分布更加均匀，从而增强图像的对比度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_eq = cv2.equalizeHist(img) <span class="comment"># 直方图均衡化</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-直方图规定化">4.2.2.直方图规定化</h4><p>直方图均衡化能显著的增强整个图像的对比度，但增强效果不易控制。通过直方图规定化，可以人为地改变直方图的形状。</p><ul><li>图像直方图规定化的步骤如下：</li></ul><ol><li>统计原图像$f$中各个灰度级的像素个数，得到原图像的直方图$H(f)$。<ul><li>给定$64\times64$的图像$f$灰度级$L=8$</li><li>给定 $H(f)=[790,1023,850,656,329,245,122,81]$</li></ul></li><li>对原图像的直方图$H(f)$进行归一化处理，得到归一化直方图$P(f)$。<ul><li>$P(f)=[0.19,0.25,0.21,0.16,0.08,0.06,0.03,0.02]$</li></ul></li><li>计算归一化直方图$P(f)$的累积分布函数$C(f)$（前缀和）。<ul><li>$C(f)=[0.19,0.44,0.65,0.81,0.89,0.95,0.98,1.00]$</li></ul></li><li>对于给定的目标信息，求出目标累积分布函数$C_1(f_1)$。<ul><li>假设给定$P_1(f_1)=[0,0,0,0.15,0.2,0.3,0.2,0.15]$</li><li>$C_1(f_1)=[0,0,0,0.15,0.35,0.65,0.85,1.00]$</li></ul></li><li>比较$C(f)$和$C(f_1)$，对于原图像$f$每个灰度级$i$，找到$|C(i)-C_1(j)|$最接近的$j$，得到映射关系。<ul><li>$C(f)=[0.19,0.44,0.65,0.81,0.89,0.95,0.98,1.00]$</li><li>$C_1(f_1)=[0,0,0,0.15,0.35,0.65,0.85,1.00]$</li><li>$T(i)=[3,4,5,6,6,7,7,7]$</li></ul></li><li>将原图像$f$中的灰度级$i$替换为新灰度级$t_i$，得到直方图均衡化后的新图像$g$。</li><li>统计新图像$g$中各个灰度级的像素个数，得到新图像的直方图$H(g)$。<ul><li>$H(g)=[0,0,0,790,1023,850,985,448]$</li></ul></li><li>对新图像的直方图$H(g)$进行归一化处理，得到新图像的归一化直方图$P(g)$。<ul><li>$P(g)=[0,0,0,0.19,0.25,0.21,0.24,0.11]$</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">f = cv2.imread(<span class="string">&#x27;lenna.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">f1 = cv2.imread(<span class="string">&#x27;Flower.png&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">Hf = cv2.calcHist([f], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">Pf = Hf / np.<span class="built_in">sum</span>(Hf)</span><br><span class="line">Cf = [np.<span class="built_in">sum</span>(Pf[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">Hf1 = cv2.calcHist([f1], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">Pf1 = Hf1 / np.<span class="built_in">sum</span>(Hf1)</span><br><span class="line">Cf1 = [np.<span class="built_in">sum</span>(Pf1[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line"></span><br><span class="line">Tr = np.zeros(<span class="number">256</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    tmp_h = np.ones(<span class="number">256</span>) * Cf1[i]</span><br><span class="line">    tmp = np.fabs(Cf - tmp_h) <span class="comment"># 对应元素相减取绝对值</span></span><br><span class="line">    Tr[i] = np.argmin(tmp) <span class="comment"># 找到最小值的索引</span></span><br><span class="line"></span><br><span class="line">out = cv2.LUT(f, Tr)</span><br></pre></td></tr></table></figure><h3 id="4-滤波">4.*.滤波</h3><ul><li>利用像素和其邻域像素的灰度值进行图像增强的方法。</li><li>空间滤波分为平滑滤波和锐化滤波。</li><li>filter：滤波器，用于对图像进行滤波处理</li><li>mask：滤波器的模板，用于计算滤波后的像素值</li></ul><h3 id="4-3-基于空间平滑滤波的图像增强方法">4.3.基于空间平滑滤波的图像增强方法</h3><ul><li>平滑滤波<ul><li>目的：去除（细小）噪声、平滑图像</li><li>本质：对像素和其邻域像素的灰度值进行加权平均</li></ul></li></ul><h4 id="4-3-1-线性滤波方法——邻域平均滤波">4.3.1.线性滤波方法——邻域平均滤波</h4><ul><li>mask：$h=\dfrac{1}{9}\begin{bmatrix}1&amp;1&amp;1 \\ 1&amp;1&amp;1 \\ 1&amp;1&amp;1\end{bmatrix}$</li><li>可以调整mask的大小和权重，实现不同的平滑效果。<ul><li>参数越大，平滑效果越明显，图像越模糊。</li><li>一般中心像素权重最大，边缘像素权重较小。</li></ul></li><li>可以根据Gaussian分布确定mask的权重，实现高斯滤波。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ksize = (<span class="number">5</span>, <span class="number">5</span>) <span class="comment"># mask大小，奇数</span></span><br><span class="line">img_blur = cv2.blur(img, ksize) <span class="comment"># 邻域平均滤波</span></span><br><span class="line">img_gaussian = cv2.GaussianBlur(img, ksize, <span class="number">0</span>) <span class="comment"># 高斯滤波</span></span><br></pre></td></tr></table></figure><h4 id="4-3-2-非线性滤波方法——中值滤波">4.3.2.非线性滤波方法——中值滤波</h4><ul><li>中值滤波窗口形状不定：矩形、圆形、十字形等</li><li>选取窗口内像素的中值作为中心像素的灰度值</li><li>优点：在减少边缘模糊方面比邻域平均效果好，对消除冲激噪声效果好</li><li>缺点：对消除高斯噪声效果差</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_median = cv2.medianBlur(img, <span class="number">5</span>) <span class="comment"># 中值滤波</span></span><br></pre></td></tr></table></figure><h3 id="4-4-基于空间锐化滤波的图像增强方法">4.4.基于空间锐化滤波的图像增强方法</h3><ul><li>锐化滤波<ul><li>目的：增强图像的边缘、轮廓</li><li>要求：图像具有较高的信噪比</li><li>锐化处理通常和边缘检测结合使用</li></ul></li><li>梯度<ul><li>函数$z=f(x,y)$在点$(x,y)$处的梯度：$\nabla f(x,y)=\left[\dfrac{\partial f}{\partial x},\dfrac{\partial f}{\partial y}\right]^T$</li><li>梯度是一个向量，具有方向和模</li><li>梯度的方向$\theta$：$\theta=\arctan\left(\dfrac{\partial f}{\partial y}/\dfrac{\partial f}{\partial x}\right)$</li><li>梯度的模$G$：<ul><li>按2-范数计算，对应欧几里得距离（欧氏距离）：$|\nabla f_{(2)}|=\sqrt{\left(\dfrac{\partial f}{\partial x}\right)^2+\left(\dfrac{\partial f}{\partial y}\right)^2}$</li><li>按1-范数计算，对应曼哈顿距离（街区距离）：$|\nabla f_{(1)}|=|\dfrac{\partial f}{\partial x}|+|\dfrac{\partial f}{\partial y}|$</li><li>按$\infty$-范数计算，对应棋盘距离：$|\nabla f_{(\infty)}|=\max(|\dfrac{\partial f}{\partial x}|,|\dfrac{\partial f}{\partial y}|)$</li></ul></li></ul></li><li>由于数字图像的离散性，偏导使用差分表示：<ul><li>一阶水平：$\Delta_y f(x,y)=f(x,y+1)-f(x,y)$</li><li>一阶垂直：$\Delta_x f(x,y)=f(x+1,y)-f(x,y)$</li><li>二阶水平：$\Delta_{yy} f(x,y)=f(x,y+1)+f(x,y-1)-2f(x,y)$</li><li>二阶垂直：$\Delta_{xx} f(x,y)=f(x+1,y)+f(x-1,y)-2f(x,y)$</li></ul></li></ul><h4 id="4-4-1-罗伯特算子（Roberts-Operator）">4.4.1.罗伯特算子（Roberts Operator）</h4><ul><li>$G=|\Delta_x f(x,y)|+|\Delta_y f(x,y)|$</li><li>$h=\begin{bmatrix}1&amp;0\\0&amp;-1\end{bmatrix}或\begin{bmatrix}0&amp;1\\-1&amp;0\end{bmatrix}$</li><li>优点：交叉差分法，简单，计算量小。</li><li>缺点：使用像素少，对噪声敏感。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_roberts = cv2.filter2D(img, -<span class="number">1</span>, np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]])) <span class="comment"># 罗伯特算子</span></span><br></pre></td></tr></table></figure><h4 id="4-4-2-拉普拉斯算子（Laplacian-Operator）">4.4.2.拉普拉斯算子（Laplacian Operator）</h4><ul><li>$G=|\Delta_{xx} f(x,y)|+|\Delta_{yy} f(x,y)|$</li><li>常用mask：<ul><li>$h_{4,1}=\begin{bmatrix}0&amp;1&amp;0\\1&amp;-4&amp;1\\0&amp;1&amp;0\end{bmatrix}$</li><li>$h_{4,2}=\dfrac{1}{2}\begin{bmatrix}1&amp;0&amp;1\\0&amp;-4&amp;0\\1&amp;0&amp;1\end{bmatrix}$</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_laplacian = cv2.Laplacian(img, cv2.CV_64F, ksize=<span class="number">3</span>) <span class="comment"># 拉普拉斯算子，参数越大，线条越粗</span></span><br></pre></td></tr></table></figure><h4 id="4-4-3-普瑞维特算子（Prewitt-Operator）">4.4.3.普瑞维特算子（Prewitt Operator）</h4><ul><li>近似一阶导数</li><li>常用mask:<ul><li>$h_1 = \begin{bmatrix}1&amp;1&amp;1\\0&amp;0&amp;0\\-1&amp;-1&amp;-1\end{bmatrix}$</li><li>其余通过旋转得到</li></ul></li></ul><h4 id="4-4-4-索贝尔算子（Sobel-Operator）">4.4.4.索贝尔算子（Sobel Operator）</h4><ul><li>近似一阶导数，往往用于估计水平和垂直方向的梯度</li><li>常用mask:<ul><li>$h_1 = \begin{bmatrix}-1&amp;-2&amp;-1\\0&amp;0&amp;0\\1&amp;2&amp;1\end{bmatrix}$</li><li>$h_2 = \begin{bmatrix}-1&amp;0&amp;1\\-2&amp;0&amp;2\\-1&amp;0&amp;1\end{bmatrix}$</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>) <span class="comment"># x方向梯度（竖直），ksize越大，成块的色块越大</span></span><br><span class="line">img_sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>) <span class="comment"># y方向梯度（水平）</span></span><br><span class="line">img_sobel = cv2.magnitude(img_sobelx, img_sobely) <span class="comment"># 梯度幅值</span></span><br></pre></td></tr></table></figure><h2 id="五、频率域图像增强">五、频率域图像增强</h2><ul><li>三大类正交变换：正弦型变换、方波型变换、基于特征向量的变换</li><li>卷积：一种数学算子，施加于两个函数$f,g$，产生第三个函数。<ul><li>定义：$(f*g)(t)=\int_{-\infty}^{+\infty}f(\tau)g(t-\tau)d\tau=\int_{-\infty}^{+\infty}f(t-\tau)g(\tau)d\tau$</li></ul></li><li>频率域图像处理流程：<ul><li>$原图像f(x,y)\xrightarrow{傅里叶变换}F(u,v)\xrightarrow{H(u,v)滤波}G(u,v)\xrightarrow{傅里叶逆变换}结果图像g(x,y)$</li></ul></li></ul><h3 id="5-1-离散傅里叶变换（Discrete-Fourier-Transform，DFT）">5.1.离散傅里叶变换（Discrete Fourier Transform，DFT）</h3><ul><li>傅里叶变换将一个信号从时间域转换到频率域，反傅里叶变换将一个信号从频率域转换到时间域。</li><li>离散傅里叶变换是正弦型变换</li></ul><h4 id="5-1-1-一维连续傅里叶变换">5.1.1.一维连续傅里叶变换</h4><ul><li>一阶连续函数$f(x)$的傅里叶变换：$F(u)=\int_{-\infty}^{+\infty}f(x)e^{-j2\pi ux}dx$（j为虚数单位）</li><li>一阶连续函数$f(x)$的反傅里叶变换：$f(x)=\int_{-\infty}^{+\infty}F(u)e^{j2\pi ux}du$</li><li><strong>欧拉公式</strong>：$e^{j\theta}=\cos\theta+j\sin\theta$</li></ul><h4 id="5-1-2-一维离散傅里叶变换">5.1.2.一维离散傅里叶变换</h4><ul><li>给定时间序列$x[n],n=0,1,2,\cdots,N-1$<ul><li>离散傅里叶变换为：<ul><li>$X[k]=\sum\limits_{n=0}^{N-1}x[n]e^{-j2\pi kn/N}$</li></ul></li><li>离散傅里叶逆变换为：<ul><li>$x[n]=\dfrac{1}{N}\sum\limits_{k=0}^{N-1}X[k]e^{j2\pi kn/N}$</li></ul></li></ul></li><li>以$N=4$为例，利用欧拉定理可知：<ul><li>$\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}=\begin{bmatrix}e^{-0\cdot i\pi/2}&amp;e^{-0\cdot i\pi}&amp;e^{-0\cdot i3\pi/2}&amp;e^{-0\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-1\cdot i\pi}&amp;e^{-2\cdot i3\pi/2}&amp;e^{-3\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-2\cdot i\pi}&amp;e^{-4\cdot i3\pi/2}&amp;e^{-6\cdot i2\pi}\\e^{-0\cdot i\pi/2}&amp;e^{-3\cdot i\pi}&amp;e^{-6\cdot i3\pi/2}&amp;e^{-9\cdot i2\pi}\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}1&amp;1&amp;1&amp;1\\1&amp;-i&amp;-1&amp;i\\1&amp;-1&amp;1&amp;-1\\1&amp;i&amp;-1&amp;-i\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}$</li></ul></li></ul><h4 id="5-1-3-二维离散傅里叶变换">5.1.3.二维离散傅里叶变换</h4><ul><li>对于给定的二维离散信号$f(x,y)$，$x\in[0,M-1],y\in[0,N-1]$<ul><li>二维离散傅里叶变换：<ul><li>$F(u,v)=\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f(x,y)e^{-j2\pi(\dfrac{ux}{M}+\dfrac{vy}{N})}$</li></ul></li><li>二维离散傅里叶逆变换：<ul><li>$f(x,y)=\dfrac{1}{\sqrt{MN}}\sum\limits_{u=0}^{M-1}\sum\limits_{v=0}^{N-1}F(u,v)exp({j2\pi(\dfrac{ux}{M}+\dfrac{vy}{N})})$</li></ul></li></ul></li><li>可分离性：傅里叶变换中的指数项可分离成只含有x,u的一项和只含有y,v的一项的乘积<ul><li>$exp(-j2\pi\dfrac{ux+vy}{N})=exp(-j2\pi\dfrac{ux}{N})\cdot exp(-j2\pi\dfrac{vy}{N})$</li><li>即$F(u,v)=\sum\limits_{x=0}^{N-1}F(x,v)exp(-j2\pi\dfrac{ux}{N})$</li><li>结论：对每个x，对行进行一次一维DFT，对每个y，对列进行一次一维DFT，可以得到二维DFT</li></ul></li><li>零频率分量与平均值<ul><li>$F(0,0)=\dfrac{1}{\sqrt{MN}}\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f(x,y)$</li><li>结论：$F(0,0)$与图像的平均值成正比，$k=\sqrt{MN}$</li></ul></li><li>共轭对称性<ul><li>$F(u,v)=F^*(-u,-v)$</li><li>结论：对于实数图像，其频谱是共轭对称的</li></ul></li><li>平移不变性<ul><li>空间域平移：$f(x-x_0,y-y_0)\leftrightarrow F(u,v)exp(-j2\pi\dfrac{ux_0}{M})exp(-j2\pi\dfrac{vy_0}{N})$</li><li>频率域平移：$f(x,y)exp(j2\pi\dfrac{ux_0}{M})exp(j2\pi\dfrac{vy_0}{N})\leftrightarrow F(u-u_0,v-v_0)$</li><li>结论：在空间域中平移图像，频率域只发生相移，不发生幅度变化；在频率域中平移图像，空间域只发生相移，图像幅值不变。</li></ul></li><li>周期性<ul><li>$|F(u,v)|=|F(u+M,v+N)|=|F(-u,-v)|=|F(M-u,N-v)|$</li></ul></li></ul><h4 id="5-1-4-OpenCV">5.1.4.OpenCV</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img_dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT) <span class="comment"># 二维离散傅里叶变换</span></span><br><span class="line"><span class="comment">## flags: cv2.DFT_COMPLEX_OUTPUT（输出为复数数组）、cv2.DFT_REAL_OUTPUT（只输出实数数组）</span></span><br><span class="line">img_idft = cv2.idft(img_dft) <span class="comment"># 二维离散傅里叶逆变换，输出为复数数组</span></span><br><span class="line">img_dftshf = np.fft.fftshift(img_dft) <span class="comment"># 频谱中心化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 当图像数组的大小为2的幂次方时，dft()的运算速度最快</span></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">new_rows = cv2.getOptimalDFTSize(rows) <span class="comment"># 获取最优行数</span></span><br><span class="line">new_cols = cv2.getOptimalDFTSize(cols) <span class="comment"># 获取最优列数</span></span><br><span class="line"></span><br><span class="line">dft_mag, dft_pol = cv2.cartToPolar(img_dft[:,:,<span class="number">0</span>], img_dft[:,:,<span class="number">1</span>]) <span class="comment"># 极坐标转换</span></span><br></pre></td></tr></table></figure><h3 id="5-2-图像的傅里叶频谱分析">5.2.图像的傅里叶频谱分析</h3><h4 id="5-2-1-频谱图像关于-M-2-N-2-对称">5.2.1.频谱图像关于$(M/2,N/2)$对称</h4><h4 id="5-2-2-频谱中心化前后的频谱图像">5.2.2.频谱中心化前后的频谱图像</h4><ul><li>中心化前：频谱图像的原点位于左上角。低频分量位于图像的四角，高频分量位于图像的中心。</li><li>中心化后：频谱图像的原点位于中心。低频分量位于图像的中心，高频分量位于图像的四角。</li><li>由于傅里叶变换的周期性，可以将中心化前的图像组成$2\times2$的周期图像，取中心部分即为中心化后的图像。</li></ul><h4 id="5-2-3-傅里叶变换的意义">5.2.3.傅里叶变换的意义</h4><ol><li>简化计算：傅里叶变换将空间域图像转换到频率域，在空间域中处理图像时用到的复杂卷积运算，等同于在频率域中进行简单的乘法运算。</li><li>用频谱图表示的频率域图像中：<ul><li>中心部位是能量集中的低频特征，反映图像的平滑部分</li><li>边缘部位是能量分散的高频特征，对应于细节、边缘、结构复杂区域、突变部位和噪声</li><li>因此，频率域中滤波的概念更直观、更易理解</li></ul></li><li>某些特定的应用需求只能在频率域进行处理，如频率域图像特征提取、数据压缩、纹理分析等</li></ol><h3 id="5-3-基于频率域滤波的图像噪声消除——频率域低通滤波">5.3.基于频率域滤波的图像噪声消除——频率域低通滤波</h3><ul><li>图像的边缘和噪声对应于傅里叶频谱的高频成分。</li><li>低通滤波器：保留低频成分，抑制高频成分。</li><li>可以削弱噪声影响，但是会模糊边缘细节，降低图像清晰度。</li><li>与空间域平滑滤波效果类似。</li></ul><h4 id="5-3-1-理想低通滤波器">5.3.1.理想低通滤波器</h4><p>设置一个截止频率$D_0$，只保留频率小于$D_0$的成分。</p><ul><li>理想低通滤波器：$H(u,v)=\begin{cases}1&amp;D(u,v)\leq D_0\\0&amp;D(u,v)&gt;D_0\end{cases}$</li><li>其中，$D(u,v)$是频率域中点$(u,v)$到中心的距离。若变换被中心化，注意调整$D(u,v)$的计算方式。</li><li>理想低通滤波器无法通过电子器件实现。</li></ul><h4 id="5-3-2-巴特沃斯低通滤波器（Butterworth-Lowpass-Filter）">5.3.2.巴特沃斯低通滤波器（Butterworth Lowpass Filter）</h4><ul><li>n阶巴特沃斯低通滤波器：$H(u,v)=\dfrac{1}{1+[D(u,v)/D_0]^{2n}}$</li><li>巴特沃斯低通滤波器能够物理实现。</li></ul><h4 id="5-4-3-其他低通滤波器">5.4.3.其他低通滤波器</h4><ul><li>梯形低通滤波器</li><li>n指数型低通滤波器</li></ul><h3 id="5-4-基于频率域滤波的图像增强——频率域高通滤波">5.4.基于频率域滤波的图像增强——频率域高通滤波</h3><ul><li>图像的边缘和细节对应于傅里叶频谱的高频成分。</li><li>高通滤波器：保留高频成分，抑制低频成分。</li></ul><h4 id="5-4-1-理想高通滤波器">5.4.1.理想高通滤波器</h4><p>与理想低通滤波器相反，只保留频率大于$D_0$的成分。</p><ul><li>理想高通滤波器：$H(u,v)=\begin{cases}1&amp;D(u,v)&gt;D_0\\0&amp;D(u,v)\leq D_0\end{cases}$</li></ul><h4 id="5-4-2-巴特沃斯高通滤波器（Butterworth-Highpass-Filter）">5.4.2.巴特沃斯高通滤波器（Butterworth Highpass Filter）</h4><ul><li>n阶巴特沃斯高通滤波器：$H(u,v)=1-\dfrac{1}{1+[D_0/D(u,v)]^{2n}}$</li></ul><h4 id="5-4-3-高频增强滤波器">5.4.3.高频增强滤波器</h4><ul><li>高通滤波会滤除低频成分，导致整体形象变暗。</li><li>高频增强滤波器：$H_e(u,v)=kH(u,v)+c$<ul><li>$k&gt;1$：增强高频成分</li><li>$c$：适当保留低频成分</li></ul></li></ul><h3 id="5-5-带通滤波和带阻滤波">5.5.带通滤波和带阻滤波</h3><ul><li>带通滤波：只保留频率在两个截止频率之间的成分。</li><li>带阻滤波：只保留频率在两个截止频率之外的成分。</li></ul><h3 id="5-6-习题">5.6.习题</h3><ol><li>空间域图像和模板之间的运算是一种卷积运算。由卷积定理，空域的卷积可以通过频域中图像的傅立叶变换和模板的傅立叶变换间的乘积运算来实现。所以，对频域中的转移函数求傅立叶反变换即可得到用于空域卷积的模板。</li></ol><h2 id="七、图像压缩编码">七、图像压缩编码</h2><h3 id="7-1-离散余弦变换（Discrete-Cosine-Transform，DCT）">7.1.离散余弦变换（Discrete Cosine Transform，DCT）</h3><ul><li>DCT变换避免了复数运算。若图像矩阵是实数矩阵，则DCT变换后的矩阵也是实数矩阵。</li><li>DCT是一种正交变换，变换矩阵是正交矩阵，变换核是可分离的。</li><li>DCT有快速算法。</li><li>DCT具有更强的信息集中能力。</li></ul><h4 id="7-1-1-一维离散余弦变换">7.1.1.一维离散余弦变换</h4><ul><li>给定长度为N的一维信号$x[n],n=0,1,2,\cdots,N-1$<ul><li>一种常用的1D-DCT形式：$X[u]=a(u)\sum\limits_{m=0}^{N-1}x[m]cos(\dfrac{(2m+1)u\pi}{2N})$，其中$a(u)=\begin{cases}\sqrt{\dfrac{1}{N}}&amp;u=0\\\sqrt{\dfrac{2}{N}}&amp;u&gt;0\end{cases}$</li></ul></li><li>以$N=4$为例<ul><li>1D-DCT：$\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}=\begin{bmatrix}0.5&amp;0.5&amp;0.5&amp;0.5\\0.65&amp;0.27&amp;-0.27&amp;-0.65\\0.5&amp;-0.5&amp;-0.5&amp;0.5\\0.27&amp;-0.65&amp;0.65&amp;-0.27\end{bmatrix}\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}$</li><li>1D-IDCT：$\begin{bmatrix}x_0\\x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}0.5&amp;0.65&amp;0.5&amp;0.27\\0.5&amp;0.27&amp;-0.5&amp;-0.65\\0.5&amp;-0.27&amp;-0.5&amp;0.65\\0.5&amp;-0.65&amp;0.5&amp;-0.27\end{bmatrix}\begin{bmatrix}X_0\\X_1\\X_2\\X_3\end{bmatrix}$</li></ul></li></ul><h4 id="7-1-2-二维离散余弦变换">7.1.2.二维离散余弦变换</h4><ul><li>给定二维信号$x[m,n],m=0,1,2,\cdots,M-1,n=0,1,2,\cdots,N-1$<ul><li>2D-DCT：<ul><li>$C(u,v)=a(u)a(v)\sum\limits_{m=0}^{M-1}\sum\limits_{n=0}^{N-1}f(x,y)cos(\dfrac{(2x+1)u\pi}{2M})cos(\dfrac{(2y+1)v\pi}{2N})$</li></ul></li><li>2D-IDCT：<ul><li>$f(x,y)=\sum\limits_{u=0}^{M-1}\sum\limits_{v=0}^{N-1}a(u)a(v)C(u,v)cos(\dfrac{(2x+1)u\pi}{2M})cos(\dfrac{(2y+1)v\pi}{2N})$</li></ul></li><li>其中，$a(u)=\begin{cases}\sqrt{\dfrac{1}{N}}&amp;u=0\\\sqrt{\dfrac{2}{N}}&amp;u&gt;0\end{cases}$</li></ul></li></ul><h4 id="7-1-3-OpenCV">7.1.3.OpenCV</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img_dct = cv2.dct(img.astype(np.float32)) <span class="comment"># 二维离散余弦变换</span></span><br><span class="line">img_idct = cv2.idct(img_dct) <span class="comment"># 二维离散余弦逆变换</span></span><br></pre></td></tr></table></figure><h3 id="7-2-数字图像压缩编码基础">7.2.数字图像压缩编码基础</h3><h4 id="7-2-1-信息冗余">7.2.1.信息冗余</h4><ul><li>图像压缩的原理<ul><li>图像信号存在大量的冗余</li><li>人眼对图像的感知有限，可以以一定失真为代价换取数据量减少</li></ul></li><li>压缩率：$压缩率=\dfrac{原始数据量}{压缩后数据量}$</li><li>信息冗余<ul><li>空间冗余：相邻像素之间具有相关性</li><li>时间冗余：视频序列中相邻帧之间具有相关性</li><li>编码冗余：由编码方式导致的冗余</li><li>心理-视觉冗余：人眼对图像的感知有限，某些信息不重要</li></ul></li><li>图像质量的主观评价：人的主观感受，如图像的清晰度、色彩、对比度等。</li><li>图像质量的客观评价：信噪比（SNR）、峰值信噪比（PSNR）、均方误差（MSE）等。</li></ul><h4 id="7-2-2-图像质量的客观评价">7.2.2.图像质量的客观评价</h4><p>原始图像$f$，压缩后的图像$g$，图像大小为$M\times N$</p><h5 id="7-2-2-1-均方误差（Mean-Square-Error，MSE）">7.2.2.1.均方误差（Mean Square Error，MSE）</h5><ul><li>$MSE=\dfrac{1}{MN}\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}[f(x,y)-g(x,y)]^2$</li></ul><h5 id="7-2-2-2-信噪比（Signal-to-Noise-Ratio，SNR）">7.2.2.2.信噪比（Signal-to-Noise Ratio，SNR）</h5><ul><li>$SNR=10\log_{10}\dfrac{\sigma^2}{MSE}$</li><li>其中$\sigma^2=\dfrac{1}{MN}\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f^2(x,y)$（原始图像的平方平均）</li></ul><h5 id="7-2-2-3-峰值信噪比（Peak-Signal-to-Noise-Ratio，PSNR）">7.2.2.3.峰值信噪比（Peak Signal-to-Noise Ratio，PSNR）</h5><ul><li>$PSNR=10\log_{10}\dfrac{max(I)^2}{MSE}$</li><li>通常$max(I)=L-1$</li></ul><h3 id="7-3-图像压缩编码">7.3.图像压缩编码</h3><ul><li>图像压缩编码处理流程：$f(x,y)\xrightarrow{信源编码器}\xrightarrow{信道编码器}信道传输\xrightarrow{信道解码器}\xrightarrow{信源解码器}g(x,y)$</li><li>信源编码：通过减少冗余来压缩数据的过程。<ul><li>信源编码器模型：$f(x,y)\rightarrow映射变换器\rightarrow量化器\rightarrow符号编码器\rightarrow 信道$</li><li>信源解码器模型：$信道\rightarrow符号解码器\rightarrow反量化器\rightarrow反向映射变换器\rightarrow g(x,y)$</li></ul></li><li>信道编码：也称差错控制编码，是一种在发送端给原数据添加与原数据相关的冗余信息，以便在接收端检测和纠正错误的编码方式。用于对抗传输过程中的噪声干扰。<ul><li>汉明码、循环冗余校验码（CRC）</li></ul></li></ul><h4 id="7-3-1-信息量与信息熵">7.3.1.信息量与信息熵</h4><ul><li>事件提供的信息量：$I(x)=-\log_2P(x)$</li><li>信源：$X,x_i=p_i$，$x_i$发生的概率为$p_i$</li><li>信源熵：$H(X)=-\sum\limits_{i=1}^n p_i\log_2p_i$（比特/符号）<ul><li>信源的平均信息量，即信源发出一个符号所携带的平均信息量</li><li>非负，在所有事件概率均等时，熵最大</li></ul></li></ul><h4 id="7-3-2-编码">7.3.2.编码</h4><ul><li>编码：由信源消息集到码字集的映射</li><li>根据长度是否相等分为：等长码和变长码</li><li>香农定理：无干扰下，平均码长的下限为信源熵</li><li>压缩比：$压缩比C=\dfrac{信源的平均比特率n}{编码后平均码长n_d}$</li><li>最大压缩比：$C_{max}=\dfrac{n}{H(X)}$</li></ul><h4 id="7-3-3-哈夫曼编码">7.3.3.哈夫曼编码</h4><ul><li>带权路径长度（WPL）：$WPL=\sum\limits_{i=1}^n p_i l_i$</li><li>算法：<ul><li>每次选取权重最小的两个节点，合并到一个新的节点，新节点的权重为两个节点的权重之和</li><li>直到所有节点合并到一起，最终得到一棵树</li><li>每个叶子节点代表一个源符号，从根节点到叶子节点的路径上的编码即为哈夫曼编码</li></ul></li></ul><h4 id="7-3-4-算术编码">7.3.4.算术编码</h4><ul><li>根据权重分配概率</li><li>符号序列映射为$[0,1)$的一个子区间</li><li>设$a:30%,b:70%$，则$a=[0,0.3),b=[0.3,1),aa=[0,0.09),ab=[0.09,0.3),ba=[0.3,0.51),bb=[0.51,1)$</li></ul><h3 id="7-4-位平面编码">7.4.位平面编码</h3><ul><li>位平面分解：一幅$m$比特表示灰度的图像，可以看作$m$个二值图像序列</li><li>在位平面中存在大量具有相同值的区域，可以利用连续的0和1进行高效的压缩编码和传输</li></ul><h4 id="7-4-1-格雷码分解编码">7.4.1.格雷码分解编码</h4><ul><li>格雷码：相邻两个数的二进制码只有一位不同</li><li>设源图像中像素灰度值原$m$位为$x_{m-1}\cdots x_1x_0$，则有：$\begin{cases}g_i=x_i\oplus x_{i-1}\\g_{m-1}=x_{m-1}\end{cases}$</li><li>这种方式保证了相邻像素的格雷码值只有一位不同，在位平面上的连续0和1的序列更多，有利于压缩编码</li></ul><h3 id="7-5-游程编码-行程编码">7.5.游程编码/行程编码</h3><ul><li>适用于连续的0和1较多的序列</li><li>缺点：对于交替的0和1，效果不好甚至会增加编码长度</li></ul><h4 id="7-5-1-基本思想">7.5.1.基本思想</h4><ul><li>对于连续的原符号，用一个符号和一个计数值来表示</li><li>如：$aaaaabbbcccc\rightarrow a5b3c4$</li></ul><h4 id="7-5-2-表0的游程编码">7.5.2.表0的游程编码</h4><ul><li>用一个$k$位二进制数表示相邻两个$1$之间$0$的个数</li><li>如：$0(14)10(9)110(20)10(30)110(11)1（括号内为连续0的数量）\rightarrow 1110(14),1001(9),0000(0),1111 0101(15+5=20),1111 1111(15+15=30),0000(0),1011(11),0000(0)（括号内为二进制表示数的含义）$</li></ul><h4 id="7-5-3-国际传真标准CCITT-T-4-G3">7.5.3.国际传真标准CCITT T.4(G3)</h4><ul><li>采用了霍夫曼编码和游程编码相结合的方法，对每种白长码字和黑长码字进行霍夫曼编码。</li><li>每一行总是以白长开始，允许为0；以唯一行尾（EOL）码字结束。</li></ul><h3 id="7-6-变换编码">7.6.变换编码</h3><h2 id="九、图像分割">九、图像分割</h2><h3 id="9-1-图像分割的基本概念">9.1.图像分割的基本概念</h3><ul><li>图像分割：依据图像的灰度、颜色、纹理、边缘等特征，把图像分成各自满足某种特征的连通区域的集合。</li><li>特征：灰度、颜色、纹理、形状、边缘轮廓等</li></ul><h3 id="9-2-基于边缘检测的图像分割——哈夫变换（Hough-Transform）">9.2.基于边缘检测的图像分割——哈夫变换（Hough Transform）</h3><ul><li>边缘：具有不同灰度的区域的边界</li><li>常用算子：Roberts、Sobel、Prewitt、Laplacian、Canny</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edge = cv2.Canny(img, <span class="number">80</span>, <span class="number">240</span>) <span class="comment"># Canny边缘检测，建议参数3是参数2的3倍</span></span><br></pre></td></tr></table></figure><ul><li>哈夫变换：用于在数字图像中检测直线、圆等形状特征</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lines = cv2.HoughLinesP(image, rho, theta, threshold, lines=<span class="literal">None</span>, minLineLength=<span class="literal">None</span>, maxLineGap=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">## 1. image--输入，必须是二值图像，推荐以canny边缘检测结果作为输入;</span></span><br><span class="line"><span class="comment">## 2. rho--线段以像素为单位的距离精度，double类型，推荐值1.0;</span></span><br><span class="line"><span class="comment">## 3. theta--线段以弧度为单位的角度精度，推荐值numpy.pi/180；</span></span><br><span class="line"><span class="comment">## 4. threshlod--累加平面的阈值参数,int类型， 超过阈值才被检测出线段, 值越大, 意味着检出的线段越长, 检出的线段个数越少</span></span><br><span class="line"><span class="comment">## 5. minLineLength--线段以像素为单位的最小，需根据具体场景设定；</span></span><br><span class="line"><span class="comment">## 6. maxLineGap--同一方向上两条线段判定为一条线段的最大允，值越大则同一方向上允许的断裂越大；</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1, y1, x2, y2 = line[<span class="number">0</span>] <span class="comment"># 线段的两个端点</span></span><br><span class="line">    cv2.line(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment"># 画线</span></span><br><span class="line"></span><br><span class="line">circles = cv2.HoughCircles(image, method, dp, minDist, param1, param2, minRadius, maxRadius)</span><br><span class="line"><span class="comment">## 1. image: 输入的灰度图像</span></span><br><span class="line"><span class="comment">## 2. method: 检测方法，可为cv2.HOUGH_GRADIENT（梯度法霍夫圆检测）、cv2.HOUGH_GRADIENT_ALT（另一种梯度法）</span></span><br><span class="line"><span class="comment">## 3. dp: 文档上写的是图像分辨率与累加器分辨率的比值，通常为1</span></span><br><span class="line"><span class="comment">## 4. minDist：圆心之间最小距离，如果距离太小，会产生很多相交的圆</span></span><br><span class="line"><span class="comment">## 5. param1：canny检测的双阈值中的高阈值，低阈值是它的一半</span></span><br><span class="line"><span class="comment">## 6. param2：最小投票数（基于圆心的投票数）</span></span><br></pre></td></tr></table></figure><h3 id="9-3-基于阈值的图像分割方法">9.3.基于阈值的图像分割方法</h3><p>提取物体与背景在灰度上的差异，将图像分为具有不同灰度级目标区域和背景区域</p><h4 id="9-3-1-基于单一阈值的图像分割">9.3.1.基于单一阈值的图像分割</h4><ul><li>找到一个介于目标和背景灰度之间的阈值$T$，将图像分为两部分</li><li>$m(x,y)=\begin{cases}1&amp;f(x,y)&gt;T\\0&amp;f(x,y)\leq T\end{cases}$</li></ul><h4 id="9-3-2-一种阈值确定方法的步骤">9.3.2. 一种阈值确定方法的步骤</h4><ol><li>选择一个初始估计值$T_0$</li><li>以$T_0$进行图像分割，计算两个像素集合各自的平均灰度值$M_1$和$M_2$</li><li>计算新的阈值$T_1=\dfrac{M_1+M_2}{2}$</li></ol><h4 id="9-3-3-自适应阈值">9.3.3.自适应阈值</h4><p>将图像分为$N\times N$个小区域，对每个小区域分别计算一个阈值</p><h3 id="9-4-基于区域的图像分割方法">9.4.基于区域的图像分割方法</h3><p>根据图像的灰度、颜色、纹理和图像像素统计特征的均匀性等图像的空间局部特征，将图像中的像素划归到各个物体或区域中。</p><h4 id="9-4-1-区域生长法">9.4.1.区域生长法</h4><ul><li>根据事先定义的相似性准则，将具有相似性质的像素点合并成一个区域</li><li>步骤：<ol><li>选择和确定一组能够正确代表所需区域的种子<ul><li>原则：接近聚类中心的像素/红外图像目标检测中最亮的像素/按位置要求/根据经验</li></ul></li><li>确定在生长过程中合并相邻像素的相似性原则<ul><li>颜色（彩色图像）/灰度值差/和已知区域构成某种形状或尺寸</li></ul></li><li>确定终止生长过程的条件或规则<ul><li>一般：没有满足合并条件的像素</li><li>其他：区域大小、灰度差、形状等触发一定条件</li></ul></li><li>从种子像素开始，逐步合并相邻像素，直到满足终止条件</li></ol></li></ul><h4 id="9-4-2-分裂合并法">9.4.2.分裂合并法</h4><ul><li>从整幅图像开始，根据图像中区域间某种不一致性，逐步分裂成更小的区域；再根据相邻子区域的某种一致性准则，逐步合并。</li><li>图像四叉树表示法：<img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/05.png" alt="图像四叉树表示法"></li><li>步骤：<ol><li>对初始图像$R_0$进行一次四分裂得到四个子区域$R_1,R_2,R_3,R_4$</li><li>对于所有图像$R_i$进行检测，若满足分裂规则（$P(R_i)=TRUE$），则对该区域进行四分裂</li><li>对于所有图像$R_i$进行检测，若相邻区域满足合并规则（$M(R_i,R_j)=TRUE$），则合并这两个区域</li><li>重复步骤2和3，直到不再有区域满足分裂或合并规则</li></ol></li></ul><h2 id="十二、形态学图像处理">十二、形态学图像处理</h2><h3 id="12-1-二值形态学的基本运算">12.1.二值形态学的基本运算</h3><h4 id="12-1-1-膨胀运算">12.1.1.膨胀运算</h4><p>$A\oplus B={x|(\hat{B})_y\cap A\neq\emptyset}$</p><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/07.png" alt="膨胀运算"></p><p>计算过程：<br>创建一个与原图像$A$形状同的全0图像$G$。<br>对于原图像$A$中的每一个1所在的像素，将结构元素$B$的原点放在该位置，将$B$中的1对应的位置在$G$中置1。</p><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/10.png" alt="膨胀运算计算过程"></p><ul><li>图$G$中：白0表示原来是1新图像是0；灰1表示原来是1新图像还是1；黑2表示原来是0，新图像是1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">1</span>), np.uint8) <span class="comment"># 5x1的结构元素</span></span><br><span class="line">img_dilate = cv2.dilate(img, kernel, iterations=<span class="number">1</span>) <span class="comment"># 膨胀运算</span></span><br></pre></td></tr></table></figure><h4 id="12-1-2-腐蚀运算">12.1.2.腐蚀运算</h4><p>$A\ominus B={x|(\hat{B})_y\subseteq A}$</p><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/06.png" alt="腐蚀运算"></p><p>计算过程：<br>创建一个与原图像$A$形状同的全0图像$G$。<br>对于原图像$A$中的每一个1所在的像素，将结构元素$B$的原点放在该位置。<br>若$B$中的1对应的位置在$A$中都是1，则将$G$中该位置置1；<br>否则，$G$中该位置为0。</p><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/11.png" alt="腐蚀运算"></p><ul><li>图$G$中：白0表示原来是1新图像是0；灰1表示原来是1新图像还是1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">3</span>,<span class="number">1</span>), np.uint8) <span class="comment"># 3x1的结构元素</span></span><br><span class="line">img_dilate = cv2.dilate(img, kernel, iterations=<span class="number">1</span>) <span class="comment"># 膨胀运算</span></span><br></pre></td></tr></table></figure><h4 id="12-1-3-开运算">12.1.3.开运算</h4><ul><li>先腐蚀后膨胀</li><li>$A\circ B=(A\ominus B)\oplus B$</li><li>能够消除外部噪点，平滑轮廓</li></ul><h4 id="12-1-4-闭运算">12.1.4.闭运算</h4><ul><li>先膨胀后腐蚀</li><li>$A\bullet B=(A\oplus B)\ominus B$</li><li>能够消除内部噪点，保持物体的面积和形状</li></ul><h4 id="12-1-5-四种基本运算的性质">12.1.5.四种基本运算的性质</h4><p>单调性、扩展性、交换性、结合性、平移不变性</p><h3 id="12-2-二值图像的形态学处理">12.2.二值图像的形态学处理</h3><h4 id="12-2-1-形态滤波">12.2.1.形态滤波</h4><p>形态滤波器：先开后闭/先闭后开</p><h4 id="12-2-2-边界提取">12.2.2.边界提取</h4><p>原图像-腐蚀图像=边界图像</p><h4 id="12-2-3-区域填充">12.2.3.区域填充</h4><ol><li>先对原图像$f$取反得到$f_c$</li><li>对$f_c$进行膨胀运算，得到$f_1$</li><li>对$f_1$和$f_c$求交集，得到$f_2$</li><li>对$f_2$和$f$求并集，得到目标图像$g$</li></ol><h4 id="12-2-4-骨架提取">12.2.4.骨架提取</h4><p>通过迭代腐蚀和差分运算，得到图像的骨架</p><h4 id="12-2-5-物体识别-击中击不中变换">12.2.5.物体识别/击中击不中变换</h4><p>利用具有特定形状的结构元素，对图像进行腐蚀运算，根据内部像素的变化判断物体的形状</p><h2 id="零一、彩色图像与颜色模型">零一、彩色图像与颜色模型</h2><h3 id="01-1-彩色图像的概述">01.1.彩色图像的概述</h3><ol><li>颜色模型：也称作颜色空间，常见的包括：HSI、HSV、RGB、NTSC、YCbCr等</li><li>光谱分布和彩色感觉是多对一关系：为了得到某一种彩色感觉，可以用不同光谱分布的光以适当比例混合而成，参与混合的光的成分不唯一</li><li>三基色原理：合理地选取三种基本颜色，几乎自然界中所有颜色都可以用这三种颜色的适当混合来表示</li><li>彩色电视及图像处理系统的彩色显示器，都采用红绿蓝三色作为三基色</li></ol><h3 id="01-2-HSI">01.2.HSI</h3><h4 id="01-2-1-HSI">01.2.1.HSI</h4><ul><li>HSI模型：色调（Hue）、饱和度（Saturation）、亮度/灰度（Intensity）</li><li>色调：反映颜色的类别，决定于彩色光的光谱成分，是“质”的特征</li><li>饱和度：反映颜色的纯度，即色彩的浓淡。纯色光谱色的含量越多，饱和度越高</li><li>亮度/灰度：决定了彩色光的强度</li><li>色调和饱和度合称“色度”</li></ul><h4 id="01-2-2-HSI模型">01.2.2.HSI模型</h4><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/09.png" alt="HSI模型"></p><ul><li>HSI模型可以表示为一个纺锤体</li><li>色调$H$对应极坐标的$\rho$，饱和度$S$对应极坐标的$\theta$，亮度$I$对应垂直坐标$z$</li><li>$\theta=0,120,240$对应红、绿、蓝三原色</li><li>$I$越大，越靠近白色；$I$越小，越靠近黑色</li></ul><h4 id="01-2-3-HSI与RGB之间的转换">01.2.3.HSI与RGB之间的转换</h4><ol><li>求色调$H$<ul><li>$\theta=\arccos(\dfrac{[(R-G)+(R-B)]}{2\sqrt{(R-G)^2+(R-B)(G-B)}})$</li><li>$H=\begin{cases}\theta&amp;G\geq B\\2\pi-\theta&amp;G&lt;B\end{cases}$</li></ul></li><li>求饱和度$S$<ul><li>$S=1-\dfrac{3min(R,G,B)}{R+G+B}$</li></ul></li><li>求亮度$I$<ul><li>$I=\dfrac{R+G+B}{3}$</li></ul></li></ol><h3 id="01-3-HSV">01.3.HSV</h3><h4 id="01-3-1-HSV">01.3.1.HSV</h4><ul><li>与HSI类似，只是计算亮度的方式不同</li><li>V：Value，表示颜色的亮度</li></ul><h4 id="01-3-2-HSV与RGB之间的转换">01.3.2.HSV与RGB之间的转换</h4><ul><li>$V=\dfrac{max(R,G,B)}{255}$</li></ul><h3 id="01-4-YUV">01.4.YUV</h3><h4 id="01-4-1-YUV">01.4.1.YUV</h4><ul><li>欧洲电视系统所采用的一种颜色编码</li><li>Y：亮度信号；U、V：色差信号</li></ul><h4 id="01-4-2-YUV与RGB之间的转换">01.4.2.YUV与RGB之间的转换</h4><ul><li>$Y=0.299R+0.587G+0.114B$</li><li>$U=-0.147R-0.289G+0.436B$</li><li>$V=0.615R-0.515G-0.100B$</li></ul><h4 id="01-4-3-YUV的优点">01.4.3.YUV的优点</h4><ul><li>采用YUV色彩空间，可以将亮度信号和色度信号分开处理，使得黑白电视机也能接收彩色信号</li><li>与RGB相比，最大的优点在于只需要占用极少的带宽，适合于传输和存储</li></ul><h3 id="01-5-YCbCr">01.5.YCbCr</h3><h4 id="01-5-1-YCbCr">01.5.1.YCbCr</h4><ul><li>DVD、DV摄像机、数字电视等消费类视频产品中广泛使用的一种颜色编码</li><li>Y：亮度信号；Cb：蓝色与参考值的差；Cr：红色与参考值的差</li></ul><h4 id="01-5-2-YCbCr与RGB之间的转换">01.5.2.YCbCr与RGB之间的转换</h4><p>$$<br>\begin{bmatrix} Y\\Cb\\Cr\end{bmatrix}=\begin{bmatrix}16\\128\\128\end{bmatrix}+\begin{bmatrix}0.257&amp;0.504&amp;0.098\\-0.148&amp;-0.291&amp;0.439\\0.439&amp;-0.368&amp;-0.071\end{bmatrix}\begin{bmatrix}R\\G\\B\end{bmatrix}<br>$$</p><h4 id="01-5-3-YCbCr与YUV的对比">01.5.3.YCbCr与YUV的对比</h4><ul><li>YUV：适合于模拟电视系统</li><li>YCbCr：适合于数字系统</li></ul><h3 id="01-6-彩色图像增强">01.6.彩色图像增强</h3><ol><li>单分量变化，亮度增强</li><li>单分量变化，饱和度增强</li><li>每个像素看作向量，以向量方式处理</li></ol><h2 id="零二、图像特征与理解">零二、图像特征与理解</h2><h3 id="02-1-边界表示：链码">02.1.边界表示：链码</h3><h4 id="02-1-1-链码">02.1.1.链码</h4><ul><li>用一组数字序列来表示边界的形状</li><li>以右向为0，顺时针方向为正方向，为每个方向编码。分为：4方向链码、8方向链码</li><li>从边界最左上角的像素开始，按照逆时针方向，将边界上的像素点用链码表示</li><li>链码是一个循环序列</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/12.png" alt="链码"></p><ul><li>上图的链码<ul><li>4方向链码：$00333332322121110101$</li><li>8方向链码：$07666553321202$</li></ul></li></ul><h4 id="02-1-2-链码归一化">02.1.2.链码归一化</h4><p>对链码进行循环右移，直到链码的字典序最小</p><h4 id="02-1-3-链码一阶差分">02.1.3.链码一阶差分</h4><p>对链码进行模下差分，即$x_i=(x_i-x_{i-1}+n)\mod n$（n为链码的方向数）</p><h3 id="02-2-二值图像的几何特征">02.2.二值图像的几何特征</h3><h4 id="02-2-1-位置">02.2.1.位置</h4><p>一般以物体面积的重心表示物体的位置<br>$$<br>\begin{cases}<br>x_c=\dfrac{1}{N}\sum\limits_{i=1}^N x_i\\\\<br>y_c=\dfrac{1}{N}\sum\limits_{i=1}^N y_i<br>\end{cases}<br>$$</p><h4 id="02-2-2-方向">02.2.2.方向</h4><ul><li>物体的方向：物体的主轴方向</li><li>确定主轴：（旋转）寻找最小外接矩形，主轴与矩形的长边平行</li></ul><h4 id="02-2-3-面积">02.2.3.面积</h4><p>物体的像素个数</p><h4 id="02-2-4-周长">02.2.4.周长</h4><ol><li>链码计算：$C=n_0+\sqrt{2}n_1$（$n_0$为偶数方向的个数，$n_1$为奇数方向的个数）</li><li>边界所占面积</li><li>边界的长度</li></ol><h4 id="02-2-5-形状">02.2.5.形状</h4><ol><li>矩形度：$R=\dfrac{A}{A_r}$（$A$为物体面积，$A_r$为最小外接矩形的面积）</li><li>宽长比：$W=\dfrac{W_r}{L_r}$（$W_r$为最小外接矩形的宽度，$L_r$为最小外接矩形的长度）</li><li>圆形度<ol><li>周长平方与面积的比值：$\dfrac{C^2}{A}$</li><li>面积与平均半径的比值：$\dfrac{A}{\bar{r}^2}$</li></ol></li><li>偏心率</li></ol><h3 id="02-3-形状描述子">02.3.形状描述子</h3><ul><li>傅里叶描述子</li><li>边界链码</li><li>微分链码</li></ul><h3 id="02-4-矩描述">02.4.矩描述</h3><h3 id="02-5-纹理分析：灰度共生矩阵">02.5.纹理分析：灰度共生矩阵</h3><p><img src="https://source.cclmsy.cc/Posts/Course/digital_image_processing/13.png" alt="纹理分析"></p><ul><li>数组合数量</li></ul><h2 id="考试重点">考试重点</h2><ul><li><a href="#3-2-%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE">3.2 灰度直方图</a></li><li><a href="#4-2-%E5%9F%BA%E4%BA%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95">4.2 基于直方图的图像增强方法</a><ul><li>直方图均衡化</li></ul></li><li><a href="#4-3-%E5%9F%BA%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%B9%B3%E6%BB%91%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95">4.3 基于空间平滑滤波的图像增强方法</a></li><li><a href="#4-4-%E5%9F%BA%E4%BA%8E%E7%A9%BA%E9%97%B4%E9%94%90%E5%8C%96%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95">4.4 基于空间锐化滤波的图像增强方法</a></li><li><a href="#5-1-2D-DFT">5.1 2D-DFT</a><ul><li>2D-DFT的性质</li><li>图像的傅里叶频谱图特性分析</li></ul></li><li><a href="#7-1-DCT">7.1 DCT</a></li><li><a href="#7-3-%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81">7.3 图像压缩编码</a><ul><li>Huffman编码</li></ul></li><li><a href="#7-4-%E4%BD%8D%E5%B9%B3%E9%9D%A2%E7%BC%96%E7%A0%81">7.4 位平面编码</a></li><li><a href="#9-3-%E5%9F%BA%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95">9.3 基于阈值的图像分割</a></li><li><a href="#9-5-%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95">9.5 基于区域的图像分割</a></li><li><a href="#12-1-%E4%BA%8C%E5%80%BC%E5%BD%A2%E6%80%81%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97">12.1 二值形态学的基本运算</a></li><li><a href="#12-2-%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F%E7%9A%84%E5%BD%A2%E6%80%81%E5%AD%A6%E5%A4%84%E7%90%86">12.2 二值图像的形态学处理</a></li></ul><h2 id="cv2-np">cv2/np</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(filename, flag) <span class="comment"># 读取图像</span></span><br><span class="line"><span class="comment">## filename: str 图像文件名 &quot;lenna.jpg&quot;</span></span><br><span class="line"><span class="comment">## flag: int cv2.IMREAD_COLOR（默认彩色）、cv2.IMREAD_GRAYSCALE（灰度）</span></span><br><span class="line">img[:,:,] <span class="comment"># 行切片、列切片、通道（BGR）</span></span><br><span class="line">b,g,r = cv2.split(img) <span class="comment"># 分离通道 </span></span><br><span class="line">img_rgb = cv2.merge([r,g,b]) <span class="comment"># 合并通道</span></span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) <span class="comment"># 转换为灰度图</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;image&quot;</span>, img) <span class="comment"># 显示图像 </span></span><br><span class="line">cv2.waitKey() <span class="comment"># 等待键盘输入</span></span><br><span class="line">cv2.destroyAllWindows() <span class="comment"># 关闭所有窗口</span></span><br><span class="line"><span class="comment">## 求反色：255-原像素值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>,<span class="number">600</span>):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>,<span class="number">600</span>):</span><br><span class="line">         img[i,j] = [<span class="number">255</span>-img[i,j][<span class="number">0</span>],<span class="number">255</span>-img[i,j][<span class="number">1</span>],<span class="number">255</span>-img[i,j][<span class="number">2</span>]] </span><br><span class="line">img_cat = cv2.hconcat([r,g,b]) <span class="comment"># 从左到右水平拼接图像</span></span><br></pre></td></tr></table></figure><h2 id="plt">plt</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">221</span>) <span class="comment"># 2行2列，第1个图</span></span><br><span class="line">plt.imshow(img) <span class="comment"># 显示图像</span></span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>) <span class="comment"># 图像标题</span></span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment"># 关闭坐标轴</span></span><br><span class="line"></span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>//<span class="number">8</span>], [<span class="number">0</span>, <span class="number">256</span>]) </span><br><span class="line">plt.subplot(<span class="number">222</span>) <span class="comment"># 2行2列，第2个图</span></span><br><span class="line">plt.plot(hist) <span class="comment"># 绘制hist折线图（坐标0-31）</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">223</span>) <span class="comment"># 2行2列，第3个图</span></span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>//<span class="number">8</span>, [<span class="number">0</span>, <span class="number">256</span>]) <span class="comment"># 绘制binwidth=8的直方图（坐标0-255）</span></span><br><span class="line"><span class="comment">## img.ravel()：将图像转换为一维数组</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组成原理》课程笔记</title>
      <link href="/posts/computer_composition_principle.html"/>
      <url>/posts/computer_composition_principle.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、计算机系统概论">一、计算机系统概论</h2><h3 id="1-1-计算机系统简介">1.1 计算机系统简介</h3><h4 id="1-1-1-计算机系统的组成">1.1.1 计算机系统的组成</h4><ol><li>计算机由<strong>硬件</strong>与<strong>软件</strong>两部分组成</li><li>软件分为<strong>系统软件</strong>与<strong>应用软件</strong>两大类<ul><li>系统软件：管理整个计算机系统</li><li>应用软件：根据任务需要编制的程序</li></ul></li></ol><h4 id="1-1-2-计算机系统的层次结构">1.1.2 计算机系统的层次结构</h4><table><thead><tr><th>层次</th><th>说明</th></tr></thead><tbody><tr><td>应用层</td><td>用户直接使用的软件</td></tr><tr><td>高级语言机器$M_4$</td><td>高级语言编译成汇编语言</td></tr><tr><td>汇编语言机器$M_3$</td><td>汇编语言汇编成机器语言</td></tr><tr><td>操作系统机器$M_2$</td><td>用机器语言解释操作系统</td></tr><tr><td>机器语言机器$M_1$</td><td>用微程序解释机器指令</td></tr><tr><td>微程序机器$M_0$</td><td>用硬件直接执行微指令</td></tr></tbody></table><p>虚拟机器：$M_4$、$M_3$、$M_2$；实际机器：$M_1$；微程序机器：$M_0$</p><ul><li>机器语言、汇编语言、高级语言的区别<ul><li>机器语言是一种用二进制代码表示的计算机语言，机器可以直接执行用机器语言编写的程序。</li><li>汇编语言是一种用助记符表示的与机器语言一一对应的语言，用汇编语言编写的程序需经过汇编后才能执行。</li><li>高级语言是一种接近人类自然语言的与计算机结构无关的语言，用高级语言编写的程序要经过解释和编译才能执行。</li></ul></li></ul><h3 id="1-2-计算机的基本组成">1.2 计算机的基本组成</h3><h4 id="1-2-1-冯·诺依曼计算机的特点">1.2.1 冯·诺依曼计算机的特点</h4><ol><li>核心特征：存储程序的工作方式</li><li>计算机由五大功能部件组成：运算器、控制器、存储器、输入设备、输出设备<ul><li>运算器：完成算术运算和逻辑运算</li><li>控制器：控制程序的执行</li><li>存储器：存放指令和数据</li><li>输入输出设备：与外部环境交换信息</li></ul></li><li>指令和数据用二进制代码表示<ul><li>原因：<ol><li>二进制编码的运算规则简单</li><li>制造2个稳定状态的物理器件较容易</li><li>便于使用逻辑电路实现算术运算</li></ol></li></ul></li><li>工作原理：存储程序、程序控制<ul><li>存储程序程序控制方式：事先编写程序，再由计算机把这些程序存储起来，然后连续地、快速地执行程序，从而完成各种运算过程。</li><li>根据存储程序原理，计算机具有五大功能：数据传送、数据存储、数据处理、操作控制、操作判断</li></ul></li><li>基本工作方式：控制流驱动方式</li><li>指令和数据以同等地位存放在存储器中，可按地址寻访</li><li>指令由操作码和地址码组成</li><li>以运算器为中心</li></ol><h4 id="1-2-2-计算机的硬件框图">1.2.2 计算机的硬件框图</h4><p>改进：以存储器为核心<br><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/02.png" alt="冯·诺依曼计算机结构VS以存储器为中心的体系结构"><br>（实线：数据传输；虚线：指令传输）<br><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/01.png" alt="冯·诺依曼体系结构VS哈弗体系结构"></p><h3 id="1-3-计算机硬件的主要技术指标">1.3 计算机硬件的主要技术指标</h3><h4 id="1-3-1-字长">1.3.1 字长</h4><ul><li>机器字长：计算机一次能处理的二进制数的位数，通常与CPU的寄存器位数有关。等于ALU位数，直接影响数据总线和存储字长的位数</li><li>指令字长：计算机指令中二进制代码的总位数。</li><li>存储字长：存储器的一个存储单元中能存放的二进制数的位数。</li><li>三者可以相当也可以不等，视不同机器而定。</li></ul><h4 id="1-3-2-存储容量">1.3.2 存储容量</h4><ul><li>存储容量：计算机存储器中能存放的二进制数的位数</li><li>存储容量 = 主存+辅存 = 存储单元数×存储字长 （/8（字节））</li></ul><h4 id="1-3-3-存储器带宽">1.3.3 存储器带宽</h4><ul><li>存储器带宽：存储器的数据传输速率</li><li>存储器带宽=存储字数/存储周期（字/秒）</li><li>存储字长（字长）：一个存储单元中存放的二进制数的位数</li><li>字节：8位二进制数</li></ul><h4 id="1-3-4-运算速度">1.3.4 运算速度</h4><ol><li>CPI（Cycle Per Instruction）：每条指令的平均时钟周期数<ul><li>$CPI = CPU时钟周期数 \div 指令数（加权平均）$</li><li>注意平均指令周期（时间）与CPI（时钟周期数）的区别</li></ul></li><li>MIPS（Million Instructions Per Second）：每秒执行的百万条指令数<ul><li>$MIPS = \dfrac{指令条数N}{执行时间t×10^6} = \dfrac{主频f}{CPI\times 10^6}$</li></ul></li><li>主频f：CPU时钟频率；时钟周期T：CPU时钟周期</li><li>执行时间t：执行一组指令所需的时间<ul><li>$t = \dfrac{指令条数N\times CPI}{主频f}$ = $\dfrac{指令条数N}{MIPS\times 10^6}$</li></ul></li><li>每秒浮点运算次数：FLOPS（Floating Point Operations Per Second）</li></ol><h2 id="二、计算机发展史（了解）">二、计算机发展史（了解）</h2><h2 id="三、系统总线">三、系统总线</h2><h3 id="3-1-总线的基本概念">3.1 总线的基本概念</h3><h4 id="3-1-1-总线的作用">3.1.1 总线的作用</h4><ul><li>总线：连接各个部件的信息传输线，各个部件共享的传输介质</li><li>提供信息交换时所需的数据、地址、时序和控制信息</li><li>提供一个共同遵循的协议或标准</li></ul><h3 id="3-2-总线的分类（按连接部件）">3.2 总线的分类（按连接部件）</h3><ol><li>片内总线：CPU内部的总线</li><li>系统总线：CPU与其他部件之间的总线<ul><li>根据传输的信息划分：数据总线、地址总线、控制总线</li><li>数据总线：双向，位数与机器字长相关</li><li>地址总线：单向，位数与存储单元个数相关</li><li>控制总线：双向，传输控制信息</li></ul></li><li>通信总线：连接计算机与其它系统的总线</li></ol><h3 id="3-3-总线的特性与性能指标">3.3 总线的特性与性能指标</h3><h4 id="3-3-1-总线的特性">3.3.1 总线的特性</h4><ol><li>机械特性（物理特性）：总线的物理连接方式（根数、插口形状）</li><li>电气特性：传输方向、有效电平范围</li><li>功能特性：根据传输的信息划分（数据、地址、控制）</li><li>时间特性：同步、异步、功能复用</li></ol><h4 id="3-3-2-总线的性能指标">3.3.2 总线的性能指标</h4><ol><li>总线宽度：数据总线的位数</li><li>总线带宽：单位时间内传输的数据量（Bps：字节/秒）</li><li>总线时钟频率：总线的工作频率</li><li>总线复用</li><li>信号线数量</li><li>总线控制方式</li></ol><h3 id="3-4-总线结构">3.4 总线结构</h3><h4 id="3-4-1-总线事务">3.4.1 总线事务</h4><ol><li>总线事务：从请求总线到完成总线使用的操作序列</li><li>典型事务：存储器R/W，I/O-R/W，中断请求，DMA请求</li><li>典型事务操作：请求、仲裁、地址传输、数据传输、总线释放</li></ol><h4 id="3-4-2-单总线结构">3.4.2 单总线结构</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/25.png" alt="单总线结构"></p><ul><li>结构简单、使用方便、易扩充</li><li>统一编址、简化指令系统、存储空间减少</li><li>共享总线、分时使用、通讯速度慢</li><li>高速设备的高速性能得不到发挥</li></ul><h4 id="3-4-3-双总线结构1：增加CPU-主存的存储总线">3.4.3 双总线结构1：增加CPU-主存的存储总线</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/26.png" alt="双总线结构1"></p><ul><li>存储总线有效的降低了系统总线的负载，提高了并行性能</li><li>需要增加专门的I/O指令，存储空间增加</li><li>结构简单、易扩充</li></ul><h4 id="3-4-4-双总线结构2：增加I-O总线">3.4.4 双总线结构2：增加I/O总线</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/27.png" alt="双总线结构2"></p><h4 id="3-4-5-三总线结构">3.4.5 三总线结构</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/28.png" alt="三总线结构"></p><ul><li>高速与低速传输活动分离<ul><li>I/O设备与主存之间的通信和CPU活动分离</li><li>高速设备靠近CPU，低速设备远离CPU</li></ul></li><li>不同层次的总线之间采用桥接方式连接和缓冲</li></ul><h4 id="3-4-6-总线结构与设备性能之间的关系">3.4.6 总线结构与设备性能之间的关系</h4><ul><li>最大存储容量：单总线系统中，内存要为外部设备预留地址</li><li>指令系统：单总线结构无需专门的I/O指令</li><li>吞吐率：三总线系统比单总线系统大得多</li></ul><h4 id="3-4-7-采用南北桥结构的奔腾机系统总线结构">3.4.7 采用南北桥结构的奔腾机系统总线结构</h4><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/29.png" alt="南北桥结构"></p><ul><li>北桥靠近CPU，连接高速设备：主存、图形设备、CPU</li><li>南桥连接低速设备：I/O设备、硬盘、USB、网卡</li><li>南北桥之间通过PCI总线连接</li></ul><h3 id="3-5-总线控制">3.5 总线控制</h3><h4 id="3-5-1-信息传送方式">3.5.1 信息传送方式</h4><ol><li>串行传送<ul><li>位信息从低到高在一条传输线上逐位以脉冲方式传送</li><li>成本低、速度慢、传输距离远</li></ul></li><li>并行传送<ul><li>每位一条数据线，同时传送多位信息</li><li>速度快、传输距离短</li></ul></li><li>分时传送<ul><li>采用总线复用技术，地址数据共用</li><li>分时使用总线</li></ul></li></ol><h4 id="3-5-2-总线判优控制（总线仲裁）">3.5.2 总线判优控制（总线仲裁）</h4><ul><li>总线仲裁：多个设备同时请求总线时，由总线控制器判定哪个设备优先使用总线</li><li>根据总线控制部件的位置，仲裁方式分为两类：集中式、分布式</li></ul><table><thead><tr><th>集中式仲裁</th><th>链式查询方式</th><th>计数器定时查询方式</th><th>独立请求方式</th></tr></thead><tbody><tr><td>控制线</td><td>3根：总线状态BS，总线请求BR，总线授权BG</td><td>$2+log_2n$根：总线状态BS，总线请求BR，地址计数线（$log_2n$根）</td><td>$2n$根：总线请求BR（$n$根），总线授权BG（$n$根）</td></tr><tr><td>响应速度</td><td>慢</td><td>慢</td><td>快</td></tr><tr><td>优先级</td><td>固定</td><td>可适当变化</td><td>可灵活调整</td></tr><tr><td>故障敏感性</td><td>敏感</td><td>不敏感</td><td>不敏感</td></tr><tr><td>扩展性</td><td>容易</td><td>困难</td><td>容易</td></tr></tbody></table><h4 id="3-5-3-总线定时">3.5.3 总线定时</h4><ul><li>总线定时主要解决通信双方如何获知传输开始和传输结束，通信双方如何配合的问题</li><li>同步方式：用公共时钟信号对传输过程的每一步进行控制，适合快速设备<ul><li>无应答方式</li><li>事件时刻由总线时钟信号决定，采用公共时钟，数据传输率高</li><li>木桶效应：必须按照最慢的设备定时</li></ul></li><li>异步方式：用应答信号对传输过程进行控制。又分为非互锁、半互锁和全互锁；适合慢速设备<ul><li>不互锁<ul><li>主模块：发出请求一段时间，认为副模块收到请求，撤销请求并通信</li></ul></li><li>半互锁<ul><li>主模块：发出请求，收到副模块应答后撤销请求并通信</li><li>副模块：收到请求后应答一段时间，认为主模块收到应答，撤销应答并通信</li></ul></li><li>全互锁<ul><li>主模块：发出请求，收到副模块应答后撤销请求并通信</li><li>副模块：收到请求后应答，收到主模块撤销请求后撤销应答并通信</li></ul></li></ul></li><li>半同步方式：结合同步方式和异步方式的特点，在同步时钟的控制下进行采样和应答</li><li>分离式通信</li></ul><h3 id="3-5-4-总线通讯控制-总线传输过程">3.5.4 总线通讯控制/总线传输过程</h3><ol><li>总线申请（总线仲裁）：部件提出请求，总线控制器确定将下一个总线使用权分配给谁</li><li>地址阶段（总线寻址）：主设备通过总线发出从部件的存储器地址或I/O端口地址及相关命令，启动从设备</li><li>数据传输阶段</li><li>结束阶段：主部件撤消总线请求等有关信息，总线控制器释放总线</li></ol><h3 id="3-6-例题">3.6 例题</h3><ol><li>假定某总线的时钟周期为50ns,每次总线传输需要1个时钟周期，总线宽度为32位，存储器的存储周期为300ns,求同步方式下从该存储器中读一个字时总线的数据传输率为多少?<ul><li>同步方式下按顺序进行以下步骤：<ol><li>送地址和读命令：1个总线周期 = 50ns</li><li>存储器读数据：300ns</li><li>总线传输数据：1个总线周期 = 50ns</li></ol></li><li>一个字的总时间：$50+300+50=400ns$</li><li>数据传输率：$32bit/8/400ns=10MBps$</li></ul></li><li>系统总线传输的信息类型为：数据、地址、控制信号<ul><li>握手应答信号是通信总线传输的信息类型！</li></ul></li><li>提高同步总线数据传输速率的方法<ol><li>增加总线宽度</li><li>增加总线时钟频率</li><li>支持突发传输</li></ol><ul><li>地址/数据线复用不能提高数据传输速率</li></ul></li><li>主存通过<strong>总线类型</strong>识别地址和数据</li></ol><h2 id="四、存储器">四、存储器</h2><h3 id="4-1-概述">4.1 概述</h3><h4 id="4-1-1-存储器的分类">4.1.1 存储器的分类</h4><ol><li>按存储介质分类<ul><li>半导体存储器（易失性：断电即失）<ul><li>TTL：高速</li><li>MOS：高集成度、低功耗、低成本、应用广泛</li></ul></li><li>磁表面存储器：磁头+磁载体</li><li>磁芯存储器：体积大、功耗大、工艺复杂</li><li>激光存储器：CD、DVD</li></ul></li><li>按存取方式分类<ul><li>物理地址和存取时间无关（随机访问）<ul><li>随机存储器（RAM） 可读可写<ul><li>SRAM（静态RAM）：速度快、价格高、集成度低</li><li>DRAM（动态RAM）：速度慢、价格低、集成度高</li></ul></li><li>只读存储器（ROM）<ul><li>M：Masked（掩模）；P：Programmable（可编程）；E：Erasable（可擦写）；EE：Electrically-Erasable（电可擦写）</li></ul></li></ul></li><li>物理地址和存取时间有关（串行访问）<ul><li>顺序存储器：磁带</li><li>直接存储器：磁盘</li></ul></li></ul></li><li>按在计算机中的作用分类</li></ol><p>$$<br>存储器\begin{cases}<br>主存\begin{cases}<br>随机存储器（RAM）\begin{cases}<br>SRAM \\<br>DRAM<br>\end{cases} \\<br>只读存储器（ROM）\begin{cases}<br>MROM\\<br>PROM\\<br>EPROM\\<br>EEPROM<br>\end{cases}<br>\end{cases}\\<br>闪速存储器（Flash Memory）\\<br>辅助存储器\begin{cases}<br>磁盘\\<br>磁带\\<br>光盘<br>\end{cases}\\<br>缓存（Cache）<br>\end{cases}<br>$$</p><h4 id="4-1-2-存储器的层次结构">4.1.2 存储器的层次结构</h4><ol><li>存储系统的层次结构（自上到下从内到外）<ul><li>CPU寄存器</li><li>缓存Cache（SRAM）（内存）</li><li>主存储器（DRAM） （内存）</li><li>磁盘 （辅助存储器）</li><li>磁带、光盘 （辅助存储器）</li></ul></li><li>存储器的主要特性（自上到下）<ul><li>速度：快 -&gt; 慢<ul><li>存储时间、存取周期、存储带宽</li></ul></li><li>容量：小 -&gt; 大</li><li>价格：贵 -&gt; 便宜</li></ul></li><li>存储器的层次结构的作<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/03.png" alt="存储器的层次结构"></li><li>缓存-主存层次：解决CPU与主存之间速度不匹配的问题<ul><li>透明：对系统程序员和应用程序员屏蔽</li><li>主存储器、实地址、物理地址</li></ul></li><li>主存-辅存层次：解决存储系统的容量问题<ul><li>不透明：系统程序员可以对此层次进行修改</li><li>虚拟存储器、虚地址、逻辑地址</li></ul></li></ul></li><li>存储系统为什么采用分层体系结构？<ul><li>采用层次化存储体系的目的包括两方面：其一是解决快速的CPU和慢速的主存之间的速度差异；其二是解决主存容量不够大的问题。存储系统的分级结构由Cache、主存和辅助存储器三级结构构成。其理论基础是时间局部性原理和空间局部性原理，Cache—主存存储层次解决了主存速度不快的问题；而主存-辅存存储层次解决了主存容量不足的问题。</li></ul></li></ol><h3 id="4-2-主存储器">4.2 主存储器</h3><h4 id="4-2-1-概述">4.2.1 概述</h4><ol><li><p>主存的基本组成</p><ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/05.png" alt="主存的基本组成"></li><li>存储体：存储数据</li><li>MAR：存储器地址寄存器，保存要访问的存储单元地址<ul><li>经过译码器进行译码，选定存储单元</li></ul></li><li>MDR：存储器数据寄存器，存储要写入或读出的数据<ul><li>通过读写电路和控制电路控制数据的读写</li></ul></li></ul></li><li><p>主存中存储单位地址分配方式</p><ul><li>子地址+字节地址</li><li>大端存储（大尾存储）：<code>0x12345678</code>存储为<code>12 34 56 78</code></li><li>小端存储（小尾存储）：<code>0x12345678</code>存储为<code>78 56 34 12</code></li><li>（小格中顺序正常，大格中顺序颠倒） 小端存储例：x86</li><li>n根地址线可按字节寻址$2^n$个字节（按字寻址按比例计算）</li></ul></li><li><p>主存中的数据组织和边界对齐</p><ul><li>寄巧：每种数据类型的数据存储在存储器中的<strong>起始地址</strong>必须是该数据所占字节数的<strong>整数倍</strong></li></ul></li><li><p>主存储器的技术指标</p><ol><li>字长：一个存储单元存放的二进制数的位数</li><li>存储容量：存储器中能存放的二进制数的总位数<ul><li>存储容量=存储单元数×存储字长（位）/8（字节）</li></ul></li><li>存储速度：由存取周期表示<ul><li>存取周期：连续2次存取所需的最小时间间隔</li><li>分为读周期和写周期</li></ul></li><li>存储器带宽=存储字数/存储周期（字/秒）=(存储字数*存储字长)/8/存储周期（字节/秒）</li></ol></li></ol><h4 id="4-2-2-半导体存储芯片">4.2.2 半导体存储芯片</h4><ol><li>基本结构与芯片容量<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/13.png" alt="半导体存储芯片"></li><li>例：地址线10位；数据线8位</li><li>存储单元：$2^{10}$个；存储字长：8位；芯片容量：$2^{10}\times 8=1K*8位=8Kbit=1KB$</li><li>片选线CS/CE：选择芯片Chip Select/Enable</li><li>读写控制线WE/OE：读写控制Write/Output Enable</li></ul></li><li>译码驱动方式<ul><li>单译码结构：$n$位地址输入，经$n$位译码器译码，指向$2^n$个存储单元</li><li>双译码结构：将存储芯片阵列，分为行译码和列译码，指向$2^{2n}$个存储单元<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/04.png" alt="静态存储器芯片结构"></li><li>地址译码器：将二进制地址译码为存储单元的物理地址（类比3-8线译码器）</li><li>Y向驱动器：将地址译码后的列地址送到存储矩阵的列选择线</li></ul></li></ul></li></ol><h4 id="4-2-3-随机存取存储器（RAM）">4.2.3 随机存取存储器（RAM）</h4><ol><li>SRAM（静态RAM）<ol><li>存储原理：触发器<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/06.png" alt="SRAM存储单元"></li><li>中心与GND相连的T1, T2：存储数据</li><li>中心与VCC相连的T3, T4：补充电荷</li><li>外侧的T5-T8：T5、T6行选，T7、T8列选</li></ul></li><li>SRAM芯片（以Intel 2114为例）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/14.png" alt="SRAM芯片"></li><li>地址线：$A_{9-0}$，地址数=$2^{10}$个</li><li>数据线：$I/O_{3-0}$，数据位数=$4$位</li><li>芯片存储容量=$2^{10}\times 4bit=1K\times 4bit$</li></ul></li><li>SRAM的不足<ul><li>晶体管数量多，集成度低，功耗大</li></ul></li></ol></li><li>DRAM（动态RAM）<ol><li>分单管式和三管式，存储原理：电容</li><li>DRAM的优点<ul><li>存储密度高，集成度高，功耗低</li><li>速度慢，需要刷新</li></ul></li><li>DRAM刷新<ol><li>刷新：DRAM存储单元中的电荷会逐渐泄漏，需要定期刷新补充</li><li>刷新周期：存储器两次完整刷新之间的时间间隔</li><li>刷新方式：集中式、分散式、异步式（假设刷新周期为2ms）<ul><li>集中式<ul><li>一个刷新间隔（2ms）：|-----R/W/维持-----|—集中刷新n行—|</li><li>在数据丢失之前集中刷新所有行</li><li>保持存储单体的高速特性，存在死区（死时间）</li><li>死区=存取周期*刷新行数，死时间率=死区/刷新间隔</li><li>场景：实时性要求不高</li></ul></li><li>分散式<ul><li>一个刷新间隔（小于2ms）：|R/W|刷新第0行|R/W|刷新第1行|…|R/W|刷新第n行|</li><li>存储周期=读写+刷新：各刷新周期分散安排在存取周期中</li><li>过度刷新，通常刷新间隔远小于所需最大刷新间隔，芯片性能下降</li><li><strong>不存在死区</strong></li></ul></li><li>异步式<ul><li>一个刷新间隔（2ms）：|R/W|R/W|…|R/W|刷新第0行|R/W|R/W|…|R/W|刷新第n行|</li><li>每行每隔一定时间/多次读写后刷新一次，（平均）分散在一个刷新间隔的任意部分</li><li>存在死区，但可以将刷新安排在指令译码阶段</li></ul></li></ul></li></ol></li></ol></li><li>SRAM与DRAM的比较</li></ol><table><thead><tr><th></th><th>SRAM</th><th>DRAM</th></tr></thead><tbody><tr><td>存储原理</td><td>触发器</td><td>电容</td></tr><tr><td>集成度</td><td>低</td><td>高</td></tr><tr><td>刷新</td><td>不需要</td><td>需要</td></tr><tr><td>存储成本（功耗）</td><td>高</td><td>低</td></tr><tr><td>速度</td><td>快（无需重写）</td><td>慢（需重写）</td></tr><tr><td>破坏性读出</td><td>非</td><td>是</td></tr><tr><td>送行列地址</td><td>同时</td><td>分2次</td></tr><tr><td>主要用途</td><td>Cache高速缓存</td><td>主存</td></tr></tbody></table><h4 id="4-2-4-只读存储器（ROM）">4.2.4 只读存储器（ROM）</h4><p>MROM：Masked（掩模）<br>PROM：Programmable（可编程）<br>EPROM：Erasable P（可擦写可编程）<br>EEPROM：Electrically-Erasable P（电可擦写可编程）<br>Flash Memory：闪速存储器</p><h4 id="4-2-5-主存与CPU的连接方式（不考察）">4.2.5 主存与CPU的连接方式（不考察）</h4><ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/07.png" alt="主存与CPU的连接方式"></li><li>$MREQ(存储器请求)\Rightarrow CS(片选线)$</li><li>$A_{17-0}(地址线)\Rightarrow A$：存储单元数=$2^{18-10} K$个</li><li>$R/W(读写控制)\Rightarrow WE(写使能)$</li><li>$D_{31-0}(数据线)\Rightarrow D$：数据位数=$32$位</li></ul><h4 id="4-2-6-存储器容量扩展（不考察）">4.2.6 存储器容量扩展（不考察）</h4><ul><li>位扩展（DBUS）：增加存储字长<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/08.png" alt="位扩展"></li><li>方法：<ul><li>MREQ、A同时连接$n$个芯片</li><li>R/W同时连接所有RAM芯片</li><li>D位数扩展到原来的$n$倍，按顺序分配给每个芯片</li></ul></li><li>特点：<ul><li>从每个芯片内部相同的地址单元中读取数据，同时读写</li><li>位扩展后的存储容量=单元数×（字长×片数）</li></ul></li></ul></li><li>字扩展（ABUS）：增加存储单元数<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/09.png" alt="字扩展"></li><li>方法：<ul><li>D同时连接$n$个芯片</li><li>R/W同时连接所有RAM芯片</li><li>MREQ连接到3-8译码器的OE</li><li>A位数增加$log_2n$，原来的部分与每一片连接，增加的部分分配给3-8译码器</li><li>3-8译码器的输出连接到$n$个芯片的CS（片选）</li></ul></li><li>特点：<ul><li>从单个芯片（组）中的地址单元中读取数据</li><li>字扩展后的存储容量=（单元数×片数）×字长</li></ul></li></ul></li><li>字位综合扩展：同时增加存储单元数和存储字长<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/10.png" alt="字位扩展"></li><li>方法：<ul><li>R/W同时连接所有RAM芯片组</li><li>D位数扩展到原来的$n$倍，连接每个芯片组</li><li>MREQ连接到3-8译码器的OE</li><li>A位数增加$log_2n$，原来的部分与每一片连接，增加的部分分配给3-8译码器</li><li>3-8译码器的输出连接到$n$个芯片的CS（片选）</li></ul></li></ul></li><li>例：存储器容量扩展<ul><li>需求：<ul><li>0x0000到3FFF为ROM存储区域</li><li>0x4000到0x5FFF为保留地址区域</li><li>0x6000到0xFFFF为RAM地址区域</li><li>RAM的控制信号为CS#和WE#，CPU地址线A15~A0，数据线D7~D0，控制信号有读写控制R/W#和访存请求MREQ#</li></ul></li><li>材料：16K×8 ROM 4K×8 RAM</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/11.png" alt="存储器容量扩展"></li><li>注意：<ul><li>译码器一位信号对应两片芯片时，高位地址（$A_{12}$）参与片选</li><li>译码器两位信号对应一片芯片时，信号取或传入片选</li></ul></li><li>不同区域选择芯片类型：<ul><li>系统程序区域：ROM</li><li>保留区域：无需选择</li><li>用户程序区域：RAM</li></ul></li></ul></li></ul><h4 id="4-2-7-优化主存性能的方法">4.2.7 优化主存性能的方法</h4><ol><li>采用高速器件：SDRAM（同步DRAM）</li><li>增加Cache：采用层级结构 Cache-主存 （CDRAM）</li><li>双端口存储器<ul><li>具有两个独立的读写控制线</li><li>地址不冲突时，可并行读写</li></ul></li><li>增加字长、每个存储周期存取多个字：单体多字存储器（位扩展）<ul><li>多个单字长存储器并行工作</li><li>共用一个地址寄存器</li><li>单存储周期内访问多个存储字</li></ul></li><li>将主存分为多个模块，并行存取：多体并行存储器<ul><li>高位交叉、顺序编址（顺序方式）（字扩展）</li><li>低位交叉、轮流编址（交叉方式）<ul><li>流水线式存储：<ul><li>总线传输周期$\tau$，存储周期$T$，交叉模数$m$</li><li>流水线方式存储的条件：$T=m\tau$</li><li>连续传输n个字的时间：$T+(n-1)\tau$</li></ul></li><li>存储体数量：不小于$\dfrac{存储周期}{总线传输周期}$</li></ul></li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/12.png" alt="多模块存储器"></li></ul></li></ol><table><thead><tr><th></th><th>高位交叉</th><th>低位交叉</th></tr></thead><tbody><tr><td>相邻数据地址</td><td>同一存储体</td><td>不同存储体</td></tr><tr><td>地址寄存器</td><td>一个</td><td>每个存储体一个</td></tr><tr><td>局部性原理</td><td>高位片选，多模块串行</td><td>低位片选，多模块并行</td></tr><tr><td>性能</td><td>无提升</td><td>提升</td></tr><tr><td>故障隔离</td><td>方便</td><td>-</td></tr><tr><td>连续读取$n$个字的时间</td><td>$nT$</td><td>$T+(n-1)\tau$</td></tr></tbody></table><h3 id="4-3-高速缓存存储器Cache">4.3 高速缓存存储器Cache</h3><h4 id="4-3-1-概述">4.3.1 概述</h4><ol><li>Cache解决的问题<ul><li>避免CPU“空等”状态</li><li>弥补CPU与主存的速度差异</li></ul></li><li>程序访问的局部性原理<ul><li>时间局部性：刚访问过的数据很可能马上再次访问</li><li>空间局部性：刚访问过的数据附近的数据很可能马上访问</li><li>优化手段：调度算法（时间局部性）；预读优化（空间局部性）</li></ul></li><li>Cache的工作原理<ul><li>主存地址：n位=m位主存块号+b位块内地址（字地址）</li><li>Cache地址：c位Cache块号+b位块内地址（c &lt;&lt; m）</li><li>按块存储，块大小相同</li><li>命中（HIT）：Cache中有所需数据</li><li>缺失（MISS）：Cache中无所需数据，需要从主存中读取</li><li>标记记录某缓存块对应的主存块号</li></ul></li><li>命中率、访问时间、访问效率<ul><li>记$N$为访问次数，$N_c$为命中次数，$N_m$为缺失次数（访问主存次数）；$t_c$为Cache存取时间，$t_m$为主存存取时间</li><li>命中率：$h=\dfrac{N_c}{N}$ / 缺失率：$1-h$</li><li>平均访问时间：$t_{avg}=ht_c+(1-h)t_m$</li><li>访问效率：$E=\dfrac{t_c}{t_{avg}}$</li></ul></li><li>关键技术<ul><li>数据查找、地址映射、替换策略、写入策略</li></ul></li><li>Cache的读操作<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/15.png" alt="Cache的读操作"></li></ul></li><li>Cache的写操作<ul><li>写穿法（Write Through）：写Cache同时写主存<ul><li>优点：维持了主存和Cache的数据一致性</li><li>缺点：写主存次数多，在连续多次更新同一数据时效率低</li></ul></li><li>写回法（Write Back）：只写Cache，标记为脏，被替换时才写回主存<ul><li>优点：减少了写主存次数，提高了效率</li><li>缺点：需要额外的标记位和判断，增加了Cache复杂度</li></ul></li></ul></li><li>Cache的改进<ul><li>增加Cache级数（CPU片内、片外）</li><li>统一Cache（指令、数据共用）和分立Cache（指令、数据分开）</li></ul></li></ol><h4 id="4-3-2-Cache-主存地址映射">4.3.2 Cache-主存地址映射</h4><ol><li>直接映射<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/16.png" alt="直接映射"></li><li>根据Cache块数对主存块号取模，只能存放在对应模数的位置</li><li>主存地址n位=t位标记位+c位Cache块号+b位块内地址（t+c=m）</li></ul></li><li>全相联映射（主存容量大考虑采用）<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/17.png" alt="全相联映射"></li><li>任意主存块可以存放在任意Cache块中</li><li>主存地址n位=m位标记位+b位块内地址</li></ul></li><li>组相联映射<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/18.png" alt="组相联映射"></li><li>组间直接映射，组内全相联映射，先分组</li><li>组数$2^q$，组内Cache块数$2^r$，$q+r=c$</li><li>主存地址n位=(t+r)位标记位+q(c-r)位组号+b位块内地址</li></ul></li></ol><table><thead><tr><th></th><th>直接映射</th><th>全相联映射</th><th>组相联映射</th></tr></thead><tbody><tr><td>冲突</td><td>最容易</td><td>最不容易</td><td>中等</td></tr><tr><td>Cache利用率</td><td>低</td><td>高</td><td>中等</td></tr><tr><td>淘汰算法</td><td>无</td><td>需要</td><td>需要</td></tr></tbody></table><h4 id="4-3-3-Cache的替换策略">4.3.3 Cache的替换策略</h4><ol><li>先进先出（FIFO）<ul><li>优点：易实现、开销小</li><li>缺点：未考虑局部性原理，被替换的数据再次被访问</li></ul></li><li>近期最少使用（Least Recently Used，LRU）<ul><li>优点：减少了被替换的数据再次被访问的概率，提高了命中率</li></ul></li><li>随机法</li></ol><h3 id="4-4-存储器的校验">4.4 存储器的校验</h3><ol><li>概述<ul><li>存储器校验的意义：解决编码在时间、空间上传输可靠性问题；减少基于软件检错的代价</li><li>码距：两个合法码之间的不同位数。<ul><li>码距越大，抗干扰能力、纠错能力越强，数据冗余越大，编码效率越低</li></ul></li><li>检错和纠错：检错位数=码距//2，纠错位数=（码距-1）//2</li></ul></li><li>奇偶校验（以偶校验为例）<ul><li>待传输数据：$D_1D_2D_3D_4D_5D_6D_7D_8$</li><li>校验位：$P=D_1\oplus D_2\oplus D_3\oplus D_4\oplus D_5\oplus D_6\oplus D_7\oplus D_8$（奇校验取反）</li><li>发送与接收的数据：$D_1D_2D_3D_4D_5D_6D_7D_8P$（末尾加校验码）</li><li>检错码：$G=D_1\oplus D_2\oplus D_3\oplus D_4\oplus D_5\oplus D_6\oplus D_7\oplus D_8\oplus P$<ul><li>$G=0$，无错；$G=1$，有错</li></ul></li><li>码距：2</li><li>检1位错，纠0位错</li></ul></li><li>汉明校验<ul><li>待传输数据：$D_n…D_3D_2D_1$</li><li>增加校验位$P$数量：$k$，$2^k\geq n+k+1$ （$n=4$时，$k=3$）</li><li>校验位$P_i$处于$2^{i-1}$位置，即传输数据：$H_{7-1}=D_4D_3D_2P_3D_1P_2P_1$</li><li>校验位$P_i$为位置下标二进制第$i$位为1的数据（除自己外）的异或和。<ul><li>$P_1= H_3\oplus H_5\oplus H_7=D_1\oplus D_2\oplus D_4$</li><li>$P_2= H_3\oplus H_6\oplus H_7=D_1\oplus D_3\oplus D_4$</li><li>$P_3= H_5\oplus H_6\oplus H_7=D_2\oplus D_3\oplus D_4$</li></ul></li><li>检错码$G_i$为位置下标二进制第$i$位为1的数据的异或和。<ul><li>$G_1=H_1\oplus H_3\oplus H_5\oplus H_7=P_1\oplus D_1\oplus D_2\oplus D_4$</li><li>$G_2=H_2\oplus H_3\oplus H_6\oplus H_7=P_2\oplus D_1\oplus D_3\oplus D_4$</li><li>$G_3=H_4\oplus H_5\oplus H_6\oplus H_7=P_3\oplus D_2\oplus D_3\oplus D_4$</li></ul></li><li>每一组数据都是一次偶校验</li><li>检错码的排列$G_3G_2G_1$所示的二进制数表示出错的位置</li><li>码距：3</li><li>检1位错，纠1位错</li><li>实现检2位错<ul><li>开头增加一个总偶校验位$P_4=H_1\oplus H_2\oplus H_3\oplus H_4\oplus H_5\oplus H_6\oplus H_7$</li><li>检错码：$G_4=P_4\oplus H_1\oplus H_2\oplus H_3\oplus H_4\oplus H_5\oplus H_6\oplus H_7$</li></ul></li><li>优点<ul><li>编码效率高：数据增加一倍，校验位增加1位</li><li>可纠正1位错，检错2位错</li></ul></li></ul></li><li>CRC循环冗余校验<ul><li>待传输数据：$1100$</li><li>约定一个$r+1$位二进制数$1011$（r=3）</li><li>将待传输数据左移$r$位，得到$1100|000$</li><li>做模二除法，做减法时做异或，余数首位为1时商上1</li><li>$1100000\div1011=1110\cdots 010$其中余数$010$是校验位</li><li>$1100|000$和余数$010$相加，得到传输数据$D=1100|010$</li><li>接收方将接收到的数据$D$除以约定的数$1011$，余数为0则无错</li></ul></li></ol><h3 id="4-5-辅助存储器-外存储器">4.5 辅助存储器/外存储器</h3><h4 id="4-5-1-概述">4.5.1 概述</h4><ul><li>磁表面存储器、硬盘存储器、光盘存储器</li><li>特点；容量大、速度慢、价格低、长期存储、非破坏性读出</li><li>原理：电磁变换</li></ul><h4 id="4-5-2-磁表面存储器的技术指标">4.5.2 磁表面存储器的技术指标</h4><ol><li>记录密度<ul><li>道密度$D_t(TPI)$</li><li>位密度$D_b(BPI)$</li><li>面密度$D_s=D_t\times D_b$</li></ul></li><li>$圆柱面数N_c=(外径R-内径r)\times F_t$</li><li>$磁道长度l=2\pi r(内径)$</li><li>$存储容量C=l\times D_b\times N_c\times 盘面数$</li><li>$寻址时间/定位时间T_a=寻道时间t_s+等待时间t_w$</li><li>数据传输率$D_r$：单位时间传输的数据量</li><li>误码率：$\dfrac{错误位数}{总位数}$，通常用CRC校验纠正</li></ol><h4 id="4-5-3-硬磁盘存储器">4.5.3 硬磁盘存储器</h4><ol><li>类型<ul><li>固定磁头/移动磁头</li><li>可换盘/固定盘</li></ul></li><li>结构<ul><li>$主机\Leftrightarrow 磁盘控制器\Leftrightarrow 磁盘驱动器\Leftrightarrow 磁盘盘片$</li></ul></li><li>磁盘控制器：主机与磁盘驱动器之间的接口<ul><li>功能：数据传输、数据校验、磁盘调度、磁盘格式化</li></ul></li></ol><h4 id="4-5-4-软盘存储器">4.5.4 软盘存储器</h4><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>快</td><td>慢</td></tr><tr><td>磁头</td><td>固定/活动、浮动</td><td>固定、接触盘片</td></tr><tr><td>盘片</td><td>固定、盘组、大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>工作环境</td><td>苛刻</td><td></td></tr></tbody></table><h4 id="4-5-5-光盘存储器">4.5.5 光盘存储器</h4><ul><li>采用光存储技术，利用激光读写</li><li>第一代：非磁性介质、不可擦写</li><li>第二代：磁性介质、可擦写</li><li>只读型/只写一次型：热作用</li><li>可擦写型：热磁效应</li></ul><h2 id="五、输入输出系统">五、输入输出系统</h2><h3 id="5-1-概述">5.1 概述</h3><h4 id="5-1-1-输入输出系统的发展概况">5.1.1* 输入输出系统的发展概况</h4><ol><li>早期阶段<ul><li>分散连接</li><li>CPU与I/O设备 串行工作</li><li>程序查询方式</li></ul></li><li>接口模块和DMA阶段<ul><li>总线连接</li><li>CPU与I/O设备 并行工作</li><li>中断方式/直接存储器访问（DMA）</li></ul></li><li>具有通道结构的阶段</li><li>具有I/O处理机的阶段</li></ol><h4 id="5-1-2-输入输出系统的组成">5.1.2* 输入输出系统的组成</h4><ol><li>I/O软件<ul><li>I/O指令：CPU指令的部分。 操作码|命令码|设备码<ul><li>操作码：I/O指令的标志，指出该指令是I/O指令</li><li>命令码：指出I/O操作的类型：输入、输出、状态测试、控制</li><li>设备码：指出I/O设备的地址（端口号）</li></ul></li><li>通道指令<ul><li>通道：具有特殊功能的处理器IOP</li><li>指出要传输的字节数、数据地址、操作命令</li></ul></li></ul></li><li>I/O硬件<ul><li>接口方式：设备、I/O接口：设备通过接口连接到总线，和主机进行数据交换</li><li>通道方式：设备、设备控制器、通道</li></ul></li></ol><h4 id="5-1-3-I-O设备与主机的联系方式">5.1.3 I/O设备与主机的联系方式</h4><ol><li>外设分类<ul><li>按功能：输入设备、输出设备</li><li>按速度：低速设备、中速设备、高速设备</li><li>按作用：人机交互设备、外存储器设备、通信设备</li></ul></li><li>I/O设备的编址方式<ul><li>统一编址方式：将I/O设备看作是内存地址的一部分，共用地址空间，指令集相对简单</li><li>不统一编址方式：内存之外专设I/O设备地址空间，有专门的I/O指令集</li></ul></li><li>设备寻址：通过设备选择电路</li><li>传送方式：串行、并行</li><li>联络方式/外围设备定时方式<ul><li>立即响应方式（极慢的设备）</li><li>异步工作采用应答信号联络（慢速和中速设备）</li><li>同步工作采用同步时标联络（高速设备）</li></ul></li><li>I/O设备和主机的连接方式<ul><li>辐射式（分散连接）：每台设备都配有独立的控制电路和信号线</li><li>总线式：便于增删设备</li></ul></li></ol><h3 id="5-2-I-O端口">5.2 I/O端口</h3><ol><li>设置I/O端口的原因<ul><li>外部设备工作的异步性：外部设备工作的时钟和时序与微处理器不同</li><li>速度差异：外部设备的速度远远低于微处理器</li><li>信号线与数据格式不同</li><li>便于外设发展</li></ul></li><li>I/O端口的功能<ul><li>实现数据缓冲</li><li>执行CPU的命令返回外设状态</li><li>设备选择</li><li>数据格式、信号的转换</li><li>中断管理</li></ul></li><li>I/O接口的组成<ul><li>基本电路：寄存器及逻辑控制</li><li>端口地址译码电路</li><li>供选电路：可选器件</li></ul></li></ol><h3 id="5-3-I-O控制方式-信息交换方式-总览">5.3 I/O控制方式 / 信息交换方式 总览</h3><ol><li>程序查询方式<ul><li>$启动设备\Rightarrow 反复查询设备状态直至设备准备好\Rightarrow 传输单个数据\Rightarrow 结束设备$</li><li>信息交换完全由CPU执行程序实现</li><li>串行工作、反复查询、系统效率低</li><li>用于早期计算机系统</li></ul></li><li>程序中断方式<ul><li>$CPU发起指令\Rightarrow 设备准备数据+CPU处理其他进程\Rightarrow 设备准备好数据，向CPU发出中断请求\Rightarrow CPU响应中断$</li><li>主动告知避免反复查询</li><li>仍需CPU占用</li><li>一次中断传输数据少，CPU开销大</li></ul></li><li>直接存储器存取（DMA）方式<ul><li>适用于成组数据传输</li><li>传输阶段DMAC从CPU接管总线，直接在内存及外设之间进行，节约了中断开销</li><li>需要更多硬件</li></ul></li><li>通道方式<ul><li>通道：具有特殊功能的处理器IOP，独立于CPU，分担I/O处理，可实现外设的统一管理和DMA操作</li><li>通道执行通道程序来完成CPU指定的I/O任务，通道程序是由一系列通道指令组成的</li></ul></li></ol><h3 id="5-4-程序中断方式">5.4 程序中断方式</h3><ol><li><p>中断概念</p><ul><li>中断：CPU暂时中止现行程序的执行，转去执行为某个随机事件服务的中断处理子程序，处理完后自动恢复原程序的执行</li><li>作用：实现CPU与I/O设备的并行工作、故障处理等</li></ul></li><li><p>中断的分类</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">中断</span><br><span class="line">├── 内中断（异常）</span><br><span class="line">│   ├── 软件中断</span><br><span class="line">│   └── 异常</span><br><span class="line">│       ├── 故障Fault</span><br><span class="line">│       ├── 陷阱Trap</span><br><span class="line">│       └── 终止Abort</span><br><span class="line">└── 外中断（强迫中断）</span><br><span class="line">   ├── 不可屏蔽中断NMI：由系统内部硬件引发的中断</span><br><span class="line">   └── 可屏蔽中断INTR：由外设通过中断请求线向处理器申请</span><br></pre></td></tr></table></figure></li><li><p>中断系统基本功能</p><ol><li>中断请求的保持和清除：硬件实现</li><li>中断仲裁：多个中断请求同时到达时，确定优先级</li><li>中断源识别：获取中断号（识别中断源）</li><li>中断处理</li><li>中断控制<ul><li>中断触发方式：边沿触发、电平触发</li><li>中断排队方式：优先级高先服务</li></ul></li></ol></li><li><p>单级中断和多级中断</p><ul><li>单级中断：所有中断同级，离CPU近的优先，处理中断时不响应其他中断</li><li>多级中断：优先级高的中断可打断优先级低的中断，中断嵌套</li></ul></li><li><p>优先级划分一般规律</p><ul><li>硬件中断最高，程序错误中断其次</li><li>NMI&gt;INTR</li><li>DMA&gt;I/O</li><li>高速设备&gt;低速设备</li><li>输入设备&gt;输出设备</li><li>实时设备&gt;非实时设备</li></ul></li><li><p>中断屏蔽字与优先级设定</p><ul><li>以A,B,C为例，设定优先级B&gt;C&gt;A</li><li>A：100；B：111；C：101</li><li>0所在的位置表示允许被该位中断</li></ul></li><li><p>缺点</p><ol><li>传输一次数据就要中断一次，CPU开销大</li><li>效率低，不适合高速传输系统</li></ol></li></ol><h3 id="5-5-DMA（直接存储器存取）方式">5.5 DMA（直接存储器存取）方式</h3><ol><li>优点<ul><li>外设与主存间建立一个由硬件管理的数据通路</li><li>CPU不介入外设与主存的数据传输</li><li>减少CPU开销，提高系统效率</li></ul></li><li>内存争用： DMA控制器和CPU可能同时访问内存<ol><li>DMA访内过程中，停止CPU访问内存<ul><li>DMA批量数据传输周期过长，CPU长期无法访内</li><li>外设传送两个数据的时间间隔大于存储周期，内存未充分利用</li></ul></li><li>DMA与CPU交替访问内存<ul><li>每个CPU工作周期分成两段：DMA访内和CPU访内</li><li>无主存使用权移交过程</li></ul></li><li>周期挪用法<ul><li>DMA要求访问主存时，CPU暂停一个或多个存储周期。一个数据传送结束后，CPU继续运行。</li></ul></li></ol></li></ol><h2 id="六、计算机的运算方法">六、计算机的运算方法</h2><h3 id="6-1-无符号数和有符号数">6.1 无符号数和有符号数</h3><h4 id="6-1-1-无符号数">6.1.1 无符号数</h4><p>按照规定的长度（字长）以二进制保存，只有数值部分，没有符号位。</p><h4 id="6-1-2-有符号数">6.1.2 有符号数</h4><ol><li>机器数与真值<ul><li>机器数：计算机内部表示的数</li><li>真值：数的实际值</li><li>四种机器码：原码、反码、补码、移码<ul><li>最高位表示符号：0为正，1为负</li><li>其余位表示数值</li><li>小数的定点表示：原码、反码、补码</li></ul></li></ul></li><li>原码<ul><li>整数：数值位表示小数点前的整数部分</li><li>小数：数值位表示小数点后的小数部分（绝对值小于1）</li><li>特点：<ol><li>有+0(0,000)和-0(1,000)两种0</li><li>加、减运算方式不统一，符号相异不能直接计算</li></ol></li></ul></li><li>反码<ul><li>正数：原码</li><li>负数：其正数原码的各位取反</li><li>特点：<ol><li>有+0(0,000)和-0(1,111)两种0</li><li>运算较复杂</li></ol></li></ul></li><li>补码<ul><li>正数：原码</li><li>负数：反码+1</li><li>特点：<ol><li>0有唯一的表示方式</li><li>加、减运算方式统一</li><li>机器数的唯一表示</li><li>小数可以表示-1(1.000)</li></ol></li><li>补码运算：<ol><li>$[[X]_补]_补=-(-X)=X$</li><li>//2：右移1位，最高位补符号位（正数补0，负数补1）</li><li>*2：左移1位，最低位补0，符号位变化即为溢出</li><li>不同位数加减法：位数少的数，高位补符号位直至位数相同，然后按位加减</li></ol></li></ul></li><li>移码<ul><li>补码的符号位取反</li><li>保持数据原有的大小顺序，便于比较</li><li>仅用于表示整数，通常用于浮点数的阶码</li></ul></li></ol><h3 id="6-2-小数的浮点表示（原码表示）">6.2 小数的浮点表示（原码表示）</h3><ol><li>表示格式<ul><li>$N=S\times r^j$</li><li>S：尾数（小数）；r：基数($2^k$)；j：阶码（二进制表示）</li><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/19.png" alt="浮点数表示"></li><li>$S_f$：浮点数的符号</li><li>$n$：决定浮点数的精度</li><li>$m$：决定浮点数的表示范围</li></ul></li><li>规格化数<ul><li>基数$r=2^k$时</li><li>尾数$S$的最高的$k$位（小数点后$k$位）不全为0</li><li>特别的，$r=2$时，S=0.1xxxxxx</li><li>尾数左右移动$k$位，阶码变化$1$</li></ul></li><li>表示范围<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/20.png" alt="浮点数表示范围"></li><li>尾数$S$：$0,[2^{-n},1-2^{-n}]$</li><li>阶码$j$：$[-2^m+1,2^m-1]$</li><li>表示范围：$[-(1-2^{-n})\times 2^{2^m-1},-(2^{-n})\times 2^{-2^m+1}],0,[2^{-n}\times 2^{-2^m+1},(1-2^{-n})\times 2^{2^m-1}]$</li></ul></li><li>机器0<ul><li>尾数$S=0$的数：x,xxxx;0.0000000000</li><li>阶码小于等于精度（$-2^m+1,-15$）的数：1,0000(-16);x.xxxxxxxxxx</li><li>阶码用移码时，机器$0$为：0,0000;0.0000000000</li></ul></li><li>IEEE754 Standard<ul><li>构成：符号位$m_s$（数符），阶码$E$（含阶符，移码表示，基数为2），尾数$M$（隐去开头的1，原码表示）</li><li>$(-1)^{m_s}\times 1.M\times 2^E$</li><li>偏置值：阶码的移码与原码的差值（$2^{k-1}-1$）</li></ul></li></ol><table><thead><tr><th></th><th>符号位</th><th>阶码</th><th>尾数</th><th>总位数</th></tr></thead><tbody><tr><td>单精度float</td><td>1</td><td>8</td><td>23</td><td>32</td></tr><tr><td>双精度double</td><td>1</td><td>11</td><td>52</td><td>64</td></tr><tr><td>临时实数</td><td>1</td><td>15</td><td>64</td><td>80</td></tr></tbody></table><h3 id="6-3-定点运算">6.3 定点运算</h3><h4 id="6-3-1-移位运算">6.3.1 移位运算</h4><ol><li><p>算术移位与逻辑移位</p><ul><li>算术移位：符号位不变</li><li>逻辑移位：左移右移补0</li></ul></li><li><p>算术移位添补</p><table><thead><tr><th>正负</th><th>码值</th><th>添补</th></tr></thead><tbody><tr><td>+</td><td>原码、反码、补码</td><td>补0</td></tr><tr><td>-</td><td>原码</td><td>补0</td></tr><tr><td>-</td><td>反码</td><td>补1</td></tr><tr><td>-</td><td>补码</td><td>左移补0，右移补1</td></tr></tbody></table></li><li><p>丢失有效位</p><ul><li>左移丢高位：溢出</li><li>右移丢低位：损失精度</li></ul></li></ol><h4 id="6-3-2-加减法运算">6.3.2 加减法运算</h4><ol><li>补码加减运算公式<ol><li>加法：$[A]_补+[B]_补=[A+B]_补$</li><li>减法：$[A]_补-[B]_补=[A+(-B_补)]_补=[A]_补+[-B]_补$</li><li>连同符号位一起相加，溢出位舍去</li><li>真实溢出：正正得负/负负得正</li></ol></li><li>硬件实现<ol><li>串行加法器：逐位相加，进位传递<ol><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/21.png" alt="串行加法器"></li><li>缺点：高位依赖低位，速度慢</li><li>$S_i=X_i\oplus Y_i\oplus C_{i-1}$</li><li>$C_i=X_iY_i+X_iC_{i-1}+Y_iC_{i-1}=X_iY_i+(X_i\oplus Y_i)C_{i-1}$</li></ol></li><li>并行加法器：每一位并行计算<ol><li>原理<ol><li>记：<ul><li>$G_i=X_iY_i$：生成位（Generate）</li><li>$P_i=X_i\oplus Y_i$：传递位（Propagate）</li></ul></li><li>则：<ul><li>$C_i = G_i + P_iC_{i-1}$</li></ul></li><li>传递得到：<ul><li>$C_i = G_i + P_iG_{i-1} + P_iP_{i-1}G_{i-2} + \cdots + P_iP_{i-1}\cdots P_1C_0$</li><li>$以i=4为例，C_4 = G_4 + P_4G_3 + P_4P_3G_2 + P_4P_3P_2G_1 + P_4P_3P_2P_1C_0$</li></ul></li><li>记：<ul><li>$G_4^* = G_4 + P_4G_3 + P_4P_3G_2 + P_4P_3P_2G_1$：组进位生成位</li><li>$P_3^* = P_4P_3P_2P_1$：组进位传递位</li><li>$C_4 = G_4^* + P_4^*C_0$：组进位传递函数</li></ul></li><li>$S_i=P_i\oplus C_{i-1}$</li></ol></li><li>1级门电路延迟-与门异或门电路：计算$G_i,P_i$<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/22.png" alt="1级门电路"></li></ul></li><li>2级门电路延迟-先行进位电路：计算$C_i$<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/23.png" alt="2级门电路"></li></ul></li><li>四位快速加法器<ul><li><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/24.png" alt="四位快速加法器"></li></ul></li></ol></li></ol></li></ol><h4 id="6-3-3-乘法运算">6.3.3 乘法运算</h4><ul><li>思想：移位相加</li></ul><h5 id="6-3-3-1-原码乘法">6.3.3.1 原码乘法</h5><ul><li>符号位：单独计算</li><li>数值位：从$Y$的最低位开始，逐位决定$SUM$是否加$X$，然后$Sum$右移一位。</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/30.png" alt="原码乘法"></p><h5 id="6-3-3-2-（重点）补码乘法：Booth算法">6.3.3.2 （重点）补码乘法：Booth算法</h5><ul><li>给定：$[X]_补,[Y]_补$，求$[X]_补\times [Y]_补$</li></ul><ol><li>求$[-X]_补$，$[Y]_补$最后补一位0</li><li>当前$Y$的末2位$Y_{-2}Y_{-1}$决定$SUM$加$X,0,-X$的哪一个<ul><li>$SUM+=X\times (Y_{-1}-Y_{-2})=\begin{cases}<br>0 &amp; Y_{-2}Y_{-1}=00\\<br>X &amp; Y_{-2}Y_{-1}=01\\<br>-X &amp; Y_{-2}Y_{-1}=10\\<br>0 &amp; Y_{-2}Y_{-1}=11<br>\end{cases}$</li></ul></li><li>右移$SUM$，左边补符号位</li><li>去掉$Y$的最低位，重复步骤2-3，直到$Y$只剩1位</li></ol><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/31.png" alt="补码乘法"></p><h4 id="6-3-4-除法运算">6.3.4 除法运算</h4><h5 id="6-3-4-1-恢复余数法">6.3.4.1 恢复余数法</h5><ul><li>给定：$[X]_补,[Y]_补$，求$[X]_补\div [Y]_补$（$X,Y$为正数）</li></ul><ol><li>求$[-Y]_补$</li><li>计算$X+=(-Y)$</li><li>若双符号位为$11$，即$X$为负数，不够减，则该位为$0$，恢复余数：$X+=Y$</li><li>若双符号位为$00$，即$X$为正数，够减，该位为$1$</li><li>$X$左移一位，右边补0</li><li>重复步骤2-5，直到$X$左移$4$位（$Y$的位数）</li><li>当前的余数为$X\times 2^{-4}$</li></ol><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/32.png" alt="恢复余数法"></p><h5 id="6-3-4-2-重点-非恢复余数法-加减交替法">6.3.4.2 (重点)非恢复余数法/加减交替法</h5><ul><li>给定：$[X]_补,[Y]_补$，求$[X]_补\div [Y]_补$（$X,Y$为正数）</li></ul><ol><li>求$[-Y]_补$</li><li>若双符号位为$00$，即$X$为正数，计算$X+=(-Y)$（第一次必定做减法）</li><li>若双符号位为$11$，即$X$为负数，计算$X+=Y$</li><li>若双符号位为$00$，即$X$为正数，该位为$1$</li><li>若双符号位为$11$，即$X$为负数，该位为$0$</li><li>$X$左移一位，右边补0</li><li>重复步骤2-6，直到$X$左移$4$位（$Y$的位数）</li><li>当前的余数为$X\times 2^{-4}$</li></ol><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/33.png" alt="非恢复余数法"></p><h3 id="6-4-浮点运算">6.4 浮点运算</h3><p><a href="#62-%E5%B0%8F%E6%95%B0%E7%9A%84%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA">规格化浮点数</a></p><h4 id="6-4-1-浮点加减法">6.4.1 浮点加减法</h4><p>例：<br>$$<br>X=2^{E_x}M_x=2^{101}\times 0.11011011 \\<br>Y=2^{E_y}M_y=2^{111}\times-0.10101100<br>$$<br>尾数在计算机中以补码表示，可存储10位尾数，2位符号位，阶码以补码表示，双符号位, 求$X+Y$</p><h5 id="6-4-1-1-将X-Y转化为带符号的浮点补码格式">6.4.1.1 将X,Y转化为带符号的浮点补码格式</h5><p>$$<br>X=00101,00.11011011 \\<br>Y=00111,11.01010100(-0.10101100)<br>$$</p><h5 id="6-4-1-2-对阶">6.4.1.2 对阶</h5><ul><li>原则：小阶对大阶</li></ul><ol><li>计算$[-E_y]_补=11001$</li><li>计算阶差$E=E_x+(-E_y)=00101+11001=11110=-2(D)&lt;0$</li><li>$X$是小阶，$M_x$右移$|E|=2$位：$M_x=00.0011011011$，$E=111$</li><li>$X=00111,00.0011011011$</li></ol><h5 id="6-4-1-3-尾数求和-差">6.4.1.3 尾数求和/差</h5><p>$$M=M_x+M_y=00.0011011011+11.01010100=11.1000101011 \\<br>X+Y=00111,11.1000101011<br>$$</p><h5 id="6-4-1-4-结果规格化">6.4.1.4 结果规格化</h5><ul><li>双符号位为$11$，是负数，规格化到小数点后一位为$0$。（本题中，$M$双符号位为$11$）</li><li>双符号位为$00$，是正数，规格化到小数点后一位为$1$。</li><li>结果左移一位得到：</li></ul><p>$$<br>X+Y=00110,11.000101011<br>$$</p><ul><li>尾数溢出时可能需要尾数右移</li></ul><h5 id="6-4-1-5-舍入处理">6.4.1.5 舍入处理</h5><ul><li>0舍1入：$X+Y=00111,11.00010110$</li><li>截断：$X+Y=00111,11.00010101$</li></ul><h5 id="6-4-1-6-得出结果">6.4.1.6 得出结果</h5><p>$$<br>X+Y=00110,11.00010101 \\<br>=2^{110}\times -0.11101011<br>$$</p><h5 id="6-4-1-7-溢出判断">6.4.1.7 溢出判断</h5><p>根据阶码的双符号位进行判断：</p><ul><li>01：正溢出</li><li>10：负溢出</li></ul><h4 id="6-4-2-浮点乘法-除法">6.4.2 浮点乘法/除法</h4><ul><li>乘法：尾数定点相乘，阶码相加</li><li>除法：尾数定点相除，阶码相减</li></ul><h2 id="七、指令系统">七、指令系统</h2><h3 id="7-0-基本概念">7.0 基本概念</h3><ol><li>指令：计算机能直接识别、执行的操作命令（机器指令）；冯诺依曼结构“程序控制”原理实现的载体</li><li>指令集：一台计算机能执行的全部指令的集合</li><li>等长指令（MIPS）/变长指令（x86）</li><li>指令系统的特点：完备、高效、规整、兼容</li><li>为什么说“指令系统是计算机系统硬件与软件之间的界面”？<ul><li>从程序的编写与执行角度看，指令规定了计算机的操作类型及操作数地址，它们是产生各种控制信号的基础。</li><li>从硬件设计角度看，在设计计算机的时候先要确定硬件能够直接执行哪些操作，表现为一组指令集合，称之为计算机的指令系统。</li><li>因此，指令系统体现了一台计算机的软、硬件界面。</li></ul></li></ol><h3 id="7-1-机器指令">7.1 机器指令</h3><h4 id="7-1-1-指令的一般格式">7.1.1 指令的一般格式</h4><p>$操作码OP|(寻址模式Mode)|地址码A_1|地址码A_2|\cdots$</p><ol><li>操作码字段：反映机器（对什么数据）做什么操作<ol><li><ul><li>定长操作码：总操作种类=2^k</li><li>变长操作码：操作码向不用的地址码字段扩展</li></ul></li><li>扩展操作码技术<ul><li>假设二操作数指令格式为：$OP(4)|A_1(6)|A_2(8)$ 15条</li><li>只保留全1为长操作数的锚点，那么：<ul><li>单操作数指令格式可以为：$1111|OP(6)|A_1(8)$ 63条</li><li>无操作数指令格式可以为：$1111|111111|OP(8)$ 256条</li></ul></li><li>原则：短操作码不能是长操作码的前缀</li><li>可以根据实际指令数量，通过保留多个锚点，识别更多的操作码：<ul><li>假设二操作数指令有10条，则可以保留6个锚点</li><li>可用于单操作数指令的条数变为$6\times 2^6$ 条</li><li>按需分配后剩下的可以作为无操作数指令的锚点</li></ul></li><li>例题：设某指令系统指令字长16位，每个地址码为6位。若要求设计二地址指令15条、一地址指令34条，问最多还可设计多少条零地址指令？<ul><li>指令格式：$OP(4)|A_1(6)|A_2(6)$</li><li>二地址指令条数15，保留锚点数$2^4-15=1$</li><li>一地址指令条数34，保留锚点数$1\times 2^6 - 34 = 30$</li><li>零地址指令条数：$30\times 2^6 = 1920$</li></ul></li></ul></li><li>经常使用的操作设计为短操作码，不常用的设计为长操作码</li></ol></li><li>操作数字段（地址码字段）：<ul><li>四地址指令（$OP|A_1|A_2|A_3|A_4$）：$(A_1)OP(A_2)\rightarrow A_3$，下一条指令位于$A_4$</li><li>三地址指令（$OP|A_1|A_2|A_3$）：$(A_1)OP(A_2)\rightarrow A_3$，下一条指令位于$PC+1$（利用$PC$代替$A_4$）</li><li>二地址指令（$OP|A_1|A_2$）：$(A_1)OP(A_2)\rightarrow AC$，下一条指令位于$PC+1$（利用$AC$代替$A_3$）</li><li>一地址指令（$OP|A_1$）：$(A_1)OP(AC)\rightarrow AC$，下一条指令位于$PC+1$（利用$AC$代替$A_2,A_3$）</li><li>零地址指令（$OP$）：基本的无操作数操作指令，如空操作、停机、中断、返回等</li><li>访存次数：取指令1次+读取操作数次数+存结果到操作数次数（若存入AC则不计）</li><li>直接寻址范围：$2^k$，k是单个地址码位数</li><li>减少操作数个数的优点：<ol><li>利用硬件资源代替地址码字段</li><li>扩大指令的寻址范围</li><li>缩短指令字长</li></ol></li></ul></li></ol><h4 id="7-1-2-指令字长">7.1.2 指令字长</h4><ol><li>指令字长决定于：<ul><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数的个数</li></ul></li><li><ul><li>定长指令：指令字长=存储字长</li><li>变长指令：通常按字节的倍数存储</li></ul></li></ol><h3 id="7-2-操作数类型和操作类型">7.2* 操作数类型和操作类型</h3><h4 id="7-2-1-操作数类型">7.2.1 操作数类型</h4><ol><li>地址：用于表示地址的无符号整数</li><li>数字：定点数、浮点数、十进制数</li><li>字符：ASCII</li><li>逻辑：逻辑数据/运算</li></ol><h4 id="7-2-2-数据在存储器中的存储方式">7.2.2 数据在存储器中的存储方式</h4><ul><li>边界对齐/边界不对齐</li><li>大端存储/小端存储</li></ul><h4 id="7-2-3-操作类型">7.2.3 操作类型</h4><p>1.数据传送 2.算术/逻辑运算 3.移位运算 4.控制转移</p><h3 id="7-3-寻址方式">7.3 寻址方式</h3><h4 id="7-3-1-指令寻址">7.3.1 指令寻址</h4><ol><li>顺序寻址：通过程序计数器PC+指令占用字节数，自动生成下一条指令地址<ul><li>PC的变化时机：每当CPU从存储器中读取出一个字节时，PC+1</li></ul></li><li>跳跃寻址：通过指令中的转移类操作，跳转到指定地址</li></ol><h4 id="7-3-2-数据寻址">7.3.2 数据寻址</h4><p>$操作码OP|(寻址模式Mode)|地址码A_1|地址码A_2|\cdots$</p><p>记：形式地址$D$/寄存器地址$R$、实际地址$E$、实际操作数$S$、基址/变址寄存器$B$、解地址符号$()$</p><ol><li>隐含寻址：操作数地址隐含在操作码或寄存器中（有利于减少指令字长）</li><li>立即寻址：操作数直接在指令中给出（补码，形式地址位数限制了范围）$S=D$</li><li>直接寻址：操作数在存储器中，地址码在指令中给出 $E=D$</li><li>寄存器寻址：操作数在寄存器中，寄存器编号在指令中给出 $E=R$</li><li>间接寻址：地址码指向的存储器中存放的地址是操作数的地址（二级指针）$E=(D),S=((D))$<ul><li>优点：减少指令字长，增加寻址范围，方便编程</li><li>缺点：两次访存，速度慢，已淘汰</li></ul></li><li>寄存器间接寻址：地址码（寄存器编号）指向的寄存器中存放的地址是操作数地址（应用广泛）$E=®$</li><li>相对寻址：操作数地址=PC+偏移量 $E=D+(PC)$</li><li>基址/变址寻址：操作数地址=基址/变址+偏移量（可以指定通用寄存器作为基址/变址寄存器）$E=D+(B)$</li><li>堆栈寻址：操作数地址=栈顶指针寄存器SP<ul><li>入栈：SP-1（上移），存入数据</li><li>出栈：取出数据，SP+1（下移）</li><li>单次变化量取决于主存编址方式：<ul><li>按字编址：$SP\pm 1$</li><li>按字节编址存储字长32位：$SP\pm 4(32/8)$</li></ul></li></ul></li></ol><h3 id="7-4-指令格式分析与设计">7.4 指令格式分析与设计</h3><h4 id="7-4-1-指令格式分析">7.4.1 指令格式分析</h4><p>例：$OP(15-12)|Mode(11-9)|Reg(8-6)|Mode(5-3)|Reg(2-0)$</p><ol><li>二地址指令</li><li>操作码：最多支持16种指令</li><li>寻址方式：源数据和目的数据都最多支持8种寻址方式</li><li>寄存器个数：源地址和目的地址都最多支持8个寄存器</li><li>可寻址范围：<ul><li>直接寻址范围：$2^3=8$（寄存器地址）</li><li>间接寻址范围：默认存储字长=指令字长，$2^{16}=64K$（存储器地址）</li></ul></li></ol><h3 id="7-5-RISC-CISC">7.5 RISC/CISC</h3><ul><li>CISC：复杂指令集计算机（Complex Instruction Set Computer）</li><li>RISC：精简指令集计算机（Reduced Instruction Set Computer）</li><li>80-20规律：经典程序中80%的指令只使用了处理机指令集20%的指令</li></ul><table><thead><tr><th></th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>指令系统</td><td>复杂、庞大</td><td>简单、精简</td></tr><tr><td>指令数目</td><td>一般&gt;200</td><td>一般&lt;100</td></tr><tr><td>指令字长</td><td>变长</td><td>定长</td></tr><tr><td>寻址方式</td><td>多</td><td>少</td></tr><tr><td>访存指令</td><td>不限</td><td>只有LOAD/STORE</td></tr><tr><td>单条指令执行时间</td><td>相差较大</td><td>多数在一个周期内</td></tr><tr><td>各指令使用频度</td><td>相差较大</td><td>都较常用</td></tr><tr><td>通用寄存器数量</td><td>较少</td><td>多</td></tr><tr><td>目标代码</td><td>难以优化</td><td>优化编译生成高效代码</td></tr><tr><td>控制方式</td><td>大多为微程序控制</td><td>大多为硬布线控制</td></tr></tbody></table><h2 id="八、CPU的结构和功能">八、CPU的结构和功能</h2><h3 id="8-0-基本概念">8.0 基本概念</h3><ol><li>CPU的功能（控制器：1~4，ALU：5）<ol><li>程序控制：控制程序的顺序执行</li><li>操作控制：产生完成每条指令所需的控制命令</li><li>时序控制：对各种操作实施时间上的控制</li><li>异常控制：处理中断</li><li>数据加工：对数据进行算术运算和逻辑运算</li></ol></li><li>CPU的组成：<ol><li>专用寄存器以及通用寄存器:程序控制元生成各种微操作命令序列</li><li>算术逻辑单元ALU：进行算术运算和逻辑运算</li><li>控制器：中断系统用于处理各种中断</li></ol></li><li>数据通路分为：共享通路（总线型）、专用通路（看作多总线型）</li></ol><h3 id="8-1-CPU的结构">8.1 CPU的结构</h3><ol><li>寄存器</li><li>ALU</li><li>控制单元和中断系统<ul><li>控制器的基本功能：取指令、分析指令、执行指令</li></ul></li></ol><h3 id="8-2-指令周期">8.2 指令周期</h3><p>指令周期：去除并执行一条指令所需要的全部时间</p><ol><li>取址周期：取指令的时间</li><li>间址周期：用于间址寻址取操作数</li><li>执行周期：执行指令，存取操作数和结果的时间</li><li>中断周期：CPU采用中断方式实现主机和I/O设备的通信时，发送中断信号的时间</li></ol><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/34.png" alt="指令周期"></p><ul><li>提高机器速度的方法<ol><li>提高访存速度：高速芯片、Cache、多体并行</li><li>提高I/O和主机之间的传输速度：中断、DMA、I/O处理机、多总线</li><li>提高CPU的运算速度：高速芯片、改进算法、快速进位链</li></ol></li></ul><h3 id="8-3-指令流水线">8.3 指令流水线</h3><p>指令流水线：将指令执行过程分为多个阶段，使多条指令在不同阶段同时执行（并行性）</p><h4 id="8-3-1-影响流水线性能的因素">8.3.1 影响流水线性能的因素</h4><ol><li>结构相关：不同指令争用同一功能部件产生资源冲突</li><li>数据相关：不同指令因重叠操作，可能改变操作数的读/写访问顺序<ul><li>读后写/写后读/写后写</li></ul></li><li>控制相关：分支指令的执行可能改变程序计数器的值，导致流水线中的其他指令失效</li></ol><h4 id="8-3-2-流水线性能">8.3.2 流水线性能</h4><ol><li>吞吐率$T_p$：单位时间内完成的指令数/输出结果的数量<ul><li>设$m$段流水线的各段时间为$\Delta t$</li><li>最大吞吐率：$\dfrac{1}{\Delta t}$</li><li>实际吞吐率：连续处理$n$条指令的吞吐率：$\dfrac{n}{(m+n-1)\Delta t}$</li></ul></li><li>加速比$S_p$：流水线处理速度与非流水线处理速度的比值<ul><li>加速比=原处理时间/流水线处理时间&gt;1</li><li>连续处理$n$条指令的加速比：$S_p=\dfrac{nm\Delta t}{(m+n-1)\Delta t}=\dfrac{mn}{m+n-1}$</li></ul></li><li>效率$E_p$：流水线中各功能段的利用率<ul><li>由于流水线有建立时间和排空时间 ，因此各功能段的设备不可能一直处于工作状态</li><li>$E_p=\dfrac{实际工作的时空区域}{总时空区域}=\dfrac{n}{m+n-1}$</li></ul></li></ol><h4 id="8-3-3-流水线的多发技术">8.3.3 流水线的多发技术</h4><ol><li>超标量技术：多个流水线并行执行多条指令</li><li>超流水线技术：将流水线分为多个较短的段，提高吞吐率</li><li>超长指令字技术VLIW：将多条能够并行操作的指令组合成一条指令，提高吞吐率</li></ol><h4 id="8-3-4-流水线结构">8.3.4 流水线结构</h4><ol><li>指令流水线：取指令、指令译码、地址形成、取操作数、操作执行、写回结果</li><li>运算流水线（浮点数）：对阶功能、尾数相加、规格化</li></ol><h3 id="8-4-指令周期与时序">8.4 指令周期与时序</h3><ul><li>时钟周期=节拍脉冲=震荡周期：完成一次微操作的时间</li><li>机器周期=CPU周期：从主存读出一条指令的<strong>最短时间</strong></li><li>指令周期：从主存取一条指令到执行完毕的时间</li></ul><p><img src="https://source.cclmsy.cc/Posts/Course/computer_composition_principle/35.png" alt="时序"></p><h3 id="8-5-控制器设计">8.5 控制器设计</h3><table><thead><tr><th></th><th>硬布线控制器</th><th>微程序控制器</th></tr></thead><tbody><tr><td>逻辑</td><td>同步逻辑</td><td>存储逻辑</td></tr><tr><td>特点</td><td>繁、快、贵</td><td>简、慢、廉</td></tr><tr><td>更改</td><td>难</td><td>易</td></tr></tbody></table><h4 id="8-5-1-硬布线控制器">8.5.1 硬布线控制器</h4><ol><li>设计时序产生器：根据固定机器周期、节拍数固定构建状态图</li><li>画出指令周期流程图</li><li>找控制信号产生条件</li><li>写出逻辑表达式</li><li>化简表达式</li><li>利用组合逻辑电路实现</li></ol><p>优化：有限状态机、异步控制</p><p>特点：</p><ul><li>结构复杂、无规则</li><li>设计和调试困难</li><li>不可改变指令系统和功能</li><li>速度快、成本高</li></ul><h4 id="8-5-2-微程序控制器">8.5.2 微程序控制器</h4><p>（计组实验相关）</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/posts/dsu.html"/>
      <url>/posts/dsu.html</url>
      
        <content type="html"><![CDATA[<h2 id="并查集">并查集</h2><p>实现的功能：管理元素所属集合</p><p>洛谷模板题：<a href="https://www.luogu.com.cn/problem/P3367">Luogu P3367</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;ll&gt; parents, size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DSU</span><span class="params">(ll n)</span> : parents(n + <span class="number">1</span>), size(n + <span class="number">1</span>, <span class="number">1</span>) &#123;</span> <span class="built_in">iota</span>(parents.<span class="built_in">begin</span>(), parents.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> (parents[x] == x) ? x : (parents[x] = <span class="built_in">find</span>(parents[x])); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// merge a and b</span></span><br><span class="line">        a = <span class="built_in">find</span>(a);</span><br><span class="line">        b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//启发式合并，定向merge删去，merge a -&gt; b</span></span><br><span class="line">        <span class="keyword">if</span> (size[a] &gt; size[b]) <span class="built_in">swap</span>(a, b); </span><br><span class="line">        parents[a] = b;</span><br><span class="line">        size[b] += size[a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll opt, a, b;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="comment">// merge</span></span><br><span class="line">            dsu.<span class="built_in">merge</span>(a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// query</span></span><br><span class="line">            cout &lt;&lt; (dsu.<span class="built_in">find</span>(a) == dsu.<span class="built_in">find</span>(b) ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假06</title>
      <link href="/posts/ACM_2024Winter_NCD06.html"/>
      <url>/posts/ACM_2024Winter_NCD06.html</url>
      
        <content type="html"><![CDATA[<h1>A.宇宙的终结</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>在$[1,100]$中给定的某个区间内找到一个数，它是$3$个不同素数的积。</p><h2 id="解题思路">解题思路</h2><p>打出$100$以内素数表，然后暴力枚举判定。</p><p>手算也行，$100$以内答案只有$30,42,66,70,78$。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; phi=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pend</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:phi)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%p==<span class="number">0</span>) &#123; cnt++; x/=p; &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;cnt==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r;cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,l,r) <span class="keyword">if</span>(<span class="built_in">pend</span>(i)) &#123;cout &lt;&lt; i &lt;&lt; endl;<span class="keyword">return</span>;&#125; </span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; ans=&#123;<span class="number">30</span>,<span class="number">42</span>,<span class="number">66</span>,<span class="number">70</span>,<span class="number">78</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l,r;cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:ans) <span class="keyword">if</span>(x&gt;=l&amp;&amp;x&lt;=r) &#123;cout &lt;&lt; x &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.爱恨的纠葛</h1><p><strong>思维</strong></p><h2 id="题意-2">题意</h2><p>给定$2$个长度为$n$的数组$a,b$。调整$a$数组使得$|a_i-b_i|$的最小值最小。</p><h2 id="解题思路-2">解题思路</h2><p>在$a,b$中分别找到一个数，它们的差的绝对值最小。</p><p>对数组$a$排序，在数组$a$中二分查找$b_i$的最近邻，记录差的绝对值最小的一对的下标$i,j$，最后把$a_i$和$a_j$交换使这一对在同一位置。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">SORT</span>(a);</span><br><span class="line">    ll mindif=INF,idxa=<span class="number">-1</span>,idxb=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(a),b[i]);</span><br><span class="line">        <span class="keyword">if</span>(it!=a.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="built_in">abs</span>(b[i]-*it);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;mindif)</span><br><span class="line">            &#123;</span><br><span class="line">                mindif=t;</span><br><span class="line">                idxa=i;</span><br><span class="line">                idxb=it-a.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(it!=a.<span class="built_in">begin</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            it--;</span><br><span class="line">            t=<span class="built_in">abs</span>(b[i]-*it);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;mindif)</span><br><span class="line">            &#123;</span><br><span class="line">                mindif=t;</span><br><span class="line">                idxa=i;</span><br><span class="line">                idxb=it-a.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[idxa],a[idxb]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; a[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.心绪的解剖</h1><p><strong>思维</strong></p><h2 id="题意-3">题意</h2><p>给定一个数$x$，问$x$是否可以表示为$3$个斐波那契数之和。<br>其中，斐波那契数指的是斐波那契数列$0,1,1,2,3,5\cdots$ 中的数。</p><h2 id="解题思路-3">解题思路</h2><p>预处理$N$以内斐波那契数列，每次二分找到恰小于等于$x$的数，然后$x$减去这个数。<br>三次之后，如果$x$为$0$，则可以表示。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preFeb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Feb.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    Feb.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(Feb.<span class="built_in">back</span>()&lt;=<span class="number">1e10</span>)&#123;</span><br><span class="line">        Feb.<span class="built_in">pb</span>(Feb[Feb.<span class="built_in">size</span>()<span class="number">-1</span>]+Feb[Feb.<span class="built_in">size</span>()<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;cin &gt;&gt; x;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(<span class="number">3</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = --<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(Feb),x);</span><br><span class="line">        ans[i] = *it;</span><br><span class="line">        x -= *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.友谊的套路</h1><p><strong>2签</strong></p><h2 id="题意-4">题意</h2><p>在五局三胜的游戏中，一方先胜$2$场，另一方再胜$3$场逆袭，这种情况叫做“让二追三”。<br>已知小红的胜率为$p$，求让二追三的概率。</p><h2 id="解题思路-4">解题思路</h2><p>分小红让二追三和小红被让二追三两种情况。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ld p;cin &gt;&gt; p;</span><br><span class="line">    ld np=<span class="number">1</span>-p;</span><br><span class="line">    ld ans=p*p*np*np*np+np*np*p*p*p;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.未来的预言</h1><p><strong>思维</strong></p><h2 id="题意-5">题意</h2><p>给定一个形如“BOx”的字符串，表示进行$x$局的游戏（$x$为奇数），赢得更多场次的队伍获胜。<br>另给一个字符串，表示每局胜利的队伍。</p><p>问第几局已经确定了胜负，或是还未确定。</p><h2 id="解题思路-5">解题思路</h2><p>数数</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">getnum</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        ret*=<span class="number">10</span>;</span><br><span class="line">        ret+=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ts;cin &gt;&gt; ts;</span><br><span class="line">    string s; cin &gt;&gt; s;</span><br><span class="line">    ll tn=<span class="built_in">getnum</span>(ts); tn/=<span class="number">2</span>;</span><br><span class="line">    ll cntR=<span class="number">0</span>,cntP=<span class="number">0</span>;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>) cntR++;</span><br><span class="line">        <span class="keyword">else</span> cntP++;</span><br><span class="line">        <span class="keyword">if</span>(cntR&gt;tn)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;kou!&quot;</span> &lt;&lt; endl &lt;&lt; i+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cntP&gt;tn)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;yukari!&quot;</span> &lt;&lt; endl &lt;&lt; i+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;to be continued.&quot;</span> &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F.命运的抉择</h1><p><strong>思维</strong></p><h2 id="题意-6">题意</h2><p>给定一个长度为$n$的数组，把它分成非空的两部分$a,b$，使得从$a,b$中分别任取一个元素$a_i,b_j$，它们互质$gcd(a_i,b_j)=1$</p><h2 id="解题思路-6">解题思路</h2><p>先在$a$中放置一个数，开一个set记录$a$中已存在的质数因子。</p><p>在剩余的数字中多次扫描，一旦某个数$x$能被$a$中的质数因子整除，就把它放入$a$中，直到某次扫描没有加入新的数字。<br>剩余的数字作为$b$。</p><p>时间复杂度比较抽象//</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">GetFac</span><span class="params">(ll x)</span></span>&#123;<span class="comment">//返回x的质因数集合</span></span><br><span class="line">    vector&lt;ll&gt; ret;</span><br><span class="line">    ll i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[x])&#123;<span class="comment">//check[i]==1表示i是合数</span></span><br><span class="line">            <span class="keyword">if</span>(x%prime[i]==<span class="number">0</span>)&#123;<span class="comment">//prime是质数表</span></span><br><span class="line">                ret.<span class="built_in">pb</span>(prime[i]);</span><br><span class="line">                <span class="keyword">while</span>(x%prime[i]==<span class="number">0</span>) x/=prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; ret.<span class="built_in">pb</span>(x); <span class="keyword">return</span> ret; &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; vFac;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">push_back</span>(t);</span><br><span class="line">        vFac.<span class="built_in">push_back</span>(<span class="built_in">GetFac</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;ll&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sa</span><span class="params">(n,<span class="number">0</span>)</span></span>;<span class="comment">//放入集合a</span></span><br><span class="line">    sa[<span class="number">0</span>]=<span class="number">1</span>; t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vFac[<span class="number">0</span>]) st.<span class="built_in">insert</span>(x);<span class="comment">//将第一个数的质因数放入集合</span></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        t=<span class="number">0</span>;<span class="comment">//t表示本轮是否有数放入集合a</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(sa[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vFac[i]) <span class="keyword">if</span>(st.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">                sa[i]=<span class="number">1</span>; t++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:vFac[i]) st.<span class="built_in">insert</span>(y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; a,b;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(sa[i]) a.<span class="built_in">pb</span>(v[i]); <span class="keyword">else</span> b.<span class="built_in">pb</span>(v[i]);</span><br><span class="line">    <span class="keyword">if</span>(b.<span class="built_in">size</span>()==<span class="number">0</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll na=a.<span class="built_in">size</span>(),nb=b.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; na &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; nb &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,na<span class="number">-1</span>) cout &lt;&lt; a[i] &lt;&lt; <span class="built_in">Presentation</span>(i,na<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,nb<span class="number">-1</span>) cout &lt;&lt; b[i] &lt;&lt; <span class="built_in">Presentation</span>(i,nb<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.人生的起落</h1><p><strong>构造</strong></p><h2 id="题意-7">题意</h2><p>形如$(a,b,a),a\gt b$的三元组称为“v-三元组”。<br>构造一个长度为$n$，和为$S$，且恰好有$k$个“v-三元组”的正整数数组。</p><h2 id="解题思路-7">解题思路</h2><p>限定正整数，“v-三元组”至少为$(2,1,2)$。<br>依此开局特判：</p><ol><li>$n&lt;k*2+1$：k个“v-三元组”最少需要$2k+1$个数。</li><li>$S&lt;n+k+1$：k个“v-三元组”最少需要$k+1$个$2$，其余为$1$，和至少为$n+k+1$。</li></ol><p>构造方法是，先在最前的$k+1$个奇数位上放置尽可能大的数，然后在剩余的位置上放置$1$。若还有多余的数，放在第$k+1$个奇数位（$k*2+1$）上。</p><p>若$n$恰好等于$k*2+1$，则将多余的数放置在偶数位上，但偶数位上的数不能超过奇数位上的数。</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,S,k;cin &gt;&gt; n &gt;&gt; S &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) cout &lt;&lt; S/<span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; S-S/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; S-n+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>*k+<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(k&amp;&amp;S&lt;n+k+<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    ll t=(S-(n-(k+<span class="number">1</span>)))/(k+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; ans;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        ans.<span class="built_in">pb</span>(t);</span><br><span class="line">        ans.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">        S-=t+<span class="number">1</span>;</span><br><span class="line">    &#125;ans.<span class="built_in">pb</span>(t); S-=t;</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&gt;=n)&#123;</span><br><span class="line">        t=S/(n/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n/<span class="number">2</span><span class="number">-1</span>)&#123;</span><br><span class="line">            ans[i*<span class="number">2</span>+<span class="number">1</span>]+=t;</span><br><span class="line">            S-=t;</span><br><span class="line">        &#125;</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(S)&#123;</span><br><span class="line">            ans[t*<span class="number">2</span>+<span class="number">1</span>]++;</span><br><span class="line">            S--;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span>&amp;&amp;ans[<span class="number">1</span>]&gt;=ans[<span class="number">0</span>]) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t=ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&lt;n)&#123;</span><br><span class="line">            ans.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">            S--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[t]+=S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i==n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I.时空的交织</h1><p><strong>贪心</strong></p><h2 id="题意-8">题意</h2><p>给定$n$个数的数组$a$和$m$个数的数组$b$，表示一个$n\times m$的矩阵，矩阵中的元素$m_{i,j}=a_i*b_j$。<br>选择一个子矩阵，使得子矩阵中的元素之和最大，输出这个和。</p><h2 id="解题思路-8">解题思路</h2><p>假设选定的矩阵区间为$(r_i,r_j):(c_i,c_j)$，则子矩阵的和为$\sum_{i=r_i}^{r_j}\sum_{j=c_i}^{c_j}a_i<em>b_j=\sum_{i=r_i}^{r_j}a_i</em>\sum_{j=c_i}^{c_j}b_j$。</p><p>问题转化为求$a$数组的一个非空连续子数组和乘上$b$数组的一个非空连续子数组和的最大值。</p><p>可为空的数组区间和的最大值可以贪心的求解：</p><ol><li>用$cur$表示对当前区间和，$max$表示区间和的最大值。</li><li>将当前元素$a_i$加入区间，和当前最大值比较。</li><li>若当前区间和$cur&lt;0$，则舍弃之前的区间，重新开始计算（$cur:=0$）。</li></ol><p>本题中的区间要求非空，可以用最值修正。</p><p>此外，$a$数组和$b$数组的元素可以为负数，因此同时求出区间和的最大值和最小值，两两相乘取最大即可。</p><h2 id="参考程序-8">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="built_in">create_vec</span>(b,m);</span><br><span class="line">    ll mxa,mxb,mna,mnb,curmn,curmx;</span><br><span class="line">    mxa=mxb=-INF; mna=mnb=INF;</span><br><span class="line">    curmn=curmx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn+=a[i];</span><br><span class="line">        curmx+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(curmn&gt;<span class="number">0</span>) curmn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(curmx&lt;<span class="number">0</span>) curmx=<span class="number">0</span>;</span><br><span class="line">        mna=<span class="built_in">min</span>(mna,curmn);</span><br><span class="line">        mxa=<span class="built_in">max</span>(mxa,curmx);</span><br><span class="line">    &#125;</span><br><span class="line">    curmn=curmx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn+=b[i];</span><br><span class="line">        curmx+=b[i];</span><br><span class="line">        <span class="keyword">if</span>(curmn&gt;<span class="number">0</span>) curmn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(curmx&lt;<span class="number">0</span>) curmx=<span class="number">0</span>;</span><br><span class="line">        mnb=<span class="built_in">min</span>(mnb,curmn);</span><br><span class="line">        mxb=<span class="built_in">max</span>(mxb,curmx);</span><br><span class="line">    &#125;</span><br><span class="line">    curmn=INF; curmx=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn=<span class="built_in">min</span>(curmn,a[i]);</span><br><span class="line">        curmx=<span class="built_in">max</span>(curmx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curmx&lt;=<span class="number">0</span>) mxa=<span class="built_in">min</span>(mxa,curmx);</span><br><span class="line">    <span class="keyword">if</span>(curmn&gt;=<span class="number">0</span>) mna=<span class="built_in">max</span>(mna,curmn);</span><br><span class="line">    curmn=INF; curmx=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        curmn=<span class="built_in">min</span>(curmn,b[i]);</span><br><span class="line">        curmx=<span class="built_in">max</span>(curmx,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curmx&lt;=<span class="number">0</span>) mxb=<span class="built_in">min</span>(mxb,curmx);</span><br><span class="line">    <span class="keyword">if</span>(curmn&gt;=<span class="number">0</span>) mnb=<span class="built_in">max</span>(mnb,curmn);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(&#123;mna*mnb,mna*mxb,mxa*mnb,mxa*mxb&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.时空的交织</h1><p><strong>贪心、构造</strong></p><h2 id="题意-9">题意</h2><p>给定一棵有根树，若干个节点为红色。<br>为每个节点赋值$1$或$2$，使得每个以红色节点为根的子树，其节点值之和为$3$的倍数。</p><h2 id="解题思路-9">解题思路</h2><p>对于每个红色节点，如果它没有白色子节点，则它的子树除它以外的和已经是$3$的倍数，它为$1$或$2$都不可能再使它的子树和为$3$的倍数。</p><p>如果它至少有1个白色子节点，则它和白色子节点可以配合使得它的子树和为$3$的倍数。</p><p>因此，按DFS逆序遍历，白色节点先赋值为$1$。若红色节点除其本身外，和不是$3$的倍数，则用它补上；否则将任一白色子节点改为$2$，它赋为$2$。</p><h2 id="参考程序-9">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line">vector&lt;ll&gt; vDFS_rev;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) <span class="built_in">DFS</span>(y);</span><br><span class="line">    vDFS_rev.<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n; G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    bitset&lt;N&gt; red;<span class="comment">//red[i]表示第i个节点是否为红色</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) red[i+<span class="number">1</span>]=(s[i]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">white</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//white[i]表示第i个节点下的某一白色节点，0表示没有</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t; G[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(white[t]==<span class="number">0</span>&amp;&amp;!red[i]) white[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(white[i]==<span class="number">0</span>&amp;&amp;red[i]) &#123;cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;<span class="keyword">return</span> ;&#125;<span class="comment">//红色节点下必须有白色节点</span></span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>);<span class="comment">//获取逆DFS序列</span></span><br><span class="line">    ll S[N]=&#123;<span class="number">0</span>&#125;,ans[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vDFS_rev)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:G[x]) S[x]+=S[y];</span><br><span class="line">        <span class="keyword">if</span>(red[x])&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[x]%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[x]=<span class="number">2</span>; S[x]+=<span class="number">3</span>;</span><br><span class="line">                ans[white[x]]=<span class="number">2</span>; S[white[x]]+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S[x]%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                ans[x]=<span class="number">2</span>; S[x]+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[x]=<span class="number">1</span>; S[x]+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[x]=<span class="number">1</span>;</span><br><span class="line">            S[x]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
            <tag> 竞赛笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假05</title>
      <link href="/posts/ACM_2024Winter_NCD05.html"/>
      <url>/posts/ACM_2024Winter_NCD05.html</url>
      
        <content type="html"><![CDATA[<h1>A.mutsumi的质数合数</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>给定一个正整数集合，问其中质数和合数的个数之和。</p><h2 id="解题思路">解题思路</h2><p>正整数中只有$1$既不是质数也不是合数，总数减去$1$的个数即为答案</p><p>(P.S.)：有人这题WA了4发。。。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t,cnt=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>) cnt++;</span><br><span class="line">    &#125;cout &lt;&lt; n-cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.anon的私货</h1><p><strong>贪心</strong></p><h2 id="题意-2">题意</h2><p>给定一个长度为$n$的正整数序列，可以在其中任意位置插入$0$。<br>在保证除全$0$外的任意子序列的平均值大于$1$的条件下最多可以插入多少个$0$。</p><h2 id="解题思路-2">解题思路</h2><p>题目可以转换为：对于每个数字，两边插入的$0$的个数之和不大于它。</p><p>贪心的，先从左往右扫描，对于每个数字，尽量往左插入$0$，<br>第$i$个数字$a_i$左边插入$0$的个数记为$pl_i$。</p><p>最左边的数字$a_1$可以往左插入$a_1-1$个$0$，<br>后面的数字$a_i$允许往左插入$0$的个数$pl_i$被限制为以下两个值的最小值：</p><ol><li>$a_i-1$：$a_i$左边插入的数量最多为$a_i-1$</li><li>$a_{i-1}-1-pl_{i-1}$：$a_{i-1}$两边插入的数量$pl_{i-1}+pl_i&lt;=a_{i-1}-1$</li></ol><p>接着，从右往左扫描，对于每个数字，尽量往右插入$0$，类比上面的过程。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pl</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">//pl[i]表示第i个位置左边的空当，pl[n]表示最右端</span></span><br><span class="line">    pl[<span class="number">0</span>]=v[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">    pl[n]=v[n<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        pl[i]=<span class="built_in">min</span>(v[i<span class="number">-1</span>]<span class="number">-1</span>-pl[i<span class="number">-1</span>],v[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        pl[i]=<span class="built_in">min</span>(&#123;v[i]<span class="number">-1</span>-pl[i+<span class="number">1</span>],v[i<span class="number">-1</span>]<span class="number">-1</span>,pl[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n) ans+=pl[i];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) ans=v[<span class="number">0</span>]<span class="number">-1</span>;<span class="comment">//特判</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.soyorin的数组操作（easy）</h1><p><strong>贪心</strong></p><h2 id="题意-3">题意</h2><p>给定一个长度为$n$的数组，每次可以选定一个$n$以内的偶数$k$，使得$a_1$到$a_k$这$k$个数的值都增加它们的下标。<br>问任意次操作后能否使得数组不严格单调递增。</p><h2 id="解题思路-3">解题思路</h2><p>如果$n$为偶数，每次选中全数组都可以使相邻两个数之差（后一个减前一个）增加$1$，显然必定可以使得数组递增。</p><p>如果$n$为奇数。<br>从后往前遍历，对于每个偶数位置$i$，在满足$a_i&lt;=a_{i+1}$的前提下使其最大。<br>这样做可以保证，在合法的情况下，这个数减前面的数最大。</p><p>同时记录操作次数，同步到前面的元素。</p><p>最后判断数组是否有序。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123; cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;<span class="comment">//偶数个数，直接YES</span></span><br><span class="line"></span><br><span class="line">    ll cur=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n<span class="number">-2</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        v[i]+=cur*(i+<span class="number">1</span>);</span><br><span class="line">        v[i<span class="number">-1</span>]+=cur*i;<span class="comment">//同步更新左边的值</span></span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;v[i+<span class="number">1</span>])&#123; cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="comment">//v[i+1]已经是满足条件下最大的值了。如果还是小于v[i]，那么就不可能满足条件了</span></span><br><span class="line">        t=(v[i+<span class="number">1</span>]-v[i])/(i+<span class="number">1</span>);</span><br><span class="line">        v[i]+=t*(i+<span class="number">1</span>);</span><br><span class="line">        v[i<span class="number">-1</span>]+=t*i;</span><br><span class="line">        cur+=t; i--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>) <span class="keyword">if</span>(v[i]&gt;v[i+<span class="number">1</span>])&#123; cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>GH.sakiko的排列构造（easy+hard）</h1><p><strong>构造</strong></p><h2 id="题意-4">题意</h2><p>给定一个正整数$n$，构造一个$n$的排列$p$，使得$p_i+i$全为质数</p><h2 id="解题思路-4">解题思路</h2><p>考虑一段连续的数字$[l,r]$，如果两端之和$l+r$是质数，那么把这段数字倒过来，与原来的数字序列对应相加，将得到$r-l+1$个质数$r+l$。</p><p>先确定右端点$r=n$，从后往前寻找一个左端点$l$，使得$l+r$为质数，再将这个区间的数字序列倒过来放入这个区间。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Phi_and_Prime_Table</span>(<span class="number">2</span>*n+<span class="number">2</span>);<span class="comment">//预处理质数表，数据区间有限暴力判断也可</span></span><br><span class="line">    ll r=n;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check[i+r])&#123;<span class="comment">//check[i+r]==0表示i+r是质数</span></span><br><span class="line">            <span class="built_in">FORLL</span>(j,i,r) ans[j]=r+i-j;</span><br><span class="line">            r=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; ans[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I.rikki的最短路</h1><p><strong>思维</strong></p><h2 id="题意-5">题意</h2><p>在一条数轴上，你在原点$O$，$A$在$a$处，$T$在$t$处，你的视线区间为$k$。<br>你先去找$T$。</p><p>如果路上看到$A$，先去找$A$，再去找$T$。<br>如果路上没看到$A$，先去去找$T$，再去找$A$，再去找$T$。</p><p>问最短路程。</p><h2 id="解题思路-5">解题思路</h2><p>分类讨论</p><ol><li>$t&gt;=0$：$T$在原点右边，去找$T$可以看到的区间为$[-k,t+k]$<ol><li>$A$在$[-k,0]$：先去找$A$，再去找$T$，最短路程为$t+2|a|=t-2a$</li><li>$A$在$[0,t]$：路上把$A$捡走，再去找$T$，最短路程为$t$</li><li>$A$在$[t,t+k]$：先去找$T$，再去找$A$，再去找$T$，合并到其他情况</li><li>其他：先去找$T$，再去找$A$，再去找$T$，最短路程为$t+2|a-t|$</li></ol></li><li>$t&lt;0$：$T$在原点左边，类比即可</li></ol><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t,a,k;cin &gt;&gt; t &gt;&gt; a &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=-k&amp;&amp;a&lt;=t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;=<span class="number">0</span>) cout &lt;&lt; t-a*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; t+<span class="built_in">abs</span>(t-a)*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=t&amp;&amp;a&lt;=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">0</span>) cout &lt;&lt; a*<span class="number">2</span>-t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; -t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; -t+<span class="built_in">abs</span>(t-a)*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.rikki的数组陡峭值</h1><p><strong>贪心</strong></p><h2 id="题意-6">题意</h2><p>长度为$n$的数组，每个元素$a_i$限定在一个区间$[l_i,r_i]$内。</p><p>定义陡峭值为每对相邻元素的差的绝对值之和$\sum\limits_{i=1}^{n-1}|a_{i+1}-a_i|$，求陡峭值的最小值。</p><h2 id="解题思路-6">解题思路</h2><p>从前往后遍历。</p><p>如果$[l_i,r_i]$和当前区间有交集，那么都取交集内的数字，陡峭值为$0$。<br>如果$[l_i,r_i]$和当前区间没有交集，那么取两个区间的边界，将当前区间退化成一点。<br>退化后，改为用前一点和区间作比。在区间外，取区间边界。</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>+<span class="number">5</span>,pre=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll tl,tr;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tl &gt;&gt; tr;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;<span class="comment">//当前为一区间</span></span><br><span class="line">            <span class="keyword">if</span>(tr&lt;=l||tl&gt;=r)&#123;<span class="comment">//元素a_i区间与当前区间不相交</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(tr&lt;=l)&#123;</span><br><span class="line">                    ans+=<span class="built_in">abs</span>(l-tr);</span><br><span class="line">                    pre=tr;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans+=<span class="built_in">abs</span>(tl-r);</span><br><span class="line">                    pre=tl;</span><br><span class="line">                &#125;<span class="comment">//区间退化</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tl&gt;=l) l=tl;</span><br><span class="line">                <span class="keyword">if</span>(tr&lt;=r) r=tr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前为一点</span></span><br><span class="line">            <span class="keyword">if</span>(tl&lt;=pre&amp;&amp;tr&gt;=pre) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(tl&gt;=pre)&#123;</span><br><span class="line">                ans+=<span class="built_in">abs</span>(tl-pre);</span><br><span class="line">                pre=tl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr&lt;=pre)&#123;</span><br><span class="line">                ans+=<span class="built_in">abs</span>(pre-tr);</span><br><span class="line">                pre=tr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.soyorin的通知</h1><p><strong>完全背包</strong></p><h2 id="题意-7">题意</h2><p>你要通知$n$个人。你通知1个人花费$p$，第$i$个人通知$a_i$个人花费$b_i$。问最少花费。</p><h2 id="解题思路-7">解题思路</h2><p>首先你至少需要通知$1$个人，才能使他们相互传递通知。<br>再让这个人去通知其他人，以此传递，直到其他$n-1$个人都被通知到。<br>把$a_i$看作容量，$b_i$看作价值，每个人可以选多次，问题转化为求最小价值完全背包问题。<br>DP前，也要把自己作为$a=1,b=q$的物品加入，因为自己也可以单独通知多个人。</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,p,t;cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">cost</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">val</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; cost[i] &gt;&gt; val[i];</span><br><span class="line">    cost[<span class="number">0</span>]=p;val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INF)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">            t=j+val[i]&gt;n<span class="number">-1</span>?n<span class="number">-1</span>:j+val[i];</span><br><span class="line">            dp[t]=<span class="built_in">min</span>(dp[t],dp[j]+cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n<span class="number">-1</span>]+p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>L.rikki的星星</h1><p><strong>2签</strong></p><h2 id="题意-8">题意</h2><p>进行$n$局游戏，赢一局$+1$分，输一局$-1$分，没有平局。</p><p>游戏结束后分数为$x$，问赢多少局输多少局，或是无解。</p><h2 id="解题思路-8">解题思路</h2><p>赢一局和输一局的分差为$2$，因此最终得分和局数的奇偶性一定相同。</p><p>记赢了$a$局，则：$a+(n-a)=x$，解得$a=\dfrac{x+n}{2}$。</p><h2 id="参考程序-8">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x;cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span>((x+n)%<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (x+n)/<span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (n-x)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>M.rikki的排列连通</h1><p><strong>贪心</strong></p><h2 id="题意-9">题意</h2><p>给定$2$个$n$的排列，置入$2\times n$的矩阵。<br>每次操作可以消掉同一数字所在的方块。</p><p>问最少操作多少次可以把矩阵分为没有相邻边的两部分（及以上）。</p><h2 id="解题思路-9">解题思路</h2><p>以下是几种合法的情况：</p><ol><li>某个数字在两个排列中的位置相同，且两边都有数字，消除它即可，答案为$1$。</li><li>某个数字在两个排列中的位置相差$1$，交叉的部分一定有数字，消除它即可，答案为$1$。</li><li>每个数字在两个排列中的位置都至少相差$2$，选择同一位置的两个数字消除，答案为$2$。</li></ol><p>特判是<code>n=1,&#123;1&#125;,&#123;1&#125;</code>、<code>n=2,&#123;1,2&#125;,&#123;1,2&#125;</code>、<code>n=2,&#123;2,1&#125;,&#123;2,1&#125;</code>。<br>第一种情况中，某个数字在两个排列中都位于最左或都位于最右，这个数字不能计入答案。</p><h2 id="参考程序-9">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t; cin &gt;&gt; n;</span><br><span class="line">    ll mndif=INF;<span class="comment">//最小差值</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pos</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    pos.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        pos[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;pos[t]==<span class="number">1</span>) ;<span class="comment">//最左</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==n&amp;&amp;pos[t]==n) ;<span class="comment">//最右</span></span><br><span class="line">        <span class="keyword">else</span> mndif=<span class="built_in">min</span>(mndif,<span class="built_in">abs</span>(i-pos[t]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;mndif&gt;<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(mndif&lt;<span class="number">2</span>) &#123;cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
            <tag> 竞赛笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假04</title>
      <link href="/posts/ACM_2024Winter_NCD04.html"/>
      <url>/posts/ACM_2024Winter_NCD04.html</url>
      
        <content type="html"><![CDATA[<h1>A.柠檬可乐</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>第一行输入三个整数$a,b,k$，判断是否$a\ge k\times b$</p><h2 id="解题思路">解题思路</h2><p>如题</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,k;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=b*k) cout &lt;&lt; <span class="string">&quot;good\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;bad\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.左右互博</h1><p><strong>思维</strong></p><h2 id="题意-2">题意</h2><p>有$n$堆石子，每堆石子有$a_i$个，两个人轮流取操作。<br>每次操作可以选择一堆至少有$2$个石子的石子堆，然后任意分成两堆，每堆至少有一个石子。<br>最先无法操作的人输。</p><h2 id="解题思路-2">解题思路</h2><p>对于有$x$个石子的石堆，它被分成$x$堆一个石子的石堆，需要操作$x-1$次。<br>因此，对所有石堆的操作次数求和 $sum = \sum\limits_{i=1}^{n}a_i-1$。<br>判断奇偶性</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ans+=t<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans%<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;gui&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;sweet&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.冬眠</h1><p><strong>模拟</strong></p><h2 id="题意-3">题意</h2><p>给定$n\times m$的字符矩阵和一段有$q$次操作的操作序列，包含两种操作：</p><ol><li><code>1 t</code>表示将第$t$行向右移动$1$次，最右的一个字符移到最左的位置。</li><li><code>2 t</code>表示将第$t$列向下移动$1$次，最下的一个字符移到最上的位置。<br>问最后的字符矩阵第$x$行第$y$列的字符是什么</li></ol><h2 id="解题思路-3">解题思路</h2><p>数据范围不大，模拟操作</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,x,y;cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    x--;y--;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">mp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; mp[i];</span><br><span class="line">    ll p,q;cin &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">op</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,q<span class="number">-1</span>) cin &gt;&gt; op[i].first &gt;&gt; op[i].second;</span><br><span class="line">    <span class="type">char</span> tc;</span><br><span class="line">    <span class="keyword">while</span>(p--)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,q<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[i].first==<span class="number">1</span>)&#123;<span class="comment">//行向右循环移动一次</span></span><br><span class="line">                tc=mp[op[i].second<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">FORLL_rev</span>(j,m<span class="number">-1</span>,<span class="number">1</span>) mp[op[i].second<span class="number">-1</span>][j]=mp[op[i].second<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                mp[op[i].second<span class="number">-1</span>][<span class="number">0</span>]=tc;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//列向下循环移动一次</span></span><br><span class="line">                tc=mp[n<span class="number">-1</span>][op[i].second<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">FORLL_rev</span>(j,n<span class="number">-1</span>,<span class="number">1</span>) mp[j][op[i].second<span class="number">-1</span>]=mp[j<span class="number">-1</span>][op[i].second<span class="number">-1</span>];</span><br><span class="line">                mp[<span class="number">0</span>][op[i].second<span class="number">-1</span>]=tc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; mp[x][y] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.守恒</h1><p><strong>数学</strong></p><h2 id="题意-4">题意</h2><p>给定$n$个正整数，可以将它们的和重新分配为$n$个正整数。<br>求所有分配方法中，这$n$个数的最大公约数有多少种可能性。</p><h2 id="解题思路-4">解题思路</h2><p>先对所有数求和，记为$sum$。<br>假设这$n$个数的最大公约数为$g$，则$g$一定是$sum$的因子。<br>且因为这$n$个数至少都为$g$，所以$sum/g\ge n$。</p><p>$O(\sqrt(n))$遍历$sum$的因子，判断是否满足条件</p><p>注意特判：当$n=1$时，答案为$1$</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll sum=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) &#123;cin &gt;&gt; t;sum+=t;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;<span class="comment">//特判</span></span><br><span class="line">    ll ub=<span class="built_in">sqrt</span>(sum)+<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i*i&gt;sum) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum%i==<span class="number">0</span>)&#123;</span><br><span class="line">            t=sum/i;</span><br><span class="line">            <span class="keyword">if</span>(t==i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;=n) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;=n) ans++;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=n) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.漂亮数组</h1><p><strong>思维</strong></p><h2 id="题意-5">题意</h2><p>给定一个长度为$n$的整数数组$a$和一个正整数$k$。<br>可以将$a$划分成任意个非空子串，如果子串和能被$k$整除，则称这个子串是漂亮的。<br>求 使得漂亮子串最多的方案 得到的漂亮子串的个数。</p><h2 id="解题思路-5">解题思路</h2><p>从前往后遍历，计算（从上个割点开始的）前缀和对$k$的余数$pre$。<br>如果当前位置的前缀和余数$pre_i$在上个割点之后的位置$j$有出现过，即$pre_i=pre_j$，则子串$[j+1,i]$区间和能被$k$整除。</p><p>因此，我们可以记录每个前缀和对$k$的余数在上个割点之后是否出现过，贪心的求出最多的漂亮子串个数。</p><p>时间复杂度：$O(n)$</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k,t;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//余数为0即空</span></span><br><span class="line">    ll sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        sum+=t;</span><br><span class="line">        <span class="keyword">if</span>(mp[sum%k])&#123;<span class="comment">//如果当前 前缀和对k的余数在上个割点之后出现过</span></span><br><span class="line">            ans++;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            mp.<span class="built_in">clear</span>();<span class="comment">//清空map</span></span><br><span class="line">            mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mp[sum%k]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.数三角形（easy）</h1><p><strong>计数</strong></p><h2 id="题意-6">题意</h2><p>将<code>*</code>看作实体，<code>.</code>看作空白，等腰三角形具有类似以下的形状且不可旋转：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一阶：</span><br><span class="line">.*.</span><br><span class="line">*** </span><br><span class="line"></span><br><span class="line">二阶：</span><br><span class="line"><span class="string">..</span>*<span class="string">..</span></span><br><span class="line">.*.*.</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">三阶：</span><br><span class="line"><span class="string">...</span>*<span class="string">...</span></span><br><span class="line"><span class="string">..</span>*.*<span class="string">..</span></span><br><span class="line">.*<span class="string">...</span>*.</span><br><span class="line">*******</span><br></pre></td></tr></table></figure><p>以此类推，给定一个$n\times m$的字符矩阵，求有多少个等腰三角形</p><h2 id="解题思路-6">解题思路</h2><p>枚举三角形的顶点，然后向两边延展，判断是否满足条件。</p><p>对于底边，如果每次都从左往右扫描，则时间复杂度较高。<br>可以预处理每一个<code>*</code>在该行连续最左的<code>*</code>的位置，使用时直接查询$O(1)$判断。</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    <span class="type">char</span> mp[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//字符矩阵</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m) cin &gt;&gt; mp[i][j];</span><br><span class="line">    ll pre[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//预处理</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[i][j<span class="number">-1</span>]) pre[i][j]=pre[i][j<span class="number">-1</span>];<span class="comment">//如果当前位置是*，且左边有*，则pre[i][j]等于左边的*的位置</span></span><br><span class="line">                <span class="keyword">else</span> pre[i][j]=j;<span class="comment">//否则pre[i][j]等于当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pre[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FORLL(i,1,n) FORLL(j,1,m) cout &lt;&lt; pre[i][j] &lt;&lt; &quot; \n&quot;[j==m];//test</span></span><br><span class="line">    ll ans=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m) <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        ll l=j<span class="number">-1</span>,r=j+<span class="number">1</span>,d=i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//d表示当前底边所在的行，l和r表示底边的两个端点位置</span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">1</span>&amp;&amp;r&lt;=m&amp;&amp;d&lt;=n&amp;&amp;mp[d][l]==<span class="string">&#x27;*&#x27;</span>&amp;&amp;mp[d][r]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre[d][r]&lt;=l) t=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t) ans++;</span><br><span class="line">            l--;r++;d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
            <tag> 竞赛笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假03</title>
      <link href="/posts/ACM_2024Winter_NCD03.html"/>
      <url>/posts/ACM_2024Winter_NCD03.html</url>
      
        <content type="html"><![CDATA[<h1>A.智乃与瞩目狸猫、幸运水母、月宫龙虾</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>题目分享了一个冷知识：<br>Ubuntu 发行版的每个代号都包含一个形容词和一个动物。例如：瞩目狸猫(Focal Fossa)、幸运水母(Jammy Jellyfish)、月宫龙虾(Lunar Lobster)，每个代号的两个单词首字母相同。<br>现在给定两个字符串，问首字母是否相同（忽略大小写）。</p><h2 id="解题思路">解题思路</h2><p>直接比较首字母即可。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">if</span>(s1[<span class="number">0</span>]==s2[<span class="number">0</span>]||s1[<span class="number">0</span>]<span class="number">-32</span>==s2[<span class="number">0</span>]||s1[<span class="number">0</span>]+<span class="number">32</span>==s2[<span class="number">0</span>]) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.智乃的数字手串</h1><p><strong>博弈、猜结论</strong></p><h2 id="题意-2">题意</h2><p>有一串首尾相连的数字，两个玩家轮流操作。<br>当且仅当相邻$2$个数字之和为偶数时，可以消除其中一个，<br>然后<strong>可以</strong>交换剩下的数字中任意两个数字的位置（也可以不交换）。<br>特别的，如果只有$1$个数字，可以直接消除。<br>最先无法操作的玩家输。<br>问对于给定的数字串，qcjj（先手）和zn（后手）谁会赢。</p><h2 id="解题思路-2">解题思路</h2><p>考虑游戏结束时的状态：手串上的数字排布为<code>奇偶奇偶...奇偶</code>，特点是数量为偶数。<br>数量为奇数时，一定存在两个相邻的数，奇偶校验相同（和为偶数）。</p><p>判断原始数字串长度的奇偶性即可。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;qcjj&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;zn&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.chino’s bubble sort and maximum subarray sum(easy version)</h1><p><strong>最大子段和</strong></p><h2 id="题意-3">题意</h2><p>给定一个长度为$n$的数组$a$，求恰好执行“交换任意相邻元素”操作$k$次后，数组$a$的最大非空子段和。</p><h2 id="解题思路-3">解题思路</h2><p>由于easy version的$k$范围极小（$k\in [0,1]$），暴力枚举所有情况求最大非空子段和即可。</p><p>对于最大非空字段和的求法，可以用贪心方法：<br>记$cur$为：包含当前位置元素的最大子段和。<br>从$a_2$开始遍历数组，记当前元素为$a_i$，则当前最大子段和有$2$种情况：</p><ol><li>将当前位置的元素加入当前最大子段和，值为$cur+a_i$；</li><li>以当前位置的元素为起点，重新开始计算最大子段和，值为$a_i$。</li></ol><p>每个位置的$cur$取这$2$种情况的较大值，每个位置$cur$的最大值即为最大非空子段和。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    ll ans=-INF,cur;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        vector&lt;ll&gt; tv;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">            tv=v;</span><br><span class="line">            <span class="built_in">swap</span>(tv[i],tv[i+<span class="number">1</span>]);</span><br><span class="line">            ll tans=tv[<span class="number">0</span>];</span><br><span class="line">            cur=tv[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                cur=<span class="built_in">max</span>(tv[j],cur+tv[j]);</span><br><span class="line">                tans=<span class="built_in">max</span>(tans,cur);</span><br><span class="line">            &#125;ans=<span class="built_in">max</span>(ans,tans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//求原数组的最大子段和</span></span><br><span class="line">        ans=v[<span class="number">0</span>];</span><br><span class="line">        cur=v[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cur=<span class="built_in">max</span>(v[i],cur+v[i]);</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>GH.智乃的比较函数(easy+normal)</h1><p><strong>偏序</strong></p><h2 id="题意-4">题意</h2><p>给定$3$个数字的$n$对关系<code>x y z</code>，$z=1$表示$x\lt y$；$z=0$表示$x\ge y$。<br>问这$n$对关系是否存在逻辑矛盾。</p><h2 id="解题思路-4">解题思路</h2><p>由于只有$3$个数字，可以直接暴力赋值，验证是否有情况可以满足所有关系。<br>时间复杂度：$O(3^3n)$</p><p>赛时本人直接对给定的关系集进行判断，会很麻烦，需要注意很多细节；<br>还有大佬用Floyd算法求偏序关系//%%%</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;array&lt;ll,3&gt;&gt; cmp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pending</span><span class="params">(array&lt;ll,<span class="number">4</span>&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y,o]:cmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="number">1</span>) &#123; <span class="keyword">if</span>(a[x]&gt;=a[y]) <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">if</span>(a[x]&lt;a[y]) <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//判断是否满足所有关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y,o;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cmp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; o;</span><br><span class="line">        cmp.<span class="built_in">pb</span>(&#123;x,y,o&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">FORLL</span>(k,<span class="number">1</span>,<span class="number">3</span>) ans|=<span class="built_in">pending</span>(&#123;<span class="number">0</span>,i,j,k&#125;);</span><br><span class="line">    <span class="comment">//存在满足所有关系的情况即可</span></span><br><span class="line">    cout &lt;&lt; (ans?YES:NO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.智乃的相亲活动</h1><p><strong>建图、概率论</strong></p><h2 id="题意-5">题意</h2><p>有$n$名男嘉宾和$m$名女嘉宾，异性之间存在$k$对双向的好感关系。<br>每位男嘉宾和女嘉宾都会从ta喜欢的异性中均匀随机的选择一个，<br>被至少选中一次的嘉宾称为“心动嘉宾”。<br>求本次相亲活动中，心动男嘉宾和女嘉宾的期望数量。</p><h2 id="解题思路-5">解题思路</h2><p>建图：对每对好感关系，建立一条从男嘉宾到女嘉宾的无向边。<br>对于任一嘉宾$i$：<br>ta喜欢的每位嘉宾被ta选中的概率为$\frac{1}{deg_i}$；<br>ta成为心动嘉宾的概率为$1-\prod_{j\in like_i}(1-\frac{1}{deg_j})$，其中$like_i$为ta喜欢的嘉宾集合（因为好感关系为双向）。</p><p>分别求出每位嘉宾成为心动嘉宾的概率，再对男女嘉宾分别求和即可。</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+m+<span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">deg</span><span class="params">(n+m+<span class="number">1</span>)</span></span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;  </span><br><span class="line">        G[u].<span class="built_in">pb</span>(n+v);</span><br><span class="line">        G[n+v].<span class="built_in">pb</span>(u);</span><br><span class="line">        deg[u]++;</span><br><span class="line">        deg[n+v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ansn,ansm,t;</span><br><span class="line">    ansn=ansm=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:G[i])&#123;</span><br><span class="line">            <span class="built_in">multo</span>(t,<span class="built_in">mdiv</span>(deg[x]<span class="number">-1</span>,deg[x]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ansn,<span class="built_in">sub</span>(<span class="number">1</span>,t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,n+<span class="number">1</span>,n+m)&#123;</span><br><span class="line">        t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:G[i])&#123;</span><br><span class="line">            <span class="built_in">multo</span>(t,<span class="built_in">mdiv</span>(deg[x]<span class="number">-1</span>,deg[x]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addto</span>(ansm,<span class="built_in">sub</span>(<span class="number">1</span>,t));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;modint&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ansn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ansm &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.智乃的“黑红树”</h1><p><strong>数据结构</strong></p><h2 id="题意-6">题意</h2><p>定义“黑红树”满足以下条件：</p><ol><li>一棵以黑色节点$1$为根的二叉树</li><li>每个节点只能有$0$或$2$个子节点。</li><li>黑色节点的子节点只能是红色；红色节点的子节点只能是黑色。</li></ol><p>给定黑红节点的数量$a,b$，构造一棵黑红树。</p><h2 id="解题思路-6">解题思路</h2><p>根据定义$1,2$，黑色节点的个数必须为奇数，红色节点的个数必须为偶数，因此$a$必须为奇数，$b$必须为偶数。<br>根据定义$3$，节点颜色将由节点的深度决定。</p><p>在满二叉树的情况下：</p><ol><li>如果最后一层是黑色节点，则节点数满足$a=2*b+1$</li><li>如果最后一层是红色节点，则节点数满足$b=2*a$</li></ol><p>利用这两个关系，可以再排除不合法的情况，剩余的情况都可以构造。</p><p>本人选用的构造方法为：按照层序遍历顺序铺设节点，直到节点数达到要求。</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ub=a+b;</span><br><span class="line">    <span class="keyword">if</span>((a%<span class="number">2</span>==<span class="number">0</span>)||b%<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="comment">//奇偶性不符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(b&gt;<span class="number">2</span>*a||a<span class="number">-1</span>&gt;<span class="number">2</span>*b)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="comment">//节点数超出临界值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ll i=<span class="number">2</span>,st=<span class="number">1</span>,ed=<span class="number">1</span>;a--;</span><br><span class="line">    <span class="comment">//[st,ed]为上一层的节点范围，i为当前节点编号</span></span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">son</span><span class="params">(ub+<span class="number">5</span>,pll(<span class="number">-1</span>,<span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(a||b)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,st,ed)&#123;<span class="comment">//铺设红色节点</span></span><br><span class="line">            <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            son[j]=<span class="built_in">pll</span>(i,i+<span class="number">1</span>);</span><br><span class="line">            i+=<span class="number">2</span>;b-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st=ed+<span class="number">1</span>;ed=i<span class="number">-1</span>;<span class="comment">//更新本层的节点范围</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,st,ed)&#123;<span class="comment">//铺设黑色节点</span></span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(son[j].first==<span class="number">-1</span>)&#123;</span><br><span class="line">                son[j]=<span class="built_in">pll</span>(i,i+<span class="number">1</span>);</span><br><span class="line">                i+=<span class="number">2</span>;a-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st=ed+<span class="number">1</span>;ed=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,ub) cout &lt;&lt; son[i].first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; son[i].second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>LM.智乃的36倍数(easy+normal)</h1><p><strong>模数</strong></p><h2 id="题意-7">题意</h2><p>给定$n$个$10^{18}$范围内的非负整数。<br>求在其中取不同的$2$个元素，拼接起来后能被$36$整除的方案数。</p><h2 id="解题思路-7">解题思路</h2><p>假设$a$和$b$拼接，拼接后的数记为$c=a\times10^k+b$，其中$k$为$b$的位数。<br>可以发现：</p><p>$$c\%36=(a\times10^k+b)\%36 =(a\times10^k)\%36+b\%36 =(a\%36)\times(10^k\%36)+b\%36$$</p><p>因此，预处理$10^k\%36$的值，记录每个数对$36$的余数及其位数。<br>计算时，枚举每个数作为右半部分$b$，此时$k$也被确定为$b$的位数，<br>只需枚举左半部分$a$的余数，对满足条件的部分求和即可。</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; DM;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;<span class="comment">//预处理10^k%36</span></span><br><span class="line">    ll t=<span class="number">1</span>;</span><br><span class="line">    DM.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">19</span>)&#123;</span><br><span class="line">        t*=<span class="number">10</span>;</span><br><span class="line">        DM.<span class="built_in">pb</span>(t%<span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dig</span><span class="params">(ll x)</span></span>&#123;<span class="comment">//求位数</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123; x/=<span class="number">10</span>; ret++; &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll t;pll tp;</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    vector&lt;pll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        tp=<span class="built_in">make_pair</span>(t%<span class="number">36</span>,<span class="built_in">dig</span>(t));</span><br><span class="line">        v.<span class="built_in">pb</span>(tp);</span><br><span class="line">        mp[t%<span class="number">36</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v)&#123;</span><br><span class="line">        t=x.second;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">35</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i*DM[t]+x.first)%<span class="number">36</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=mp[i];</span><br><span class="line">                <span class="keyword">if</span>(i==x.first) ans--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
            <tag> 竞赛笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假02</title>
      <link href="/posts/ACM_2024Winter_NCD02.html"/>
      <url>/posts/ACM_2024Winter_NCD02.html</url>
      
        <content type="html"><![CDATA[<h1>A.Tokitsukaze and Bracelet</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>装备有$a,b,c$三个值，每个值分别对应一个强化等级，求装备的总强化等级。</p><h2 id="解题思路">解题思路</h2><p>根据每项数值判断强化等级，然后求和即可。</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b,c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">150</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">200</span>) ans+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;<span class="number">32</span>&amp;&amp;b&lt;<span class="number">41</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b&gt;<span class="number">42</span>) ans+=<span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span>(c&gt;<span class="number">32</span>&amp;&amp;c&lt;<span class="number">41</span>) ans+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;<span class="number">42</span>) ans+=<span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.Tokitsukaze and Cats</h1><p><strong>模拟</strong></p><h2 id="题意-2">题意</h2><p>上场关鸡，这场关猫//<br>有$n$只猫，在$(n,m)$大小的矩阵中，每只猫占据一个格子，坐标给定。<br>每只猫的四面需要围上围栏，求需要多少根围栏。</p><h2 id="解题思路-2">解题思路</h2><p>模拟，一只一只放入，根据已经放入的猫的位置，判断需要增加多少根围栏。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> v[<span class="number">305</span>][<span class="number">305</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll x,y,cnt;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x<span class="number">-1</span>][y<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;v[x<span class="number">-2</span>][y<span class="number">-1</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;n&amp;&amp;v[x][y<span class="number">-1</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;<span class="number">1</span>&amp;&amp;v[x<span class="number">-1</span>][y<span class="number">-2</span>]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;m&amp;&amp;v[x<span class="number">-1</span>][y]) cnt++;</span><br><span class="line">        <span class="keyword">switch</span>(cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: ans+=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: ans+=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: ans+=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: ans+=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.Tokitsukaze and Slash Draw</h1><p><strong>图论</strong></p><h2 id="题意-3">题意</h2><p>有一堆$n$张卡牌的牌堆。<br>有$m$种操作，第$i$种操作可以将牌堆顶的前$a_i$张卡牌按原本的顺序放置在牌堆底，代价为$b_i$.<br>求将牌堆<strong>从下往上数</strong>第$k$张卡牌放到牌堆顶的最小代价。</p><h2 id="解题思路-3">解题思路</h2><p>将牌堆看作一个有向图，$n$个位置代表$n$个节点。<br>第$i$种操作可以看作从每个顶点引出一条指向向后$a_i$个节点的边，边权为$b_i$。<br>求从第$n-k$个节点（从上往下数）到第$0$个节点的最短路即可。<br>由于总边数来到了$mn=5\times10^6$，最短路算法可以用$O(m\log n)$的Dijkstra。</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  ll v, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  ll dis, u;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line">ll dis[N], vis[N];</span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(ll n, ll s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ll u = q.<span class="built_in">top</span>().u;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            ll v = ed.v, w = ed.w;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    ll a,b,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n) e[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) e[i].<span class="built_in">push_back</span>((edge)&#123;(i+a)%n,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dis[n-k]==INF) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dis[n-k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.F.Tokitsukaze and Eliminate(easy+hard)</h1><p><strong>贪心</strong></p><h2 id="题意-4">题意</h2><p>$n$个宝石排成一排，第$i$个宝石的颜色为$col_i$<br>每次操作可以任选一种颜色，消除这种颜色的最右端的宝石和它右边的所有宝石。<br>问最少需要多少次操作才能消除所有宝石。</p><h2 id="解题思路-4">解题思路</h2><p>贪心，从右往左扫描，直到从当前位置到最右端。<br>这一区间内的宝石，包含了当前剩余的所有颜色，操作消除。<br>当前剩余颜色可在读入时处理前缀和</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt; v,sc;<span class="comment">//sc[i]记录位置i之前出现过的颜色数量</span></span><br><span class="line">    v.<span class="built_in">pb</span>(<span class="number">0</span>);sc.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">pb</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(mp[t]==<span class="number">0</span>) &#123;sc.<span class="built_in">pb</span>(sc[i<span class="number">-1</span>]+<span class="number">1</span>);mp[t]++;&#125;</span><br><span class="line">        <span class="keyword">else</span> sc.<span class="built_in">pb</span>(sc[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    t=<span class="number">0</span>;<span class="comment">//t记录当前的颜色数量</span></span><br><span class="line">    ll r=n,ans=<span class="number">0</span>;<span class="comment">//r记录当前剩余宝石数量</span></span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[v[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">            t++;</span><br><span class="line">            mp[v[i]]=<span class="number">1</span>;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==sc[r])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            t=<span class="number">0</span>;mp.<span class="built_in">clear</span>();</span><br><span class="line">            r=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.Tokitsukaze and Power Battle (esay)</h1><p><strong>数据结构</strong></p><h2 id="题意-esay-version">题意 (esay version)</h2><p>有一个长度为$n$的<strong>非负</strong>整数数组，有$q$次操作：</p><ol><li><code>1 i x</code>：将第$i$个数改为$x$</li><li><code>2 l r</code>：查询区间$[l,r]$内，每个长度不小于$2$的<strong>子区间</strong>，任意分成连续两段后，<code>左段之和减去右段之和</code>的最大值。</li></ol><h2 id="解题思路-5">解题思路</h2><p>实现单点修改、区间查询的数据结构，可以选用线段树或树状数组（本人采用树状数组）。<br>根据贪心的思想，由于数组非负，要最大化<code>左段之和减去右段之和</code>，子区间的左端点选定查询区间的左端点。<br>从右往左枚举右端点，并在分段时，右段只需留下一个数即可。</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))<span class="comment">//取最后一个1所在位置的权值</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BITree</span>&#123;<span class="comment">//树状数组，下标i从1开始</span></span><br><span class="line">    vector&lt;ll&gt; Data;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BITree</span><span class="params">(ll n)</span>:Data(n*<span class="number">2</span>+<span class="number">5</span>,<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll i,ll dif)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//给予i增量dif,维护树状数组，O(logn)</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;Data.<span class="built_in">size</span>())&#123;</span><br><span class="line">            Data[i]+=dif;</span><br><span class="line">            i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">presum</span><span class="params">(ll i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//查询前缀和sum[i]，O(logn)</span></span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            sum+=Data[i];</span><br><span class="line">            i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll l,ll r)</span></span>&#123;<span class="comment">//查询区间和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">presum</span>(r)-<span class="built_in">presum</span>(l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,Q,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="function">BITree <span class="title">bt</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        bt.<span class="built_in">update</span>(i,t);<span class="comment">//维护原数组，实现单点修改，区间查询</span></span><br><span class="line">    &#125;<span class="comment">//建树</span></span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        ll l,r;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            r=r-bt.<span class="built_in">query</span>(l,l);</span><br><span class="line">            bt.<span class="built_in">update</span>(l,r);</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans=-INF;</span><br><span class="line">            <span class="built_in">FORLL_rev</span>(i,r,l+<span class="number">1</span>)&#123;<span class="comment">//枚举右端点</span></span><br><span class="line">                <span class="keyword">if</span>(ans&gt;=bt.<span class="built_in">query</span>(l,i)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//优化：如果当前答案已经大于接下来的区间前缀和，则不必再继续枚举</span></span><br><span class="line">                ans=<span class="built_in">max</span>(ans,bt.<span class="built_in">query</span>(l,i<span class="number">-1</span>)-bt.<span class="built_in">query</span>(i,i));</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>I.Tokitsukaze and Short Path (plus)</h1><p><strong>思维</strong></p><h2 id="题意-5">题意</h2><p>给定一个有$n$个点的完全图（每两点之间有一条边），每个点$i$具有点权$a_i$。<br>每两个点之间的边权为这两点点权<strong>较大</strong>的值的2倍。<br>求每两个点之间的最短路之和：$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}dist(i,j)$</p><h2 id="解题思路-6">解题思路</h2><p>$n\le 2e5$ 的数据范围，首先排除建图暴算</p><p>对于任意两点$u,v$：<br>假设$u&gt;v$，那么$e(u,v)$（$u,v$之间的直接边）的权值为$2a_u$。<br>除$u$之外的任意点$w$，$e(u,w)$的权值为$2max{a_u,a_w}\ge a_u$，因此经过任意点$w$再到$u$的路径都不会比$e(u,v)$更短。<br>因此，对于任意两点$u,v$，$e(u,v)$是$u$到$v$的最短路。</p><p>对所有点权升序排序，点权的位次也是这个点权对答案贡献的次数。<br>时间复杂度：$O(n)$</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">create_vec</span>(v,n);</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) ans+=v[i]*i;</span><br><span class="line">    cout &lt;&lt; ans*<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//*4的含义：边权有系数2；每两个点互相到达要计算2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.Tokitsukaze and Short Path (minus)</h1><p><strong>思维</strong></p><h2 id="题意-6">题意</h2><p>给定一个有$n$个点的完全图（每两点之间有一条边），每个点$i$具有点权$a_i$。<br>每两个点之间的边权为这两点点权<strong>较小</strong>的值的2倍。<br>求每两个点之间的最短路之和：$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}</p><h2 id="解题思路-7">解题思路</h2><p>对于任意两点$u,v$：<br>假设$u&lt;v$，那么$e(u,v)$（$u,v$之间的直接边）的权值为$2a_v$。<br>又假设$u,v$都不是点权最小的点，对于图中点权最小的点$w$，$u\rightarrow v\rightarrow w$的路径长度为$4a_w$（两条边）。<br>那么$dist(u,v)=min{4a_w,2a_v}$<br>因此，每个点为$min{2a_w,a_v}$在对答案做贡献</p><p>对所有点权降序排序，点权的位次也是这个点（$min{2a_w,a_v}$）对答案贡献的次数</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    ll mn=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mn=<span class="built_in">min</span>(mn,t);</span><br><span class="line">        v.<span class="built_in">pb</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) ans+=<span class="built_in">min</span>(mn*<span class="number">2</span>,v[i])*(n-i<span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; ans*<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//*4的含义：边权有系数2；每两个点互相到达要计算2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.Tokitsukaze and Password (easy)</h1><p><strong>暴力</strong></p><h2 id="题意-7">题意</h2><p>给定一个长度为$n$的字符串$x$，其中包含数字、小写字母和下划线‘_’，用来表示一个纯数字密码。<br>密码满足以下条件：</p><ol><li>密码没有前导$0$</li><li>密码可以被$8$整除</li><li>给定另一个长度为$n$的数字$y$，保证$x\lt y$</li><li>每种字母表示$[0,9]$中的一个，且不同字母表示的数字必定不同</li><li>每一位下划线‘_’都可以表示$[0,9]$中的任意一个数字，下划线上的数字不必相同</li></ol><p>求可能成为密码的数量</p><h2 id="解题思路-8">解题思路</h2><p>由于easy version的数据范围极小，暴力枚举判断是否满足条件即可<br>(srd有点考验耐心细心qwq)</p><h2 id="参考程序-8">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ll n,y;</span><br><span class="line">string sx;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ub;<span class="comment">//记录待定字符的取值上界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pending</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vk)</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(sx[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(sx[<span class="number">0</span>])&amp;&amp;vk[sx[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sx[<span class="number">0</span>]==<span class="string">&#x27;_&#x27;</span>&amp;&amp;vk[<span class="number">4</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不含前导0</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">3</span>) <span class="keyword">if</span>(ub[i])</span><br><span class="line">        <span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(ub[j]&amp;&amp;vk[i]==vk[j]) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不同字母取值不同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:sx)&#123;</span><br><span class="line">        x*=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) x+=c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(c)) x+=vk[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x+=vk[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">8</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不是8的倍数</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//大于y</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sy;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">    y=<span class="built_in">stoll</span>(sy);</span><br><span class="line">    ub.<span class="built_in">clear</span>();</span><br><span class="line">    ub.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:sx) <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:ub[<span class="number">0</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:ub[<span class="number">1</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:ub[<span class="number">2</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:ub[<span class="number">3</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;_&#x27;</span>:ub[<span class="number">4</span>]=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vk;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(a,<span class="number">0</span>,ub[<span class="number">0</span>]) <span class="built_in">FORLL</span>(b,<span class="number">0</span>,ub[<span class="number">1</span>]) <span class="built_in">FORLL</span>(c,<span class="number">0</span>,ub[<span class="number">2</span>]) <span class="built_in">FORLL</span>(d,<span class="number">0</span>,ub[<span class="number">3</span>]) <span class="built_in">FORLL</span>(e,<span class="number">0</span>,ub[<span class="number">4</span>])&#123;</span><br><span class="line">        vk.<span class="built_in">clear</span>();</span><br><span class="line">        vk.<span class="built_in">pb</span>(a);vk.<span class="built_in">pb</span>(b);vk.<span class="built_in">pb</span>(c);vk.<span class="built_in">pb</span>(d);vk.<span class="built_in">pb</span>(e);</span><br><span class="line">        ans+=<span class="built_in">pending</span>(vk);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
            <tag> 竞赛笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2024牛客寒假01</title>
      <link href="/posts/ACM_2024Winter_NCD01.html"/>
      <url>/posts/ACM_2024Winter_NCD01.html</url>
      
        <content type="html"><![CDATA[<h1>A.DFS搜索</h1><p><strong>1签</strong></p><h2 id="题意">题意</h2><p>题目字面意思，问能不能在长度为 $n$ 的字符串 $s$ 中找到子序列&quot;DFS&quot;和&quot;dfs&quot;；</p><h2 id="解题思路">解题思路</h2><p>直接暴力搜索<br>时间复杂度 $O(n)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,s1,s2;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s1=<span class="string">&quot;DFS&quot;</span>;s2=<span class="string">&quot;dfs&quot;</span>;</span><br><span class="line">    <span class="type">int</span> cnt1,cnt2;cnt1=cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1&lt;<span class="number">3</span>&amp;&amp;c==s1[cnt1]) cnt1++;</span><br><span class="line">        <span class="keyword">if</span>(cnt2&lt;<span class="number">3</span>&amp;&amp;c==s2[cnt2]) cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt1&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">1</span>; <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>; cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt2&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">1</span>; <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span>; cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B.关鸡</h1><p><strong>模拟</strong></p><h2 id="题意-2">题意</h2><p>有一条宽为$2$，长为$2*10^9+1$的管道，每个格子的坐标标记为$(x,y)$，$x\in[-10^9,10^9],y\in [1,2]$<br>管道内有$n$个障碍，给定障碍的坐标<br>鸡哥在$(0,1)$处，可以上下左右移动，但不能穿过障碍<br>求最少还需多少个障碍物才能使鸡哥被困在管道内无法到达管道两端</p><h2 id="解题思路-2">解题思路</h2><p>将管道两排看作两侧，如果某处有障碍（下图红），只要它的另一侧相邻的位置中有一个有障碍（下图黄）即可堵住管道：<br><img src="https://source.cclmsy.cc/Posts/ACM/2024Winter_NCD01_B.png" alt="alt text"><br>换个角度，从管道左端到右端，对于每个障碍，check它对面且与它的$x$距离不大于$1$的位置是否有障碍，即可确定是否堵住管道。</p><p>要把鸡哥困在管道内，需要把鸡哥两侧管道全都堵住。</p><p>对于鸡哥的一侧管道，如果：<br>没有堵住，没有障碍，则需放置$2$个障碍；<br>没有堵住，至少有$1$个障碍，则需放置$1$个障碍；<br>已经堵住，则不需要放置障碍。</p><p>特别的，和鸡哥直接相邻的3个位置如果都有障碍，鸡哥就直接被困住了。</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> f,fl,fr; f=fl=fr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v)&#123;</span><br><span class="line">        cin &gt;&gt; x.second &gt;&gt; x.first; <span class="comment">// 为了方便排序，将x轴坐标放在前面</span></span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">-1</span>&amp;&amp;x.second==<span class="number">1</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">0</span>&amp;&amp;x.second==<span class="number">2</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(x.first==<span class="number">1</span>&amp;&amp;x.second==<span class="number">1</span>) f++;<span class="comment">//和鸡哥直接相邻的障碍数</span></span><br><span class="line">        <span class="keyword">if</span>(x.first&lt;=<span class="number">0</span>) fl=<span class="number">1</span>;<span class="comment">//鸡哥左侧有障碍</span></span><br><span class="line">        <span class="keyword">if</span>(x.first&gt;=<span class="number">0</span>) fr=<span class="number">1</span>;<span class="comment">//鸡哥右侧有障碍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    <span class="type">int</span> ffl,ffr;ffl=ffr=<span class="number">0</span>;<span class="comment">//记录左右两侧是否被堵住</span></span><br><span class="line">    deque&lt;pll&gt; dq;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>()&amp;&amp;v[i].first-dq.<span class="built_in">front</span>().first&gt;<span class="number">1</span>) dq.<span class="built_in">pop_front</span>();<span class="comment">//dq只保存[x-1,x]内的障碍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:dq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.second!=v[i].second)&#123;<span class="comment">//如果有不同侧的障碍即堵住管道</span></span><br><span class="line">                <span class="keyword">if</span>(v[i].first&lt;=<span class="number">0</span>) ffl=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> ffr=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;dq.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">3</span>-f;<span class="comment">//直接围堵鸡哥</span></span><br><span class="line">    <span class="keyword">if</span>(ffl&amp;&amp;ffr) ans=<span class="built_in">min</span>(ans,<span class="number">0ll</span>);<span class="comment">//左右两侧都被堵住，无需添加</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ffl&amp;&amp;fr||fl&amp;ffr) ans=<span class="built_in">min</span>(ans,<span class="number">1ll</span>);<span class="comment">//一侧被堵住，另一侧有障碍，需要添加1个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ffl||ffr) ans=<span class="built_in">min</span>(ans,<span class="number">2ll</span>);<span class="comment">//一侧被堵住，另一侧无障碍，需要添加2个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fl&amp;&amp;fr) ans=<span class="built_in">min</span>(ans,<span class="number">2ll</span>);<span class="comment">//两侧没被堵住，但有障碍，需要添加2个</span></span><br><span class="line">    <span class="comment">//其余情况不如直接围堵鸡哥</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C.按闹分配</h1><p><strong>贪心</strong></p><h2 id="题意-3">题意</h2><p>$n$个人在$1$个窗口前排队办事，第$i$个人办事需要时间$t_i$<br>开始为$0$时刻，每个人的不满意度$D_i$为其办完事的时刻$D_i$<br>工作人员安排队伍顺序使得所有人的不满意度之和 $S=\sum D_i$ 最小</p><p>你也来办事，需要时间$t_c$。你可以插队，但是因此增加的不满意度之和不能超过$M$<br>问你最早什么时候能办完事</p><h2 id="解题思路-3">解题思路</h2><p>根据贪心的思想，初始使得不满意度之和最小的排序是按照$t_i$从小到大排序<br>你插队导致的不满意度之和的增量为：你插队的位置之后的人数*你的办事时间<br>因此你后面的人数不得超过 $M/t_c$ 个<br>在这个约束下计算前缀和即可</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Q,tc,M;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q &gt;&gt; tc;</span><br><span class="line">    <span class="built_in">create_vec</span>(t,n);</span><br><span class="line">    <span class="built_in">SORT</span>(t);</span><br><span class="line">    vector&lt;ll&gt; St;</span><br><span class="line">    St.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) St.<span class="built_in">pb</span>(St.<span class="built_in">back</span>()+t[i]);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin &gt;&gt; M;</span><br><span class="line">        ll x=M/tc;</span><br><span class="line">        ll pl=<span class="built_in">max</span>(<span class="number">0ll</span>,n-x);</span><br><span class="line">        cout &lt;&lt; St[pl]+tc &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>D.数组成鸡</h1><p><strong>思维</strong></p><h2 id="题意-4">题意</h2><p>给定一个长度为$n$的整数数组，每次操作可以使所有元素都$+1$或都$-1$。<br>$Q$次询问，问任意次操作后能否使数组所有元素的乘积等于给定的数$M$（$-1e9\le M \le 1e9$）。</p><h2 id="解题思路-4">解题思路</h2><p>询问的$M$范围不大，所以数组稍微长一点儿，就很可能溢出$1e9$的范围。</p><p>由于元素都是整数，若数组中绝对值大于$1$的元素的个数超过$20$个，那么乘积的绝对值最小为$2^20$，超过$1e9$。</p><p>枚举出现过的数字$x_i$，再向$x_i$两边枚举它附近的数字$t$，使全数组$-t$，然后直接计算数组的乘积进行$check$。<br>当乘积的绝对值已经超过$1e9$，即出现最多$20$个绝对值大于$1$的元素时，直接判不合法，$check$枚举的元素个数是比较少的。<br>若最终乘积的绝对值不大于$1e9$，则加入答案集合。</p><p>询问时在答案中二分查找即可。</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Q,t;cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    set&lt;ll&gt; ans; ans.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    set&lt;ll&gt; exi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        exi.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll x) -&gt; <span class="type">bool</span>&#123;</span><br><span class="line">        ll tt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y:a)&#123;</span><br><span class="line">            tt*=y+x;</span><br><span class="line">            <span class="keyword">if</span>(tt==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(tt)&gt;<span class="number">1e9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;ans.<span class="built_in">insert</span>(tt);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:exi)&#123;</span><br><span class="line">        t=-x<span class="number">-1</span>; <span class="keyword">while</span>(<span class="built_in">check</span>(t)) t--;</span><br><span class="line">        t=-x+<span class="number">1</span>; <span class="keyword">while</span>(<span class="built_in">check</span>(t)) t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">count</span>(t)) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E.本题又主要考察了贪心</h1><p><strong>DFS、诈骗</strong></p><h2 id="题意-5">题意</h2><p>$n$个人参加比赛，当前第$i$个人已经得到了$a_i$分，接下来还有$m$轮比赛<br>每轮两个人PK,赢的人$+3$分；平局则每人$+1$分<br>给定$m$轮比赛的名单，问$1$号选手能取得的最高名次</p><h2 id="解题思路-5">解题思路</h2><p>直接贪心很难贪（反正我是贪不出来）<br>由于人数和局数很少，直接DFS到每种结局，找到最优解即可<br>时间复杂度：$O(3^m)$</p><h2 id="参考程序-5">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pll&gt; q; <span class="comment">//记录每轮比赛的参赛选手</span></span><br><span class="line">ll n,m,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;ll&gt; a,ll i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==m)&#123;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:a) <span class="keyword">if</span>(x&gt;a[<span class="number">0</span>]) cnt++;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; aa=a,ab=a,ac=a;</span><br><span class="line">    aa[q[i].first<span class="number">-1</span>]+=<span class="number">3</span>;<span class="comment">//a赢</span></span><br><span class="line">    <span class="built_in">DFS</span>(aa,i+<span class="number">1</span>);</span><br><span class="line">    ab[q[i].second<span class="number">-1</span>]+=<span class="number">3</span>;<span class="comment">//b赢</span></span><br><span class="line">    <span class="built_in">DFS</span>(ab,i+<span class="number">1</span>);</span><br><span class="line">    ac[q[i].first<span class="number">-1</span>]+=<span class="number">1</span>;<span class="comment">//平局</span></span><br><span class="line">    ac[q[i].second<span class="number">-1</span>]+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">DFS</span>(ac,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans=INF;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cin &gt;&gt; x;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        q.<span class="built_in">pb</span>(&#123;u,v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(a,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>F.鸡数题！</h1><p><strong>概率论-排列组合</strong></p><h2 id="题意-6">题意</h2><p>将$n$位的最大二进制数$111\cdots 1$（n个1）的每一位$1$分配给$m$个数，且每个数都不为$0$，问有多少种分配方案</p><h2 id="解题思路-6">解题思路</h2><p>$n$个不同的球放入$m$个不同的盒子，每个盒子至少一个球，有多少种放法<br>答案为第二类斯特林数$S(n,m)$<br>通项公式：$S(n,m)=\sum\limits_{i=0}^m\dfrac{(-1)^{m-i}\times i^n}{i!\times (m-i)!}$</p><h2 id="参考程序-6">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ll pown[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        pown[i]=<span class="built_in">qcpow</span>(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Prepare_Factorium</span>(m);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">        ll t=<span class="built_in">mul</span>(pown[i],<span class="built_in">mul</span>(Fac_inv[i],Fac_inv[m-i]));</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>) t=MOD-t;</span><br><span class="line">        <span class="built_in">addto</span>(ans,t);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>G.why买外卖</h1><p><strong>贪心</strong></p><h2 id="题意-7">题意</h2><p>有$n$张外卖券，第$i$张满$a_i$减$b_i$，$a_i$为餐品原价。<br>所有券可以叠加使用，你手上有$m$元，问你最多可以购买到原价为多少的餐品</p><h2 id="解题思路-7">解题思路</h2><p>假设餐品原价为$x$，则所有$a_i&lt;x$的券都可以使用。<br>根据使用门槛$a_i$对券排序，对减免部分做前缀和。<br>在每个门槛处计算：该门槛需支付的价格$x$（或溢出的优惠）=当前门槛-减免金额<br>如果$x$小于$m$，则更新答案，当前门槛下最高餐品价格为$m+减免金额$</p><h2 id="参考程序-7">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">vp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vp) cin &gt;&gt; x.first &gt;&gt; x.second;</span><br><span class="line">    <span class="built_in">SORT</span>(vp);</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">S</span><span class="params">(n+<span class="number">1</span>)</span></span>;S[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) S[i]=S[i<span class="number">-1</span>]+vp[i<span class="number">-1</span>].second;</span><br><span class="line">    ll ans=m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vp[i<span class="number">-1</span>].first-S[i]&lt;=m)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,S[i]+m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>H.01背包，但是bit</h1><p><strong>位运算</strong></p><h2 id="题意-8">题意</h2><p>有$n$个物品，第$i$个物品的价值为$v_i$，重量为$w_i$，每个物品只有一个。<br>选定物品的重量之和定义为这些物品各自重量的“或”和，即$w=w_1|w_2|w_3|\cdots|w_c$；价值之和定义为这些物品各自重量的初等代数和：$v=\sum v_i$<br>问选定物品的重量之和不超过$m$的情况下，价值之和的最大值</p><h2 id="解题思路-8">解题思路</h2><p>或运算的性质：有$1$出$1$，全$0$出$0$。</p><p>把所有“重量”看作二进制。</p><p>假设选定物品后结果为$x$，那么$x$的每个$1bit$的位置，一定有某个被选中的物品的重量在该位上是$1bit$。</p><p>枚举所有允许出现$1$的位置的所有情况。<br>将$m$的某一$1bit$置$0$，则该位的低位可以任意取值，高位不变。<br>如$m=1010000B$，将第二个$1bit$置$0$，则$1bit$的合法位置变为$1001111$。<br>确定了$1bit$的合法位置，那每个物品只能是选或不选。<br>遍历$m$的所有$1bit$，计算将其置$0$的情况：遍历所有物品，应选尽选。<br>取所有情况的最大值。</p><h2 id="参考程序-8">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; v,w;</span><br><span class="line">ll n,m,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span>((w[i]&amp;x)==w[i])</span><br><span class="line">            t+=v[i];</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; ans=<span class="number">0</span>;</span><br><span class="line">    v.<span class="built_in">resize</span>(n); w.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">29</span>) <span class="keyword">if</span>(m&amp;(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">        <span class="built_in">Update</span>((m^(<span class="number">1</span>&lt;&lt;i))|((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//m^(1&lt;&lt;i)：m的第i位置0</span></span><br><span class="line">        <span class="comment">//(1&lt;&lt;i)-1：低i位全1</span></span><br><span class="line">    &#125;<span class="built_in">Update</span>(m);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a href="http://I.It">I.It</a>’s bertrand paradox. Again!</h1><p><strong>概率论</strong></p><h2 id="题意-9">题意</h2><p>现在有两种在$x\in [-100,100],y\in [-100,100]$平面范围内生成（圆心在整点上且半径为整数的）圆形的算法（仅第3步不同）：</p><ol><li>均匀随机生成一个 $(-100,100)$ 内的整点 $(x,y)$</li><li>均匀随机生成一个 $[1,100]$ 内的整数半径 $r$</li></ol><p>bit的检验：不满足在范围内，返回第2步，即仅重新生成$r$<br>buaa的检验：不满足在范围内，返回第1步，即重新生成一个圆</p><p>现在给出其中某个算法的生成 $10^5$ 个圆的结果，问是由哪个算法生成的</p><h2 id="解题思路-9">解题思路</h2><p>两种算法下，生成结果的圆心和半径的分布是不同的。<br>明显bit的方法圆心是均匀分布在平面内的，而buaa的方法不是。</p><p>根据抽样分布原理，大量独立同分布随机变量和的极限分布是正态分布。<br>因此对样本建立统计量，使得两种算法下，该统计量有显著不同即可。<br>此处建立的统计量$U$为：圆心到原点的距离的均值$A(\sqrt{x^2+y^2})$。<br>用两种算法生成样本，暴算得到$U_{buaa}\approx56，U_{bit}\approx 75$。</p><h2 id="参考程序-9">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        sum+=<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;sum/=n;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">65</span>) cout &lt;&lt; <span class="string">&quot;buaa-noob&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;bit-noob&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>J.又鸟之亦心</h1><p><strong>思维</strong></p><h2 id="题意-10">题意</h2><p>两个人分别在数轴的$x,y$位置。<br>接下来$n$天，第$i$天必须从两人中选择一人到$a_i$的位置。<br>记这$n$天内两人最远的距离为$D$，决策使得$D$最小，求这个最小的$D$</p><h2 id="解题思路-10">解题思路</h2><p>二分答案$D$，判断是否存在一种决策使得两人最远距离不超过$D$。</p><p>忽略两人的身份，第$i$天一定有一个人的位置在$a_i$，记录另一个人可能的位置集合$s$。<br>对于二分点，遍历每个$a_i$，更新$s$，使得$s$中的点与$a_i$的距离不超过$D$。<br>如果$s$为空，说明不存在一种决策使得两人最远距离不超过$D$。</p><h2 id="参考程序-10">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x,y;cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">create_vec</span>(a,n);</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll d) -&gt; <span class="type">bool</span>&#123;</span><br><span class="line">        set&lt;ll&gt; s;</span><br><span class="line">        ll lst=y;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-y)&gt;d) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(t-lst)&lt;=d) s.<span class="built_in">insert</span>(lst);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;*s.<span class="built_in">begin</span>()&lt;t-d) s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;*s.<span class="built_in">rbegin</span>()&gt;t+d) s.<span class="built_in">erase</span>(*s.<span class="built_in">rbegin</span>());</span><br><span class="line">            lst=t;</span><br><span class="line">        &#125;<span class="keyword">return</span> !s.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        ll mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>K.牛镇公务员考试</h1><p><strong>图论</strong></p><h2 id="题意-11">题意</h2><p>有$n$道题，每道题的题目为：“第$a_i$题的答案是（）？”<br>每题有<code>A B C D E</code>五个选项，选项的内容是字符串<code>ABCDE</code>的一个排列，记为字符串$s_i$<br>例如第$i$题的题目为：</p><p>第$a_i$题的答案是（）？<br>A. $s_i[0]$ B. $s_i[1]$ C. $s_i[2]$ D. $s_i[3]$ E. $s_i[4]$</p><p>求答对所有题目的方案数</p><h2 id="解题思路-11">解题思路</h2><p>将题目看作节点。<br>第$i$道题决定了第$a_i$道题的答案，视为一条从$i$到$a_i$的有向边。<br>同时，每个节点的出度为$1$，这意味着每个连通分量都是一个内向基环树。<br>（内向基环树：每个节点的出度为$1$的弱连通图）</p><p>反过来看，一旦确定了第$a_i$道题的答案，第$i$道题的答案也就确定了。<br>因此对于一条链，只要确定了一个节点的答案，整条链的答案也就唯一确定了。<br>显然在内向基环树中，链一定是挂在某个环上，链的答案随环的选择而唯一确定，因此可以忽略链。</p><p>对于环，先确定一个节点的答案（5种），然后递推确定整个环的答案，判断是否合法。<br>每个环的方案数在$0-4$之间</p><p>最终答案为每个连通分量方案数的乘积</p><h2 id="参考程序-11">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n ;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; s[i];</span><br><span class="line">        a[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        ll j=i;</span><br><span class="line">        <span class="keyword">while</span>(vis[j]==<span class="number">-1</span>)&#123;</span><br><span class="line">            vis[j]=i;</span><br><span class="line">            j=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[j]!=i) <span class="keyword">continue</span>;</span><br><span class="line">        vector&lt;ll&gt; cycle;<span class="comment">//环</span></span><br><span class="line">        ll k=j;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            cycle.<span class="built_in">push_back</span>(k);</span><br><span class="line">            k=a[k];</span><br><span class="line">        &#125;<span class="keyword">while</span>(k!=j);</span><br><span class="line">        ll res=<span class="number">0</span>,t;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">            t=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:cycle) t=s[x][t]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(t==i) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">multo</span>(ans,res);</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>L.要有光</h1><p><strong>诈骗题</strong></p><h2 id="题意-12">题意</h2><p>给了一些几何形状的方程，求在<strong>地面</strong>（$z=0$）上的最大阴影面积</p><h2 id="解题思路-12">解题思路</h2><p>题目拐弯抹角吓唬人///<br>保证符合题意的状态是光源处于$xOy$平面上($z=0$)。<br>目的是求一个$xOy$平面上的梯形阴影的面积。<br>上底长$2w$，下底长$4w$，高为$c$，面积为$3wc$。</p><h2 id="参考程序-12">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll c,d,h,w;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; d &gt;&gt; h &gt;&gt; w;</span><br><span class="line">    cout &lt;&lt; w*<span class="number">3</span>*c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>M.牛客老粉才知道的秘密</h1><p><strong>2签</strong></p><h2 id="题意-13">题意</h2><p>某场比赛一共有$n$道题目，但每面只能显示$6$道。<br>点击<code>下一页</code>时，如果后面的题目足够$6$题，则显示下面的$6$题，否则显示最后6题。<br>点击<code>上一页</code>时，如果前面的题目足够$6$题，则显示上面的$6$题，否则显示最前6题。<br>求比赛中可能出现在第一题位置的题目数量。</p><h2 id="解题思路-13">解题思路</h2><p>如果题目数量是$6$的倍数，那页面可能的题目排布为$n/6$。<br>如果题目数量不是$6$的倍数，<br>从第一页到最后一页，可能的题目排布为$n/6+1$；<br>从最后一页到第一页，可能的题目排布为$n/6+1$。<br>去除首页尾页，可能的题目排布为$(n/6)*2$。</p><h2 id="参考程序-13">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">6</span>==<span class="number">0</span>) cout &lt;&lt; n/<span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; n/<span class="number">6</span>*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024牛客寒假 </tag>
            
            <tag> 竞赛笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库原理》课程笔记</title>
      <link href="/posts/database_principles.html"/>
      <url>/posts/database_principles.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述（理解、记忆）">一、概述（理解、记忆）</h2><h3 id="1-2-基本知识">1.2. 基本知识</h3><h4 id="1-数据、数据库">1. 数据、数据库</h4><ul><li>数据：表示客观事物的符号。</li><li>数据类型：文本、图形、图像、声音等。</li><li>数据库：<strong>长期存储</strong>在计算机内、<strong>有组织</strong>的、<strong>可共享</strong>的大量数据的集合。</li></ul><h4 id="2-数据的特征">2. 数据的特征</h4><ul><li>静态特征：数据结构、数据联系、数据约束</li><li>动态特征：数据操作</li></ul><h4 id="2-数据库的特点">2. 数据库的特点</h4><p>1.长期存储 2.有组织 3.可共享</p><h4 id="3-数据库管理系统（DBMS）">3. 数据库管理系统（DBMS）</h4><ul><li>定义：提供给用户，并帮助用户建立、使用和管理数据库的软件系统。</li><li><strong>是数据库系统（DBS）的核心</strong>。</li><li>建立在操作系统之上，位于操作系统与用户之间。</li></ul><h4 id="4-数据库的主要功能（和SQL语言相对应）">4. 数据库的主要功能（和SQL语言相对应）</h4><ul><li>数据定义：数据定义语言（DDL），定义数据库的数据对象及其关系</li><li>数据操纵：数据操纵语言（DML），增删改查</li><li>事务和运行管理：数据控制语言（DCL），对数据库的安全性、完整性、并发性和恢复性进行保护控制</li><li>组织、存储和管理数据</li><li>数据库的建立和维护</li></ul><h4 id="5-数据库系统（DBS）的结构">5. 数据库系统（DBS）的结构</h4><ul><li>硬件：计算机硬件和数据库专用硬件</li><li>软件：操作系统（OS）、数据库管理系统（DBMS）（核心）、开发工具（数据库专用工具、程序设计语言）和应用系统</li><li>人员：数据库管理员（DBA）、数据库设计人员、应用程序员和最终用户</li></ul><h4 id="6-数据库管理员（DBA）的主要职责">6. 数据库管理员（DBA）的主要职责</h4><ul><li>决定数据库的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据库的安全性要求和完整性约束</li></ul><h4 id="7-数据管理技术的3个阶段">7. 数据管理技术的3个阶段</h4><ul><li>人工管理阶段<br>数据不保存、没有结构化、不独立、不共享、冗余度高</li><li>文件管理阶段<br>文件系统：数据<strong>可长期保存</strong>但没有结构化、独立性低、共享性低、冗余度高</li><li><strong>数据库系统阶段</strong><br>数据库系统：<strong>数据结构化、独立性高、共享性高、冗余度低</strong></li></ul><h3 id="1-3-数据模型">1.3. 数据模型</h3><h4 id="1-数据模型的组成">1. 数据模型的组成</h4><p>1.数据结构 2.数据操作（增删改查） 3.数据的完整性约束</p><h4 id="2-数据模型">2. 数据模型</h4><p>（实际问题） $\Rightarrow$ 概念模型（高层） $\Rightarrow$ 逻辑模型 $\Rightarrow$ 物理模型（底层）</p><h4 id="3-概念模型">3. 概念模型</h4><ol><li>概念模型：数据及其关系的图形表示。如：实体-联系图（<strong>E-R图</strong>）</li><li>要求：简单、清晰、易于理解，<strong>独立于DBMS</strong></li><li>名词解释</li></ol><ul><li>表（实体集、关系）：同一类实体的集合</li><li>元组（行、记录、实体）：客观存在且相互区别的事物</li><li>属性（列、字段、数据项）：实体所具有的特性</li><li>域（值域）：属性的取值范围</li><li>码/键：唯一标识实体的属性或属性组</li><li>候选键：唯一标识实体的最小属性组</li><li>主属性：包含在任一候选键中的属性</li><li>主键：用户选定的候选键</li><li>外键：一个实体集的属性集，它是另一个实体集的主键</li><li>超键：在键中删除一个或多个属性后，仍然能唯一标识实体的属性或属性组</li><li>全键：包含所有属性的候选键</li><li>联系：实体集之间或内部的关联。类型：一对一、一对多、多对多</li><li>元/度：表中属性的个数</li></ul><h4 id="4-逻辑模型">4. 逻辑模型</h4><ul><li>定义：概念模型的DBMS表示</li><li>分类：层次模型、网状模型、<strong>关系模型</strong>、面向对象模型等</li><li>关系模型</li></ul><ol><li>关系（表）</li><li>关系模式（表头）：关系的结构描述</li><li>关系模型的特点：满足1NF、属性和元组不重复且无序。</li><li>关系数据库：支持关系模型的数据库</li><li>关系模式的数学表达：<br>$R(U,F),U={A_1,A_2,\cdots,A_n},F={A_i\rightarrow A_j,\cdots}$</li></ol><h3 id="1-4-数据库系统结构">1.4. 数据库系统结构</h3><h4 id="1-数据库系统的模式结构">1. 数据库系统的模式结构</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据库系统</span><br><span class="line">|---应用（一个外模式可以有多个应用）</span><br><span class="line">|---DBMS</span><br><span class="line">|   |---外模式（一个DBMS可以有多个外模式）</span><br><span class="line">|   |---模式（一个）</span><br><span class="line">|   |---内模式（一个）</span><br><span class="line">|---数据库</span><br></pre></td></tr></table></figure><h4 id="2-数据库系统的三级模式结构">2. 数据库系统的三级模式结构</h4><ol><li>外模式（子模式、用户模式）：面向用户的局部数据的逻辑结构和特征的描述，数据库用户的数据视图<ul><li>一个数据库可以有多个外模式</li><li>一个外模式可以对应多个应用，一个应用只能对应一个外模式</li></ul></li><li>模式（结构模式、逻辑模式）：数据库中全体数据的逻辑结构和特征的描述<ul><li>一个数据库只有一个模式</li><li>DBMS的核心</li></ul></li><li>内模式（存储模式、物理模式）：数据库在计算机内部的表示方式和数据存储方式</li></ol><h4 id="3-数据库系统的二级映像">3. 数据库系统的二级映像</h4><ol><li>外模式/模式映像：保证了数据库的逻辑独立性</li><li>模式/内模式映像：保证了数据库的物理独立性</li><li>逻辑独立性和物理独立性合称数据独立性</li></ol><h3 id="1-5-数据库系统的体系结构">1.5. 数据库系统的体系结构</h3><ol><li>C/S结构：客户/服务器结构</li><li>B/S结构：浏览器/服务器结构</li></ol><p>外部网络（表示层）$\Leftrightarrow$ 应用服务器（处理层）$\Leftrightarrow$ 内部网络（数据层）</p><h2 id="二、关系运算">二、关系运算</h2><h3 id="2-1-关系数据语言">2.1. 关系数据语言</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关系数据语言</span><br><span class="line">|---关系演算语言</span><br><span class="line">|   |---关系代数语言（如ISBL）</span><br><span class="line">|   |---元组关系演算语言（如ALPHA）</span><br><span class="line">|   |---域关系演算语言（如QBE）</span><br><span class="line">|---关系代数/演算双重语言：结构化查询语言（SQL）</span><br></pre></td></tr></table></figure><h3 id="2-2-关系代数语言">2.2. 关系代数语言</h3><h4 id="基本运算">基本运算</h4><p>并$\cup$、差$-$、积$\times$、选择$\sigma$、投影$\pi$（注意：投影需要去重，即运算后记录数量可能变少）</p><h4 id="导出运算">导出运算</h4><p>交$\cap$、除$\div$、连接$\Join$</p><h4 id="核心运算">核心运算</h4><p>选择$\sigma$、投影$\pi$、连接$\Join$</p><h3 id="2-3-基于关系代数语言的更新运算">2.3. 基于关系代数语言的更新运算</h3><h4 id="1-插入运算">1. 插入运算</h4><p>建立一个与原表$R$具有相同属性的临时关系$T$，计算$R\cup T$</p><h4 id="2-删除运算">2. 删除运算</h4><p>建立一个与原表$R$具有相同属性的临时关系$T$，计算$R-T$</p><h4 id="3-修改运算">3. 修改运算</h4><p>先删除，再插入</p><h3 id="2-4-查询优化">2.4. 查询优化</h3><p>在做笛卡尔积前先尽可能地进行选择和投影，以减少计算量。</p><h3 id="寄巧">*寄巧</h3><p>查询不满足某条件的元组（如不能提供A的供应商）：$\pi_{SNO}(S)-\pi_{SNO}(S\Join\sigma_{PNAME=A} (P))$</p><p>查询满足多重条件的元组（如同时提供A和B的供应商）：<br>$\pi_{SNO}(S\Join\sigma_{PNAME=A} (P))\cap\pi_{SNO}(S\Join\sigma_{PNAME=B} (P))$</p><h2 id="三、数据完整性">三、数据完整性</h2><p>数据完整性是指：数据的正确性、相容性和一致性</p><ol><li>实体完整性<ul><li>定义：主属性A的值不能为空值（Not Null）</li><li>关键词：主键（Primary Key）</li></ul></li><li>参照完整性<ul><li>定义：外键列的值必须是其参照表的主键列的值或空值</li><li>关键词：外键（Foreign Key）</li></ul></li><li>用户自定义完整性<ul><li>定义：用户根据应用的需要定义的完整性约束</li><li>关键词：默认值（Default）、检查（Check）、非空（Not Null）、唯一（Unique）</li></ul></li></ol><h3 id="3-1-完整性控制机制">3.1. 完整性控制机制</h3><h4 id="1-完整性控制3个层面">1. 完整性控制3个层面</h4><ul><li>属性级（列级）：对特定属性（列）的条件约束</li><li>元组级（行级）：元组各个属性之间的约束（如售价必须大于进价）</li><li>关系级（表级）：不同元组、不同表之间的约束（如外键）</li></ul><h4 id="2-完整性控制机制具备的功能">2. 完整性控制机制具备的功能</h4><p>定义功能、检查功能、违约处理</p><h4 id="3-定义功能">3. 定义功能</h4><p>提供完善的定义完整性约束的功能</p><h4 id="4-检查功能">4. 检查功能</h4><p>对于增删改的更新操作，提供检查完整性约束违约的功能</p><p>两种检查方式：立即检查（单语句）、延迟检查（多语句）</p><h4 id="5-违约处理">5. 违约处理</h4><p>对于破坏完整性约束的更新操作，提供相应的违约处理功能</p><ol><li>拒绝更新：主键、非空、外键</li><li>置空：非主属性、外键</li><li>级联更新：把违约的更新转化为非违约更新，然后接受更新</li></ol><h2 id="四、SQL-Server">四、SQL Server</h2><h3 id="结构化查询语言（SQL-Structured-Query-Language）">结构化查询语言（SQL, Structured Query Language）</h3><h3 id="1-数据定义语言（DDL-Data-Definition-Language）">1. 数据定义语言（DDL, Data Definition Language）</h3><ul><li>相关功能：定义数据的关系及完整性约束</li><li>关键词：Create、Alter、Drop</li></ul><h3 id="2-数据操纵语言（DML-Data-Manipulation-Language）">2. 数据操纵语言（DML, Data Manipulation Language）</h3><ul><li>相关功能：操纵数据（增删改查）</li><li>关键词：Insert、Delete、Update、Select（对应增删改查）</li></ul><h3 id="3-数据控制语言（DCL-Data-Control-Language）">3. 数据控制语言（DCL, Data Control Language）</h3><ul><li>相关功能：控制数据库的安全性、完整性、并发性和恢复性</li><li>关键词：Grant、Revoke、Deny、Check</li></ul><h2 id="四（一）、数据定义语言（DDL）与完整性约束实现">四（一）、数据定义语言（DDL）与完整性约束实现</h2><h3 id="3-1-数据定义语言（DDL）">3.1. 数据定义语言（DDL）</h3><ul><li>操作：创建Create、修改ALTER、删除DROP</li><li>对象：数据库Database、表Table、视图View、索引Index、登录Login、数据库用户User、数据库角色Role、触发器Trigger、断言Assertion、过程Procedure</li><li>数据库（存储文件）属于内模式，表属于模式，视图属于外模式，索引隶属于表。</li><li>数据库和断言没有修改操作</li></ul><h3 id="3-2-数据库和表的定义">3.2. 数据库和表的定义</h3><h4 id="1-创建数据库">1. 创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> Database EBook<span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">On</span>(Name <span class="operator">=</span> <span class="string">&#x27;EBook&#x27;</span><span class="operator">&lt;</span>数据库逻辑名称<span class="operator">&gt;</span>,</span><br><span class="line">    FileName <span class="operator">=</span> <span class="string">&#x27;D:\DataBases\EBook.mdf&#x27;</span><span class="operator">&lt;</span>数据库物理名称<span class="operator">&gt;</span>,</span><br><span class="line">    <span class="comment">-- 创建前需要先创建文件夹</span></span><br><span class="line">    Size <span class="operator">=</span> <span class="number">5</span>MB<span class="operator">&lt;</span>初始大小<span class="operator">&gt;</span>,</span><br><span class="line">    FileGrowth <span class="operator">=</span> <span class="number">1</span>MB<span class="operator">&lt;</span>增长大小<span class="operator">&gt;</span>,</span><br><span class="line">    MaxSize <span class="operator">=</span> <span class="number">100</span>MB<span class="operator">&lt;</span>最大大小<span class="operator">&gt;</span>)]</span><br><span class="line">[Log <span class="keyword">On</span>(Name <span class="operator">=</span> <span class="string">&#x27;EBook_log&#x27;</span><span class="operator">&lt;</span>日志逻辑名称<span class="operator">&gt;</span>,</span><br><span class="line">    FileName <span class="operator">=</span> <span class="string">&#x27;D:\DataBases\EBook_log.ldf&#x27;</span><span class="operator">&lt;</span>日志物理名称<span class="operator">&gt;</span>,</span><br><span class="line">    Size <span class="operator">=</span> <span class="number">1</span>MB<span class="operator">&lt;</span>初始大小<span class="operator">&gt;</span>,</span><br><span class="line">    FileGrowth <span class="operator">=</span> <span class="number">5</span><span class="operator">%</span><span class="operator">&lt;</span>增长大小(可以是百分比)<span class="operator">&gt;</span>,</span><br><span class="line">    MaxSize <span class="operator">=</span> Unlimited<span class="operator">&lt;</span>最大大小(可以是无限)<span class="operator">&gt;</span>)]</span><br></pre></td></tr></table></figure><h4 id="2-删除数据库">2. 删除数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Drop</span> Database EBook</span><br></pre></td></tr></table></figure><h4 id="3-创建表">3. 创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span> SyT<span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 格式：&lt;列名&gt; &lt;数据类型&gt; [属性级完整性约束条件],</span></span><br><span class="line">    <span class="keyword">No</span> <span class="type">int</span>,</span><br><span class="line">    Name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">Unique</span>,</span><br><span class="line">    Code <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">Check</span>(Code <span class="keyword">like</span> <span class="string">&#x27;Sy[0-9][0-9][0-9][0-9]&#x27;</span>),</span><br><span class="line">    <span class="comment">-- [表级完整性约束条件]</span></span><br><span class="line">    <span class="keyword">Constraint</span> PK_SyT <span class="keyword">Primary</span> Key(<span class="keyword">No</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="4-修改表（修改表的结构，属于DDL）">4. 修改表（修改表的结构，属于DDL）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="comment">-- 添加属性：Add &lt;列名&gt; &lt;数据类型&gt; [属性级完整性约束条件]</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> Age <span class="type">int</span> <span class="keyword">Not</span> <span class="keyword">Null</span></span><br><span class="line"><span class="comment">-- 修改属性：Alter Column &lt;列名&gt; &lt;新数据类型&gt;</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Alter</span> <span class="keyword">Column</span> Name <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- 删除属性：Drop Column &lt;列名&gt;</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Drop</span> <span class="keyword">Column</span> Age</span><br></pre></td></tr></table></figure><h4 id="5-删除表">5. 删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Drop</span> <span class="keyword">Table</span> SyT</span><br></pre></td></tr></table></figure><h4 id="6-数据类型">6. 数据类型</h4><ul><li>数值型：int、float</li><li>字符型：char(n)</li><li>日期型：date</li><li>图片型：image</li></ul><h3 id="3-3-完整性约束实现">3.3. 完整性约束实现</h3><h4 id="1-实体完整性（主键）">1. 实体完整性（主键）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，属性级</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key</span><br><span class="line"><span class="comment">--建表时，关系级,可以是属性组</span></span><br><span class="line">[<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key(<span class="keyword">No</span>,Name)</span><br><span class="line"><span class="comment">--修改表时，关系级（Primary Key要求属性已为NOT NULL）</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> PK_No] <span class="keyword">Primary</span> Key(<span class="keyword">No</span>,Name)</span><br></pre></td></tr></table></figure><h4 id="2-参照完整性（外键）">2. 参照完整性（外键）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，关系级</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> FK_No] <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line"><span class="comment">--建表时，关系级</span></span><br><span class="line">[<span class="keyword">Constraint</span> FK_No] <span class="keyword">Foreign</span> Key(<span class="keyword">No</span>) <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line"><span class="comment">--修改表时，关系级，级联更新</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> FK_No] <span class="keyword">Foreign</span> Key(<span class="keyword">No</span>) <span class="keyword">References</span> CCT(<span class="keyword">No</span>)</span><br><span class="line">    <span class="keyword">On</span> <span class="keyword">Update</span> Cascade <span class="keyword">On</span> <span class="keyword">Delete</span> Cascade</span><br></pre></td></tr></table></figure><h4 id="3-用户自定义完整性（默认值、检查、非空、唯一）">3. 用户自定义完整性（默认值、检查、非空、唯一）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表时，属性级（NOT NULL只能在建表时定义）</span></span><br><span class="line"><span class="keyword">No</span> <span class="type">int</span> [<span class="keyword">Constraint</span> NN_No] <span class="keyword">Not</span> <span class="keyword">Null</span></span><br><span class="line">Name <span class="type">char</span>(<span class="number">8</span>) [<span class="keyword">Constraint</span> UQ_Name] <span class="keyword">Unique</span></span><br><span class="line"><span class="comment">--建表时，元组级</span></span><br><span class="line">[<span class="keyword">Constraint</span> SP] <span class="keyword">Check</span>(SPrice<span class="operator">&gt;</span>PPrice)</span><br><span class="line"><span class="comment">--修改表时，属性级</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> CK_Code] <span class="keyword">Check</span>(Code <span class="keyword">like</span> <span class="string">&#x27;Sy[0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line"><span class="comment">--修改表时，属性级，默认值</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Add</span> [<span class="keyword">Constraint</span> DF_No] <span class="keyword">Default</span> <span class="number">0</span> <span class="keyword">For</span> Age</span><br></pre></td></tr></table></figure><p>like：模糊查询，%表示任意多个字符，_表示一个字符，[]表示一个字符集合，[a-z]表示a到z的任意一个字符，[^a-z]表示非a到z的任意一个字符</p><h4 id="4-删除完整性约束">4. 删除完整性约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> SyT</span><br><span class="line">    <span class="keyword">Drop</span> <span class="keyword">Constraint</span> DF_No</span><br></pre></td></tr></table></figure><h2 id="四（二）、数据操纵语言（DML）与数据查询">四（二）、数据操纵语言（DML）与数据查询</h2><h3 id="4-1-数据操纵语言（DML）">4.1. 数据操纵语言（DML）</h3><ul><li>操作：增Insert、删Delete、改Update、查Select</li><li>对象：表Table、视图View</li></ul><h3 id="4-2-添加记录">4.2. 添加记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT[(<span class="keyword">No</span>,Name,Code)] <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>)</span><br><span class="line"><span class="comment">-- 一句只能添加一条记录</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>)</span><br><span class="line"><span class="comment">-- 不指定列名，列名和值一一对应</span></span><br></pre></td></tr></table></figure><h3 id="4-3-删除记录">4.3. 删除记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> SyT [<span class="keyword">Where</span> <span class="keyword">No</span><span class="operator">=</span><span class="number">1</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line"><span class="comment">-- 不加条件，删除所有记录</span></span><br></pre></td></tr></table></figure><h3 id="4-4-修改记录">4.4. 修改记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Update</span> SyT <span class="keyword">Set</span> Name<span class="operator">=</span><span class="string">&#x27;王五&#x27;</span> [<span class="keyword">Where</span> <span class="keyword">No</span><span class="operator">=</span><span class="number">2</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line"><span class="comment">-- 不加条件，修改所有记录</span></span><br></pre></td></tr></table></figure><h3 id="4-5-查询记录">4.5. 查询记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Use EBook</span><br><span class="line"><span class="keyword">Select</span> [<span class="operator">&lt;</span>行：<span class="keyword">All</span><span class="operator">/</span><span class="keyword">Distinct</span><span class="operator">/</span>Top n<span class="operator">&gt;</span>] <span class="operator">&lt;</span>列：<span class="operator">*</span><span class="operator">/</span><span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>显示名<span class="number">1</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>显示名<span class="number">2</span><span class="operator">&gt;</span>,...<span class="operator">&gt;</span> <span class="comment">--行：选择/列：投影</span></span><br><span class="line"><span class="keyword">From</span> SyT [<span class="keyword">Join</span> CCT <span class="keyword">On</span>(SyT.A<span class="operator">=</span>CCT.B)] <span class="comment">--连接</span></span><br><span class="line">[<span class="keyword">Where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>] <span class="comment">--选择</span></span><br><span class="line">[<span class="keyword">Group</span> <span class="keyword">By</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">Having</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]] <span class="comment">--分组、筛选分组</span></span><br><span class="line">[<span class="keyword">Order</span> <span class="keyword">By</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">Asc</span><span class="operator">/</span><span class="keyword">Desc</span>]] <span class="comment">--排序</span></span><br></pre></td></tr></table></figure><ol><li>笛卡尔积：<code>Select * From SyT,CCT</code></li><li>并集：<code>Select * From SyT Union Select * From CCT</code></li><li>交集：<code>Select * From SyT Intersect Select * From CCT</code></li><li>差集：<code>Select * From SyT Except Select * From CCT</code></li><li>条件表达式：<ul><li>区间：<code>Where No Between 1 And 3</code></li><li>列表：<code>Where No In(1,3)</code></li><li>匹配：<code>Where Name Like '张%'</code></li><li>空值：<code>Where Name Is Null</code></li><li>取反：<code>Where Not No=1</code></li></ul></li><li>统计（需要分组，除被统计量外，其他列必须在Group By中）：<ul><li>Count：<code>Select Count(*) From SyT</code></li><li>Sum：<code>Select Sum(No) From SyT</code></li><li>Avg：<code>Select Avg(No) From SyT</code></li><li>Max：<code>Select Max(No) From SyT</code></li><li>Min：<code>Select Min(No) From SyT</code></li></ul></li><li>嵌套查询：<code>Select … From SyT Where No In(Select No From CCT Where …)</code></li><li>Having子句：<code>Select … From SyT Group By HNo Having Count(*)&gt;1</code>，筛选满足特定条件的分组</li></ol><h2 id="专：SQL例题">专：SQL例题</h2><h3 id="创建数据库">创建数据库</h3><p>创建一个名为<code>EBook</code>的数据库，数据库文件存放在<code>D:\DataBases</code>文件夹下，数据库文件名为<code>EBook.mdf</code>，日志文件名为<code>EBook_log.ldf</code>，数据库文件初始大小为<code>5MB</code>，增长大小为<code>1MB</code>，最大大小为<code>100MB</code>，日志文件初始大小为<code>1MB</code>，增长大小为<code>5%</code>，最大大小为<code>无限</code>。</p><h3 id="创建表">创建表</h3><p>创建一个名为<code>SyT</code>的表，表中包含<code>No</code>、<code>Name</code>、<code>Code</code>三个属性，其中<code>No</code>为整型，<code>Name</code>为长度为<code>8</code>的字符型，<code>Code</code>为长度为<code>6</code>的字符型，<code>No</code>和<code>Name</code>不能为空，<code>Code</code>以<code>Sy</code>开头，后面跟着<code>4</code>位数字。</p><h3 id="添加记录">添加记录</h3><p>向<code>SyT</code>表中添加一条记录，<code>No</code>为<code>1</code>，<code>Name</code>为<code>张三</code>，<code>Code</code>为<code>Sy0001</code>。</p><h3 id="删除记录">删除记录</h3><p>删除<code>SyT</code>表中<code>No</code>为<code>1</code>的记录。</p><h3 id="添加属性">添加属性</h3><p>向<code>SyT</code>表中添加一个名为<code>Age</code>的属性，属性类型为整型，属性值不能为空。</p><h3 id="修改属性">修改属性</h3><p>将<code>SyT</code>表中<code>Name</code>属性的长度改为<code>10</code>。</p><h3 id="准备数据">准备数据</h3><p>利用以下语句创建名为<code>CCT</code>的表，并向其中添加记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span> CCT</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">No</span> <span class="type">int</span> <span class="keyword">Not</span> <span class="keyword">Null</span>,</span><br><span class="line">    Name <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">Unique</span>,</span><br><span class="line">    Code <span class="type">char</span>(<span class="number">6</span>) <span class="keyword">Primary</span> Key</span><br><span class="line">)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">4</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">5</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">6</span>,<span class="string">&#x27;周八&#x27;</span>,<span class="string">&#x27;Sy0006&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">7</span>,<span class="string">&#x27;吴九&#x27;</span>,<span class="string">&#x27;Sy0007&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> CCT <span class="keyword">Values</span>(<span class="number">8</span>,<span class="string">&#x27;郑十&#x27;</span>,<span class="string">&#x27;Sy0008&#x27;</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h3 id="实体完整性">实体完整性</h3><p>将<code>SyT</code>表中<code>No</code>、<code>Name</code>属性组设为主键。</p><h3 id="参照完整性">参照完整性</h3><p>将<code>SyT</code>表中<code>Code</code>属性修改为外键，参照<code>CCT</code>表中<code>Code</code>属性，级联更新。</p><h3 id="用户自定义完整性">用户自定义完整性</h3><p>将<code>SyT</code>表中<code>Age</code>属性的默认值设为<code>0</code>。</p><h3 id="准备数据2">准备数据2</h3><p>利用以下语句在<code>SyT</code>表中添加记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;周八&#x27;</span>,<span class="string">&#x27;Sy0006&#x27;</span>,<span class="number">25</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;吴九&#x27;</span>,<span class="string">&#x27;Sy0007&#x27;</span>,<span class="number">26</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">1</span>,<span class="string">&#x27;郑十&#x27;</span>,<span class="string">&#x27;Sy0008&#x27;</span>,<span class="number">27</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;Sy0001&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;Sy0002&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;Sy0003&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;Sy0004&#x27;</span>,<span class="number">24</span>)</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">Into</span> SyT <span class="keyword">Values</span>(<span class="number">2</span>,<span class="string">&#x27;孙七&#x27;</span>,<span class="string">&#x27;Sy0005&#x27;</span>,<span class="number">25</span>)</span><br></pre></td></tr></table></figure><h3 id="查询记录">查询记录</h3><ol><li>查询<code>SyT</code>表中年龄前5名的学生的序号、姓名、年龄。</li><li>统计<code>SyT</code>表中名为<code>张三</code>的学生的人数。</li><li>查询名字在<code>CCT</code>表中出现且在<code>SyT</code>表中未出现的学生的序号、姓名、编码。</li></ol><h2 id="五、概念模型和逻辑模型">五、概念模型和逻辑模型</h2><h3 id="5-1-概念模型（E-R图）">5.1. 概念模型（E-R图）</h3><p>1.实体：方框<br>2.属性：椭圆（主键用下划线标注）<br>3.关系：菱形<br>4.联系：线（实体与属性、实体与关系（标注1对1/1对n））</p><p><img src="ER.png" alt="ER图"></p><h3 id="5-2-逻辑模型（关系模型）">5.2. 逻辑模型（关系模型）</h3><p>主键用下划线标注，外键用波浪线标注</p><p>上图的逻辑模型：</p><p>实体：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">供应商（商号（主键）、商名、城市、电话）</span><br><span class="line">项目（项目号（主键）、项目名、单位、负责人）</span><br><span class="line">零件（零件号（主键）、名称、规格、单价）</span><br><span class="line">仓库（仓库号（主键）、面积、电话）</span><br><span class="line">职工（工号（主键）、姓名、性别、职称）</span><br></pre></td></tr></table></figure><p>关系：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">供应（商号（主键、外键）、项目号（主键、外键）、供应量）</span><br><span class="line">库存（零件号（主键、外键）、仓库号（主键、外键）、库存量）</span><br><span class="line">工作（工号（主键、外键）、仓库号（主键、外键）、合同）</span><br><span class="line">领导（工号（主键、外键）、工号（主键、外键）、职补）</span><br></pre></td></tr></table></figure><h2 id="六、关系规范化">六、关系规范化</h2><h3 id="6-1-函数依赖">6.1. 函数依赖</h3><ul><li>函数依赖：$X\rightarrow Y$，$X$决定$Y$，$Y$依赖于$X$</li><li>非平凡函数依赖：$X\rightarrow Y$，Y不是X的子集</li><li>完全函数依赖：$X\rightarrow Y$，$Y$不依赖于$X$的任何真子集，只依赖于$X$，记作$X -F\rightarrow Y$</li><li>部分函数依赖：$X\rightarrow Y$，$Y$依赖于$X$的某个真子集，记作$X -P\rightarrow Y$</li><li>传递函数依赖：$X\rightarrow Y$，$Y\rightarrow Z$，$Z$依赖于$X$，且$Y$不依赖于$X$，记作$X -T\rightarrow Z$</li></ul><h3 id="6-2-范式与关系规范化">6.2. 范式与关系规范化</h3><h4 id="1-第一范式（1NF）">1. 第一范式（1NF）</h4><ul><li>定义：所有属性都是不可分的基本数据项</li></ul><h4 id="2-第二范式（2NF）">2. 第二范式（2NF）</h4><ul><li>定义：满足1NF，且每个非主属性完全函数依赖于候选键（消除部分函数依赖）</li></ul><h4 id="3-第三范式（3NF）">3. 第三范式（3NF）</h4><ul><li>定义：满足2NF，且每个非主属性不传递函数依赖于候选键</li></ul><h4 id="4-BC范式（BCNF）">4. BC范式（BCNF）</h4><ul><li>定义：满足3NF，且任意函数依赖，$X\rightarrow Y$，$X$必包含候选键</li></ul><h4 id="5-第四范式（4NF）：不存在多值依赖">5. *第四范式（4NF）：不存在多值依赖</h4><h4 id="6-第五范式（5NF）：消除连接依赖">6. *第五范式（5NF）：消除连接依赖</h4><h3 id="6-3-关系规范化">6.3. 关系规范化</h3><h4 id="1-Amstrong公理">1. Amstrong公理</h4><ul><li>自反律：$Y\subseteq X\Rightarrow X\rightarrow Y$</li><li>增广律：$X\rightarrow Y\Rightarrow XZ\rightarrow YZ$</li><li>传递律：$X\rightarrow Y,Y\rightarrow Z\Rightarrow X\rightarrow Z$</li><li>合成律：$X\rightarrow Y,Y\rightarrow Z\Rightarrow X\rightarrow YZ$</li><li>分解律：$X\rightarrow YZ\Rightarrow X\rightarrow Y,X\rightarrow Z$</li><li>伪传递律：$X\rightarrow Y,YW\rightarrow Z\Rightarrow XW\rightarrow YZ$</li></ul><h4 id="2-函数依赖集闭包-F">2. *函数依赖集闭包$F^+$</h4><h4 id="3-属性集闭包-X-F">3. 属性集闭包$X^+_F$</h4><ul><li>已知$X$，利用函数依赖集可以计算出的最大属性集</li></ul><h4 id="4-最小函数依赖集-F-min">4. 最小函数依赖集$F_{min}$</h4><ul><li>从函数依赖集中删除冗余的函数依赖</li></ul><h4 id="5-求所有候选键">5. 求所有候选键</h4><ul><li>只在左边出现：一定属于每个候选键</li><li>只在右边出现：一定不属于任何候选键</li><li>左右都出现：可能属于候选键，闭包计算</li><li>左右都不出现：一定属于每个候选键（否则无法得到它本身）</li></ul><h2 id="七、数据安全">七、数据安全</h2><h3 id="7-1-数据保护">7.1. 数据保护</h3><p>主要包括：数据安全、数据完整、数据并发和数据恢复</p><h3 id="7-2-安全标准">7.2. 安全标准</h3><p>4组7个等级：$D,C_1,C_2,B_1,B_2,B_3,A_1$</p><h3 id="7-3-数据安全">7.3. 数据安全</h3><p>包括：用户鉴别、数据存取控制、视图、审计与数据加密</p><h4 id="1-用户鉴别">1. 用户鉴别</h4><p>鉴别方式：静态鉴别（用户名和密码）和动态鉴别（验证码）等</p><h4 id="2-数据存取控制（SQL的DCL）">2. 数据存取控制（SQL的DCL）</h4><ul><li>Grant：授权</li><li>Revoke：撤销</li><li>Deny：拒绝</li></ul><h4 id="3-视图">3. 视图</h4><ul><li>定义：从一个或多个基本表中导出的虚表，局部数据的临时体现</li><li>作用<br>（1）简化用户操作<br>（2）清晰表达查询<br>（3）同一数据可以以不同形式提供给不同用户<br>（4）在一定程度上确保了数据安全<br>（5）在一定程度上提供了逻辑独立性</li><li>数据操纵与表一致，关键词由<code>Table</code>改为<code>View</code></li><li>更新视图：（表内数据同步更新）</li></ul><h4 id="4-审计">4. 审计</h4><h4 id="5-数据加密">5. 数据加密</h4><p>常用的加密方法：替换方法、置换方法和混合方法等。</p><h2 id="八、并发控制">八、并发控制</h2><h3 id="8-1-事务">8.1. 事务</h3><ul><li>用户定义的一个数据操作序列，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。</li><li>事务中的操作一般是对数据的更新操作，包括增、删、改。</li><li>以<code>BEGIN TRANSACTION</code>语句开始，以<code>COMMIT</code>语句（正常）或<code>ROLLBACK</code>语句（异常）结束</li><li>特征：原子性、一致性、隔离性、持久性</li></ul><h3 id="8-2-并发控制错误">8.2. 并发控制错误</h3><h4 id="1-丢失修改">1. 丢失修改</h4><p>事务T1,T2同时读入同一数据并加以修改，T2的提交结果会破坏T1提交的结果</p><h4 id="2-读脏数据">2. 读脏数据</h4><p>事务T1修改数据后撤销，使得T2读取的数据与数据库中不一致</p><h4 id="3-不可重复读">3. 不可重复读</h4><p>事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果</p><h3 id="8-3-封锁：最常用的并发控制方法">8.3. 封锁：最常用的并发控制方法</h3><ol><li>排他锁（X锁），用于写操作，其他事务不允许读写，也不允许加锁</li><li>共享锁（S锁），用于读操作，其他事务允许读，不允许写，允许加S锁，不允许加X锁</li></ol><h3 id="8-4-封锁协议">8.4. 封锁协议</h3><h4 id="1-一级封锁协议">1. 一级封锁协议</h4><p>T1,T2都加X锁（解决丢失修改）</p><h4 id="2-二级封锁协议">2. 二级封锁协议</h4><p>T1加X锁，T2加S锁（解决丢失修改和不可重复读）</p><h4 id="3-三级封锁协议">3. 三级封锁协议</h4><p>T1加S锁，T2加X锁（解决丢失修改、不可重复读和读脏数据）</p><h3 id="8-5-两段锁协议和可串行化">8.5. 两段锁协议和可串行化</h3><p>满足两段锁协议一定可串行化，不满足两段锁协议也可能可串行化。</p><h3 id="8-6-封锁粒度">8.6. 封锁粒度</h3><p>粒度越细，软件复杂性和系统开销也就越小</p><h3 id="8-7-活锁">8.7. 活锁</h3><ul><li>由于授权封锁的随机性，导致事务T的封锁请求一直处于等待状态的封锁。即：T封锁一个数据对象时，T始终处于等待状态。</li><li>解决方法：采用先来先服务的授权策略。并发事务请求封锁数据对象时，按照请求封锁的先后次序依次进行授权。</li></ul><h3 id="8-8-死锁">8.8. 死锁</h3><ul><li>两个或两个以上事务在执行过程中，因争夺资源而造成的一种互相等待的现象。</li><li>预防：一次封锁、顺序封锁</li><li>诊断：超时法、等待图法</li></ul><h2 id="九、数据库恢复">九、数据库恢复</h2><h3 id="9-1-故障管理">9.1.  故障管理</h3><ul><li>事务故障：运行的事务T遭到强行终止，使T非正常结束。破坏了原子性。</li><li>系统故障：导致系统停止运转的任何事件。系统故障需要重新启动系统。</li><li>介质故障：导致外存储设备故障的任何事件。</li><li>病毒故障</li></ul><h3 id="9-2-建立冗余数据">9.2. 建立冗余数据</h3><ul><li>数据恢复的核心技术：建立冗余数据和利用冗余数据实施数据库恢复。</li><li>建立冗余数据的技术：数据转储和登记日志文件等。</li><li>数据转储分类：静态海量转储、静态增量转储、动态海量转储和动态增量转储，各自的含义。</li></ul><h2 id="十、数据库设计">十、数据库设计</h2><p>数据库设计方法：手工经验法，新奥尔良法，ER图法，3NF法等</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《概率论与数理统计》课程笔记</title>
      <link href="/posts/probability_theory.html"/>
      <url>/posts/probability_theory.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、随机事件与概率">一、随机事件与概率</h2><h3 id="1-公式">1.公式</h3><ol><li>条件概率：$P(A|B)=\frac{P(AB)}{P(B)}$</li><li>乘法公式：$P(AB)=P(A|B)P(B)=P(B|A)P(A)$</li><li>全概率公式：$P(A)=\sum_{i=1}^nP(A|B_i)P(B_i)$</li><li>贝叶斯公式：$P(B_i|A)=\frac{P(A|B_i)P(B_i)}{\sum_{i=1}^nP(A|B_i)P(B_i)}$</li><li>抽签问题：$P(A)=\frac{m}{n}$</li></ol><h3 id="2-事件独立性">2.事件独立性</h3><p>事件A,B,C相互独立 $\Leftrightarrow $ $P(ABC)=P(A)P(B)P(C),$ $P(AB)=P(A)P(B),$ $P(AC)=P(A)P(C),$ $P(BC)=P(B)P(C)$</p><h4 id="例题">例题</h4><p>$A,B,C$独立，$ABC=\varnothing,$ $P(A)=P(B)=P(C)\lt\frac{1}{2},$ $P(A\cup B\cup C)=\frac{9}{16}$,求$P(A)$</p><p>$P(A\cup B\cup C)$ $=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$ $=3P(A)-3P(A)^2+0=\frac{9}{16}$ $\Rightarrow$ $P(A)=\frac{1}{4}$或$P(A)=\frac{3}{4}$(舍)</p><h3 id="3-超几何分布">3.超几何分布</h3><ol><li>概述：$n+m$件产品中有$m$件次品，从中抽取$k$件，求其中有$i$件次品的概率</li><li>分布律：$P(X=i)=\frac{C_m^iC_{n}^{k-i}}{C_{m+n}^k}$</li></ol><h2 id="二、随机变量及其分布-数字特征">二、随机变量及其分布+数字特征</h2><h3 id="1-X-B-n-p">1. $X$ ~ $B(n,p)$</h3><ol><li>分布名称：二项分布</li><li>概述：$n$次独立重复试验中，事件A发生的次数$X$（伯努利试验）</li><li>分布律：$P(X=k)=C_n^kp^k(1-p)^{n-k}$</li><li>期望：$E(X)=np$</li><li>方差：$D(X)=np(1-p)$</li></ol><h3 id="2-X-P-lambda">2. $X$ ~ $P(\lambda)$</h3><ol><li>分布名称：泊松分布</li><li>概述：多次试验中小概率事件A发生的次数$X$</li><li>分布律：$P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda}$</li><li>期望：$E(X)=\lambda$</li><li>方差：$D(X)=\lambda$</li><li>泊松定理：对于$X$ ~ $B(n,p)$，当$n\rightarrow\infty,p\rightarrow0,np=\lambda$时，可近似认为$X$ ~ $P(\lambda)$</li></ol><h3 id="3-X-g-p">3. $X$ ~ $g(p)$</h3><ol><li>分布名称：几何分布</li><li>概述：多次试验中事件A第一次成功的次数$X$</li><li>分布律：$P(X=k)=p(1-p)^{k-1}$</li><li>期望：$E(X)=\frac{1}{p}$</li><li>方差：$D(X)=\frac{1-p}{p^2}$</li><li>无记忆性：$P(X&gt;s+t|X&gt;s)=P(X&gt;t)$</li></ol><h3 id="4-X-U-a-b">4. $X$ ~ $U(a,b)$</h3><ol><li>分布名称：均匀分布</li><li>分布函数：$F(x)=\begin{cases}0&amp;,x&lt;a \\ \frac{x-a}{b-a}&amp;,a\leq x\leq b \\ 1&amp;,x&gt;b\end{cases}$</li><li>概率密度函数：$f(x)=\begin{cases}\frac{1}{b-a}&amp;,a\leq x\leq b \\ 0&amp;,\text{其他}\end{cases}$</li><li>期望：$E(X)=\frac{a+b}{2}$</li><li>方差：$D(X)=\frac{(b-a)^2}{12}$</li></ol><h3 id="5-X-E-lambda">5. $X$ ~ $E(\lambda)$</h3><ol><li>分布名称：指数分布</li><li>分布函数：$F(x)=\begin{cases}1-e^{-\lambda x}&amp;,x\geq 0 \\ 0&amp;,x&lt;0\end{cases}$</li><li>概率密度函数：$f(x)=\begin{cases}\lambda e^{-\lambda x}&amp;,x\geq 0 \\ 0&amp;,x&lt;0\end{cases}$</li><li>期望：$E(X)=\frac{1}{\lambda}$</li><li>方差：$D(X)=\frac{1}{\lambda^2}$</li><li>$P(X&gt;t)=e^{-\lambda t}$</li><li>无记忆性：$P(X&gt;s+t|X&gt;s)=P(X&gt;t)$</li><li>与泊松分布的关系：服从$E(\lambda)$的事件，$t$时间内发生的次数$X$ ~ $P(\lambda t)$</li><li>事件下次发生的时间：$X$ ~ $E(\lambda)$，$P(X&gt;t)=e^{-\lambda t}$</li></ol><h3 id="6-X-N-mu-sigma-2">6. $X$ ~ $N(\mu,\sigma^2)$</h3><ol><li>分布名称：正态分布</li><li>分布函数：$F(x)=\frac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^xe^{-\frac{(t-\mu)^2}{2\sigma^2}}dt$</li><li>概率密度函数：$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$</li><li>期望：$E(X)=\mu$</li><li>方差：$D(X)=\sigma^2$</li><li>对称轴：$x=\mu$</li><li>拐点：$x=\mu \pm \sigma$</li><li>分布函数最大值：$f(x)_{max}=f(\mu)=\frac{1}{\sqrt{2\pi}\sigma}$</li><li>$\sigma\uparrow$：扁平 ； $\sigma\downarrow$：尖锐</li><li>$\mu\uparrow\downarrow$：左右平移，形状不变</li></ol><h3 id="7-X-N-0-1">7. $X$ ~ $N(0,1)$</h3><ol><li>分布名称：标准正态分布</li><li>分布函数：$\varPhi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^xe^{-\frac{t^2}{2}}dt$</li><li>概率密度函数：$\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$</li><li>期望：$E(X)=0$</li><li>方差：$D(X)=1$</li><li>$\varPhi(-x)=1-\varPhi(x)$</li><li>$P(a&lt;X&lt;b)=\varPhi(b)-\varPhi(a)$</li><li>$P(|X|&lt;a)=2\varPhi(a)-1$</li><li>$3\mu$原则：$P(|X-\mu|&lt;k\sigma),k=1,2,3$分别对应$0.683,0.954,0.997$</li><li>正态分布标准化：$X$ ~ $N(\mu,\sigma^2)$，$Z=\frac{X-\mu}{\sigma}$ ~ $N(0,1)$</li></ol><h2 id="三、多维随机变量及其分布">三、多维随机变量及其分布</h2><h3 id="1-二维随机分布函数的充要条件-3">1. 二维随机分布函数的充要条件(3)</h3><ol><li>右连续：$F(x+0,y)=F(x,y)$</li><li>规范性：$P(+\infty,+\infty)=1,P(-\infty,-\infty)=0$</li><li>容斥：$P(x_1\leq x\leq x_2,y_1\leq y\leq y_2)$ $=F(x_2,y_2)-F(x_1,y_2)-F(x_2,y_1)+F(x_1,y_1)$</li></ol><h3 id="2-边缘分布函数">2. 边缘分布函数</h3><ol><li>$F_X(x)=F(x,+\infty)$</li><li>$F_Y(y)=F(+\infty,y)$</li></ol><h3 id="3-联合密度函数、边缘密度函数定义">3. 联合密度函数、边缘密度函数定义</h3><ol><li>联合密度函数：$F(x,y)=\int_{-\infty}^x\int_{-\infty}^yf(x,y)dxdy$</li><li>边缘密度函数：$f_X(x)=\int_{-\infty}^{+\infty}f(x,y)dy,f_Y(y)$ $=\int_{-\infty}^{+\infty}f(x,y)dx$</li></ol><h3 id="4-二维正态分布">4. 二维正态分布</h3><ol><li>$(X,Y)$ ~ $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$</li><li>二维正态分布的边缘分布仍是正态分布：$X$ ~ $N(\mu_1,\sigma_1^2),Y$ ~ $N(\mu_2,\sigma_2^2)$</li><li>$X,Y$ 独立 $\Leftrightarrow$ $X,Y$ 无关 $\Leftrightarrow$ $\rho=0$</li></ol><h3 id="5-可加性">5. 可加性</h3><ol><li>前提：$X_i$ 独立</li><li>泊松分布：$X_i$ ~ $P(\lambda _i)$ $\Rightarrow$ $\sum X_i$ ~ $P(\sum \lambda _i)$</li><li>二项分布：$X_i$ ~ $B(n_i,p)$ $\Rightarrow$ $\sum X_i$ ~ $B(\sum n_i,p)$</li><li>正态分布：$X_i$ ~ $N(\mu _i,\sigma _i^2)$ $\Rightarrow$ $\sum k_iX_i$ ~ $N(\sum k_i\mu _i,\sum k_i^2\sigma _i^2)$</li></ol><h3 id="6-最值分布函数">6. 最值分布函数</h3><ol><li>$F_{max}(x)=P(X_1\leq x,X_2\leq x,\cdots,X_n\leq x)$ $=\prod F(x_i)$</li><li>$F_{min}(x)=P(X_1\leq x,X_2\leq x,\cdots,X_n\leq x)$ $=1-\prod (1-F(x_i))$</li></ol><h4 id="例题：已知-mathbb-X-X-1-X-2-cdots-X-n-独立同分布，且服从于-U-0-theta-，求-max-mathbb-X-、-min-mathbb-X-的密度函数-f-M-x-、-f-N-x">例题：已知$\mathbb{X}=(X_1,X_2,\cdots,X_n)$独立同分布，且服从于$U(0,\theta)$，求$\max(\mathbb{X})$、$\min(\mathbb{X})$的密度函数$f_M(x)$、$f_N(x)$</h4><p>$X_i$ ~ $U(0,\theta)$ $\Rightarrow$ $F(x)=\begin{cases}0&amp;,x&lt;0 \\ \frac{x}{\theta}&amp;,0\leq x\leq \theta \\ 1&amp;,x&gt;\theta\end{cases}$</p><p>$F_M(x)=\prod F(x_i)=(F(x))^n$ $=\begin{cases}0&amp;,x&lt;0 \\ \left(\frac{x}{\theta}\right)^n&amp;,0\leq x\leq \theta \\ 1&amp;,x&gt;\theta\end{cases}$</p><p>$\Rightarrow$ $f_M(x)=\frac{dF_M(x)}{dx}=\begin{cases}\frac{nx^{n-1}}{\theta^n}&amp;,0\leq x\leq \theta \\ 0&amp;,Otherwise\end{cases}$</p><p>$F_N(x)=1-F_M(x)=\begin{cases}1&amp;,x&lt;0 \\ 1-\left(\frac{x}{\theta}\right)^n&amp;,0\leq x\leq \theta \\ 0&amp;,x&gt;\theta\end{cases}$</p><p>$\Rightarrow$ $f_N(x)=\frac{dF_N(x)}{dx}=\begin{cases}\frac{nx^{n-1}}{\theta^n}&amp;,0\leq x\leq \theta \\ 0&amp;,Otherwise\end{cases}$</p><h2 id="专：随机变量函数的分布">专：随机变量函数的分布</h2><h3 id="1-离散型随机变量">1. 离散型随机变量</h3><ol><li>一维：$P(X=x_i)=p_i$，$Y=h(X)$ $\Rightarrow$ $P(Y=y_j)=\sum\limits_{h(x_i)=y_j}p_i$</li><li>二维：$P(X=x_i,Y=y_j)=p_{ij}$，$Z=h(X,Y)$ $\Rightarrow$ $P(Z=z_k)=\sum\limits_{h(x_i,y_j)=z_k}p_{ij}$</li></ol><h3 id="2-连续型随机变量">2. 连续型随机变量</h3><h4 id="一维例题：-X-N-0-1-Y-X-2-，求-f-Y-y">一维例题：$X$ ~ $N(0,1)$ , $Y=X^2$，求$f_Y(y)$</h4><p>第1步：写$X$的取值范围，确认$f_Y(y)$的定义域，定义域外$f_Y(y)=0$</p><p>$X\in R$ $\Rightarrow$ $Y=X^2\geq 0$</p><p>第2步：写出$X$的分布函数$F_X(x)$</p><p>$F_X(x)=\varPhi(x)$</p><p>第3步：求$Y$的分布函数$F_Y(y)$</p><p>$y\geq 0$ 时， $F_Y(y)=P(Y\leq y)=P(X^2\leq y)$ $=P(|X| \leq \sqrt{y})=2\varPhi(\sqrt{y})-1$</p><p>$\Rightarrow$ $F_Y(y)=\begin{cases}0&amp;,y&lt;0 \\ 2\varPhi(\sqrt{y})-1&amp;,y\geq 0\end{cases}$</p><p>第4步：对$F_Y(y)$求导，得$f_Y(y)$</p><p>$f_Y(y)=\frac{dF_Y(y)}{dy}=\begin{cases}0&amp;,y&lt;0 \\ y^{-\frac{1}{2}}\varphi(\sqrt{y})&amp;,y\geq 0\end{cases}$</p><h4 id="二维例题：-X-E-1-Y-U-0-1-X-Y-独立-Z-X-2Y-，求-f-Z-z">二维例题：$X$ ~ $E(1)$ , $Y$ ~ $U(0,1)$ , $X,Y$独立 , $Z=X+2Y$，求$f_Z(z)$</h4><p>第1步：写$X,Y$的取值范围，确认$f_Z(z)$的定义域，定义域外$f_Z(z)=0$</p><p>$X \geq 0$ , $Y\in [0,1]$ $\Rightarrow$ $Z=X+2Y\geq 0$</p><p>第2步：写出$X,Y$的密度函数$f_X(x)$、$f_Y(y)$</p><p>$f_X(x)=\begin{cases}e^{-x}&amp;,x\geq 0 \\ 0&amp;,Otherwise\end{cases}$</p><p>$f_Y(y)=\begin{cases}1&amp;,y\in[0,1] \\ 0&amp;,Otherwise\end{cases}$</p><p>第3步：写出$X,Y$的联合密度函数$f_{XY}(x,y)$</p><p>$f_{XY}(x,y)=f_X(x)f_Y(y)=\begin{cases}e^{-x}&amp;,x\geq 0,y\in[0,1] \\ 0&amp;,Otherwise\end{cases}$</p><p>第4步：确定积分区域（作图）</p><p>第5步：求$Z$的分布函数$F_Z(z)$</p><p>$F_Z(z)=P(Z\leq z)=P(X+2Y\leq z)=P(Y\leq \frac{z-X}{2})$</p><p>$$\begin{align}<br>\Rightarrow F_Z(z)&amp;=\begin{cases}<br>\int_0^ze^{-x}dx\int_0^{\frac{z-x}{2}}dy &amp;, z\in[0,2]   \\<br>\int_0^{z-2}e^{-x}dx\int_0^1dy+\int_{z-2}^ze^{-x}dx\int_0^{\frac{z-x}{2}}dy &amp;, z\geq 2  \\<br>0 &amp;, Otherwise<br>\end{cases}<br>\\<br>&amp;=\begin{cases}<br>\frac{1}{2}(e^{-z}+z-1) &amp;, z\in[0,2]  \\<br>1-\frac{1}{2}e^{2-z}+\frac{1}{2}e^{-z} &amp;, z\geq 2  \\<br>0 &amp;, Otherwise<br>\end{cases}<br>\end{align}<br>$$</p><p>第6步：对$F_Z(z)$求导，得$f_Z(z)$</p><p>$$<br>f_Z(z)=\frac{dF_Z(z)}{dz}=<br>\begin{cases}<br>-\frac{1}{2}e^{-z}+\frac{1}{2} &amp;, z\in[0,2]  \\<br>\frac{1}{2}e^{2-z}-\frac{1}{2}e^{-z} &amp;, z\geq 2  \\<br>0 &amp;, Otherwise<br>\end{cases}<br>$$</p><h2 id="四、随机变量的数字特征">四、随机变量的数字特征</h2><h3 id="1-数学期望">1. 数学期望</h3><p>离散型：$E(X)=\sum x_ip_i$</p><p>连续型：$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$</p><p>随机变量函数：$E(Y)=E(h(X))$</p><p>性质：</p><ol><li>$E(C)=C$</li><li>$E(CX)=CE(X)$</li><li>$E(X\pm Y)=E(X)\pm E(Y)$</li><li>$X,Y$ 独立 $\Rightarrow$ $E(XY)=E(X)E(Y)$</li></ol><h3 id="2-方差">2. 方差</h3><p>$D(X)=E(X-E(X))^2=E(X^2)-[E(X)]^2$</p><p>标准差：$\sqrt{D(X)}$</p><p>性质：</p><ol><li>$D(C)=0$</li><li>$D(X+C)=D(X)$</li><li>$D(CX)=C^2D(X)$</li><li>$D(X\pm Y)=D(X)+D(Y)\pm 2Cov(X,Y)$</li><li>$X,Y$ 独立 $\Rightarrow$ $D(X\pm Y)=D(X)+D(Y)$</li><li>$D(X)=0 \Leftrightarrow P(X=E(X))=1$</li></ol><h3 id="3-协方差">3. 协方差</h3><p>$Cov(X,Y)=E(XY)-E(X)E(Y)$</p><p>性质：</p><ol><li>$Cov(X,X)=D(X)$</li><li>$Cov(X,Y)=Cov(Y,X)$</li><li>$Cov(aX,bY)=abCov(X,Y)$</li><li>$Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)$</li><li>$Cov(X,C)=0$</li><li>$X,Y$ 独立 $\Rightarrow$ $Cov(X,Y)=0$</li></ol><h3 id="4-相关系数">4. 相关系数</h3><p>随机变量$X$的标准化：$X^*=\frac{X-E(X)}{\sqrt{D(X)}}$</p><p>相关系数：$\rho_{XY}=Cov(X^*,Y^*)=\frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}$</p><p>性质：</p><ol><li>$|\rho_{XY}|\leq 1$</li><li>$|\rho_{XY}|=1 \Leftrightarrow$ $X,Y$ 成线性关系，$\exists a,b\ s.t.\ P(Y=aX+b)=1$, $a\rho_{XY}&gt;0$</li></ol><h2 id="五、大数定律与中心极限定理">五、大数定律与中心极限定理</h2><h3 id="1-大量独立同分布随机变量和的极限分布是正态分布（基础）">1. 大量独立同分布随机变量和的极限分布是正态分布（基础）</h3><p>$E(X_i)=\mu,D(X_i)=\sigma^2,Y=\sum X_i$</p><p>$\Rightarrow$ $E(Y)=n\mu,D(Y)=n\sigma^2$</p><p>$\Rightarrow$ $Y$ ~ $N(n\mu,n\sigma^2)$</p><p>$\Rightarrow$ 标准化： $\frac{Y-n\mu}{\sigma\sqrt{n}}$ ~ $N(0,1)$</p><h3 id="2-切比雪夫不等式（重点）">2. 切比雪夫不等式（重点）</h3><p>若$E(X)=\mu,D(X)=\sigma^2$，则对任意$\epsilon&gt;0$，有$P(|X-\mu|\geq \epsilon)\leq \frac{\sigma^2}{\epsilon^2}$</p><p>落在$\mu\pm\epsilon$外的概率不超过$\frac{\sigma^2}{\epsilon^2}$</p><h3 id="3-中心极限定理">3. 中心极限定理</h3><p>$\mathbb{X}=(X_1,X_2,\cdots,X_n)$独立同分布，$E(X_i)=\mu,0\lt D(X_i)=\sigma^2\lt\infty$，则$\forall x,\lim\limits_{n\rightarrow\infty}P\left(\frac{\sum X_i-n\mu}{\sigma\sqrt{n}}\leq x\right)=\varPhi(x)$</p><h4 id="例题：每台车床有-70-的时间在工作">例题：每台车床有$70%$的时间在工作</h4><h4 id="1-100台车床，求任意时刻有70至80台车床在工作的概率">1. 100台车床，求任意时刻有70至80台车床在工作的概率</h4><p>第1步：写出单个样本$X$的期望和方差</p><p>单个车床$X$ ~ $B(1,0.7)$ $\Rightarrow$ $E(X)=0.7,D(X)=0.21$</p><p>第2步：写出样本总体$Y$的期望和方差</p><p>记任意时刻工作的车床数为$Y$，<br>$E(Y)=100E(X)=70,D(Y)=100D(X)=21$</p><p>第3步：写出所求概率，对$Y$进行标准化，并用标准正态分布分布函数表示</p><p>$P(70\leq Y\leq 80)=P\left(\frac{70-70}{\sqrt{21}}\leq \frac{Y-70}{\sqrt{21}}\leq \frac{80-70}{\sqrt{21}}\right)$ $=\varPhi\left(\frac{10}{\sqrt{21}}\right)-\varPhi(0)=\varPhi\left(2.18\right)-\varPhi(0)$</p><p>第4步：查表代入</p><h4 id="2-求以0-997的概率保证-任意时刻至少有80台车床在工作-所需的车床数">2. 求以0.997的概率保证 任意时刻至少有80台车床在工作 所需的车床数</h4><p>设所需车床数为$N$，任意某时刻工作的车床数为$X$，则$E(X)=0.7N,D(X)=0.21N$</p><p>$P(X\geq 80)=1-P(X\lt 80)$ $=1-P\left(\frac{X-0.7N}{\sqrt{0.21N}}\lt \frac{80-0.7N}{\sqrt{0.21N}}\right)$ $=1-\varPhi\left(\frac{80-0.7N}{\sqrt{0.21N}}\right)\geq 0.997$</p><p>$\Rightarrow$ $\varPhi\left(\frac{80-0.7N}{\sqrt{0.21N}}\right)\leq 0.003$ $\Rightarrow$ $\frac{80-0.7N}{\sqrt{0.21N}}\leq -2.75$</p><h3 id="4-伯努利大数定律">4*. 伯努利大数定律</h3><p>$n$次独立重复试验中，事件A发生的次数$m$，$P(A)=p$，则对任意$\epsilon&gt;0$，有$\lim\limits_{n\rightarrow\infty}P\left(\left|\frac{m}{n}-p\right|\leq \epsilon\right)=1$</p><h3 id="5-辛钦大数定律">5*. 辛钦大数定律</h3><p>$\mathbb{X}=(X_1,X_2,\cdots,X_n)$独立同分布，记$X_i=\begin{cases}1&amp;,A发生 \\ 0&amp;,A不发生\end{cases}$，则对任意$\epsilon&gt;0$，有$\lim\limits_{n\rightarrow\infty}P\left(\left|\frac{\sum X_i}{n}-p\right|\leq \epsilon\right)=1$</p><h3 id="6-切比雪夫大数定律">6*. 切比雪夫大数定律</h3><p>$\mathbb{X}=(X_1,X_2,\cdots,X_n)$不相关，$\exists E(X_i),D(X_i)&lt;\infty$，则对任意$\epsilon&gt;0$，有$\lim\limits_{n\rightarrow\infty}P\left(\left|\frac{\sum X_i}{n}-\frac{\sum E(X_i)}{n}\right|\leq \epsilon\right)=1$</p><h2 id="六、抽样分布">六、抽样分布</h2><h3 id="1-统计量">1. 统计量</h3><ol><li>样本均值：$\overline{X}=\frac{1}{n}\sum X_i$</li><li>样本方差：$S^2=\frac{1}{n-1}\sum(X_i-\overline{X})^2$</li><li>样本标准差：$S=\sqrt{S^2}$</li><li>样本$k$阶原点矩：$A_k=\frac{1}{n}\sum X_i^k$</li><li>样本$k$阶中心矩：$B_k=\frac{1}{n}\sum(X_i-\overline{X})^k$</li></ol><p>$\overline{X}=A_1$，$S^2=\frac{n-1}{n}B_2$，$B_1=0$</p><h3 id="2-X-N-mu-sigma-2">2. $X$~$N(\mu,\sigma^2)$</h3><ol><li>分布名称：正态分布</li><li>上$\alpha$分位数：$u_\alpha$</li></ol><h3 id="3-X-chi-2-n">3. $X$~$\chi^2(n)$</h3><ol><li>分布名称：卡方分布</li><li>概述：$X_1,X_2,\cdots,X_n$独立同分布，且$X_i$ ~ $N(0,1)$，则$X=\sum X_i^2$ ~ $\chi^2(n)$</li><li>上$\alpha$分位数：$\chi_\alpha^2(n)$</li><li>期望：$E(X)=n$</li><li>方差：$D(X)=2n$</li><li>$n\rightarrow\infty$时，$\chi^2(n)$近似于$N(n,2n)$</li><li>可加性：$X_i$ ~ $\chi^2(n_i)$ $\Rightarrow$ $\sum X_i$ ~ $\chi^2(\sum n_i)$</li></ol><h3 id="4-X-t-n">4. $X$~$t(n)$</h3><ol><li>分布名称：t分布</li><li>概述：$X$ ~ $N(0,1)$，$Y$ ~ $\chi^2(n)$，$X,Y$独立，$\frac{X}{\sqrt{\frac{Y}{n}}}$ ~ $t(n)$</li><li>上$\alpha$分位数：$t_\alpha(n)$</li><li>期望：$E(X)=0$ 对称性：$t_{1-\alpha}(n)=-t_\alpha(n)$</li><li>$n\rightarrow\infty$时，$t(n)$近似于$N(0,1)$</li></ol><h3 id="5-X-F-n-1-n-2">5. $X$~$F(n_1,n_2)$</h3><ol><li>分布名称：F分布</li><li>概述：$X_1$ ~ $\chi^2(n_1)$，$X_2$ ~ $\chi^2(n_2)$，$X_1,X_2$独立，$\frac{X_1/n_1}{X_2/n_2}$ ~ $F(n_1,n_2)$</li><li>上$\alpha$分位数：$F_\alpha(n_1,n_2)$</li><li>性质1：$F_{1-\alpha}(n_1,n_2)=\frac{1}{F_\alpha(n_2,n_1)}$</li><li>性质2：$P(F\leq F_\alpha(n_1,n_2))=1-\alpha$</li></ol><h3 id="6-单正态总体下的抽样分布">6.单正态总体下的抽样分布</h3><ol><li>$\overline{X}$ ~ $N(\mu,\frac{\sigma^2}{n})$</li><li>$U=\frac{\overline{X}-\mu}{\sigma}{\sqrt{n}}$ ~ $N(0,1)$</li><li>$T=\frac{\overline{X}-\mu}{S}{\sqrt{n}}$ ~ $t(n-1)$</li><li>$C=\frac{(n-1)S^2}{\sigma^2}=\frac{1}{\sigma^2}\sum(X_i-\overline{X})^2$ ~ $\chi^2(n-1)$</li></ol><h3 id="7-两正态总体下的抽样分布">7.两正态总体下的抽样分布</h3><ol><li>$\overline{X}-\overline{Y}$ ~ $N(\mu_1-\mu_2,\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2})$ $\Rightarrow$ $U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}$ ~ $N(0,1)$</li><li>$\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$ $\Rightarrow$ $T=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$</li><li>$\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2}$ ~ $F(n_1-1,n_2-1)$ $\Rightarrow$ $F=\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2}$ ~ $F(n_1-1,n_2-1)$</li></ol><p>注：$S_w^2=\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$</p><h2 id="七、参数估计（点估计）">七、参数估计（点估计）</h2><h3 id="1-矩估计">1. 矩估计</h3><p>利用样本矩去估计总体矩，建立样本矩与总体矩的关系，解出参数</p><p>$A_1=\overline{X}=E(X)$，$A_2=\frac{1}{n}\sum X_i^2=E(X^2)$，$B_2=A_2-\overline{X}^2$</p><p>$\Rightarrow$ $\mu=A_1$，$\sigma^2=B_2$</p><h3 id="2-极大似然估计">2. 极大似然估计</h3><ol><li>写出总体的密度函数$f(x;\theta)$</li><li>写出样本的似然函数$L(\theta)=\prod f(x_i;\theta)$</li><li>对$L(\theta)$取对数，得到对数似然函数$\ln L(\theta)$</li><li>对$\ln L(\theta)$求导，令其等于0，解出$\theta$的值</li><li>多个参数时，对每个参数分别求偏导，令其等于0，得到方程组，解出每个参数的值</li></ol><h3 id="3-点估计的优良性">3. 点估计的优良性</h3><ol><li>无偏性：$E(\hat{\theta})=\theta$</li><li>有效性：$D(\hat{\theta})\leq D(\tilde{\theta})$，$\hat{\theta}=\overline{X}$时最有效</li></ol><h4 id="例题：设-X-1-X-2-cdots-X-n-是来自总体-X-的样本，-X-的密度函数为-f-x-sigma-frac-1-2-sigma-e-frac-x-sigma-，其中-sigma-0-为未知参数，求-sigma-的矩估计和极大似然估计">例题：设$X_1,X_2,\cdots,X_n$是来自总体$X$的样本，$X$的密度函数为$f(x;\sigma)=\frac{1}{2\sigma}e^{-\frac{|x|}{\sigma}}$，其中$\sigma&gt;0$为未知参数，求$\sigma$的矩估计和极大似然估计</h4><p>矩估计</p><p>$E(X)=\int_{-\infty}^{+\infty}xf(x;\sigma)dx=\frac{1}{2\sigma}\int_{-\infty}^{+\infty}xe^{-\frac{|x|}{\sigma}}dx=0$，无法求出$\sigma$，故用二阶矩求解</p><p>$E(X^2)=\int_{-\infty}^{+\infty}x^2f(x;\sigma)dx=\frac{1}{2\sigma}\int_{-\infty}^{+\infty}x^2e^{-\frac{|x|}{\sigma}}dx=2\sigma^2$</p><p>$A_2=2\hat\sigma^2$，解得$\hat\sigma=\sqrt{\frac{A_2}{2}}$</p><p>极大似然估计</p><p>$L(\hat\sigma)=\prod f(x_i;\hat\sigma)=\prod\frac{1}{2\hat\sigma}e^{-\frac{|x_i|}{\hat\sigma}}=\frac{1}{2^n\hat\sigma^n}e^{-\frac{\sum|x_i|}{\hat\sigma}}$</p><p>$\ln L(\hat\sigma)=-n\ln(2\hat\sigma)-\frac{\sum|x_i|}{\hat\sigma}$</p><p>$\frac{d\ln L(\hat\sigma)}{d\hat\sigma}=-\frac{n}{\hat\sigma}+\frac{\sum|x_i|}{\hat\sigma^2}=0$，解得$\hat\sigma=\frac{\sum|x_i|}{n}$</p><h2 id="八、假设检验">八、假设检验</h2><h3 id="1-基本步骤">1. 基本步骤</h3><ol><li>建立原假设$H_0$和备择假设$H_1$，确定显著性水平$\alpha$</li><li>选取检验统计量$U$，此时拒绝域$C={|U| \ge u_\frac{\alpha}{2}}$</li><li>计算检验统计量的值$u$，若$u\in C$，则拒绝$H_0$，否则接受$H_0$</li></ol><h3 id="2-单个正态总体的假设检验">2. 单个正态总体的假设检验</h3><h4 id="H-0-mu-mu-0-，-H-1-mu-neq-mu-0">$H_0:\mu=\mu_0$，$H_1:\mu\neq\mu_0$</h4><ol><li>$\sigma^2$已知，$U=\frac{\overline{X}-\mu_0}{\sigma/\sqrt{n}}$ ~ $N(0,1)$</li><li>$\sigma^2$未知，$T=\frac{\overline{X}-\mu_0}{S/\sqrt{n}}$ ~ $t(n-1)$</li></ol><h4 id="H-0-sigma-2-sigma-0-2-，-H-1-sigma-2-neq-sigma-0-2">$H_0:\sigma^2=\sigma_0^2$，$H_1:\sigma^2\neq\sigma_0^2$</h4><p>$\chi^2=\frac{(n-1)S^2}{\sigma_0^2}$ ~ $\chi^2(n-1)$</p><h3 id="3-两个正态总体的假设检验">3. 两个正态总体的假设检验</h3><h4 id="H-0-mu-1-mu-2-，-H-1-mu-1-neq-mu-2">$H_0:\mu_1=\mu_2$，$H_1:\mu_1\neq\mu_2$</h4><ol><li>$\sigma_1^2,\sigma_2^2$已知，$U=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}$ ~ $N(0,1)$</li><li>$\sigma_1^2,\sigma_2^2$未知，$T=\frac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}$ ~ $t(n_1+n_2-2)$</li></ol><h4 id="H-0-sigma-1-2-sigma-2-2-，-H-1-sigma-1-2-neq-sigma-2-2">$H_0:\sigma_1^2=\sigma_2^2$，$H_1:\sigma_1^2\neq\sigma_2^2$</h4><p>$F=\frac{S_1^2}{S_2^2}$ ~ $F(n_1-1,n_2-1)$</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教程|NoneBot2本地部署QQ机器人</title>
      <link href="/posts/nonebot2_qqbot_deployment.html"/>
      <url>/posts/nonebot2_qqbot_deployment.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-望粥汁">-1.望粥汁</h2><p>由于go-cqhttp已不再维护，nonebot_plugin_gocqhttp插件已于2024年2月下线noneBot商店，本教程第<code>5.2</code>步之后的方法已不再适用。<br>具体替代方案请参考：<a href="https://github.com/Mrs4s/go-cqhttp/issues/2471">https://github.com/Mrs4s/go-cqhttp/issues/2471</a></p><h2 id="0-序言">0.序言</h2><ol><li>本教程主要面向<strong>Windows系统</strong>用户</li><li>教程从0开始全程详细指导，0基础萌新请放心食用🍕</li><li>如果你遇到了问题，在提问前，请仔细检查是否哪一步有遗漏。</li><li>如果你确定自己的操作没问题，可以在评论区里提问。注意留言时请填写正确的邮箱以确保能收到站长的回复。</li></ol><h2 id="1-搭建前的准备工作">1.搭建前的准备工作</h2><h3 id="1-1-需要用到的工具">1.1.需要用到的工具</h3><ul><li>一台24小时开机联网的服务器/计算机</li><li>操作系统：Windows10</li><li>文本编辑器（强烈推荐使用VSCode）</li><li>Python3.11.5</li><li>一个闲置的QQ账号</li></ul><h3 id="1-2-Python安装指南">1.2.Python安装指南</h3><p>参考我的这篇文章：<a href="/posts/Tutor_Python_Install.html">Python安装指南</a></p><p>10月2日发布了Python3.12.0版本，站长在10月5日安装机器人框架依赖时会报以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not build wheels for yarl, httptools, multidict, which is required to install pyproject.toml-based projects</span><br><span class="line">安装依赖失败! 请手动安装依赖.</span><br></pre></td></tr></table></figure><p>尝试了几种方法没有解决，故使用之前成功过的Python3.11.5版本。</p><p>Python 3.11.5官方下载链接：<a href="https://www.python.org/downloads/release/python-3115/">Python 3.11.5</a><br>国内下载速度可能会有点慢，有条件的可以通过国际网络访问。<br>站长这里提供Windows64位版本的下载：<a href="https://source.cclmsy.cc/Tools/python-3.11.5-amd64.exe">python-3.11.5-amd64</a></p><h3 id="1-3-VSCode安装指南">1.3.VSCode安装指南</h3><p>VSCode是一款轻量化的IDE，支持市面上绝大多数编程语言，具有良好的扩展性，且具有非常友好的代码补全功能。<s>是CC站长的最爱</s><br>下载完成后直接一路确定傻瓜式安装即可//部分自定义配置说明如下：<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_12.png" alt="VSCode"></p><p>VSCode官网：<a href="https://code.visualstudio.com/">Visual Studio Code</a><br>同样国内下载比较慢，站长这里提供Windows64位1.82.2版本的下载，VSCode支持软件内更新到最新版本：<a href="https://source.cclmsy.cc/Tools/VSCodeUserSetup-x64-1.82.2.exe">VSCodeUserSetup-x64-1.82.2</a></p><h2 id="2-安装Nonebot框架">2.安装Nonebot框架</h2><h3 id="2-1-创建文件夹">2.1.创建文件夹</h3><p>创建一个文件夹用于存放项目，然后用VSCode打开这个文件夹。<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_13.png" alt="InstallNonebot1"></p><h3 id="2-2-安装pipx">2.2.安装pipx</h3><p>点击“终端-新建终端”（或直接按住Ctrl+Shift+`）创建一个终端，在终端中输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --user pipx</span><br><span class="line">python -m pipx ensurepath</span><br></pre></td></tr></table></figure><p>如果出现以下提示，请调整你的账户环境变量：<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_14.png" alt="InstallNonebot2"><br>调整账户的环境变量参考：<a href="/posts/Tutor_Python_Install.html">教程|Python安装指南</a></p><p><strong>安装完成后，关闭当前VSCode窗口，重启VSCode后才会生效。</strong></p><h3 id="2-3-安装Nonebot脚手架">2.3.安装Nonebot脚手架</h3><p>创建一个终端，在终端中输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx install nb-cli</span><br></pre></td></tr></table></figure><p><img src="https://source.cclmsy.cc/Posts/BOT/BOT_15.png" alt="InstallNonebot3"><br>如果出现无法找到<code>pipx</code>命令的情况（例如出现“Command not found”字样），请确认你在上一步中账户环境变量设置正确，且<strong>完全重启</strong>VSCode。<br>如果你确信自己的所有配置完全正确，请尝试重启你的计算机。</p><h2 id="3-创建项目">3.创建项目</h2><p>在终端中输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb create</span><br></pre></td></tr></table></figure><p>选择“bootstrap (初学者或用户)”，回车。<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_16.png" alt="Create1"></p><p>等待资源加载，加载完成后进行如下配置：<br>(键盘上下键移动光标，空格选中，回车确认)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[?] 项目名称: [为你的项目取个名字吧！] (项目名称建议由英文字母和数字构成，因为部分插件可能不支持包含中文的路径)</span><br><span class="line">[?] 要使用哪些驱动器? FastAPI (FastAPI 驱动器) </span><br><span class="line">[?] 要使用哪些适配器? OneBot V11 (OneBot V11 协议) </span><br><span class="line">[?] 立即安装依赖? y</span><br><span class="line">[?] 创建虚拟环境? y</span><br></pre></td></tr></table></figure><p><img src="https://source.cclmsy.cc/Posts/BOT/BOT_17.png" alt="Create2"><br>脚手架会自动创建并引入所需的依赖包。</p><p>最后选择安装内置插件<code>echo</code>，这是一个简单的复读回显插件，可以用于测试你的机器人是否正常运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[?] 要使用哪些内置插件? echo</span><br></pre></td></tr></table></figure><p>请注意，如果你这一步没有安装<code>echo</code>，<strong>后续将无法进行补装</strong>。<br>如果你操作失误没有安装，请删除当前项目文件夹并返回第<code>3</code>节开头。</p><p>出现以下提示则项目创建成功<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_18.png" alt="Create3"></p><p>在终端中输入以下命令进入项目文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [你的项目的名字]</span><br></pre></td></tr></table></figure><p><strong>请注意：后续的操作均需要你的终端处于项目文件夹中。</strong><br>如果你使用的是VSCode，方便起见，你可以直接选择打开项目文件夹作为VSCode工作文件夹：<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_22.png" alt="Create4"><br>这样后续VSCode新建终端就会默认处于项目文件夹中。</p><h2 id="4-编辑配置文件">4.编辑配置文件</h2><p>脚手架会在项目文件夹中自动创建一个配置文件<code>.env.prod</code>，但你仍然需要进行一些自定义配置。</p><p>打开项目文件夹下的<code>.env.prod</code>文件，编辑内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRIVER=~fastapi  # 脚手架自动生成的配置</span><br><span class="line"></span><br><span class="line">HOST=127.0.0.1  # 配置 NoneBot 监听的 IP / 主机名</span><br><span class="line">PORT=23333  # 配置 NoneBot 监听的端口</span><br></pre></td></tr></table></figure><p>其中<code>HOST</code><strong>必须</strong>设为<code>127.0.0.1</code>（即localhost）<br><code>PORT</code>可以选择你喜欢的数字，范围在0-65535之间。不设置默认为8080，但尽量在15000-50000之间选择，避免和已有的端口发生冲突。</p><p>此外，你可以选择设置超级用户<code>SUPERUSERS</code>、命令起始字符<code>COMMAND_START</code>和命令分割字符<code>COMMAND_SEP</code>，你可以在有需要使用这些设置的时候再行配置。<br>部分插件可能会区分普通用户和超级用户（管理员），可以在<code>SUPERUSERS</code>中设置超级用户<br>设置命令起始字符后，机器人只响应以起始字符开头的命令。<br>设置命令分割字符后，你可以用一个语句包含多个命令，机器人会先按分割字符将命令分开，再按顺序处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUPERUSERS=[&quot;1234567890&quot;,&quot;2333333333&quot;]  # 配置 NoneBot 的超级用户，可以是多个（你的QQ号）（可选）</span><br><span class="line">COMMAND_START=[&quot;/&quot;]  # 配置命令起始字符（可选）</span><br><span class="line">COMMAND_SEP=[&quot;.&quot;]  # 配置命令分割字符（可选）</span><br></pre></td></tr></table></figure><h2 id="5-安装插件">5.安装插件</h2><h3 id="5-1-管理插件的方法">5.1.管理插件的方法</h3><blockquote><p>本节旨在让读者了解操作管理插件的流程，选择自己喜欢的管理插件的方式。<br>你也可以选择先跳过本节，在后面的教程中会默认提供方法一的命令。</p></blockquote><p>Nonebot提供了三种管理插件的方法，请确保你的终端当前处于项目文件夹中。<br>其中使用<code>pip</code>安装（方法三）需要手动激活Python虚拟环境，方法一、二管理插件时会自动使用虚拟环境。</p><h4 id="5-1-1-方法一：命令行管理">5.1.1.方法一：命令行管理</h4><p>在终端输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nb plugin install &lt;插件名称&gt;  # 安装插件</span><br><span class="line">nb plugin uninstall &lt;插件名称&gt;  # 卸载插件</span><br><span class="line">nb plugin update &lt;插件名称&gt;  # 升级插件</span><br><span class="line">nb plugin list  # 列出商店所有插件</span><br><span class="line">nb plugin search [关键词]  # 搜索商店插件</span><br></pre></td></tr></table></figure><h4 id="5-1-2-方法二：交互式管理">5.1.2.方法二：交互式管理</h4><p>在终端输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb plugin</span><br></pre></td></tr></table></figure><p>将进入控制台交互模式，键盘上下键移动光标，空格选中，回车确认。<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_21.png" alt="Plugin1"><br>按照提示输入插件名称即可。</p><h4 id="5-1-3-方法三：使用pip安装">5.1.3.方法三：使用pip安装</h4><p>如果你在第3节中正确创建了项目，那么你的项目文件夹中会有一个<code>.venv</code>文件夹，这是项目的Python虚拟环境文件夹。</p><p>值得一提的是，虚拟环境是Python提供的一个非常实用的功能，它可以将项目环境和全局环境隔离。<br>你可以在虚拟环境中安装和管理项目特定的Python库和依赖项，而不会与全局Python环境相互影响。</p><p>在终端输入以下命令以激活虚拟环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\.venv\Scripts\activate</span><br></pre></td></tr></table></figure><p>如果遇到“禁止运行脚本”的报错，可以参考我的这篇文章来解决：<a href="/posts/Tutor_Windows_venv_activate.html">Windows系统无法激活Python虚拟环境的解决方案</a><br>如果命令行开头出现一个括号，内容为你的项目名称，则代表Python虚拟环境已经成功激活。</p><p>接下来你可以使用pip命令来管理你的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install &lt;插件名称&gt;  # 安装插件</span><br><span class="line">pip uninstall &lt;插件名称&gt;  # 卸载插件</span><br><span class="line">pip install --upgrade &lt;插件名称&gt;  # 升级插件</span><br><span class="line">pip list  # 列出当前已经安装的插件（包含Nonebot依赖包）</span><br></pre></td></tr></table></figure><p><code>pip</code>相比前两种方法，缺少了列出和搜索商店插件的功能，多了可以查询当前已经安装了的插件的功能。<br>在忘记已经安装的插件或插件名情况下查询比较方便（当然你也可以自己在<code>.\.venv\Lib\site-packages</code>里查看）。</p><h3 id="5-2-安装go-cqhttp">5.2.安装go-cqhttp</h3><p><code>go-cqhttp</code>框架提供了接收QQ事件与调用QQ的API的能力，是QQ机器人的核心组件。<br>NoneBot插件商店中提供了这个框架的插件，插件名称为：<code>nonebot-plugin-gocqhttp</code><br>在终端中输入以下命令安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb plugin install nonebot-plugin-gocqhttp</span><br></pre></td></tr></table></figure><p>安装完成后，在终端中输入以下命令运行机器人：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb run</span><br></pre></td></tr></table></figure><p>出现以下提示则安装和运行成功：<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_23.png" alt="gocq1"><br>按住Ctrl单击链接进入<code>go-cqhttp</code>的WebUI界面<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_24.png" alt="gocq2"></p><h2 id="6-登录QQ机器人与检查">6.登录QQ机器人与检查</h2><h3 id="6-1-登录QQ机器人">6.1.登录QQ机器人</h3><p>点击左上角“添加账号”，输入要部署的QQ账号，密码留空，设备类型选择“Android Watch”：<br>（注：也可以选择账号密码登录，但可能出现账号被风控无法登录的情况，手表协议登录相对比较稳定。）<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_25.png" alt="QQLogin1"><br>添加完成后点击启动，待加载出二维码后点击“显示登录二维码”。<br>用你的手机登录要部署的QQ账号，扫描二维码登录。<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_26.png" alt="QQLogin2"><br>登陆完成后会有消息提示如下：<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_27.png" alt="QQLogin3"></p><h3 id="6-2-检查QQ机器人是否正常运行">6.2.检查QQ机器人是否正常运行</h3><p>登录你自己的QQ账号，添加机器人为QQ好友，然后按以下格式发送给机器人消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\echo [自定义消息]</span><br></pre></td></tr></table></figure><p>请注意，不论你有没有配置命令起始字符，在这里echo的开头<strong>必须包含&quot;\&quot;字符</strong>。<br>如果机器人回复了和自定义消息相同的内容，那么恭喜你，你已经成功地完成了QQ机器人的部署。</p><div class="hide-block"><button type="button" class="hide-button" style="background-color:  --theme-color;">点我预览示例    </button><div class="hide-content"><img src="https://source.cclmsy.cc/Posts/BOT/BOT_28.png" alt="image" style="zoom:67%;" /></div></div><p>这一步完成后，建议将项目文件夹复制一份作为备份。<br>这样后续重置机器人时，只需要将备份复制一份回来即可。</p><h2 id="7-为你的QQ机器人赋能">7.为你的QQ机器人赋能</h2><p>完成了QQ机器人部署后，你就可以为你的机器人添加插件以实现各种各样的功能。插件的管理方式见<code>5.1</code>节。<br>你可以在官方插件商店找到你需要的插件，根据插件开发者提供的的文档进行安装与配置：<a href="https://nonebot.dev/store/plugins">插件商店</a>。<br>如果你有足够的能力和精力，可以学习NoneBot文档，编写开发自己的插件：<a href="https://nonebot.dev/docs/">NoneBot文档</a>。</p><h2 id="8-注意事项">8.注意事项</h2><ol><li>机器人的运行进程由终端调起，在你运行机器人的过程中，请务必保证你原来的终端窗口一直保持开启状态。如果你使用的是VSCode之类的IDE，请不要关闭你终端所在的窗口。</li><li>机器人以你的计算机作为服务器端，BOT使用期间请务必保证你的服务器/计算机处于开机联网状态。</li><li>Windows系统时常会进行自动更新，必要时可以关闭自动更新。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> NoneBot2 </tag>
            
            <tag> QQ机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python安装指南</title>
      <link href="/posts/python_install.html"/>
      <url>/posts/python_install.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-选择正确的版本，下载安装包">1. 选择正确的版本，下载安装包</h2><p>根据你的实际需要选择Python发行版本。值得注意的是，编程语言包并不是越新越好的，不同版本的Python之间可能会产生兼容性问题。</p><p>如果你不确定你的项目需要哪个版本，请查阅您可能需要使用到的插件的文档或咨询有相关经验的前辈。</p><ul><li>注：Python于10月2日发布3.12.0版本，站长今天使用该版本安装某项目依赖包时发生兼容性错误//本教程采用先前成功过的Python3.11.5版本。</li></ul><p>Python 3.11.5官方下载链接：<a href="https://www.python.org/downloads/release/python-3115/">Python 3.11.5</a><br>拉到页面底部，<strong>根据你的系统选择对应的版本下载</strong>，站长使用的是64位Windows系统，国内大多数普通用户使用的一般也是这个版本。<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_01.png" alt="Download"></p><p>国内下载速度可能会有点慢，有条件的可以通过国际网络访问<br>站长这里提供Python 3.11.5 Windows64位版本的下载：<a href="https://source.cclmsy.cc/Tools/python-3.11.5-amd64.exe">python-3.11.5-amd64</a></p><h2 id="2-安装Python到计算机">2. 安装Python到计算机</h2><p>下载完成后，打开文件所在的文件夹，选中文件右键，以管理员身份运行，按下图所示的步骤安装<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_02.png" alt="Install1"><br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_03.png" alt="Install2"><br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_04.png" alt="Install3"><br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_05.png" alt="Install4"><br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_06.png" alt="Install5"></p><h2 id="3-检查环境变量">3. 检查环境变量</h2><ol><li>打开设置，搜索“环境变量”，点击“编辑账户的环境变量”<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_07.png" alt="Env1"></li><li>在弹出的页面单击选中“Path”，点击“编辑”<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_08.png" alt="Env2"></li><li>在弹出的页面查看是否包含这两项。若没有，则添加这两项。（如果你在上一步自定义了安装路径，则添加对应的路径）<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_09.png" alt="Env3"></li><li>依次点击上面两个弹窗的“确定”，才能正确保存PATH。如果不确定是否正确保存，可以回去看一下//</li></ol><h2 id="4-检查是否正确安装了Python">4. 检查是否正确安装了Python</h2><ol><li>键盘按Windows+R，输入cmd运行终端<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_10.png" alt="Check1"></li><li>输入python回车，若显示版本号则表示安装成功<br><img src="https://source.cclmsy.cc/Posts/BOT/BOT_11.png" alt="Check2"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统无法激活Python虚拟环境的解决方案</title>
      <link href="/posts/windows_venv_activate.html"/>
      <url>/posts/windows_venv_activate.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>在Windows系统终端激活Python虚拟环境时可能出现以下报错（假设你的虚拟环境名为“.venv”）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS (yourpath\yourProj)&gt; .\.venv\Scripts\activate</span><br><span class="line">.\.venv\Scripts\activate : 无法加载文件 (yourpath\yourProj)\.venv\Scripts\activate.ps1，因为在此系统上禁止运行脚本。</span><br><span class="line">有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ .\.venv\Scripts\activate</span><br><span class="line">+ ~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure><h2 id="报错原因">报错原因</h2><p>Windows系统具有执行策略（Execution Policy），导致无法运行虚拟环境的激活脚本。<br>执行策略是Windows中的一种安全机制，它可以防止执行不信任的脚本。</p><h2 id="解决方案">解决方案</h2><ol><li><p>点击屏幕左下角Windows徽标打开“开始”菜单栏，在搜索栏搜索“PowerShell”，然后单击 “以管理员身份运行”。</p><p><img src="https://source.cclmsy.cc/Posts/BOT/BOT_19.png" alt="Python_venv1"></p></li><li><p>在弹出的终端中输入以下命令，回车：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure></li><li><p>弹出询问时输入“y”，回车：</p><p><img src="https://source.cclmsy.cc/Posts/BOT/BOT_20.png" alt="Python_venv2"></p></li><li><p>没有消息提示，退出 PowerShell 终端，回到你激活Python虚拟环境的终端。此时可以正常激活Python虚拟环境：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS (yourpath\yourProj)&gt; .\.venv\Scripts\activate</span><br><span class="line">(yourProj) PS (yourpath\yourProj)&gt; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction</title>
      <link href="/posts/introduction.html"/>
      <url>/posts/introduction.html</url>
      
        <content type="html"><![CDATA[<h1>博客介绍</h1><p>关于网站、关于站长：见<a href="/about">关于</a>栏目</p><p>维护日志：见<a href="/site/time">旧时光</a>栏目</p><p>欢迎来到CCLMSY的Blog！<br>博客不定期更新算法竞赛题解、学习笔记、模板等内容//<br>网站已开启邮件提醒功能。正确输入邮箱后，评论收到回复将有邮件提醒。</p><p>已知问题：</p><ul><li>由于MarkDown版本、Katex版本、网页转义等原因，部分内容的MarkDown格式或Katex公式渲染可能会不正确</li><li>使用国际网络访问可能导致无法正常使用自定义美化功能</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划-其他</title>
      <link href="/posts/dp_others.html"/>
      <url>/posts/dp_others.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-子序列问题">一.子序列问题</h2><h3 id="1-最长公共子序列-LCS">1.最长公共子序列(LCS)</h3><p>O(mn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;,dp[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最长上升子序列">2.最长上升子序列</h3><h4 id="2-1-DP">2.1.DP</h4><p>$O(n^2)$ 洛谷B3637</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        ll mx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j]) mx=<span class="built_in">max</span>(mx,dp[j]);</span><br><span class="line">        dp[i]=mx+<span class="number">1</span>;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-贪心">2.2.贪心</h4><p>$O(n\log n)$ 洛谷B3637<br>贪心：维护当前子序列d，替换序列中不小于a[i]的第一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; d;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; a[i];</span><br><span class="line">    d.<span class="built_in">emplace_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.<span class="built_in">back</span>()&lt;a[i]) d.<span class="built_in">emplace_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(d),a[i])=a[i];</span><br><span class="line">    &#125;<span class="comment">//最长不降子序列改成upper_bound</span></span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-区间DP">二.区间DP</h2><p>$O(n^3)$ NOI1995/LOJ10147<br>分治：父问题的答案由子问题集中最优解转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 205</span></span><br><span class="line">ll v[N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,S[N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dpmx[N*<span class="number">2</span>][N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,dpmn[N*<span class="number">2</span>][N*<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        v[i+n]=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n*<span class="number">2</span>) dpmn[i][j]=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) dpmn[i][i]=<span class="number">0</span>;<span class="comment">//Init</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) S[i]=S[i<span class="number">-1</span>]+v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(len,<span class="number">1</span>,n)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n*<span class="number">2</span>-len+<span class="number">1</span>)&#123;</span><br><span class="line">            ll j=i+len<span class="number">-1</span>;<span class="comment">//根据长度和i算出j</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,i,j<span class="number">-1</span>)&#123;<span class="comment">//枚举分界点</span></span><br><span class="line">                dpmx[i][j]=<span class="built_in">max</span>(dpmx[i][j],dpmx[i][k]+dpmx[k+<span class="number">1</span>][j]+S[j]-S[i<span class="number">-1</span>]);</span><br><span class="line">                dpmn[i][j]=<span class="built_in">min</span>(dpmn[i][j],dpmn[i][k]+dpmn[k+<span class="number">1</span>][j]+S[j]-S[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;<span class="comment">//转移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mx=<span class="number">0</span>,mn=INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) mx=<span class="built_in">max</span>(mx,dpmx[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) mn=<span class="built_in">min</span>(mn,dpmn[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    cout &lt;&lt; mn &lt;&lt; endl &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-期望DP">三.期望DP</h2><p>ATC-abc323_e<br>某点的期望从此前的一段区间内转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 1003</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> X 10004</span></span><br><span class="line">ll dp[X]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//歌曲在t时刻切换的概率</span></span><br><span class="line">ll t[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,x;cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; t[i];</span><br><span class="line">    ll invn=<span class="built_in">inv</span>(n);<span class="comment">//1/n</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,x)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(i&gt;=t[j])</span><br><span class="line">            <span class="built_in">addto</span>(dp[i],dp[i-t[j]]);</span><br><span class="line">        <span class="built_in">multo</span>(dp[i],invn);</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="built_in">max</span>(<span class="number">0ll</span>,x-t[<span class="number">1</span>]+<span class="number">1</span>),x) <span class="built_in">addto</span>(re,dp[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multo</span>(re,invn) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-DP优化">四.DP优化</h2><h3 id="1-单调队列优化DP">1. 单调队列优化DP</h3><p>O(mn) M(m) CF372C<br>利用单调队列将每次区间DP均摊复杂度降至O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 305</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> M 150005</span></span><br><span class="line">ll a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;,t[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[<span class="number">2</span>][M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,m,d;<span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">ll que[M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i];</span><br><span class="line">    fl=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        ll l=<span class="number">1</span>,r=<span class="number">0</span>,k=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;k&lt;=<span class="built_in">min</span>(n,j+(t[i]-t[i<span class="number">-1</span>])*d);k++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(r&gt;=l&amp;&amp;dp[fl^<span class="number">1</span>][que[r]]&lt;dp[fl^<span class="number">1</span>][k]) r--;</span><br><span class="line">                que[++r]=k;<span class="comment">//单调队列优化DP：维护上一状态的有效区间内的最大值的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r&gt;=l&amp;&amp;que[l]&lt;<span class="built_in">max</span>(<span class="number">1ll</span>,j-(t[i]-t[i<span class="number">-1</span>])*d)) l++;</span><br><span class="line">            dp[fl][j]=dp[fl^<span class="number">1</span>][que[l]]+b[i]-<span class="built_in">abs</span>(a[i]-j);</span><br><span class="line">        &#125;fl^=<span class="number">1</span>;<span class="comment">//状态转换</span></span><br><span class="line">    &#125;fl^=<span class="number">1</span>;<span class="comment">//回到最终状态</span></span><br><span class="line">    ll ans=-INF;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">max</span>(ans,dp[fl][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference：<a href="https://oi-wiki.org/dp/">OI-Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划-背包DP</title>
      <link href="/posts/dp_bag.html"/>
      <url>/posts/dp_bag.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-01背包">1.01背包</h2><h3 id="1-1-DFS记忆化搜索">1.1.DFS记忆化搜索</h3><p>$O(wn)$ <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 105</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;z</span><br><span class="line">ll mem[W][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll maxw,n;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll i,ll curw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mem[i][curw]) <span class="keyword">return</span> mem[i][curw];</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="keyword">return</span> mem[i][curw]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(curw&gt;=w[i])</span><br><span class="line">        <span class="keyword">return</span> mem[i][curw]=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw-w[i])+v[i],<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> mem[i][curw]=<span class="built_in">dfs</span>(i+<span class="number">1</span>,curw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>,maxw) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-二维数组">1.2.二维数组</h3><p>$O(wn) M(wn)$ <a href="https://www.luogu.com.cn/problem/P1048">洛谷P1048</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 105</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[N][W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,maxw)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i]) dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-w[i]]+v[i],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-一维滚动数组">1.3.一维滚动数组</h3><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P2871">洛谷P2871</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123;<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-完全背包">2.完全背包</h2><h3 id="2-1-一维滚动数组">2.1.一维滚动数组</h3><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616</a><br>和01背包唯一区别在剩余容量从小到大遍历，每个物品能取多次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL</span>(j,w[i],maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-贪心优化">2.2.贪心优化</h3><p>$O(wn) M(w)$ <a href="https://www.luogu.com.cn/problem/P1616">洛谷P1616</a><br>贪心思想：对于两件物品 $i,j$ ，如果 $w_i \le w_j \And v_i \ge v_j$ ，则只需保留 $i$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">vector&lt;pll&gt; objs,tv;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw,w,v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    tv.<span class="built_in">resize</span>(n);<span class="comment">//物品：&lt;weight,value&gt;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:tv) cin &gt;&gt; x.first &gt;&gt; x.second;</span><br><span class="line">    <span class="built_in">SORT</span>(tv);ll maxv=<span class="number">-1</span>;<span class="comment">//物品序列按主w次v排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:tv)</span><br><span class="line">        <span class="keyword">if</span>(x.second&gt;maxv)<span class="comment">//O(n)筛去多余物品</span></span><br><span class="line">            &#123;objs.<span class="built_in">emplace_back</span>(x);maxv=x.second;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:objs)&#123;</span><br><span class="line">        w=x.first;v=x.second;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,w,maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w]+v,dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-多重背包">3.多重背包</h2><h3 id="3-1-朴素方法">3.1.朴素方法</h3><p>$O(w\sum cnt_i)$<br>朴素方法：按有 $cnt_i$ 个的物品 $i$ ，进行01背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; tn &gt;&gt; maxw;</span><br><span class="line">    ll tv,tw,cnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">            v[++n]=tv;</span><br><span class="line">            w[n]=tw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-二进制分组">3.2.二进制分组</h3><p>$O(w\sum\lg{cnt_i})$<br>二进制分组优化：对于每个物品，将其按二进制分组，捆绑一个物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; tn &gt;&gt; maxw;</span><br><span class="line">    ll tv,tw,cnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tv &gt;&gt; tw &gt;&gt; cnt;</span><br><span class="line">        ll b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;b)&#123;</span><br><span class="line">            v[++n]=tv*b;</span><br><span class="line">            w[n]=tw*b;</span><br><span class="line">            cnt-=b;b*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt) &#123;v[++n]=tv*cnt;w[n]=tw*cnt;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-混合背包">4.混合背包</h2><p>$O(wn)$ <a href="https://www.luogu.com.cn/problem/P1833">洛谷P1833</a><br>01背包、多重背包和完全背包的缝合怪//</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 100005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n=<span class="number">0</span>,maxw,tn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll h1,m1,h2,m2;<span class="type">char</span> tc;</span><br><span class="line">    cin &gt;&gt; h1 &gt;&gt; tc &gt;&gt; m1 &gt;&gt; h2 &gt;&gt; tc &gt;&gt; m2 &gt;&gt; tn;</span><br><span class="line">    maxw=<span class="built_in">abs</span>((h2*<span class="number">60</span>+m2)-(h1*<span class="number">60</span>+m1));</span><br><span class="line">    ll tv,tw,tcnt,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tv &gt;&gt; tcnt;</span><br><span class="line">        <span class="keyword">if</span>(tcnt)&#123;</span><br><span class="line">            ll b=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tcnt&gt;b)&#123;</span><br><span class="line">                v[++n]=tv*b;</span><br><span class="line">                w[n]=tw*b;</span><br><span class="line">                cnt[n]=b;</span><br><span class="line">                tcnt-=b;b*=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="comment">//多重背包二进制分组</span></span><br><span class="line">            <span class="keyword">if</span>(tcnt) &#123;v[++n]=tv*tcnt;w[n]=tw*tcnt;cnt[n]=<span class="number">1</span>;&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            v[++n]=tv;</span><br><span class="line">            w[n]=tw;</span><br><span class="line">            cnt[n]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i])&#123;<span class="comment">//01背包</span></span><br><span class="line">            <span class="built_in">FORLL_rev</span>(j,maxw,w[i])</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//完全背包</span></span><br><span class="line">            <span class="built_in">FORLL</span>(j,w[i],maxw)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-二维费用背包">5.二维费用背包</h2><p>$O(nw_1w_2)$ <a href="https://www.luogu.com.cn/problem/P1855">洛谷P1855</a><br>具有两种费用属性的背包问题，以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 205</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w1[N]=&#123;<span class="number">0</span>&#125;,w2[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W][W]=&#123;<span class="number">0</span>&#125;;<span class="comment">//二维滚动数组</span></span><br><span class="line">ll n,maxw1,maxw2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw1 &gt;&gt; maxw2;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; w1[i] &gt;&gt; w2[i];</span><br><span class="line">        v[i]=<span class="number">1</span>;<span class="comment">//本题中价值均为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j1,maxw1,w1[i])</span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j2,maxw2,w2[i])</span><br><span class="line">            dp[j1][j2]=<span class="built_in">max</span>(dp[j1-w1[i]][j2-w2[i]]+v[i],dp[j1][j2]);</span><br><span class="line">    cout &lt;&lt; dp[maxw1][maxw2] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-分组背包">6.分组背包</h2><p>$O(nw)$ <a href="https://www.luogu.com.cn/problem/P1757">洛谷P1757</a><br>01背包的进化体，每个组中最多能取1个物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 65536</span></span><br><span class="line">ll maxw,n;</span><br><span class="line">ll v[<span class="number">105</span>][N]=&#123;<span class="number">0</span>&#125;,w[<span class="number">105</span>][N]=&#123;<span class="number">0</span>&#125;,dp[<span class="number">1000</span>*N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll cnt[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;,mxid=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    ll tv,tw,id;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tv &gt;&gt; id;</span><br><span class="line">        cnt[id]++;</span><br><span class="line">        v[id][cnt[id]]=tv;</span><br><span class="line">        w[id][cnt[id]]=tw;</span><br><span class="line">        mxid=<span class="built_in">max</span>(mxid,id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,mxid)<span class="comment">//对于每一组物品</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,<span class="number">0</span>)<span class="comment">//对于每一种容量（从后往前遍历，保证同组两种物品不同时取到）</span></span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">1</span>,cnt[k]) <span class="keyword">if</span>(j&gt;=w[k][i])<span class="comment">//放入该组每种物品时可达到的最大值</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[k][i]]+v[k][i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-有依赖的背包">7.有依赖的背包</h2><p>$O(nw)$ <a href="https://www.luogu.com.cn/problem/P1064">洛谷P1064</a><br>分组背包的进化体，将所有主副件组合方案作为一组进行分组背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> W 32005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 61</span></span><br><span class="line">ll maxw,n;</span><br><span class="line">ll w[N][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,v[N][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,dp[W]=&#123;<span class="number">0</span>&#125;,cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; id_list;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    ll tw,tp,id;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tw &gt;&gt; tp &gt;&gt; id;</span><br><span class="line">        <span class="keyword">if</span>(id==<span class="number">0</span>)&#123;<span class="comment">//0：纯主件</span></span><br><span class="line">            id=i;w[id][<span class="number">0</span>]=tw;v[id][<span class="number">0</span>]=tw*tp;</span><br><span class="line">            id_list.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[id]==<span class="number">0</span>)&#123;<span class="comment">//1：主件+配件1</span></span><br><span class="line">            cnt[id]++;</span><br><span class="line">            w[id][<span class="number">1</span>]=tw+w[id][<span class="number">0</span>];</span><br><span class="line">            v[id][<span class="number">1</span>]=tw*tp+v[id][<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[id]==<span class="number">1</span>)&#123;<span class="comment">//2：主件+配件2//3：主件+配件1+配件2</span></span><br><span class="line">            cnt[id]++;</span><br><span class="line">            w[id][<span class="number">2</span>]=tw+w[id][<span class="number">0</span>];</span><br><span class="line">            v[id][<span class="number">2</span>]=tw*tp+v[id][<span class="number">0</span>];</span><br><span class="line">            w[id][<span class="number">3</span>]=tw+w[id][<span class="number">1</span>];</span><br><span class="line">            v[id][<span class="number">3</span>]=tw*tp+v[id][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> k:id_list)&#123;<span class="comment">//对于每一组物品</span></span><br><span class="line">        ll t=<span class="number">0</span>; <span class="keyword">if</span>(cnt[k]==<span class="number">1</span>) t=<span class="number">1</span>; <span class="keyword">if</span>(cnt[k]==<span class="number">2</span>) t=<span class="number">3</span>; </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,<span class="number">0</span>)<span class="comment">//对于每一种容量（从后往前遍历，保证同组两种方案不同时取到）</span></span><br><span class="line">            <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t) <span class="keyword">if</span>(j&gt;=w[k][i])<span class="comment">//采取该组每种方案时可达到的最大值</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[k][i]]+v[k][i],dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-进阶问题">8.进阶问题</h2><h3 id="1-求具体方案">1.求具体方案</h3><p>$O(wn)$<br>以完全背包为例，在转移时记录容量j下选择的物品编号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 10000005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;,cnt[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;,g[W]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL</span>(j,w[i],maxw)&#123;<span class="comment">//和01背包唯一区别在从小到大遍历，每个物品能取多次</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+v[i]&gt;dp[j])&#123;</span><br><span class="line">                dp[j]=dp[j-w[i]]+v[i];</span><br><span class="line">                g[j]=i;<span class="comment">//记录在容量j下选择了物品i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">    ll curw=maxw;</span><br><span class="line">    <span class="keyword">while</span>(g[curw])&#123;</span><br><span class="line">        cnt[g[curw]]++;</span><br><span class="line">        curw-=w[g[curw]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) ;<span class="comment">//输出方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-装满方案计数">2.装满方案计数</h3><p>对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。</p><h4 id="2-1-不考虑顺序">2.1.不考虑顺序</h4><p>$O(wn)$<br>不同的选择顺序看作相同方案。以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//dp[0]即不选，方案数为1</span></span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="comment">//先遍历物品</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123;<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            dp[j]=dp[j]+dp[j-w[i]];<span class="comment">//不选+选</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-考虑顺序">2.2.考虑顺序</h4><p>$O(wn)$ ZJNU C1299_B<br>不同的选择顺序看作不同方案。以完全背包为例</p><blockquote><p>从 $0$ 到 $n$ ，每次可以前进 {1,2,4} ，求方案数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> W 205</span></span><br><span class="line">ll w[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">ll maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(j,<span class="number">1</span>,maxw) <span class="comment">//先遍历容量</span></span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">            dp[j]=dp[j]+dp[j-w[i]];</span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-最优方案计数">3.最优方案计数</h3><p>$O(wn)$<br>求最优背包方案数，以01背包为例，g[j]代表容量j下最优方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 20005</span></span><br><span class="line">ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll dp[W]=&#123;<span class="number">0</span>&#125;,g[W]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//g[0]即不选，方案数为1</span></span><br><span class="line">ll n,maxw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) </span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])<span class="comment">//01背包从大到小遍历，每个物品只能取一次</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w[i]]+v[i]&gt;dp[j])&#123;<span class="comment">//取 最优</span></span><br><span class="line">                dp[j]=dp[j-w[i]]+v[i];</span><br><span class="line">                g[j]=g[j-w[i]];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j-w[i]]+v[i]==dp[j]) g[j]+=g[j-w[i]]; <span class="comment">//取或不取都最优</span></span><br><span class="line">    cout &lt;&lt; dp[maxw] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; g[maxw] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-求第k优解">4.求第k优解</h3><p>$O(wnk)$ <a href="https://vjudge.net/problem/HDU-2639">HDU2639</a><br>求背包的第k优解，以01背包为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W 1005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll dp[W][<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//dp[j][k]表示容量j下第k优解</span></span><br><span class="line">    ll a[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll n,maxw,tark;</span><br><span class="line">    ll x,y,z;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; maxw &gt;&gt; tark;</span><br><span class="line">    a[tark+<span class="number">1</span>]=b[tark+<span class="number">1</span>]=<span class="number">-1</span>;<span class="comment">//哨兵</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="comment">//考虑前i个物品时</span></span><br><span class="line">        <span class="built_in">FORLL_rev</span>(j,maxw,w[i])&#123; <span class="comment">//容量为j下</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">1</span>,tark)&#123;</span><br><span class="line">                a[k]=dp[j-w[i]][k]+v[i];<span class="comment">//第k优解，选</span></span><br><span class="line">                b[k]=dp[j][k];<span class="comment">//第k优解，不选</span></span><br><span class="line">            &#125;<span class="comment">//dp数组不升保证a,b数组不升</span></span><br><span class="line">            x=y=z=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(z&lt;=tark&amp;&amp;!(a[x]==<span class="number">-1</span>&amp;&amp;b[y]==<span class="number">-1</span>))&#123;<span class="comment">//循环直到找到全部前k解，或两指针都到末尾</span></span><br><span class="line">                <span class="keyword">if</span>(a[x]&gt;b[y]) dp[j][z]=a[x++];</span><br><span class="line">                <span class="keyword">else</span> dp[j][z]=b[y++];</span><br><span class="line">                <span class="keyword">if</span>(dp[j][z]!=dp[j][z<span class="number">-1</span>]) z++;<span class="comment">//非严格比较则删去if条件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; dp[maxw][tark] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference：<a href="https://oi-wiki.org/dp/">OI-Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校10</title>
      <link href="/posts/ACM_2023Summer_NCD10.html"/>
      <url>/posts/ACM_2023Summer_NCD10.html</url>
      
        <content type="html"><![CDATA[<h1>K.First Last</h1><p><strong>签到题</strong></p><h2 id="题意">题意</h2><p>$n$ 个人参加 $m$ 场比赛，每场比赛中获得名次得概率均等<br>问针对某一人，他在所有场次比赛中都获得第一或倒数第一的概率</p><h2 id="解题思路">解题思路</h2><p>如果人数 $n&gt;1$ ，每场比赛的概率是 $p=\dfrac{2}{n}$ ；人数为 $1$ 时 $p=1$</p><p>输出 $p^m$ 即可</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">double</span> p=<span class="number">2.</span>/n,re=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) p=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m) re*=p;</span><br><span class="line">    <span class="built_in">print_float</span>(re,<span class="number">15</span>);cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>M.Fair Equation</h1><p><strong>模拟</strong></p><h2 id="题意-2">题意</h2><p>给定一个式子 $A+B=C$ ，其中正整数 $A,B,C\le 10^6$<br>问能否在 $A,B,C$ 其中一个数的某一位置（可以是开头和结尾）插入一个数字，使得等式成立；或原式自然成立。<br>若成立，输出成立的等式</p><h2 id="解题思路-2">解题思路</h2><p>如题如题目所述，取出等式中的数字，逐位模拟即可。具体实现可参考代码</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_equal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">    cout &lt;&lt; num[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; num[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; num[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;<span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="built_in">get_nums</span>(s);ll t;<span class="comment">//分离出数字</span></span><br><span class="line">    <span class="keyword">if</span>(num[<span class="number">0</span>]+num[<span class="number">1</span>]==num[<span class="number">2</span>]) &#123;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;<span class="comment">//原式成立</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">0</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">0</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">0</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(t+num[<span class="number">1</span>]==num[<span class="number">2</span>]) &#123;num[<span class="number">0</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;<span class="comment">//在A的第k位插入i，判断是否符合条件，下面同理</span></span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">1</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">1</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">1</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>]+t==num[<span class="number">2</span>]) &#123;num[<span class="number">1</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">0</span>,numlen[<span class="number">0</span>])&#123;</span><br><span class="line">            t=(num[<span class="number">2</span>]/pow_10[k])*pow_10[k]*<span class="number">10</span>+i*pow_10[k]+num[<span class="number">2</span>]%pow_10[k];</span><br><span class="line">            <span class="keyword">if</span>(num[<span class="number">0</span>]+num[<span class="number">1</span>]==t) &#123;num[<span class="number">2</span>]=t;<span class="built_in">print_equal</span>();<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校10</title>
      <link href="/posts/ACM_2023Summer_HDU10.html"/>
      <url>/posts/ACM_2023Summer_HDU10.html</url>
      
        <content type="html"><![CDATA[<h1><a href="http://1004.Do">1004.Do</a> You Like Interactive Problems?</h1><p><strong>概率论-数学期望</strong></p><h2 id="题意">题意</h2><p>给定一个正整数 $n$ ，在 $1$ ~ $n$ 范围内有一个正整数 $x$<br>进行若干轮猜测，每次猜测在 $1$ ~ $n$ 范围内等概率随机选择一个正整数 $y$ ，可以得到如下信息中的一个： $y&gt;x,y=x,y&lt;x$<br><strong>每次猜测后，下一次猜测仍在原范围内随机选择</strong>。当得到的信息能够唯一确定 $x$ 时，游戏结束<br>求猜测轮数的数学期望</p><h2 id="解题思路">解题思路</h2><p>由题意可知，当且仅当出现以下情况时，可以唯一确定 $x$ ：</p><ol><li>选到 $x$</li><li>$x$ 的相邻元素都被选到</li></ol><p>每次选择后，下一次选择的范围是不变的，因此其他元素的信息对唯一确定 $x$ 是没有作用的</p><p>对于给定 $n$ ，根据以下情况展开讨论：</p><ol><li>不论 $x$ 的位置，直接选到 $x$ ，轮数为 $1$ ，概率为 $\dfrac{1}{n}$</li><li>已经选到一个相邻点（或 $x$ 在两端），轮数期望记为 $E_2$<ol><li>选另一相邻点（或唯一相邻点），轮数为 $1$ ，概率为 $\dfrac{1}{n}$</li><li>选其他点没有贡献，概率为 $\dfrac{n-2}{n}$</li></ol></li><li>$x$ 在中间，没有选到过相邻点，轮数期望记为 $E_3$<ol><li>选到两个相邻点之一，转移到情况 $2$ ，概率为 $\dfrac{2}{n}$</li><li>选到其他点没有贡献，概率为 $\dfrac{n-3}{n}$</li></ol></li></ol><p>综上可得：</p><p>$E_2=\dfrac{1}{n}+\dfrac{1}{n}+\dfrac{n-2}{n}(1+E_2)$</p><p>$E_3=\dfrac{1}{n}+\dfrac{2}{n}(1+E_2)+\dfrac{n-3}{n}(1+E_3)$</p><p>解得 $E_2=\dfrac{n}{2},E_3=\dfrac{2n}{3}$<br>得到最终期望为：$E=\dfrac{2}{n}E_2+\dfrac{n-2}{n}E_3=\dfrac{2n-1}{3}$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    ll t=<span class="built_in">mul</span>(<span class="built_in">Get_Mod</span>(<span class="number">2</span>*(n<span class="number">-2</span>)+<span class="number">3</span>),<span class="built_in">inv</span>(<span class="number">3</span>));</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.Equalize the Array</h1><p><strong>签到</strong></p><h2 id="题意-2">题意</h2><p>定义一个数组的 $mode$ 是其中出现次数最多的数字（可不唯一）<br>给定一个数组 $a$ ，每次操作可以选定其一个 $mode$ 并使数组中所有与之相等的元素 $+1$<br>问任意次操作后能否使数组中全部元素相等</p><h2 id="解题思路-2">解题思路</h2><p>如果数组中最小的元素是 $mode$ ，连续操作最小元素即可实现//<br>元素计数，判断最小元素出现次数是否最多即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n\log n)$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    map&lt;ll,ll&gt; mp;ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;mp[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mxcnt=<span class="number">0</span>,mxi=<span class="number">0</span>,mn=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        t=mp[i];<span class="keyword">if</span>(!mn&amp;&amp;t) mn=i;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;mxcnt) &#123;mxcnt=t;mxi=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mxi&lt;=mn) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校09</title>
      <link href="/posts/ACM_2023Summer_HDU09.html"/>
      <url>/posts/ACM_2023Summer_HDU09.html</url>
      
        <content type="html"><![CDATA[<h1>1002.Shortest path</h1><p><strong><s>签到题</s></strong> <strong>DFS记忆化搜索</strong></p><h2 id="题意">题意</h2><p>给定一个正整数 $n$ ，可以对其进行以下操作：</p><ol><li>如果 $n$ 能被 $3$ 整除，则可以使 $n=n/3$ ;</li><li>如果 $n$ 能被 $2$ 整除，则可以使 $n=n/2$ ;</li><li>使 $n=n-1$</li></ol><p>求使得 $n$ 变成 $1$ 的最少操作次数</p><h2 id="解题思路">解题思路</h2><p><s>将样例Output输出即可</s></p><blockquote><p>这题不难，但确实精彩()//毕竟……<br>《钉耙编程”中国大学生算法设计超级联赛》是由hdu自主研发的一款全新开放世界冒险竞赛。竞赛发生在一个被称作“hdu”的幻想世界，在这里，被编译器选中的人将被授予“C++”，导引代码之力。你将扮演一位名为“acmer”的神秘角色，在自由的打题中邂逅性格各异能力独特的STL容器，和他们一起击败强题，找回AC的代码</p></blockquote><p>不闹了，解题吧</p><p>不难看出操作 $3$ 的收益最低，是不满足操作 $1,2$ 的时候凑条件用的。<br>而由于只允许整除，操作 $1,2$ 的优劣性不好评估（因为要夹杂操作 $3$ 而不单纯是减少的量的区别），因此每次对本次进行的两种操作方案进行比较。</p><p>按以下操作递归处理 $n$ ：</p><ol><li>如果 $n=1$ ，则返回 $0$ ；</li><li>进行若干次（可能0次）操作 $3$ 使得 $n$ 能被 $2$ 整除，执行操作 $2$</li><li>进行若干次（可能0次）操作 $3$ 使得 $n$ 能被 $3$ 整除，执行操作 $1$</li></ol><p>由于数据范围的关系，传统的DFS会超时，因此需要使用记忆化搜索<br>即每次计算完某个数（记为 $x$ ）的结果，将其保存下来，后续搜索 $x$ 时就无需继续搜索到底部，直接输出这个数的结果即可<br>记忆化搜索可以用 map 实现，频繁读取而不考虑元素顺序的可以使用 unordered_map ，有效降低时间空间复杂度</p><p><img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_HDU09_1002.png" alt="Img"></p><p>第2、3行的提交使用了 map ，代码完全一致；第1行的提交仅仅将 map 改为了 unordered_map</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(t\log^2n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;ll,ll&gt; mp;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>-n;</span><br><span class="line">    <span class="keyword">if</span>(mp[n]) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll t1,t2;</span><br><span class="line">    t1=n%<span class="number">2</span>+<span class="number">1</span>+<span class="built_in">dfs</span>(n/<span class="number">2</span>);</span><br><span class="line">    t2=n%<span class="number">3</span>+<span class="number">1</span>+<span class="built_in">dfs</span>(n/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> mp[n]=<span class="built_in">min</span>(t1,t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1005.List Reshape</h1><p><strong>签到题、模拟</strong></p><h2 id="题意-2">题意</h2><p>按一定格式给定一个纯数字一维数组，按给定格式输出成二维数组。</p><h2 id="解题思路-2">解题思路</h2><p>读入初始数组字符串，将每个数字分离，按要求输出即可</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">char</span> s[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;string&gt; nums;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnums</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ts;ll len=<span class="built_in">strlen</span>(s);<span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,len)&#123;</span><br><span class="line">        c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) ts.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ts.<span class="built_in">size</span>())&#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">            ts.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getchar</span>();<span class="built_in">gets</span>(s);</span><br><span class="line">    ll n,m;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    nums.<span class="built_in">clear</span>();<span class="built_in">getnums</span>();</span><br><span class="line">    <span class="comment">//print_vec(nums);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; nums[i*m+j];</span><br><span class="line">            <span class="keyword">if</span>(m<span class="number">-1</span>-j) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n<span class="number">-1</span>-i) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; <span class="string">&#x27;]&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1008.Coins</h1><p><strong>概率论</strong></p><h2 id="题意-3">题意</h2><p>$n$ 个人进行游戏，每个人初始有 $a_i$ 个硬币，每次随机选择一个人给另一个人一枚硬币<br>若某人给出硬币后没有剩余，则退出游戏。直到有人拿到所有硬币游戏结束<br>求游戏轮数的数学期望</p><h2 id="解题思路-3">解题思路</h2><p>概率论还没学（）官方题解的鞅论看不懂（躺）//<br>等学完回来给严格推导（手搓大饼ing）<br>ACMer三大美德：暴力、打表、猜结论//下面给出道德解法（）</p><p>假设现在只有两个人，那么每个人给对方硬币的概率都为50%，直到其中一人没有硬币为止。<br>设这两个人的硬币数分别为 $m,n$ ，则游戏轮数期望为：<br>$f(m,n)=1+\dfrac{1}{2}f(m+1,n-1)+\dfrac{1}{2}f(m-1,n+1)$</p><p>可以发现越往后对期望的贡献越低，限制递归深度，利用如下程序暴力打表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(ll m,ll n,ll rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rnd&gt;<span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归上限40层（已经要跑很久了）</span></span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="number">0.5</span>*<span class="built_in">f</span>(m+<span class="number">1</span>,n<span class="number">-1</span>,rnd+<span class="number">1</span>)+<span class="number">0.5</span>*<span class="built_in">f</span>(m<span class="number">-1</span>,n+<span class="number">1</span>,rnd+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(m,n,<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到以下打表结果（不得不说跑的是真慢）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>:<span class="number">1</span> <span class="number">3</span> out:<span class="number">3</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">1</span> <span class="number">5</span> out:<span class="number">4</span>.<span class="number">98732</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">2</span> <span class="number">3</span> out:<span class="number">5</span>.<span class="number">99897</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">2</span> <span class="number">5</span> out:<span class="number">9</span>.<span class="number">8626</span></span><br><span class="line"><span class="attribute">in</span>:<span class="number">3</span> <span class="number">4</span> out:<span class="number">11</span>.<span class="number">8287</span></span><br></pre></td></tr></table></figure><p>暴力打完表可以猜结论了： $f(m,n)=mn$ ，即对于两个人，答案是他们硬币数的乘积；<br>那么对于三个人，利用样例<code>in:1 1 1 out:3</code>盲猜是 $a_1a_2+a_1a_3+a_2a_3$<br>推广到 $n$ 个人，两两相乘再相加即可</p><p>由于数据较大，答案需要开int128才能放得下<br>另外结合数据范围，利用前缀和算出结果即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>前缀和&amp;求和：$O(n)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int128 res;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        sum[i]=v[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL_rev</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        res=res+sum[i<span class="number">-1</span>]*v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">print</span>();<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校09</title>
      <link href="/posts/ACM_2023Summer_NCD09.html"/>
      <url>/posts/ACM_2023Summer_NCD09.html</url>
      
        <content type="html"><![CDATA[<h1>E.Puzzle: Square Jam</h1><p><strong>几何</strong></p><h2 id="题意">题意</h2><p>给定一个 $n$ 行 $m$ 列的矩形，将其切割为若干个边长为正整数的正方形部分<br>要求矩形内每个整点都不能同时在四个正方形的边界上</p><h2 id="解题思路">解题思路</h2><p>每次在矩形中取最大的正方形，剩余部分递归处理即可。如此取，每个点最多在三个正方形的边界上</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;pll,ll&gt;&gt; ans;</span><br><span class="line">pair&lt;pll,ll&gt; tp;<span class="comment">//&lt;坐标,边长&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_sqr</span><span class="params">(ll x,ll y,ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//处理坐标在(x,y)，n行m列的矩形</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=m)&#123;</span><br><span class="line">        tp.first.first=x;tp.first.second=y;tp.second=m;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        <span class="built_in">solve_sqr</span>(x+m,y,n-m,m);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tp.first.first=x;tp.first.second=y;tp.second=n;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        <span class="built_in">solve_sqr</span>(x,y+n,n,m-n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">solve_sqr</span>(<span class="number">0</span>,<span class="number">0</span>,n,m);</span><br><span class="line">    cout &lt;&lt; YES ;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)&#123;</span><br><span class="line">        cout &lt;&lt; x.first.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.first.second &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校08</title>
      <link href="/posts/ACM_2023Summer_NCD08.html"/>
      <url>/posts/ACM_2023Summer_NCD08.html</url>
      
        <content type="html"><![CDATA[<h1>A.Alive Fossils</h1><p><strong>签到</strong></p><h2 id="题意">题意</h2><p>给定 $n$ 个字符串集，求它们的交集，按字典序输出</p><h2 id="解题思路">解题思路</h2><p>逐一处理字符串集，开个 map 记录此前的交集，从当前集合中选走元素即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll tn;cin &gt;&gt; tn;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; mp;string ts;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,tn)&#123;</span><br><span class="line">        cin &gt;&gt; ts;</span><br><span class="line">        mp[ts]++;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        cin &gt;&gt; tn;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,tn)&#123;</span><br><span class="line">            cin &gt;&gt; ts;</span><br><span class="line">            <span class="keyword">if</span>(mp[ts]) v.<span class="built_in">emplace_back</span>(ts);</span><br><span class="line">        &#125;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:v) mp[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s:v) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>J.Permutation and Primes</h1><p><strong>构造</strong></p><h2 id="题意-2">题意</h2><p>给定一个正整数 $n$ ，构造一个 $n$ 的排列，使得每对相邻元素的和或差的绝对值为一奇素数</p><h2 id="解题思路-2">解题思路</h2><p>两个数的和或差是奇数，那么它们的奇偶性一定是不同的，因此所求排列中，奇数和偶数是交错分布的</p><p>对于排列的构造，首先考虑能不能通过自然排列转化而成//</p><p>赛时首先想到奇偶分开后，将全体偶数向左或向右循环移动 $2$ ~ $3$ 位，这样可以保证绝大部分位置和左右两边之差为 $3$ 或 $5$ //当时以为要切了，结果剩余的数字考虑了两年半还是没有找到符合题意而不失一般性的构造方法</p><p>然后考虑分段调整。在上面思想的基础上，发现如果元素个数为 $8$ 个，那么全体偶数左移 $2$ 位和右移 $2$ 位的结果都为： $1,6,3,8,5,2,7,4$ 。并且如果下一段长度为 $8$ 的序列也按照这种规则变换顺序，那么 $4$ 和下一段长度为 $8$ 的序列的开头 $9$ 之差为 $5$ ，符合题意，从而解决了边界问题</p><p>将 $n$ 模 $8$ 取余，记 $n=8k+r$ 。解决前 $r$ 个数的排列后，之后每 $8$ 个数按 $1,6,3,8,5,2,7,4$ 的顺序变换即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ll rem[<span class="number">8</span>][<span class="number">8</span>]=&#123;&#123;&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">ll pl[<span class="number">9</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    ll r=n%<span class="number">8</span>,d=n/<span class="number">8</span>;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,r<span class="number">-1</span>) v.<span class="built_in">emplace_back</span>(rem[r][i]);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,d<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,<span class="number">8</span>)&#123;</span><br><span class="line">            v.<span class="built_in">emplace_back</span>(<span class="number">8</span>*i+pl[j]+r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout &lt;&lt; v[i] &lt;&lt; <span class="built_in">Presentation</span>(i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校08</title>
      <link href="/posts/ACM_2023Summer_HDU08.html"/>
      <url>/posts/ACM_2023Summer_HDU08.html</url>
      
        <content type="html"><![CDATA[<h1>1005.0 vs 1</h1><p><strong>博弈，模拟</strong></p><h2 id="题意">题意</h2><p>两人名为零和壹，在给定的 $01$ 串上进行博弈<br>零只能取走两端的某一个 $0$ ，壹只能取走两端的某一个 $1$ ，零执先<br>先不能取的人判负，若取完则判平局</p><h2 id="解题思路">解题思路</h2><p>模拟博弈过程，当前操作者 $x$ 可以可以遵循以下策略：</p><ol><li>两端不同，只能取 $x$ 的一端，交替操作权</li><li>两端相同<ol><li>两端都不是 $x$ ，无法操作，失败</li><li>两端都是 $x$ ，假设取了某端<ol><li>这端的下一个数字是 $x$ ，则两端都是 $x$ ，对方无法操作，获胜</li><li>这端的下一个数字是 $!x$ ，则对方只能取这一端</li></ol></li><li>如果离任一端最近的连续两个相同的数都为 $x$ ，则根据上 $2$ 一直取到 $x$ 获胜</li><li>如果离两端最近的连续两个相同的数都为 $!x$ ，则不论选哪端，最终都会到达两端都为 $!x$ 的情况，失败<ol><li>特判：如果整个串有且仅有 $1$ 段连续两个相同的 $!x$ ，则从两端向中间将各会取掉一个，达成平局</li></ol></li></ol></li></ol><p>可以结合代码注释理解这一过程</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_s</span><span class="params">(deque&lt;<span class="type">int</span>&gt; s,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    ll n=s.<span class="built_in">size</span>(),i,j;;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//取完平局</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">front</span>()!=s.<span class="built_in">back</span>())&#123;<span class="comment">//前后不同，无法自由选择，交替操作权</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">front</span>()==now)&#123;<span class="comment">//取前</span></span><br><span class="line">            s.<span class="built_in">pop_front</span>();<span class="built_in">solve_s</span>(s,(now?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//取后</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>(); <span class="built_in">solve_s</span>(s,(now?<span class="number">0</span>:<span class="number">1</span>));<span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//前后相同</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">front</span>()!=now) &#123;cout &lt;&lt; (now?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;1&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//两端不可取，失败</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>]) <span class="keyword">break</span>;<span class="comment">//从前往后找第一个连续</span></span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span>) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//无连续，取完平局</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==now) &#123;cout &lt;&lt; (now?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;0&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有己方连续，胜利</span></span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--) <span class="keyword">if</span>(s[j]==s[j<span class="number">-1</span>]) <span class="keyword">break</span>;<span class="comment">//从后往前找最后一个连续</span></span><br><span class="line">        <span class="keyword">if</span>(s[j]==now) &#123;cout &lt;&lt; (now?<span class="string">&quot;1&quot;</span>:<span class="string">&quot;0&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有己方连续，胜利</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>==j) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//有且仅有一对对方连续，取完平局</span></span><br><span class="line">        &#123;cout &lt;&lt; (now?<span class="string">&quot;0&quot;</span>:<span class="string">&quot;1&quot;</span>) &lt;&lt; endl;<span class="keyword">return</span> ;&#125;<span class="comment">//两对以上对方连续，失去主动权，判负</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    string ts;cin &gt;&gt; ts;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;<span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) s[i]=ts[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">solve_s</span>(s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Solubility</h1><p><strong>并查集/DFS</strong></p><h2 id="题意-2">题意</h2><p>给定 $n$ 个元素之间的 $m$ 对等价关系，问指定 $k$ 个元素是否属于同一等价类</p><h2 id="解题思路-2">解题思路</h2><p>这里给出两种解题思路：</p><ol><li>DFS：建无向图，DFS判断指定元素是否在同一个连通分量里</li><li>并查集：标准并查集板子题，裸套即可</li></ol><h2 id="参考代码-2">参考代码</h2><ol><li>DFS</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> visited[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; G;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    visited[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:G[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    G.<span class="built_in">clear</span>();G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) visited[i]=<span class="number">0</span>;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k;cin &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">s</span><span class="params">(k)</span></span>;<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:s) cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">DFS</span>(s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s) <span class="keyword">if</span>(!visited[x]) &#123;cout &lt;&lt; NO;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>并查集</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,m;cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k;cin &gt;&gt; k &gt;&gt; a;a=dsu.<span class="built_in">find</span>(a);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,k)&#123;</span><br><span class="line">        cin &gt;&gt; b;b=dsu.<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(b!=a) &#123;cout &lt;&lt; NO;<span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,k) cin &gt;&gt; n;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    &#125;cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1008.Expectation of Rank</h1><p><strong>线性代数-矩阵与向量空间、期望、动态规划</strong></p><h2 id="题意-3">题意</h2><p>给定两个正整数 $n,p$ ，其中 $p$ 是质数<br>$n$ 阶矩阵 $\bf A$ 中的所有元素随机在 $p$ 的有限域 $\mathbb{F}_p$ 中产生，求矩阵 $\bf A$ 的秩的期望 $\mathbb{E}(rank(\bf A))$ ，答案取模</p><h3 id="前置知识点">前置知识点</h3><ol><li><a href="https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E5%9F%9F/4273049">有限域</a> $\mathbb{F}_p$ ：在本题中可以粗略的理解为 $[0,p-1]$ 的整数集</li><li>线性代数-矩阵与向量空间基础知识：多维向量与向量组、线性相关、矩阵的秩与向量之间的关系、向量组张成向量空间的概念等</li></ol><p>建议在学习过《线性代数》课程后再解决本题。</p><h2 id="解题思路-3">解题思路</h2><p>一个含 $k$ 个向量的极大无关组可以张成一个 $k$ 维向量空间</p><p>在 $p$ 的有限域 $\mathbb{F}_p$ 下，每一维度上的坐标有 $p$ 种选择，故以该极大无关组为基，通过线性组合可以产生 $p^k$ 种不同的 $k$ 维向量（高维包含低维）<br>顺带一提，这并不意味着这 $p^k$ 种向量仅有 $k$ 位坐标非 $0$</p><p>矩阵 $\bf A$ 的每一行可以视为一个 $n$ 维向量，前 $i$ 行的秩表示了前 $i$ 个向量组成的向量组，其极大无关组中有多少个向量。这也意味着前 $i$ 行已经张成了一个多少维度的向量空间</p><p>构造DP数组， $dp_{i,k}$ 用以表示矩阵 $\bf A$ 前 $i$ 行的秩为 $k$ 的方案数</p><p>假设前 $i-1$ 行的秩为 $k$ ，那么其张成的向量空间为 $k$ 维，考虑状态转移：</p><ol><li>第 $i$ 行中可以构造出 $p^k$ 个向量落在这个向量空间中，并不改变秩（或者说维数）</li><li>余下 $p^n-p^k$ 个向量将与前 $i-1$ 个向量线性无关，并使张成的空间增大一维，秩 $+1$</li></ol><p>综上所述，构造出以下状态转移方程：<br>$$dp_{i,k}=<br>\begin{cases}<br>0 \qquad,k&gt;i\quad(rank_i\le i恒成立) \newline<br>1 \qquad,k=0\quad(当且仅当全为 \bf{0} \text{向量}) \newline<br>\sum\limits_{j=1}^{i-1} dp_{i-1,j}\times p^j + dp_{i-1,j-1}\times (p^n-p^j) &amp;,Otherwise<br>\end{cases}<br>$$</p><p>总方案数为 $(p^n)^n=p^{n^2}$ ，最终期望为 $\dfrac{1}{p^{n^2}}\sum\limits_{j=1}^{n} j\times dp_{n,j}$</p><h3 id="时间复杂度-2">时间复杂度</h3><p>DP：$O(n^2)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line">ll n,p;</span><br><span class="line">ll dp[N][N],powp[N];<span class="comment">//dp_i,k表示矩阵前i行秩为k的方案数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n)</span><br><span class="line">            dp[i][j]=<span class="number">0</span>;</span><br><span class="line">    powp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) powp[i]=<span class="built_in">mul</span>(powp[i<span class="number">-1</span>],p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="built_in">Init</span>(n);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(k,<span class="number">1</span>,i)&#123;<span class="comment">//每行看作一个向量，有p^n种构造法。确定前i行的秩为k的总向量方案数</span></span><br><span class="line">            <span class="built_in">addto</span>(dp[i][k],<span class="built_in">mul</span>(dp[i<span class="number">-1</span>][k],powp[k]));</span><br><span class="line">            <span class="comment">//对于前i-1行秩为k的某方案，其向量空间为k维，故在p的有限集下有且仅有p^k个向量落在该向量空间</span></span><br><span class="line">            <span class="built_in">addto</span>(dp[i][k],<span class="built_in">mul</span>(dp[i<span class="number">-1</span>][k<span class="number">-1</span>],<span class="built_in">sub</span>(powp[n],powp[k<span class="number">-1</span>])));</span><br><span class="line">            <span class="comment">//对于前i-1行秩为k-1的某方案，有p^(k-1)个向量落在其张成的向量空间，剩余向量与前i-1行线性无关</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>,ninv=<span class="built_in">inv</span>(<span class="built_in">qcpow</span>(powp[n],n));<span class="comment">//ninv:总方案数(p^n)^n的倒数</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="built_in">addto</span>(re,<span class="built_in">mul</span>(<span class="built_in">mul</span>(i,dp[n][i]),ninv));</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1010.Rikka with Square Numbers</h1><p><strong>数学、贪心</strong></p><h2 id="题意-4">题意</h2><p>给定两个正整数 $a,b$ ，每次操作可以使 $a$ 增大或减小一个平方数 $x$ ，求把 $a$ 变成 $b$ 的最小操作次数</p><h2 id="解题思路-4">解题思路</h2><p>即求 $a,b$ 之差最少可以用多少个平方数的和差表示。以下是一些思路：</p><ol><li>$a=b$ ， $0$</li><li>$n^2$ ，平方数本身， $1$</li><li>$n^2-(n-1)^2=2n-1$ ，用两个相邻平方数之差即可表示任意奇数</li><li>$n^2-(n-2)^2=4(n-1)$ ，用两个距离为 $2$ 的平方数之差可以表示任意 $4$ 的倍数</li><li>结合以上两条可以归纳证明两个平方数之差一定为奇数或 $4$ 的倍数，$2$</li><li>模 $4$ 余 $2$ 的情况可能为两平方数加和，可以枚举判断， $2$</li><li>其余的数可以用第 $3$ 点得到任意奇数后加减 $1$ ， $3$</li></ol><p>综上判定即可</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(\sqrt n)$</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Is_Sqr</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(t*t==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b); ll dif=a-b;</span><br><span class="line">    <span class="keyword">if</span>(a==b) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Is_Sqr</span>(dif)) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(dif%<span class="number">2</span>||(dif%<span class="number">4</span>==<span class="number">0</span>)) &#123;cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=dif;i++) <span class="keyword">if</span>(<span class="built_in">Is_Sqr</span>(dif-i*i)) &#123;cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校07</title>
      <link href="/posts/ACM_2023Summer_HDU07.html"/>
      <url>/posts/ACM_2023Summer_HDU07.html</url>
      
        <content type="html"><![CDATA[<h1>1002.Random Nim Game</h1><p><strong>诈骗博弈题</strong></p><h2 id="题意">题意</h2><p>Nim是一种双人数学策略游戏，玩家轮流从不同的堆中移除棋子。在每一轮游戏中，玩家必须至少取出一个棋子，并且可以取出任意数量的棋子，条件是这些棋子都来自同一个棋子堆。走最后一步棋（即取出最后一块棋子）的人获胜。</p><p>现在更改游戏规则，在每个回合中，棋手必须选择一个棋子堆。假设他选择的堆包含 $x$ 个棋子，将从 $[1,x]$ 中随机一个整数 $y$ ，并从堆中移除 $y$ 个棋子</p><p>求先手获胜的概率，答案取模</p><h2 id="解题思路">解题思路</h2><p>看起来很吓人的一道题（谁被吓退了我不说）//</p><p>考虑只有一个堆的情况<br>若只有 $1$ 个棋子，先手必胜<br>如果有 $2$ 个棋子，有 $\dfrac{1}{2}$ 的概率拿完获胜，有 $\dfrac{1}{2}$ 的概率余 $1$ 失败，综合胜率 $\dfrac{1}{2}$<br>$\vdots$<br>如果有 $x\ (x&gt;1)$ 个棋子，有 $\dfrac{n-2}{n}$ 的概率转移到 剩余个数 $&gt;1$ 的状态，有 $\dfrac{1}{n}$ 的概率拿完获胜，有 $\dfrac{1}{n}$ 的概率余 $1$ 失败。递归得到 $x&gt;1$ 的状态下的综合胜率为 $\dfrac{1}{2}$</p><p>再考虑多堆的情况<br>如果所有堆的棋子数量均为 $1$ ，则当堆数 $n$ 为奇数时先手必胜<br>如果有某堆的数量多于 $1$ 个，那么必胜态将以 $\dfrac{1}{2}$ 的概率流转</p><p>综上所述，如果所有堆的棋子数量均为 $1$ ，则当堆数 $n$ 为奇数时先手必胜， $n$ 为偶数时先手必败，其余情况综合胜率 $\dfrac{1}{2}$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll mx=<span class="number">0</span>,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,t);</span><br><span class="line">    &#125;<span class="keyword">if</span>(mx&gt;<span class="number">1</span>) cout &lt;&lt; <span class="built_in">inv</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">2</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1004.Medians Strike Back</h1><p><strong>构造</strong></p><h2 id="题意-2">题意</h2><p>定义长度为 $n$ 的整数序列的中位数：</p><ol><li>如果 $n$ 为奇数，则中位数是将序列排序后正中间的数</li><li>如果 $n$ 为偶数，则中位数是将序列排序后中间两个数中，出现次数较多的那个数，如果出现次数相同则取较小的那个数</li></ol><p>定义序列的 $shikness$ ：该序列中位数出现的次数<br>定义序列的 $nitness$ ：该序列的所有连续子串的 $shikness$ 的最大值</p><p>给定一个正整数 $n$ ，构造长度为 $n$ 且仅含元素 $1,2,3$ 的序列，并使 $nitness$ 最小化，求出最小值</p><h2 id="解题思路-2">解题思路</h2><p>构造找规律<br>$nitness_{min}=1$ 时，构造出最长序列为： $123$<br>$nitness_{min}=2$ 时，构造出最长序列为： $1313221313$<br>$nitness_{min}=3$ 时，构造出最长序列为： $131313222131313$<br>$nitness_{min}=4$ 时，构造出最长序列为： $1313131322131313132213131313$</p><p>如果序列中存在两个及以上的 $2$ ，那么 $2$ 是稳定作为中位数的，因此可以考虑以下构造方法：<br>连续 $n$ 对 $13$ 为一个单位子串//每个单位子串利用两个或三个连续的 $2$ 隔开，将得到以下格式的序列：$1313(n对)\cdots22\ 1313(n对)\cdots22\ 1313(n对)$</p><p>下面阐释这种构造方法的合法性</p><ol><li>对于整个序列， $nitness=cnt_2=n$</li><li>对于含多个 $2$ 的子串， $2$ 稳定做中位数， $nitness&lt;cnt_2=n$</li><li>对于仅含一个 $2$ 的子串，这个 $2$ 一定在单位子串的左边或右边，而单位子串的长度为 $2n$ ，因此加上 $2$ 后的长度为奇数，$2$ 稳定做中位数，$nitness=1$</li><li>对于不含 $2$ 的子串，其一定也是单位子串的子串，而单位子串中 $cnt_1=cnt3=n$ ，因此 $nitness\le n$</li></ol><p>计数得到最长长度的通项公式： $len_i=2i(\lfloor \dfrac{i}{2} \rfloor+1)+i$</p><p>初始化长度数组，二分查找即可</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 500000</span></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(v),n)-v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------Initialize----------*/</span></span><br><span class="line">    v[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">        v[i]=(i/<span class="number">2</span>+<span class="number">1</span>)*<span class="number">2</span>*i+i;</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;<span class="number">1e11</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"><span class="comment">/*----------Initialize----------*/</span></span><br></pre></td></tr></table></figure><hr><h1>1011.Three Operations</h1><p><strong>签到题</strong></p><h2 id="题意-3">题意</h2><p>给定正整数 $x,a,b$ 可以进行以下操作：</p><ol><li>$x\leftarrow x-1$</li><li>$x\leftarrow \lfloor \dfrac{x+a}{2} \rfloor$</li><li>$x\leftarrow \lfloor \sqrt{x+b} \rfloor$</li></ol><p>求使得 $x$ 变为 $0$ 的最少操作次数</p><h2 id="解题思路-3">解题思路</h2><p>每次比较三种操作后的 $x$ 最小即可</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,a,b,t,re=<span class="number">0</span>;cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        t=<span class="built_in">min</span>((x+a)/<span class="number">2</span>,(ll)<span class="built_in">sqrt</span>(x+b));</span><br><span class="line">        <span class="keyword">if</span>(t&lt;x<span class="number">-1</span>) &#123;re++;x=t;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;re+=x;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1013.Minimal and Maximal XOR Sum</h1><p><strong>归并排序、贪心</strong></p><h2 id="题意-4">题意</h2><p>给定一个长度为 $n$ 的排列 $p$ ，每次操作可以选定一段连续子序列 $p_{i,j}$ ，花费等同于元素个数的代价 $c=j-i+1$ ，使得这一段顺序反转<br>记使得排序变成自然排序（ $p_i=i$ ）所经过的一系列操作中，每一次的代价的异或和为 $x=c_1 \oplus c_2 \oplus \cdots \oplus c_i$<br>求 $x$ 的最大值和最小值</p><h2 id="解题思路-4">解题思路</h2><p>排列的奇偶性定义为其所具有的逆序对数的奇偶性。任意一个n阶排列，可经过一系列对换转变为标准排列，且所做对换的次数与排列具有相同的奇偶性。</p><p>观察操作的特点可以得出，选定单一元素操作时，排列本身不发生改变，但产生 $1$ 点代价//这意味着所得结果 $x$ 的最后一个二进制位可以任意调整（和 $1$ 做异或）</p><p>考虑使得 $x$ 最小的操作方法<br>每次花费 $2$ 代价做对换，最小值 $x_{min}$ 一定会落在 $0$ 或 $2$ 上。根据对换次数与排列奇偶性的关系，判断排列逆序对数的奇偶性即可，可以使用归并排序进行逆序对计数</p><p>接下来考虑使得 $x$ 最大的操作方法<br>在排列 $p$ 已经有序的情况下，考虑如何操作花费代价可以使得异或和 $x$ 产生高位 $1$ ：先花费高代价 $c$ 反转某个长子序列，再连续花费 $2$ 代价做对换将序列恢复为有序</p><p>可以发现 $x$ 的最大可能二进制位数与 $n$ 相同，逐位考虑转 $1$ 记某位上的权重为 $2^m &lt;n$ ，则反转 $2^m$ 个数后，恢复有序需要连续做对换的次数为 $2^m(2^m-1)/2$ ， $m\ge 2$ 时对换次数为偶数，即对最终的异或和 $x$ 无影响，这意味着按照上述策略可以将 $x$ 倒数第3位（权重为4）及以前的数位全部置1//</p><p>$m=1$ 时对换次数为 $1$ ，和反转 $2^1$ 个数的代价 $2$ 抵消，因此无法变更倒数第二位的值</p><p>综上所述，只需将 $x$ 调整为与 $n$ 具有相同二进制数的最大值，再判断倒数第二位即可//</p><h3 id="时间复杂度">时间复杂度</h3><p>归并排序： $O(n\log n)$</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin &gt;&gt; n;ll mn,mx;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:v) cin &gt;&gt; x;</span><br><span class="line">    ll cntinv=<span class="built_in">mergeSortAndCount</span>(v,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cntinv%<span class="number">2</span>) mn=<span class="number">2</span>;<span class="keyword">else</span> mn=<span class="number">0</span>;</span><br><span class="line">    ll t=n,dig=<span class="number">0</span>;<span class="keyword">while</span>(t) &#123;dig++;t/=<span class="number">2</span>;&#125;</span><br><span class="line">    mx=(<span class="number">1</span>&lt;&lt;dig)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mn==<span class="number">0</span>) mx-=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;0 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; mn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校07</title>
      <link href="/posts/ACM_2023Summer_NCD07.html"/>
      <url>/posts/ACM_2023Summer_NCD07.html</url>
      
        <content type="html"><![CDATA[<h1>M.Writing Books</h1><p><strong>签到</strong></p><h2 id="题意">题意</h2><p>给定一个正整数 $n$ ，求 $1$ ~ $n$ 共有多少位数字</p><h2 id="解题思路">解题思路</h2><p>$1$ ~ $9$ 共 $9\times 10^0 \times 1$ 位；<br>$10$ ~ $99$ 共 $9\times 10^1 \times 2$ 位；<br>以此类推，求和即可</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a=<span class="number">1</span>,x=<span class="number">9</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=x) &#123;n-=x;cnt+=a*x;x*=<span class="number">10</span>;a++;&#125;</span><br><span class="line">    cnt+=a*n;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校06</title>
      <link href="/posts/ACM_2023Summer_NCD06.html"/>
      <url>/posts/ACM_2023Summer_NCD06.html</url>
      
        <content type="html"><![CDATA[<h1>A.Tree</h1><p><strong>图论-Kruskal、动态规划</strong></p><h2 id="题意">题意</h2><p>给定一棵 $n$ 个节点带点权和边权的无根树</p><p>节点具有颜色白（$0$）和黑（$1$），颜色可反转，所需代价 $cost_i$ 为该点点权</p><p>整棵树的 $earning$ 为 $\sum\limits_{u\in V_0}\sum\limits_{v\in V_1} val(u,v)$ 。其中， $val(u,v)$ 为节点 $u\rightarrow v$的最短路径上的最大边权， $V_0$ 为白色点集， $V_2$ 为黑色点集</p><p>可以操作反转节点颜色任意次，求最大 $earning-\sum cost$ （以下简称 $score$ ）</p><h2 id="解题思路">解题思路</h2><p>注意到对于每对黑白点对，其贡献为最短路径上的最大边权。考虑利用Kruskal算法对树进行重构，即按边权从小到大的顺序进行加边</p><p>可以发现，在加入某条边 $e_i$ 时，原本在同一连通分量中的黑白点对的 $score$ 不受影响。由于加边顺序，新加的边一定具有目前最大的边权，因此只有经过新加的这条边的点对才对 $score$ 具有贡献，每个点对的贡献值为 $w_i$ ，点对数量为：$左白\times右黑+左黑\times右白$</p><p>构造dp数组：定义 $dp_{i,j}$ 为连通分量 $i$ （以并查集中连通分量的根节点标识）中具有 $j$ 个白色节点时的最大 $score$ 。初始对于点 $i$ ，$dp_{i,color_i}=0$ （不变）；$dp_{i,color_i\oplus 1}=-cost_i$ （反转）</p><p>在合并 $A、B$ 两个连通分量到 $C$ 时具有以下转移方程：<br>$$<br>dp_{C,i}=\max\limits_{0\le k \le |A| \And 0\le i-k\le |B|}{dp_{A,k}+dp_{B,i-k}+w(k(|B|-(i-k))+(i-k)(|A|-k))}<br>$$<br>（两边原有的 $score$ 加上过新加边的 $score$ ）</p><p>可以结合代码注释进行理解</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n^2\log n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;ll w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">edge</span>():<span class="built_in">u</span>(<span class="number">0</span>),<span class="built_in">v</span>(<span class="number">0</span>),<span class="built_in">w</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> _u,<span class="type">int</span> _v,ll _w): <span class="built_in">u</span>(_u),<span class="built_in">v</span>(_v),<span class="built_in">w</span>(_w) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//手写edge类，自定义比较方式</span></span><br><span class="line"><span class="comment">//下面的注释中也添加了不用手写的代码，优点是少写一段代码，缺点是表述较为冗杂不直观</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"><span class="type">int</span> dsu[N]=&#123;<span class="number">0</span>&#125;,sz[N]=&#123;<span class="number">0</span>&#125;,color[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;ll&gt; dp[N];<span class="comment">//dp_i,j:集合i有j个白色点时的score</span></span><br><span class="line">vector&lt;edge&gt; Edge;</span><br><span class="line"><span class="comment">//vector&lt;pair&lt;ll,pll&gt;&gt; Edge;//&lt;w,&lt;u,v&gt;&gt;;</span></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">cost</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">find_dsu</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dsu[x]==x?x:dsu[x]=<span class="built_in">find_dsu</span>(dsu[x]);</span><br><span class="line">&#125;<span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_dsu</span><span class="params">(ll a,ll b,ll w)</span></span>&#123;</span><br><span class="line">    a=<span class="built_in">find_dsu</span>(a);b=<span class="built_in">find_dsu</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(sz[a]&gt;sz[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    ll n=sz[a]+sz[b],rt;</span><br><span class="line">    <span class="comment">//n:a,b点集体积之和，即白点数量上限</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">tmp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">        rt=-INF;</span><br><span class="line">        <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=sz[a];k++) <span class="keyword">if</span>(k&lt;=i&amp;&amp;i-k&lt;=sz[b])&#123;<span class="comment">//k:a中白点数量</span></span><br><span class="line">            ll cnt0=i-k,cnt1=sz[b]-(i-k);<span class="comment">//cnt0:b中白点数量 cnt1:b中黑点数量</span></span><br><span class="line">            rt=<span class="built_in">max</span>(rt,dp[a][k]+dp[b][i-k]+w*(k*cnt1+cnt0*(sz[a]-k)));</span><br><span class="line">            <span class="comment">//dp=max(两点集已经具有的最大earning-cost+经过这条边的点对数*边权)</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp[i]=rt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[b]=tmp;</span><br><span class="line"></span><br><span class="line">    sz[b]+=sz[a];</span><br><span class="line">    dsu[a]=b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    Edge.<span class="built_in">resize</span>(n<span class="number">-1</span>);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        dp[i].<span class="built_in">resize</span>(<span class="number">2</span>);<span class="comment">//接下来有需求会扩容</span></span><br><span class="line">        dsu[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; color[i];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">        dp[i][color[i]]=(ll)<span class="number">0</span>;</span><br><span class="line">        dp[i][color[i]^<span class="number">1</span>]=(ll)-cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:Edge)&#123;</span><br><span class="line">        cin &gt;&gt; e.u &gt;&gt; e.v &gt;&gt; e.w;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">        <span class="comment">//e.second.first=u;e.second.second=v;e.first=w;</span></span><br><span class="line">    &#125;<span class="comment">//存边</span></span><br><span class="line">    <span class="built_in">SORT</span>(Edge);<span class="comment">//按边权从小到大重构树</span></span><br><span class="line">    edge e;</span><br><span class="line">    <span class="comment">//pair&lt;ll,pll&gt; e;</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">        e=Edge[i];</span><br><span class="line">        u=e.u;v=e.v;w=e.w;</span><br><span class="line">        <span class="comment">//u=e.second.first;v=e.second.second;w=e.first;</span></span><br><span class="line">        <span class="built_in">merge_dsu</span>(u,v,w);</span><br><span class="line">    &#125;<span class="keyword">auto</span> tmp=dp[<span class="built_in">find_dsu</span>(<span class="number">1</span>)];</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(<span class="built_in">ALL</span>(tmp)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>B.Distance</h1><p><strong>数学、贪心(?)</strong></p><h2 id="题意-2">题意</h2><p>对于两个大小相同的多重集 $\mathbb{A},\mathbb{B}$ ，可以选择其中任一元素 $x$ 执行操作 $x=x+1$  任意次数，最少的使得 $\mathbb{A},\mathbb{B}$ 相同的操作次数记为 $C(\mathbb{A},\mathbb{B})$<br>不同大小的 $\mathbb{A},\mathbb{B}$ 视为 $C(\mathbb{A},\mathbb{B})=0$</p><p>现在，给定两个大小为 $n$ 的多重集 $\mathbb{S},\mathbb{T}$ ，求对于 $\mathbb{S},\mathbb{T}$ 的所有子集 $\mathbb{A},\mathbb{B}$ ，最少操作次数之和 $\sum\limits_{\mathbb{A} \subseteq \mathbb{S}}\sum\limits_{\mathbb{B} \subseteq \mathbb{T}} C(\mathbb{A},\mathbb{B})$ 的值<br>具有相同值的两个元素视为不同元素，答案取模</p><h2 id="解题思路-2">解题思路</h2><p>对于某对子集 $\mathbb{A},\mathbb{B}$ ，为了使他们相同的操作次数最少，我们会将他们排序的元素后一一对应，使每一对中较小的数变成较大的数//假设 $a_i$ 与 $b_i$ 对应，他们在这次变化中贡献的操作次数显然是 $|a_i-b_i|$</p><p>那么换一种角度考虑，对于原多重集 $\mathbb{S},\mathbb{T}$ ，任取一对数 $a_i,b_j$ ，考虑它们俩对应的方案数 $cnt_{i,j}$ ，那么它们在全部方案中贡献的总操作次数即为 $|a_i-b_i|\times cnt_{i,j}$</p><p>由于我们的操作策略是排序后对应，因此先对 $\mathbb{S},\mathbb{T}$ 进行排序//<br>选定两个数 $a_i,b_j$ 后，它们在 $\mathbb{S},\mathbb{T}$ 中的位置前面选 $k$ 对数的方案数为 $\sum\limits_{k=0}^{min(i-1,j-1)}C_{i-1}^kC_{j-1}^k=C_{i+j-2}^k$ （<a href="https://oi-wiki.org/math/combinatorics/vandermonde-convolution/">范德蒙德卷积</a>）</p><p>同理，它们在 $\mathbb{S},\mathbb{T}$ 中的位置后面选 $k$ 对数的方案数为 $C_{2<em>n-i-j}^k$<br>总方案数为 $cnt_{i,j}=C_{i+j-2}^kC_{2</em>n-i-j}^k$ ，乘以两数之差的绝对值即为它们对答案的总贡献//</p><p>预处理组合数，枚举 $i,j$ 求和即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n^2)$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:b) cin &gt;&gt; x;</span><br><span class="line">    ll re=<span class="number">0</span>;<span class="built_in">SORT</span>(a);<span class="built_in">SORT</span>(b);</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">addto</span>(re,<span class="built_in">mul</span>(<span class="built_in">abs</span>(a[i]-b[j]),<span class="built_in">mul</span>(<span class="built_in">Get_Combination</span>(i+j,i),<span class="built_in">Get_Combination</span>((n-i<span class="number">-1</span>)+(n-j<span class="number">-1</span>),(n-i<span class="number">-1</span>)))));</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>C.idol!!</h1><p><strong>数学</strong></p><h2 id="题意-3">题意</h2><p>正整数 $n$ 的双阶乘 $n!!$ 表示不超过 $n$ 且与 $n$ 有相同奇偶性的所有正整数乘积<br>求对于给定 $n$ ，$\prod\limits_{i=1}^n i!!$ 的后缀 $0$ 个数</p><h2 id="解题思路-3">解题思路</h2><p>根据双阶乘的性质，可以得到： $(n-1)!!\times n!!=n!$<br>因此对于给定的 $n$ ，原式可化为：<br>$$\prod\limits_{i=1}^n i!!=\begin{cases}<br>\prod\limits_{i=1}^\frac{n}{2} (2i)! &amp;,n为偶数 \newline<br>\prod\limits_{i=1}^\frac{n+1}{2} (2i-1)! &amp;,n为奇数<br>\end{cases}$$<br>显而易见的，阶乘中因子 $2$ 的个数一定多于因子 $5$ 的个数，因此题目等价于求上式中因子 $5$ 的个数//</p><p>考虑某单一阶乘 $n!$ 中所含因子 $5$ 的个数。<br>可以发现，每个 $5$ 的倍数项会提供 $1$ 个因子 $5$ ，共有 $\lfloor \dfrac{n}{5} \rfloor$ 项<br>除此之外每个 $25=5^2$ 的倍数项会额外提供一个因子 $5$ ，共有 $\lfloor \dfrac{n}{5^2} \rfloor$ 项<br>再除此之外每个 $125=5^3$ 的倍数项会额外提供一个因子 $5$ ，共有 $\lfloor \dfrac{n}{5^3} \rfloor$ 项……<br>因此对于单一阶乘 $n!$ ，其提供因子 $5$ 的数量 $cnt_5=\sum\limits_{i=1}^N \lfloor \dfrac{n}{5^i} \rfloor (5^N&gt;n)$</p><p>接着考虑连乘积中因子 $5$ 个数的总和。<br>$$<br>ans=\begin{cases}<br>\sum\limits_{i=1}^\frac{n}{2} \sum\limits_{j=1}^N \lfloor \dfrac{2i}{5^j} \rfloor=\sum\limits_{i=1}^N \sum\limits_{j=1}^\frac{n}{2} \lfloor \dfrac{2j}{5^i} \rfloor &amp;,n为偶数 \newline<br>\sum\limits_{i=1}^\frac{n+1}{2} \sum\limits_{j=1}^N \lfloor \dfrac{2i-1}{5^j} \rfloor=\sum\limits_{i=1}^N \sum\limits_{j=1}^\frac{n+1}{2} \lfloor \dfrac{2j-1}{5^i} \rfloor &amp;,n为奇数<br>\end{cases} \newline<br>$$</p><p>对于某一 $i$ ，发现不论 $n$ 的奇偶， $j=1$ 开始的每 $5^i$ 项之和构成公差为 $2\times5^i$ 的等差数列//<br>例：$i=1$ ，$n$ 为偶数且足够大时，$\lfloor \dfrac{2j}{5^i} \rfloor$ 的前 $15$ 项如下，其中每 $5$ 项之和构成公差为 $5\times 2$ 的等差数列： $0,0,1,1,2||2,2,3,3,4||4,4,5,5,6……$</p><p>经计算，对于某一 $i$ ，等差数列的首项为<br>$$<br>a_1=\begin{cases}<br>\lfloor \dfrac{5^i}{2} \rfloor+2 &amp;,n为偶数 \newline<br>\lfloor \dfrac{5^i}{2} \rfloor+1 &amp;,n为奇数<br>\end{cases}<br>$$</p><p>完整的段用等差数列求和，非完整的段手算一下//<br>​<br>若此前完整段的数量记为 $m$ ，则非完整段：<br>前 $\lfloor \dfrac{5^i}{2} \rfloor$ 项的值为 $2m$ ，<br>第 $\lfloor \dfrac{5^i}{2} \rfloor+1$ 至 $2\times\lfloor \dfrac{5^i}{2} \rfloor $ 项的值为 $2m+1$（手搓一下就知道了）</p><p>求和即可</p><p>令 $N=\lfloor \log_5n \rfloor+1$ ，对 $i\in[1,N]$ 遍历求和得到答案</p><p>由于答案数据极其庞大，超出了C++ %lld(64bits)的范围，因此需要使用更高位数的整数类型（如int128）//或者直接转战Python</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(\log n)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># while 1:</span></span><br><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">N=<span class="built_in">int</span>(math.log(n,<span class="number">5</span>)+<span class="number">1</span>)</span><br><span class="line">re=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>) :</span><br><span class="line">        <span class="comment">#print(&quot;i=&quot;+str(i))</span></span><br><span class="line">        a1=(<span class="number">5</span>**i)//<span class="number">2</span>+<span class="number">2</span> <span class="comment">#首项</span></span><br><span class="line">        <span class="comment">#print(&quot;a1=&quot;+str(a1))</span></span><br><span class="line">        d=(<span class="number">5</span>**i)*<span class="number">2</span> <span class="comment">#公差</span></span><br><span class="line">        <span class="comment">#print(&quot;d=&quot;+str(d))</span></span><br><span class="line">        m=(n//<span class="number">2</span>)//(<span class="number">5</span>**i) <span class="comment">#完整段数</span></span><br><span class="line">        <span class="comment">#print(&quot;m=&quot;+str(m))</span></span><br><span class="line">        re+=(<span class="number">2</span>*a1+(m-<span class="number">1</span>)*d)*m//<span class="number">2</span> <span class="comment">#完整段等差数列求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re1:&quot; + str(re))</span></span><br><span class="line">        re+=(n//<span class="number">2</span>-m*(<span class="number">5</span>**i))*<span class="number">2</span>*m <span class="comment">#最后一段余项求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re2:&quot; + str(re))</span></span><br><span class="line">        <span class="comment">#print(&quot;pl1=&quot; + str((n//2-m*(5**i))*2*m))</span></span><br><span class="line">        <span class="keyword">if</span> n//<span class="number">2</span>-m*(<span class="number">5</span>**i)&gt;(<span class="number">5</span>**i)//<span class="number">2</span> :</span><br><span class="line">            re+=n//<span class="number">2</span>-m*(<span class="number">5</span>**i)-(<span class="number">5</span>**i)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#print(&quot;pl2=&quot; + str(n//2-m*(5**i)-(5**i)//2))</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>) :</span><br><span class="line">        <span class="comment">#print(&quot;i=&quot;+str(i))</span></span><br><span class="line">        a1=(<span class="number">5</span>**i)//<span class="number">2</span>+<span class="number">1</span> <span class="comment">#首项</span></span><br><span class="line">        <span class="comment">#print(&quot;a1=&quot;+str(a1))</span></span><br><span class="line">        d=(<span class="number">5</span>**i)*<span class="number">2</span> <span class="comment">#公差</span></span><br><span class="line">        <span class="comment">#print(&quot;d=&quot;+str(d))</span></span><br><span class="line">        m=((n+<span class="number">1</span>)//<span class="number">2</span>)//(<span class="number">5</span>**i) <span class="comment">#完整段数</span></span><br><span class="line">        <span class="comment">#print(&quot;m=&quot;+str(m))</span></span><br><span class="line">        re+=(<span class="number">2</span>*a1+(m-<span class="number">1</span>)*d)*m//<span class="number">2</span> <span class="comment">#完整段等差数列求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re1:&quot; + str(re))</span></span><br><span class="line">        re+=((n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i))*<span class="number">2</span>*m <span class="comment">#最后一段余项求和</span></span><br><span class="line">        <span class="comment">#print(&quot;re2:&quot; + str(re)) </span></span><br><span class="line">        <span class="comment">#print(&quot;pl1=&quot; + str(((n+1)//2-m*(5**i))*2*m))</span></span><br><span class="line">        <span class="keyword">if</span> (n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i)&gt;(<span class="number">5</span>**i)//<span class="number">2</span> :</span><br><span class="line">            re+=(n+<span class="number">1</span>)//<span class="number">2</span>-m*(<span class="number">5</span>**i)-(<span class="number">5</span>**i)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#print(&quot;pl2=&quot; + str((n+1)//2-m*(5**i)-(5**i)//2))</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(re)</span><br></pre></td></tr></table></figure><hr><h1>E.Sequence</h1><p><strong>思维题</strong></p><h2 id="题意-4">题意</h2><p>给定一个长度为 $n$ 的正整数序列，并进行 $q$ 次询问<br>每次询问给定一个范围 $[l,r]$ 和一个正整数 $k$<br>问能否将序列中给定范围内的子序列划分为 $k$ 段非空区间，且每段区间之和为偶数</p><h2 id="解题思路-4">解题思路</h2><p>首先对于给定区间：</p><ol><li>给定区间内总元素个数不足 $k$ ，则无法划分</li><li>给定区间内奇数元素个数为奇数，则给定区间的和为奇数，无法划分为 $k$ 个和为偶数的区间</li><li>给定区间内奇数元素个数为偶数，则最优划分为：从前往后奇数两两匹配形成区间，余下的偶数自成一个区间</li></ol><p>因此本题的关键就在于区间内奇数的处理</p><p>输入的记录奇数所在的位置，每次询问对于给定的区间，二分查找第一次出现奇数的位置和最后一次出现的位置，判断奇数个数<br>符合要求再进行区间计数判断，具体实现和解释可以参考代码注释</p><h3 id="时间复杂度-4">时间复杂度</h3><p>2023/8/5：纠正：最坏时间复杂度为 $O(qn)$ ，卡一下平均能过qwq</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,q,t;cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    vector&lt;ll&gt; v,odd;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;v.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) odd.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;<span class="comment">//奇数下标存入odd,O(n)</span></span><br><span class="line">    ll l,r,k;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span>(r-l&lt;k<span class="number">-1</span>) &#123;cout &lt;&lt; NO;<span class="keyword">continue</span>;&#125;<span class="comment">//元素数量小于k</span></span><br><span class="line">        <span class="keyword">if</span>(odd.<span class="built_in">empty</span>()) &#123;cout &lt;&lt; YES;<span class="keyword">continue</span>;&#125;<span class="comment">//整个序列无奇数</span></span><br><span class="line">        <span class="keyword">auto</span> ol=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(odd),l);<span class="comment">//找到区间左端点右边最近的奇数的位置</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(odd),r)-ol)&amp;<span class="number">1</span>) &#123;cout &lt;&lt; NO;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//如果区间内奇数个数为奇数个，一定会残留一个区间和为奇数的区间</span></span><br><span class="line">        ll cnt=<span class="number">0</span>;<span class="comment">//最多区间计数</span></span><br><span class="line">        <span class="keyword">while</span>(ol!=odd.<span class="built_in">end</span>()&amp;&amp;*ol&lt;=r)&#123;<span class="comment">//下一个奇数在区间内</span></span><br><span class="line">            cnt+=*ol-l;ol++;<span class="comment">//奇数左边的偶数一个记一段</span></span><br><span class="line">            <span class="keyword">if</span>(*ol&lt;=r) cnt++;<span class="comment">//两个奇数之间记一段</span></span><br><span class="line">            l=*ol+<span class="number">1</span>;ol++;<span class="comment">//更新左端点</span></span><br><span class="line">        &#125;<span class="keyword">if</span>(ol==odd.<span class="built_in">begin</span>()) &#123;cout &lt;&lt; YES;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        ol--;cnt+=r-*ol;<span class="comment">//加上区间右边剩余偶数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=k) cout &lt;&lt; YES;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>G.Gcd</h1><p><strong>数论</strong></p><h2 id="题意-5">题意</h2><p>给定一个包含两个非负数的初始集合 $S={x,y}$<br>每次操作可以选定其中不相等的两个数 $a,b$ ，并将 $a-b$ 或 $gcd(a,b)$ 置入集合 $S$ ，其中 $gcd(0,a)=a$<br>可以操作任意次，问能否使得集合 $S$ 包含非负数 $z$</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://oi-wiki.org/math/number-theory/bezouts/">裴蜀定理</a></p><h2 id="解题思路-5">解题思路</h2><p>根据裴蜀定理，两个正整数辗转相减只能得到他们最大公约数的倍数//<br>因此对于 $z$ ，判断其是否是 $g=gcd(x,y)$ 的倍数即可。<br>如果 $z$ 是 $g$ 的倍数，则可以通过以下操作得到 $z$ ：</p><ol><li>将 $g=gcd(x,y)$ 置入集合</li><li>$x$ 作为 $g$ 的倍数，其加减任意次 $g$ 便可得到任意 $g$ 的倍数。<br>只能减不能加怎么办呢//先把 $x$ 减到 $-g$ 就好了</li></ol><p>值得注意的是，本题的数据约束为<strong>非负数</strong>，这意味着需要对 $0$ 的情况进行特判//</p><ol><li>对于 $z=0$ ，仅当 $x,y$ 有 $0$ 时有解</li><li>对于 $x=0$ 或 $y=0$ ，仅当 $z$ 为非 $0$ 项的倍数时有解（实际上这条也满足裴蜀定理，直接归入一般情况即可）</li></ol><p>参考样例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">in</span>: <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="attribute">out</span>: YES</span><br></pre></td></tr></table></figure><h2 id="参考代码-5">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y,z;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;&amp;y&amp;&amp;z==<span class="number">0</span>) &#123;cout &lt;&lt; NO;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll g=<span class="built_in">gcd</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(z%g) cout &lt;&lt; NO;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校06</title>
      <link href="/posts/ACM_2023Summer_HDU06.html"/>
      <url>/posts/ACM_2023Summer_HDU06.html</url>
      
        <content type="html"><![CDATA[<h1>1001.Count</h1><p><strong>构造</strong></p><h2 id="题意">题意</h2><p>给定 $n,m,k$ ，构造长度为 $n$ 的整数序列，元素大小范围为 $a_i\in [1,m]$ ，并且需要保证前 $k$ 个元素和后 $k$ 个元素对应相同<br>求可以构造出的序列数量</p><h2 id="解题思路">解题思路</h2><p>模拟一下即可<br>对于 $k\le \dfrac{n}{2}$ ，最后 $k$ 个元素由前 $k$ 个元素确定，只需决定前 $n-k$ 个元素<br>对于 $\dfrac{n}{2}\le k \lt n$ ，确定了前 $n-k$ 个元素，可以递归向后确定更多元素<br>对于 $k=n$ ，序列本身自然相同，即可以随意确定 $n$ 个元素</p><p>确定 $x$ 个元素的方案总数为 $m^{x}$ ，快速幂取模即可<br>(P.S.):快速幂前先对底数取模//</p><h3 id="时间复杂度">时间复杂度</h3><p>快速幂： $O(\log n)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(n==k) cout &lt;&lt; <span class="built_in">qcpow</span>(m,n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">qcpow</span>(m,n-k) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校05</title>
      <link href="/posts/ACM_2023Summer_HDU05.html"/>
      <url>/posts/ACM_2023Summer_HDU05.html</url>
      
        <content type="html"><![CDATA[<h1>1001.Typhoon</h1><p><strong>计算几何</strong></p><h2 id="题意">题意</h2><p>依次给定 $n$ 个坐标 $P$ ，预测的台风路线为按顺序两两连接给定坐标所得的折线<br>现在有 $m$ 个庇护所的坐标 $S$ ，求每个庇护所到台风路线的最短距离<br><img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_HDU05_1001.jpg" alt="Img"></p><h2 id="解题思路">解题思路</h2><p>对于每个庇护所坐标，求它到每个路线线段的距离，再取最短即可<br>常见的错误为计算了点到线段所在直线的距离，而非到线段的距离（<s>别问我怎么知道的</s>）</p><p>问题转移到如何计算点到线段的距离<br>可以考虑将线段表示为向量，记为 $vec$ ;点到线段两端的向量记为 $vec1,vec2$<br>如果 $vec1,vec2$ 与 $vec$ 的点积同时大于 $0$ 或同时小于 $0$ ，则距离在端点取到，否则距离为点到直线的距离//<br>具体说明可以参考代码注释</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(nm)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pll&gt; typh,shel;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; frac,dist;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cal_dist</span><span class="params">(pll s,pll t1,pll t2)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    ll x,y,x1,y1,x2,y2,p1,p2;</span><br><span class="line">    pll vec,vec1,vec2;<span class="type">double</span> re;</span><br><span class="line">    x=s.first;y=s.second;<span class="comment">//庇护所坐标</span></span><br><span class="line">    x1=t1.first;y1=t1.second;<span class="comment">//端点1</span></span><br><span class="line">    x2=t2.first;y2=t2.second;<span class="comment">//端点2</span></span><br><span class="line">    vec=&#123;x2-x1,y2-y1&#125;;vec1=&#123;x-x1,y-y1&#125;;vec2=&#123;x-x2,y-y2&#125;;</span><br><span class="line">    <span class="comment">//线段向量、点到两个端点的向量</span></span><br><span class="line">    p1=vec.first*vec1.first+vec.second*vec1.second;<span class="comment">//点积1</span></span><br><span class="line">    p2=vec.first*vec2.first+vec.second*vec2.second;<span class="comment">//点积2</span></span><br><span class="line">    <span class="keyword">if</span>(p1&lt;=<span class="number">0</span>&amp;&amp;p2&gt;<span class="number">0</span>||p1&gt;<span class="number">0</span>&amp;&amp;p2&lt;=<span class="number">0</span>)&#123;<span class="comment">//点到直线距离</span></span><br><span class="line">        <span class="type">double</span> frac=(<span class="type">double</span>)<span class="built_in">sqrt</span>((y2-y1)*(y2-y1)+(x1-x2)*(x1-x2));</span><br><span class="line">        re=(<span class="type">double</span>)<span class="built_in">fabs</span>((y2-y1)*x+(x1-x2)*y-y2*x1+x2*y1)/frac;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//点到端点距离</span></span><br><span class="line">        <span class="type">double</span> dist1=(<span class="type">double</span>)<span class="built_in">sqrt</span>(vec1.first*vec1.first+vec1.second*vec1.second);</span><br><span class="line">        <span class="type">double</span> dist2=(<span class="type">double</span>)<span class="built_in">sqrt</span>(vec2.first*vec2.first+vec2.second*vec2.second);</span><br><span class="line">        re=<span class="built_in">min</span>(dist1,dist2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    typh.<span class="built_in">resize</span>(n);shel.<span class="built_in">resize</span>(m);dist.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:typh) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:shel) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;dist[i]=INF;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-2</span>)</span><br><span class="line">            dist[i]=<span class="built_in">min</span>(dist[i],<span class="built_in">cal_dist</span>(shel[i],typh[j],typh[j+<span class="number">1</span>]));&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> i:dist) &#123;<span class="built_in">print_float</span>(i,<span class="number">4</span>);cout &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1006.Touhou Red Red Blue</h1><p><strong>贪心/DP</strong></p><h2 id="题意-2">题意</h2><p>你将依次收到 $n$ 个物品，他们具有颜色红、绿或蓝，记为 $R,G,B$</p><p>你有一个大小为 $2$ 的物品栏。每当你收到一个物品，你可以考虑将其放入物品栏<strong>或直接丢弃</strong><br>物品栏是一个栈，这意味着如果你决定放入物品但物品栏是满的，你将丢弃更早放入的那个物品，并将手上的物品放入</p><p>下面是物品的得分和消除规则：</p><ol><li>如果手上和物品栏中共 $3$ 个物品颜色相同，则消除这 $3$ 个物品，得到 $1$ 分（这是唯一的得分方式），并在物品栏得到 $1$ 个颜色由你决定的新物品</li><li>如果手上和物品栏中共 $3$ 个物品颜色各不相同，则消除这 $3$ 个物品，并在物品栏得到 $2$ 个颜色由你决定的新物品</li></ol><p>求对于给定的物品序列，可以得到的最高分是多少</p><h2 id="解题思路-2">解题思路</h2><p>官方给出的做法是DP，但是考虑所有的状态转移略显繁琐，难以不重复、不遗漏<br>相比起来我还是更喜欢直接贪心的方法//</p><p>决定一种游戏策略前，先掌握游戏核心机制<br>首先，在贪心的思想下，物品栏的栈特性可以不考虑//因为如果需要被迫丢弃物品，大可以在拿到这个物品时就直接丢弃//<br>其次，注意到颜色任选的物品可以不立刻考虑，作为<code>任意物品</code>即可<br>考虑消除过程中的特点：</p><ol><li>规则 $2$ 消除后得到 $2$ 个<code>任意物品</code>，可以配合规则 $1$ ，直接和下一个物品（若有）合成得分</li><li>规则 $1$ 消除后留下 $1$ 个<code>任意物品</code>。这意味着如果有得分，最后一定会留下 $1$ 个<code>任意物品</code></li></ol><p>借助上面两个特点，单独考虑第一次消除，后续消除借助前面得到的<code>任意物品</code>，具体可以参考代码注释<br>计数直到满足条件消除，即视为取需要的物品，并直接丢弃无帮助的物品，重新计数即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RGB</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    ll n=s.<span class="built_in">length</span>(),res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>,cnt[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cur=<span class="built_in">RGB</span>(s[i]);cnt[cur]++;</span><br><span class="line">        <span class="keyword">if</span>(res)&#123;<span class="comment">//消除过，前面必定有一个自选</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]||cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">3</span>]||cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>])&#123;</span><br><span class="line">                <span class="comment">//已有两种不同颜色+自选：选不同颜色，消3得2</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>==n) <span class="keyword">break</span>;<span class="comment">//没有下一个就结束</span></span><br><span class="line">                i++;res++;<span class="comment">//再用2个自选和下一个出现的颜色消除</span></span><br><span class="line">                cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">1</span>]==<span class="number">2</span>||cnt[<span class="number">2</span>]==<span class="number">2</span>||cnt[<span class="number">3</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//已有两个相同颜色+自选：选相同颜色，消3得1</span></span><br><span class="line">                res++;cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//还没有消除过</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>])&#123;<span class="comment">//兼有三色：消3得2</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>==n) <span class="keyword">break</span>;</span><br><span class="line">                i++;res++;<span class="comment">//再用2个自选和下一个出现的颜色消除</span></span><br><span class="line">                cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt[<span class="number">1</span>]==<span class="number">3</span>||cnt[<span class="number">2</span>]==<span class="number">3</span>||cnt[<span class="number">3</span>]==<span class="number">3</span>)&#123;<span class="comment">//有三个同色：消3得1</span></span><br><span class="line">                res++;cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=cnt[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Expectation (Easy Version)</h1><p><strong>数学期望</strong></p><h2 id="题意-3">题意</h2><p>玩 $n$ 次游戏，每次游戏胜利的概率为 $\dfrac{a}{b}$<br>对于给定的 $m$ ，每次游戏胜利将获得 $k^m$ 分，其中 $k$ 是当前总胜利局数，失败得 $0$ 分<br>最终得分为 $n$ 次游戏的得分之和，求最终得分的期望</p><h2 id="解题思路-3">解题思路</h2><p>从全局角度考虑得分情况，游戏输赢概率满足二项分布，记获胜概率为 $p=\dfrac{a}{b}$<br>在 $n$ 局游戏中赢 $k$ 局的概率为： $C_n^k\cdot p^k(1-p)^{n-k}$<br>赢 $k$ 局游戏可以获得的最终得分记为 $score(k)$ ： $score(k)=\sum\limits_{i=1}^k i^m$<br>故最终得分期望为： $E=\sum\limits_{i=1}^n C_n^k\cdot p^k(1-p)^{n-k}\cdot score(k)$</p><p>分别预处理阶乘、乘方、得分数组，求和取模即可</p><h3 id="时间复杂度-3">时间复杂度</h3><p>乘方、阶乘、求和取模： $O(n)$<br>得分（快速幂+前缀和）： $O(n\log m)$<br>总时间复杂度： $O(n\log m)$</p><h2 id="参考代码-3">参考代码</h2><blockquote><p>参考代码为已AC代码主干，其中功能请读者自行实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; powp,pownp,score;<span class="comment">//p的n次、q的n次、赢n局的得分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,a,b,re=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll p=<span class="built_in">mul</span>(a,<span class="built_in">inv</span>(b));<span class="comment">//获胜的概率</span></span><br><span class="line">    ll np=<span class="built_in">Get_Mod</span>(<span class="number">1</span>-p);<span class="comment">//失败的概率</span></span><br><span class="line">    powp.<span class="built_in">clear</span>();pownp.<span class="built_in">clear</span>();score.<span class="built_in">clear</span>();</span><br><span class="line">    powp.<span class="built_in">resize</span>(n+<span class="number">1</span>);pownp.<span class="built_in">resize</span>(n+<span class="number">1</span>);score.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    powp[<span class="number">0</span>]=pownp[<span class="number">0</span>]=<span class="number">1</span>;score[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        powp[i]=<span class="built_in">mul</span>(powp[i<span class="number">-1</span>],p);</span><br><span class="line">        pownp[i]=<span class="built_in">mul</span>(pownp[i<span class="number">-1</span>],np);</span><br><span class="line">        score[i]=<span class="built_in">add</span>(score[i<span class="number">-1</span>],<span class="built_in">qcpow</span>(i,m));&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        re=<span class="built_in">add</span>(re,<span class="built_in">mul</span>(score[i],<span class="built_in">mul</span>(<span class="built_in">Get_Combination</span>(n,i),<span class="built_in">mul</span>(powp[i],pownp[n-i]))));</span><br><span class="line">        <span class="comment">//Ex(i)=C(n,i)*p^i*(1-p)^(n-i)*score(i)</span></span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.Counting Stars</h1><p><strong>计数</strong></p><h2 id="题意-4">题意</h2><p>定义 $k$ 星状图：一个 $k+1$ 个节点， $k$ 条边的无向图，中心节点与其他 $k$ 个节点之间各有一条边，其他节点之间没有边<br>给定一个无向图 $G=(V,E),|V|=n,|E|=m$ ，记其中不同的 $k$ 星状图的数量为 $cnt_k$<br>求对于 $2\le k\le n-1$ ，所有 $cnt_k$ 的异或和： $cnt_2\oplus cnt_3\oplus \cdots \oplus cnt_{n-1}$</p><h2 id="解题思路-4">解题思路</h2><p>对于某个节点 $i$ ，记它的度为 $deg_i$ ，考虑以它作为中心节点的情况<br>简单的组合问题，以 $i$ 为中心节点的 $k$ 星图数量即 $C_n^k$<br>遍历 $n$ 个节点，在每个节点处对 $2\le k\le deg_i$ 的 $k$ 星图计数取模<br>最终把所有结果做异或和即可</p><h3 id="时间复杂度-4">时间复杂度</h3><p>预处理阶乘（计算组合数）： $O(n)$<br>遍历节点：$O(n+m)$<br>异或和：$O(n)$<br>总时间复杂度：$O(n+m)$</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ll&gt; deg,cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    deg.<span class="built_in">clear</span>();deg.<span class="built_in">resize</span>(n+<span class="number">1</span>);cnt.<span class="built_in">clear</span>();cnt.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        deg[u]++;deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">2</span>,deg[i])</span><br><span class="line">            cnt[j]=<span class="built_in">Get_Mod</span>(cnt[j]+<span class="built_in">Get_Combination</span>(deg[i],j));</span><br><span class="line">    ll re=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n<span class="number">-1</span>) re^=cnt[i];</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校05</title>
      <link href="/posts/ACM_2023Summer_NCD05.html"/>
      <url>/posts/ACM_2023Summer_NCD05.html</url>
      
        <content type="html"><![CDATA[<h1>C.Cheeeeen the Cute Cat</h1><p><strong>二部图最大匹配</strong></p><h2 id="题意">题意</h2><p>给定一个具有 $2n$ 个节点的二部图，前 $n$ 个节点和后 $n$ 个节点各成一部<br>对于每对 $(i,j),i\ne j$ ，保证在 $i,j+n$ 和 $j,i+n$ 之间有且仅有一条边，整幅图的边数共 $C_n^2$ 条<br>求这个二部图的最大匹配</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://oi-wiki.org/graph/bi-graph/">二分图</a><br><a href="https://oi-wiki.org/graph/graph-matching/bigraph-match/">二分图最大匹配</a></p><h2 id="解题思路">解题思路</h2><p>题解和讨论区谈及竞赛图以及相关特点，稍微了解了一下但是赛事确实没发现可以把这个图转化成一个竞赛图//<br>当时一眼看去就像一道朴实无华的板子题，队友直接交了一发板子就过了//<br>跑一遍增广路求出最大匹配即可，具体的实现原理在OI-Wiki上有非常详细的推导与说明//<br>本蒟蒻就是看它学的qwq这里就不过多赘述了</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">augment_path <span class="title">G</span><span class="params">(n,n*<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span>(t) G.<span class="built_in">add</span>(i,j+n);</span><br><span class="line">        &#125;cout &lt;&lt; G.<span class="built_in">solve</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>D.Cirno’s Perfect Equation Class</h1><p><strong>签到</strong></p><h2 id="题意-2">题意</h2><p>给定三个整数 $k,c,n$<br>求满足以下条件的有序对 $(a,b)$ 的个数： $ka+b=c$ ， $b|c$ ， $gcd(a,b)&gt;n$</p><h2 id="解题思路-2">解题思路</h2><p>注意到第二个约束条件： $b$ 是 $c$ 的因子<br>因此对 $b$ 枚举，判断计数即可</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(qc^\frac{1}{2})$</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll k,c,n,a,tb;</span><br><span class="line">cin &gt;&gt; k &gt;&gt; c &gt;&gt; n;</span><br><span class="line">ll r=<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(c)),cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll b=<span class="number">1</span>;b*b&lt;=c;b++)&#123;</span><br><span class="line"><span class="keyword">if</span>(c%b==<span class="number">0</span>&amp;&amp;(c-b)%k==<span class="number">0</span>)&#123;</span><br><span class="line">a=(c-b)/k;</span><br><span class="line"><span class="keyword">if</span>(a&amp;&amp;b&amp;&amp;<span class="built_in">gcd</span>(a,b)&gt;=n) cnt++;</span><br><span class="line">&#125;</span><br><span class="line">tb=c/b;</span><br><span class="line"><span class="keyword">if</span>(tb!=b&amp;&amp;c%tb==<span class="number">0</span>&amp;&amp;(c-tb)%k==<span class="number">0</span>)&#123;</span><br><span class="line">a=(c-tb)/k;</span><br><span class="line"><span class="keyword">if</span>(a&amp;&amp;tb&amp;&amp;<span class="built_in">gcd</span>(a,tb)&gt;=n) cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>G.Go to Play Maimai DX</h1><p><strong>签到</strong></p><h2 id="题意-3">题意</h2><p>给定一个长度为 $n$ 仅含有 $1,2,3,4$ 四种数字的序列<br>求最短的包含 $1,2,3$ 和 $k$ 个 $4$ 的区间的长度</p><h2 id="解题思路-3">解题思路</h2><p>用快慢指针确定区间<br>快指针每次记录元素，直到满足条件；<br>慢指针每次移除元素，直到不满足条件<br>即可得到每个满足条件的最小区间，比较长度即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>$O(n)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n,k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; v[i];</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">0</span>,cnt[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;,re=n;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>]&amp;&amp;cnt[<span class="number">4</span>]&gt;=k))&#123;</span><br><span class="line">            r++;cnt[v[r]]++;<span class="keyword">if</span>(r&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cnt[<span class="number">1</span>]&amp;&amp;cnt[<span class="number">2</span>]&amp;&amp;cnt[<span class="number">3</span>]&amp;&amp;cnt[<span class="number">4</span>]&gt;=k)&#123;</span><br><span class="line">            l++;cnt[v[l]]--;<span class="keyword">if</span>(l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;re=<span class="built_in">min</span>(re,r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Nazrin the Greeeeeedy Mouse</h1><p><strong>动态规划</strong></p><h2 id="题意-4">题意</h2><p>给定一组 $n$ 个奶酪，第 $i$ 个奶酪具有重量 $w_i$ 和价值 $val_i$<br>将前来取 $m$ 次奶酪，每次会携带一个大小为 $sz$ 的背包，并保证每一次携带背包的大小不小于前一次，并从第一个奶酪出发<br>对于每一个奶酪，可以选择装入背包（如果背包剩余空间足够）或挖洞通过（被挖洞的奶酪无法带走），并且仅当上一块奶酪被带走或挖洞，才能到达下一块<br>每次出发的过程不独立，问 $m$ 次可以获得最大价值为多少//</p><h2 id="解题思路-4">解题思路</h2><p>由于每次携带的背包大小都不小于前一次，因此如果取的次数 $m$ 多于奶酪个数 $n$ ，只需要考虑最后 $n$ 个背包即可//感性证明一下：如果倒数 $n$ 背包内某次装不下任何一块奶酪，那么之前的背包也不可能装下//</p><p>对于奶酪，只有取和不取两种状态（为不影响后续操作，没取的奶酪直接视为挖洞）<br>对于某一轮行动，假设最优解下它取的第一个奶酪和最后一个奶酪之间的区间为 $[l,r]$ ，那么可以视为这一轮行动是携带空间为 $sz_i$ ，第 $[l,r]$ 个奶酪上的01背包问题</p><p>由于不确定每轮取的范围以及对应背包大小，因此每个区间的每个重量都需要一个01背包DP值<br>用 $dp_{i,j,k}$ 表示在区间 $[i,j]$ 内，取重量为 $k$ 的物品可以获得的最大价值，可以得到以下状态转移方程：<br>$$<br>dp_{i,j,k}=\begin{cases}<br>dp_{i,j-1,k} &amp;,dp_{i,j-1,k-w[j]}+val_j&lt;dp_{i,j-1,k}或 k&lt;w_j\newline<br>dp_{i,j-1,k-w[j]}+val_j &amp;,dp_{i,j-1,k-w[j]}+val_j&gt;dp_{i,j-1,k}<br>\end{cases}<br>$$</p><p>在计算完 $[i,j]$ 内的 $dp$ 值后，前缀维护每一个 $k$ 的 $dp_{i,j,k}$ ，使得对于该区间， $dp$ 值随 $k$ 增加不递减</p><p>最后对全部 $m$ 轮行动进行DP，记 $g_{i,j}$ 为第 $i$ 次行动携带背包的容量为 $sz$ ，到达的最后一个位置为 $j$ 所得到的最大价值，可以得到以下状态转移方程：<br>$$<br>g_{i,j}=max{g_{i-1,k}+dp_{k+1,j,sz}},k\in[1,j-1]<br>$$</p><h3 id="时间复杂度-3">时间复杂度</h3><p>$O(n^2w)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 205</span></span><br><span class="line">ll dp[N][N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll w[N]=&#123;<span class="number">0</span>&#125;,val[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll g[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RESET</span>(dp);</span><br><span class="line">    ll n,m,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; w[i] &gt;&gt; val[i];</span><br><span class="line">    <span class="comment">//规划[i,j]区间内取体积为k的最优解</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;<span class="comment">//从第i个开始考虑</span></span><br><span class="line">        <span class="built_in">FORLL</span>(j,i,n)&#123;<span class="comment">//目前考虑第j个取/不取</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">0</span>,w[j]<span class="number">-1</span>) dp[i][j][k]=dp[i][j<span class="number">-1</span>][k];</span><br><span class="line">            <span class="comment">//对于无法装下第j个的情况，用j-1之前的维护</span></span><br><span class="line">            <span class="built_in">FORLL</span>(k,w[j],N) dp[i][j][k]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>][k],dp[i][j<span class="number">-1</span>][k-w[j]]+val[j]);</span><br><span class="line">            <span class="comment">//可以装下的情况，更新较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)</span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)</span><br><span class="line">                dp[i][j][k]=<span class="built_in">max</span>(dp[i][j][k],dp[i][j][k<span class="number">-1</span>]);</span><br><span class="line">                <span class="comment">//对于区间[i,j]，前缀维护最优解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)&#123;<span class="built_in">FORLL</span>(i,<span class="number">1</span>,m-n) cin &gt;&gt; t; m=n;&#125;ll sz,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;cin &gt;&gt; sz;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(k,<span class="number">0</span>,j<span class="number">-1</span>) g[i][j]=<span class="built_in">max</span>(g[i][j],g[i<span class="number">-1</span>][k]+dp[k+<span class="number">1</span>][j][sz]);</span><br><span class="line">            <span class="comment">//第二项：前i个背包最远拿到第k项+第i个背包拿[k+1,j]内</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校04</title>
      <link href="/posts/ACM_2023Summer_NCD04.html"/>
      <url>/posts/ACM_2023Summer_NCD04.html</url>
      
        <content type="html"><![CDATA[<h1>A.Bobo String Construction</h1><p><strong>构造</strong></p><h2 id="题意">题意</h2><p>给定一个标识01串 $t$ ，构造一个长度为 $n$ 的信息01串 $s$ ，使得串 $m=t+s+t$ 中，串$t$ 仅在开头和结尾各出现过一次。（其中 $+$ 表示字符串连接运算）</p><h2 id="解题思路">解题思路</h2><p>考虑构造 $s$ 全为 $0$ 或 $1$</p><p>对于特殊情况， $t$ 全为 $0$ 或 $1$ ，则使 $s$ 全为 $1$ 或 $0$ 即可</p><p>如果 $t$ 中兼有 $0$ 和 $1$ ，则 显然 $s$ 中不可能有子串 $t$<br>但对于 $m=t+s+t$ ，可能有 $t的后缀+s+t的前缀=t$ 的情况出现，导致不满足题设条件//</p><p>那么下面感性证明一下两种方案至少有一种成立。<br>假设对于兼有 $0$ 和 $1$ 的 $t$ ，在 $s$ 全为 $0$ 的情况下出现：<br>$t的后缀+s+t的前缀=t$<br>那么构造 $s$ 全为 $1$ 即可，反之亦然</p><p>于是问题就转化为在 $s$ 全为 $1$ 或 $0$ 的方案中选择一种使得串$t$ 仅在开头和结尾各出现过一次<br>先使 $s$ 全为 $1$ 将 $m=t+s+t$ 去掉首尾一个字符，判断中间有无字串 $t$ 即可<br>归纳发现特殊情况也可以用这种方法构造</p><h3 id="时间复杂度">时间复杂度</h3><p>数据范围小（ $n\le 1000,|t|\le 1000$ ），BF即可</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t;ll n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    string s;<span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) s.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    string m=t+s+t;m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());m.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">find</span>(t)!=string::npos) <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>F.Election of the King</h1><p><strong>签到、模拟</strong></p><h2 id="题意-2">题意</h2><p>$n$ 个人竞选国王，每个人的从政理念用 $a_i$ 量化表示<br>每人每轮可以进行投票，对于个人而言，他会将票投给和他自己的政治理念相差最大的人<br>票数最多的人将被淘汰。如果票数相同，则淘汰值最大的；如果最大值有多个，则淘汰序号最大的人。<br>重复直到剩余一人成为国王，问最后谁会竞选上国王</p><h2 id="解题思路-2">解题思路</h2><p>对于其中某一个人，和他相差最大的，一定是最大值与最小值之一<br>那么每次一定淘汰最大值或最小值<br>因此对所有人进行排序，每轮投票处于中间位置的人代表着多数人的意志<br>因此每轮看中间的人投最大值还是最小值，踢到只剩一人即可</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    deque&lt;pll&gt; v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(t,i);</span><br><span class="line">    &#125;<span class="built_in">SORT</span>(v);</span><br><span class="line">    <span class="type">float</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        mid=<span class="number">1.</span>*(v.<span class="built_in">front</span>().first+v.<span class="built_in">back</span>().first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(v[(n+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>].first&lt;=mid) v.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">else</span> v.<span class="built_in">pop_front</span>();</span><br><span class="line">        n--;</span><br><span class="line">    &#125;cout &lt;&lt; v.<span class="built_in">front</span>().second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Merge the squares!</h1><p><strong>几何、分治</strong></p><h2 id="题意-3">题意</h2><p>给定一个 $n\times n$ 的矩阵，它由 $n\times n$ 个小正方形组成<br>每次操作可以选择 $2\le x\le50$ 个正方形并把它们组合成一个更大的正方形（组合后的形状也必须为正方形）<br>求合并到整个边长为 $n$ 大小的正方形的操作过程</p><h2 id="解题思路-3">解题思路</h2><p>这道题可以采用分治的思想</p><p>对于边长不大于 $7$ 的正方形，它的面积不大于 $49$ ，可以直接合并<br>对于边长较大的正方形，可以考虑将其分解为更小的正方形，递归处理</p><p>接下来考虑一种通用可行的分解方法如下图<br><img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_NCD04_H.png" alt="Img"><br>这种分法将大正方形分解成两个小正方形和两个矩形<br>假设小正方形在递归处理中合并完成，占用块数为 $2$ ，那么每个长方形部分允许占用的块数为 $(50-2)/2=24$ 块</p><p>对于每个长方形，按照宽分割成一个正方形和一个矩形，对两部分分别递归处理</p><p>代码中预处理了一个切割方案，用于决定在大正方形边长为 $i$ 的情况下，满足矩形 $(i-j)\times j$ 即长方形的部分，占用分割块数不超过 $24$ 时，左上角的正方形边长，以此保证每次递归处理大正方形都满足条件</p><h1>参考代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">ll len[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_len</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)&#123;</span><br><span class="line">            ll cnt=<span class="number">0</span>;</span><br><span class="line">            ll a=j,b=i-j;<span class="comment">//先减去一个j*j大小的方形</span></span><br><span class="line">            <span class="keyword">while</span>(b)&#123;</span><br><span class="line">                cnt+=a/b;</span><br><span class="line">                a%=b;</span><br><span class="line">                <span class="built_in">swap</span>(a,b);</span><br><span class="line">            &#125;<span class="comment">//辗转相减得到(i-j)*j下分块数量</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= <span class="number">24</span>)&#123;</span><br><span class="line">                len[i]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//得到长i下的可用宽j</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node_op</span>&#123;</span><br><span class="line">    ll x,y,n;</span><br><span class="line">&#125;top;</span><br><span class="line">vector&lt;node_op&gt; op;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll x1,ll y1,ll x2,ll y2)</span><span class="comment">//递归处理(x1,y1):(x2,y2)区域的矩形</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll difx=x2-x1+<span class="number">1</span>,dify=y2-y1+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(difx==<span class="number">1</span>||dify==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(difx&gt;dify)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1,x1+dify<span class="number">-1</span>,y2);</span><br><span class="line">        <span class="built_in">dfs</span>(x1+dify,y1,x2,y2);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(difx&lt;dify)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1,x2,y1+difx<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1+difx,x2,y2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//difx==dify</span></span><br><span class="line">        <span class="keyword">if</span>(difx==<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//边长为1无需merge</span></span><br><span class="line">        <span class="keyword">if</span>(difx&gt;<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x1,y1,x1+len[dify]<span class="number">-1</span>,y1+len[difx]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(x1+len[dify],y1+len[difx],x2,y2);</span><br><span class="line">            <span class="built_in">dfs</span>(x1+len[dify],y1,x2,y1+len[difx]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(x1,y1+len[difx],x1+len[dify]<span class="number">-1</span>,y2);</span><br><span class="line">        &#125;</span><br><span class="line">        top.x=x1;top.y=y1;top.n=difx;</span><br><span class="line">        op.<span class="built_in">emplace_back</span>(top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op.<span class="built_in">clear</span>();</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">pre_len</span>(n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,n,n);</span><br><span class="line">    cout &lt;&lt; op.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:op)&#123;</span><br><span class="line">        cout &lt;&lt; i.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i.n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>J.Qu’est-ce Que C’est?</h1><p><strong>动态规划</strong></p><h2 id="题意-4">题意</h2><p>给定两个正整数 $n,m$ ，要求构造长度为 $n$ 的整数序列 $a$ ，满足：</p><ol><li>$\forall i\in [1,n],-m\le a_i\le m$</li><li>任意长度大于 $1$ 的连续子段之和不小于 $0$</li></ol><p>求满足以上条件的整数序列的个数，结果取模</p><h2 id="解题思路-4">解题思路</h2><p>计数取模，比起DP我会首先考虑猜通项<br>赛时根据样例1：$n=3,m=3\Rightarrow130$ 以及手算的 $n=2,m=3\Rightarrow28$ ，结合题目特征，拟出了一个满足上面两个情况的很奇怪的式子//然后样例2过不了，<s>开摆</s></p><p>DP的思想是先计算出第 $i$ 个位置前已经满足题设条件，且最小后缀和为 $j$ 的方案数量（ $j$ 可以是负数，因为最后一个数可以单独为负数）<br>考虑如何进行状态转移</p><p>对每个位置从大到小遍历当前位置填数后的最小后缀和 $j$ ，记当前遍历到 $i$ ，填入的数为 $x$</p><ol><li>对于非负整数 $j$ ，填入 $x$ 时的方案数为 $dp_{i-1,j-x}$<br>其中 $j-x\in[-m,m],x\in[-m,m],j\ge 0 \Rightarrow x\in [j-m,m]$，此时 $dp_{i,j}=\sum\limits_{x=j-m}^m dp_{i-1,x}$</li><li>对于负整数 $j$ ，此时 $x=j$ ，其方案数为允许 $x$ 填入的所有方案数之和，即 $dp_{i,j}=\sum\limits_{x=-j}^m dp_{i-1,x}$</li></ol><p>由于每次计算都用到了前一个位置的以 $m$ 为上界的区间和，因此可以对每个位置的dp数组从 $m$ 到 $-m$ 维护一个前缀和，以降低时间复杂度</p><h2 id="复杂度">复杂度</h2><p>时间复杂度： $O(n^2)$<br>空间复杂度： $M(Cn^2)$ ， $C$ 是常数，开LL可能会导致MLE<br>7/30：开L都MLE了//进行了空间优化，只保留 $dpsum$ 数组</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O 5000 <span class="comment">//记为0</span></span></span><br><span class="line"><span class="type">long</span> dp[<span class="number">5005</span>][<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//表示前i-1个数的最小后缀和为j+5000时，满足条件的可行方案数</span></span><br><span class="line"><span class="type">long</span> dpsum[<span class="number">5005</span>][<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//表示dp[i][m]到dp[i][j]可行方案数的区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--) &#123;dp[<span class="number">1</span>][j+O]=<span class="number">1</span>;dpsum[<span class="number">1</span>][j+O]=dpsum[<span class="number">1</span>][j+<span class="number">1</span>+O]+dp[<span class="number">1</span>][j+O];&#125;</span><br><span class="line">    <span class="comment">//预处理前0位</span></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) dp[i][j+O]=dpsum[i<span class="number">-1</span>][j-m+O];</span><br><span class="line">            <span class="comment">//下界x+m=j =&gt; x=j-m</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j+O]=dpsum[i<span class="number">-1</span>][-j+O];</span><br><span class="line">            <span class="comment">//j&lt;0 下界-j</span></span><br><span class="line">            dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dp[i][j+O]);</span><br><span class="line">            <span class="comment">//计数取模</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; dpsum[n][-m+O] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7/30：空间优化后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O 5000 <span class="comment">//记为0</span></span></span><br><span class="line"><span class="comment">//long dp[5001][10001]=&#123;0&#125;;//表示前i-1个数最小后缀和为j+5000，满足条件的可行方案数</span></span><br><span class="line"><span class="type">long</span> dpsum[<span class="number">5001</span>][<span class="number">10001</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//表示dp[i][m]到dp[i][j]可行方案数的区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">        <span class="comment">//dp[1][j+O]=1;</span></span><br><span class="line">        <span class="comment">//dpsum[1][j+O]=dpsum[1][j+1+O]+dp[1][j+O];</span></span><br><span class="line">        dpsum[<span class="number">1</span>][j+O]=dpsum[<span class="number">1</span>][j+<span class="number">1</span>+O]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=m;j&gt;=-m;j--)&#123;</span><br><span class="line">            <span class="comment">//if(j&gt;=0) dp[i][j+O]=dpsum[i-1][j-m+O];//下界x+m=j =&gt; x=j-m</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dpsum[i<span class="number">-1</span>][j-m+O]);</span><br><span class="line">            <span class="comment">//else dp[i][j+O]=dpsum[i-1][-j+O];//j&lt;0 下界-j</span></span><br><span class="line">            <span class="keyword">else</span> dpsum[i][j+O]=<span class="built_in">Get_Mod</span>(dpsum[i][j+<span class="number">1</span>+O]+dpsum[i<span class="number">-1</span>][-j+O]);</span><br><span class="line">            <span class="comment">//dpsum[i][j+O]=Get_Mod(dpsum[i][j+1+O]+dp[i][j+O]);</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; dpsum[n][-m+O] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>L.We are the Lights</h1><p><strong>思维题</strong></p><h2 id="题意-5">题意</h2><p>有 $n\times m$ 的电灯矩阵，初始全为关闭状态</p><p>每次操作会打开或关闭某一行/列的所有灯</p><p>问在给定的 $q$ 次操作后，共有多少盏灯亮着</p><h2 id="解题思路-5">解题思路</h2><p>这道题和某刷墙小游戏类似（）玩过的话应该不难想到做法<br><img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_NCD04_L.jpg" alt="Img"><br>后面的行动会覆盖前面的行动，用数组记录当前行/列是否已被覆盖</p><p>从后往前遍历操作即可</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> rc[N]=&#123;<span class="number">0</span>&#125;,op[N]=&#123;<span class="number">0</span>&#125;,rowvd[N]=&#123;<span class="number">0</span>&#125;,colvd[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll x[N]=&#123;<span class="number">0</span>&#125;,cnt=<span class="number">0</span>,cntr=<span class="number">0</span>,cntc=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    string trc,top;ll t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        cin &gt;&gt; trc &gt;&gt; t &gt;&gt; top;</span><br><span class="line">        <span class="keyword">if</span>(trc==<span class="string">&quot;row&quot;</span>) rc[i]=<span class="number">1</span>;<span class="keyword">else</span> rc[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(top==<span class="string">&quot;on&quot;</span>) op[i]=<span class="number">1</span>;<span class="keyword">else</span> op[i]=<span class="number">0</span>;</span><br><span class="line">        x[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=q;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rc[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(rowvd[x[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                rowvd[x[i]]=<span class="number">1</span>;cntr++;</span><br><span class="line">                <span class="keyword">if</span>(op[i]==<span class="number">1</span>) cnt+=m-cntc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(colvd[x[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                colvd[x[i]]=<span class="number">1</span>;cntc++;</span><br><span class="line">                <span class="keyword">if</span>(op[i]==<span class="number">1</span>) cnt+=n-cntr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校04</title>
      <link href="/posts/ACM_2023Summer_HDU04.html"/>
      <url>/posts/ACM_2023Summer_HDU04.html</url>
      
        <content type="html"><![CDATA[<h1>1003.Simple Set Problem</h1><p><strong>思维</strong></p><h2 id="题意">题意</h2><p>给定 $k$ 个非空集合，在每一个集合里选择一个数 $a_i$ ，使得这些数之中最大值与最小值之差 $d=max(a_i)-min(a_i)$ 最小，输出 $d$ 的最小值</p><h2 id="解题思路">解题思路</h2><p>不论哪一种选法，最小值一定是在全体元素中取到的<br>不妨从小到大遍历全体元素作为下界，记当前遍历元素为 $a_i$<br>在每一个集合中二分查找恰好大于等于 $a_i$ 的元素选入(遍历到 $a_i$ 所在集合的时候，一定会选入 $a_i$ )<br>找到选定元素的最大值，做差<br>直到某个集合中没有大于等于 $a_i$ 的元素为止（此时该集合最大的元素选入的情况已全部考虑过），最终在得到的值中取最小即可</p><h3 id="时间复杂度">时间复杂度</h3><p>读入： $O(n)$ ；排序： $O(n\log n)$ ；遍历二分查找： $O(n\log n)$<br>综合时间复杂度：  $O(n\log n)$<br>其中 $n$ 表示全体元素个数， $n\le 4e6$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">sets</span>(n+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    vector&lt;ll&gt;::iterator it;</span><br><span class="line">    ll tn,t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; tn;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,tn) &#123;cin &gt;&gt; t;sets[i].<span class="built_in">emplace_back</span>(t);v.<span class="built_in">emplace_back</span>(t);&#125;</span><br><span class="line">        <span class="built_in">SORT</span>(sets[i]);</span><br><span class="line">    &#125;<span class="built_in">SORT</span>(v);</span><br><span class="line">    ll re=INF,tre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:v)&#123;</span><br><span class="line">        tre=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            it=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(sets[i]),x);</span><br><span class="line">            <span class="keyword">if</span>(it==sets[i].<span class="built_in">end</span>()) &#123;tre=<span class="number">-1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tre=<span class="built_in">max</span>(tre,*it-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tre==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        re=<span class="built_in">min</span>(re,tre);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1006.PSO</h1><p><strong>数学题、概率论</strong></p><h2 id="题意-2">题意</h2><p>给定一个星状图（中心节点与每个其他节点之间各有一条边，其他节点之间没有边），任选两个点，求它们之间的距离的数学期望以及最大距离的长度</p><h2 id="解题思路-2">解题思路</h2><p>任选两个点的方案总数为 $C_n^2=n(n-1)/2$<br>其中一个点是中心点的方案数为 $n-1$ ，距离是 $1$<br>其余方案数为 $n(n-1)/2-(n-1)$ ，距离是 $2$<br>因此任选两个点的距离期望为：<br>$$\begin{align}<br>E&amp;={[n(n-1)/2-(n-1)]\times2+(n-1)\times1}/C_n^2 \newline<br>&amp;=[n(n-1)-(n-1)\times2+(n-1)]/C_n^2 \newline<br>&amp;=(n-1)^2/C_n^2 \newline<br>&amp;=2(n-1)/n<br>\end{align}<br>$$<br>注意控制精度</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf&quot;</span>,<span class="number">2.</span>*(n<span class="number">-1</span>)/n);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot; 2.000000000\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; 1.000000000\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1007.Guess</h1><p><strong>莫比乌斯函数</strong></p><h2 id="题意-3">题意</h2><p>给定一个正整数 $n\le1e18$ ，求 $e^{S(n)}$</p><p>其中，$S(n)=\sum\limits_{d|n} \mu(\dfrac{n}{d})\ln(d)$ ，$e$ 是自然对数 $\ln$ 的底数，$\mu(x)$ 是莫比乌斯函数，答案取模</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://baike.baidu.com/item/%E9%BB%98%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/16625781">莫比乌斯函数</a>：<br>$$<br>\mu(n)=\begin{cases}<br>1 &amp;,n=1; \newline<br>0 &amp;,n含有大于1的完全平方因子; \newline<br>(-1)^k &amp;,n为k个质数的乘积 \newline<br>\end{cases}<br>$$</p><h2 id="解题思路-3">解题思路</h2><p>对于 $n$ 的因数 $d$ ，根据 $\dfrac{n}{d}$ 与 $d$ 的轮换对称性可知：<br>$S(n)=\sum\limits_{d|n} \mu(\dfrac{n}{d})\ln(d)=\sum\limits_{d|n} \mu(d)\ln(\dfrac{n}{d})$</p><p>对 $S(n)$ 做一次莫比乌斯变换（第一形式）可得：$\ln(n)=\sum\limits_{d|n} S(d)$</p><p>两边以 $e$ 做底数得 $e^{ln(n)}={e}^{\sum\limits_{d|n} S(d)}\Rightarrow n=\prod\limits_{d|n} e^{S(d)}$</p><p>右式是一个连乘积，其连乘长度为 $n$ 的全体因数个数<br>记 $F(x)=e^{S(x)}$ ，那么答案也就是在求 $F(n)$</p><p>根据上式：</p><ol><li>$1=F(1)\Rightarrow F(1)=1$</li><li>对于任意质数 $x$ ，$x=F(1)F(x)\Rightarrow F(x)=x$</li><li>对于任意合数 $x$ ，借助 $1,2$ 递归计算出 $F(x)$</li></ol><p>经过较长时间的感性理解，想到了一种遍历求 $F(x)$ 方法的伪代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F<span class="selector-attr">[]</span>=&#123;<span class="number">0</span>&#125;</span><br><span class="line">FOR <span class="selector-tag">i</span> <span class="keyword">in</span> &#123;<span class="number">1</span>..+∞&#125;</span><br><span class="line">    FOR <span class="selector-tag">p</span> <span class="keyword">in</span> Primes</span><br><span class="line">        <span class="keyword">if</span> F<span class="selector-attr">[i*p]</span>==<span class="number">0</span> then F<span class="selector-attr">[i*p]</span>=p</span><br></pre></td></tr></table></figure><p>（其实打表也挺好的，想个一般性的方法好难qwq）</p><p>可以得到以下 $F(x)$ 的正整数序列：<br>$1,2,3,2,5,1,7,2,3,1,11,1,13,1,1,2,17,1,19,1,1,1,23\cdots$</p><p>这个序列的意义是 $x$ 对乘积 $n$ 的贡献，回到上面看那个连乘积的长度和表达形式就非常合理了</p><p>通项公式为：<br>$$\begin{align}<br>F(n)&amp;=lcm{1…n}/lcm{1…n-1} \newline<br>&amp;=\begin{cases}<br>n&amp;,n=p^i,p是素数,i\in \N_+ \newline<br>1&amp;,Otherwise<br>\end{cases}<br>\end{align}<br>$$<br>即为最终答案</p><p>面对 $n\le 1e18$ 的庞大数据，问题就落到了如何快速求出 $F(n)$ 上了。根据通项公式，只需要判断 $n$ 是否有且只有一个素数非平凡因子 $p$ 即可</p><p>Pollard-Rho算法是一种用于因数分解整数的快速随机算法，它可以实现在 $n^{\frac{1}{4}}$ 的时间下随机找到一个 $n$ 的非平凡因子<br>其中用到了Miller-Rabin 素性测试算法，是一种测试素数的快速随机算法</p><p>Pollard-Rho算法的具体实现可以参考这篇博文：<a href="https://blog.csdn.net/maxichu/article/details/45459533">大数因数分解Pollard_rho 算法详解</a></p><p>最终根据查找结果，结合通项公式判断输出即可</p><h2 id="参考代码-2">参考代码</h2><p>（Pollard_Rho算法及Miller_Rabin算法部分略）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ll fac=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prop</span><span class="params">(ll n)</span></span>&#123;<span class="comment">//判断n==p^i</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n))&#123;</span><br><span class="line">        <span class="keyword">if</span>(fac==<span class="number">0</span>) fac=n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fac!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=n;</span><br><span class="line">    <span class="keyword">while</span>(p==n) p=<span class="built_in">Pollard_Rho</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(prop\(p\)&amp;&amp;<span class="built_in">prop</span>(n/p)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    fac=<span class="number">0</span>;</span><br><span class="line">    ll n;cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n)) &#123;cout &lt;&lt; <span class="built_in">Get_Mod</span>(n) &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">prop</span>(n)) cout &lt;&lt; <span class="built_in">Get_Mod</span>(fac) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-3.png" alt="Alt text"></p><hr><h1>1010.Kong Ming Qi</h1><p><strong><s>猜结论题</s> 找规律题</strong></p><h2 id="题意-4">题意</h2><p>如题，游戏规则和孔明棋相似<br>在一个 $(n+2)\times(m+2)$ 大小的棋盘的中间 $n\times m$ 的格子里放置着一些棋子<br>每次行动可以选择一个有四面相邻的棋子，使其跳过相邻的棋子，并使被跳过的棋子从棋盘上被移除<br>问对于给定的 $n,m$ ，剩余棋子个数最少是多少</p><h2 id="解题思路-4">解题思路</h2><p>首先考虑只有一行/一列的情况，每次只能选择倒数第二个跳出。假设 $n=1$ ，连续模拟几次可知一定剩余 $\lceil m/2 \rceil$ 颗棋子<br><img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_HDU04_1010_1.png" alt="Img"></p><p>对于多行多列的情况，可以考虑以下两个基础操作：</p><ol><li>每次消去 $1\times 3$ 区域的棋子(需要左下方有棋子，中间操作)<br><img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_HDU04_1010_2.png" alt="Img"></li><li>每次消去 $2\times 3$ 区域的棋子(最终操作)<br><img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_HDU04_1010_3.png" alt="Img"></li></ol><p>连续操作 $1$ 后操作 $2$ ，即可在行数/列数大于 $3$ 的情况下任意消除 $3$ 行/列</p><p>考虑小情况 $2\times 2,2\times 3,3\times 3,2\times 4,3\times 4$ 等，借助上述基础操作以及模拟可得，当 $m,n$ 中有一个为3时，最少剩余 $2$ 颗棋子，其他情况最少剩余 $1$ 颗棋子，依此打表</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(m,n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) cout &lt;&lt; (m+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(n%<span class="number">3</span>&amp;&amp;m%<span class="number">3</span>)) cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1011.Circuit</h1><p><strong>图论-最短路-Floyd</strong></p><h2 id="题意-5">题意</h2><p>给定一个无重边、无自循环的带权有向图 $G=(V,E),|V|=n,|E|=m$<br>求 $G$ 的所有回路中最短回路的长度以及个数，个数取模</p><h2 id="解题思路-5">解题思路</h2><p>全图范围的最短路计数，考虑使用弗洛伊德算法//</p><p>为了不重不漏的计数，考虑每个最短回路仅在其最大标号处计数<br>对于一条有向回路，可以将其最大编号到下一点的有向边单独分割出来，剩余部分即为从起点到回路上最大编号点的最短路//</p><p>借助Floyd算法，在 $O(n^3)$ 的时间内，计算最短路的同时，可以进行最短路方案数的计数，这里详细阐述一下计数过程</p><p>原图 $G$ 存在有向边 $u\rightarrow v$ ，则 $u\rightarrow v$ 的初始方案数置为 $1$ ，没有边则置为 $0$</p><p>加入点 $k$ 时，过点 $k$ 的 $i\rightarrow j$ 的最短路的方案数为： $i\rightarrow k$ 的最短方案数 $\times$ $k\rightarrow j$ 的最短路方案数<br>如果发生最短路更新，则方案数一并更新//另判断如果长度一致，则方案数需相加</p><p>每次完成更新后，假设 $k$ 已经是以 $i$ 为起点的最短回路上的最大编号点了，此时原图 $G$ 中如果有 $k\rightarrow i$ 的有向边，则可以构成回路，比较计数即可//</p><p>更加具体的内容可以参考代码注释</p><p>温馨提示： $INF$ 的值需要设置到 $1e18$ ，因为两段方案数乘积最大可以为 $MOD^2 \approx 1e18$ ，补题时因为 $INF$ 的值不够大卡了两个小时左右</p><h3 id="时间复杂度-2">时间复杂度</h3><p>Floyd算法：$O(n^3)$</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 505</span></span><br><span class="line">ll dist[N][N]=&#123;<span class="number">0</span>&#125;,cnt[N][N]=&#123;<span class="number">0</span>&#125;,ori[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll mindist=INF,cntmin=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RESET_G</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ori[i][j]=<span class="number">0</span>;</span><br><span class="line">        dist[i][j]=(i==j?<span class="number">0</span>:INF);</span><br><span class="line">        cnt[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    mindist=INF,cntmin=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//重置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FORLL</span>(k,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n)&#123;<span class="comment">//Floyd</span></span><br><span class="line">                <span class="keyword">if</span>(dist[i][j]&gt;dist[i][k]+dist[k][j])&#123;</span><br><span class="line">                    dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">                    cnt[i][j]=<span class="built_in">mul</span>(cnt[i][k],cnt[k][j]);<span class="comment">//cnt[i][j]=cnt[i][k]*cnt[k][j]</span></span><br><span class="line">                    <span class="comment">//方案数为两段方案数的乘积，更新同步</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dist[i][j]==dist[i][k]+dist[k][j])&#123;</span><br><span class="line">                    <span class="built_in">addto</span>(cnt[i][j],<span class="built_in">mul</span>(cnt[i][k],cnt[k][j]));<span class="comment">//cnt[i][j]+=cnt[i][k]*cnt[k][j]</span></span><br><span class="line">                    <span class="comment">//相等则方案数相加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k&amp;&amp;ori[k][i])&#123;<span class="comment">//假设到k为以i为起点的单向环上最大点</span></span><br><span class="line">                <span class="keyword">if</span>(ori[k][i]+dist[i][k]&lt;mindist) &#123;mindist=ori[k][i]+dist[i][k];cntmin=cnt[i][k];&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ori[k][i]+dist[i][k]==mindist) <span class="built_in">addto</span>(cntmin,cnt[i][k]);<span class="comment">//cntmin+=cnt[i][k]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">RESET_G</span>(n);</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ori[u][v]=w;</span><br><span class="line">        dist[u][v]=w;</span><br><span class="line">        cnt[u][v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Floyd</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(cntmin) cout &lt;&lt; mindist &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cntmin &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1012.a-b Problem</h1><p><strong>贪心</strong></p><h2 id="题意-6">题意</h2><p>给定一堆 $n$ 个石子，每个石子有非负值 $a_i,b_i$ ，分别代表Alice和Bob取该石子可以得到的分数<br>两人都希望自己的得分最大化，Alice执先，求最终Alice和Bob的分数差</p><h2 id="解题思路-6">解题思路</h2><p>取某石子的价值不仅在于自身得分，也在于让对手失去他那部分的分值。因此根据每颗石子的分数之和排序，从大到小依次取即可</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;ll,pll&gt;&gt; v;</span><br><span class="line">    pair&lt;ll,pll&gt; t;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t.second.first &gt;&gt; t.second.second;</span><br><span class="line">        t.first=t.second.first+t.second.second;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(v);</span><br><span class="line">    ll A,B;A=B=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n<span class="number">-1</span>-i)&amp;<span class="number">1</span>) B+=v[i].second.second;</span><br><span class="line">        <span class="keyword">else</span> A+=v[i].second.first;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=A-B;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校03</title>
      <link href="/posts/ACM_2023Summer_HDU03.html"/>
      <url>/posts/ACM_2023Summer_HDU03.html</url>
      
        <content type="html"><![CDATA[<h1>1011.8-bit Zoom</h1><p><strong>不那么签到的签到题、模拟题</strong></p><h2 id="题意">题意</h2><p>给定一个 $n\times n$ 大小的字符矩阵表示一张图片，每种字符代表一种颜色；并给定 $Z$ 代表缩放倍率<br>满足以下条件即可缩放：</p><ol><li>缩放后的边长 $\dfrac{nZ}{100}$ 是一个整数</li><li>每个像素可以被唯一确定（如果缩放后的像素被从超过两种颜色覆盖，则无法确定颜色）</li></ol><p>如果可以进行缩放，则输出缩放后的图片，否则输出“error”</p><h2 id="解题思路">解题思路</h2><p>模拟缩放过程</p><p>如果不满足上述条件 $1$ 则一定无法缩放</p><p>条件 $2$ 需要根据图片实际情况判断是否满足<br>记这张图片被放大了 $x=\dfrac{a}{b}$ 倍，假设此处 $a,b$ 互质，则等同于先将图片缩小 $b$ 倍，再放大 $a$ 倍<br>如果缩小的过程不会有像素无法被确定，则缩小后一定是可以放大整数倍的<br>因此只需检查每个边长为 $b$ 的像素区块（它们将被缩小至 $1$ 像素），如果有任意一块混色，则无法压缩<br>压缩成功后，边长放大至 $a$ 倍即可</p><p>根据题意，记缩放后的图片尺寸为 $sz$<br>易得此处 $a=sz/gcd(n,sz)$ ， $b=n/gcd(n,sz)$</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,Z,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Z;</span><br><span class="line">    string s[<span class="number">55</span>];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">if</span>((n*Z)%<span class="number">100</span>) &#123;cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll sz=(n*Z)/<span class="number">100</span>;<span class="comment">//缩放后的图片边长</span></span><br><span class="line">    <span class="type">char</span> re[<span class="number">55</span>][<span class="number">55</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    t=<span class="built_in">gcd</span>(sz,n);</span><br><span class="line">    <span class="keyword">if</span>(n==t)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(a,<span class="number">1</span>,sz/t)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">FORLL</span>(b,<span class="number">1</span>,sz/t)&#123;</span><br><span class="line">                        cout &lt;&lt; s[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">            <span class="type">char</span> ch=s[(i<span class="number">-1</span>)*(n/t)+<span class="number">1</span>][j*(n/t)];</span><br><span class="line">            <span class="built_in">FORLL</span>(a,<span class="number">0</span>,n/t<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(b,<span class="number">0</span>,n/t<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[(i<span class="number">-1</span>)*(n/t)+<span class="number">1</span>+a][j*(n/t)+b]!=ch)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            re[i<span class="number">-1</span>][j]=ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,t<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(a,<span class="number">1</span>,sz/t)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">0</span>,t<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">FORLL</span>(b,<span class="number">1</span>,sz/t) cout &lt;&lt; re[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校03</title>
      <link href="/posts/ACM_2023Summer_NCD03.html"/>
      <url>/posts/ACM_2023Summer_NCD03.html</url>
      
        <content type="html"><![CDATA[<h1>A.World Fragments I</h1><p><strong>字符串、签到</strong></p><h2 id="题意">题意</h2><p>给定两个二进制数 $x,y$<br>每次可以选择 $x$ 中的一个数位 $d$ ,并可执行 $x=x+d$ 或 $x=x-d$<br>问能否通过任意次以上操作，使得 $x=y$ ，并给出最少次数</p><h2 id="解题思路">解题思路</h2><p>这两个二进制数可以视为01串<br>对于 $x=0$ ，每一位都是0，除非 $y=0$ ，否则无法达成条件<br>对于 $x\ne 0$ ，必定有一位上是 $1$ ，通过题设操作可以转化为任何数，最小次数为这两个数的差的绝对值 $|x-y|$</p><p>bitset是一种非常便于处理01串的STL数据结构，合理利用可以省去很多麻烦</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string x,y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="function">bitset&lt;1000&gt; <span class="title">a</span><span class="params">(x)</span>,<span class="title">b</span><span class="params">(y)</span></span>;</span><br><span class="line">    ll m,n;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">none</span>()&amp;&amp;b.<span class="built_in">any</span>()) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    m=a.<span class="built_in">to_ullong</span>();</span><br><span class="line">    n=b.<span class="built_in">to_ullong</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(m-n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>D.Ama no Jaku</h1><p><strong>思维</strong></p><h2 id="题意-2">题意</h2><p>给定一个01矩阵，每次操作可以选定任意一行或一列并将其反转<br>问在操作任意次后，能否使得该矩阵 行代表的二进制数$r_i$ 与列代表的二进制数 $c_i$ ，满足 $min(r_i)\ge max(c_i)$<br>若能，输出最少操作次数，否则输出“-1”</p><h2 id="解题思路-2">解题思路</h2><p>首先考虑满足条件的矩阵的状态<br>对于 $\text O$ 矩阵，$\forall i ,r_i=c_i=0$ ，一定满足条件<br>要使 $min(r_i)&gt;0$ ，每一行都要有 $1$ 。如果在每一行都加上一个 $1$ ，会发现无论如何排列顺序，都会使得 $min(r_i)\lt max(c_i)$<br>最终当所有元素都转化为 $1$ 时，满足条件<br>综上，只有当元素全为 $0$ 或 $1$ 时满足条件</p><p>显然如果一个矩阵可以转化为全 $0$ 矩阵，那么它一定可以转化为全 $1$ 矩阵，因此考虑原矩阵是否可以转化为全 $0$ 矩阵</p><p>先将第一列全部转化为 $0$ ，后面每一列的值都必须全为 $0$ 或 $1$ 才可以满足条件<br>分别记录行和列的首位转化为0的次数，分类比较即可</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,cntr=<span class="number">0</span>,cntc=<span class="number">0</span>,re1,re2;<span class="comment">//转置为0的次数</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    bitset&lt;2005&gt; mat[<span class="number">2005</span>];</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; mat[i];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(mat[i][<span class="number">0</span>]) &#123;mat[i].<span class="built_in">flip</span>();cntr++;&#125;</span><br><span class="line">    <span class="comment">//FORLL(i,0,n-1) &#123;FORLL(j,0,n-1) cout &lt;&lt; mat[i][j]; cout &lt;&lt; endl;&#125;</span></span><br><span class="line">    <span class="built_in">FORLL</span>(j,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> b=mat[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(b) cntc++;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(mat[i][j]!=b) &#123;cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    re1=cntc+(cntr&gt;=(n+<span class="number">1</span>)/<span class="number">2</span>?cntr:n-cntr);</span><br><span class="line">    re2=cntr+(cntc&gt;=(n+<span class="number">1</span>)/<span class="number">2</span>?cntc:n-cntc);</span><br><span class="line">    cout &lt;&lt; (re1&lt;re2?re1:re2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Until the Blue Moon Rises</h1><p><strong>数学题</strong></p><h2 id="题意-3">题意</h2><p>对于给定的 $n$ 个数，每次操作可以使一个数 $-1$ ，另一个数 $+1$<br>可以操作任意次，问是否可以使这些数全部成为质数</p><h3 id="前置知识点">前置知识点</h3><p><a href="https://baike.baidu.com/item/%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3/72364">哥德巴赫猜想</a>：任一大于5的整数都可写成三个质数之和，任一大于2的偶数都可写成两个素数之和</p><h2 id="解题思路-3">解题思路</h2><p>题设操作任意次的效果即：把所有数的和 $sum$ 分成 $n$ 个数<br>问是否有一种分法使得这 $n$ 个数都是质数</p><ol><li>$n$ 个数都是质数时，最小情况是所有的数全为 $2$<br>因此，当 $sum&lt;2\times n$ 时一定不可以构成</li><li>$n=1$<br>只有一个数，直接判断它是否为质数即可</li><li>$n=2$<br>如果它们的和是偶数，根据哥德巴赫猜想一定可以构成；<br>如果它们的和是奇数，分成两个数一定是一奇一偶，众嗦粥汁，偶数中只有2是质数，因此判断 $n-2$ 是否为质数即可</li><li>$n=3$<br>由于 $sum&lt;2\times n=6$ 的情况已经在 $1$ 中筛去，故根据哥德巴赫猜想一定可以构成</li><li>$n&gt;3$<br>每次分出 $2$ 直到剩余 $3$ 个数，利用上一条可知一定可以构成</li></ol><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkprime</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,t) <span class="keyword">if</span>((n/i)*i==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t,sum=<span class="number">0</span>;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        sum+=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">2</span>*n) &#123;cout &lt;&lt; NO ;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">checkprime</span>(sum))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; YES;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; NO ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">checkprime</span>(sum<span class="number">-2</span>)) &#123;cout &lt;&lt; YES ;<span class="keyword">return</span>;&#125;</span><br><span class="line">            cout &lt;&lt; NO;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; YES;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>J.Fine Logic</h1><p><strong>拓扑排序</strong></p><h2 id="题意-4">题意</h2><p>对于 $n$ 个人（记为 $1-n$），给定 $m$ 对偏序关系，表示胜利关系<br>对于一组排名，位于前面的人视为赢过后面的人<br>问如何构造最少组数的排名，使得满足给定的 $m$ 对胜利关系</p><h2 id="解题思路-4">解题思路</h2><p>对于 $n$ 个人之间的所有胜利关系，构造两组排名：<br>$$<br>1,2,3,\cdots,n \newline<br>n,n-1,n-2,\cdots,1<br>$$<br>一定能满足所有胜利关系</p><p>如果 $m$ 个胜利关系构成DAG，则将它的拓扑排序列作为排名输出一组即可<br>否则输出上面两组排名</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+<span class="number">1</span>),<span class="built_in">pre</span>(n+<span class="number">1</span>);</span><br><span class="line">    vector&lt;pll&gt; E;</span><br><span class="line">    vector&lt;ll&gt;::iterator it;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        E.<span class="built_in">emplace_back</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(E);</span><br><span class="line">    <span class="built_in">unique</span>(<span class="built_in">ALL</span>(E));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:E)&#123;</span><br><span class="line">        G[e.first].<span class="built_in">emplace_back</span>(e.second);</span><br><span class="line">        pre[e.second].<span class="built_in">emplace_back</span>(e.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">SORT</span>(G[i]);</span><br><span class="line">        <span class="built_in">SORT</span>(pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    vector&lt;ll&gt; vec;</span><br><span class="line">    bitset&lt;1000005&gt; f;</span><br><span class="line">    f.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(f[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre[i].<span class="built_in">size</span>()&amp;&amp;f[pre[i].<span class="built_in">back</span>()]) pre[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span>(f[i]==<span class="number">0</span>&amp;&amp;pre[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">                vec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                f[i]=<span class="number">1</span>;flag=<span class="number">1</span>;cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(ll i=n;i&gt;<span class="number">0</span>;i--) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校02</title>
      <link href="/posts/ACM_2023Summer_NCD02.html"/>
      <url>/posts/ACM_2023Summer_NCD02.html</url>
      
        <content type="html"><![CDATA[<h1>D.The Game of Eating</h1><p><strong>贪心</strong></p><h2 id="题意">题意</h2><p>$n$ 个人聚餐， 在 $m$ 道菜品中选择 $k$ 道，且不能重复。从1号开始，每个人轮流选择一道菜<br>每个人对于每个菜品都有一个喜爱值，第 $i$ 个人对第 $j$ 个菜品的喜爱程度记为 $a_{i,j}$<br>假设每个人都想要使 自己对最终点的 $k$ 道菜的喜爱值总和 最大，求最终选定的菜单</p><h2 id="解题思路">解题思路</h2><p>对于当前点菜的人，假设他最喜欢的菜还没有被点，但他仍然需要考虑后面是否有人选择这道菜。如果后面一定有人选择这道菜，他可以选择第二喜欢的菜品以使得自己的满意度最大化<br>基于这种情况分析，最后一个点菜的人无需考虑其他人的需求，只需要选择剩余菜品中最喜欢的那一个，即可使得自己的满意度最大化<br>假设所有菜品中他最喜欢的还没有被选取，那么就会选择这个菜品。反推到倒数第二个、第三个亦此</p><p>因此，只需要将点菜的顺序逆转，这样只要每个人选择剩余菜品中最喜欢的菜品即可，无需考虑其他人的需求。</p><h3 id="时间复杂度">时间复杂度</h3><p>$k$ 次遍历菜品： $O(km)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,k,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;pll&gt;&gt; <span class="built_in">v</span>(n+<span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt; re;</span><br><span class="line">    vector&lt;pll&gt;::iterator it;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">chosen</span><span class="params">(m+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            v[i].<span class="built_in">emplace_back</span>(t,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SORT</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=(k<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        it=v[p].<span class="built_in">end</span>();--it;</span><br><span class="line">        <span class="keyword">while</span>(chosen[(*it).second]) it--;</span><br><span class="line">        re.<span class="built_in">emplace_back</span>((*it).second);</span><br><span class="line">        chosen[(*it).second]=<span class="literal">true</span>;</span><br><span class="line">        p--;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>) p=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SORT</span>(re);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:re)&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>E.Square</h1><p><strong>数学题</strong></p><h2 id="题意-2">题意</h2><p>对于给定的整数 $x\le 10^9$ ，找到一个 $y\le 10^9$ ，使得存在一个整数 $k$，使得 $x$ 是 $y^2$ 的前 $k$ 位<br>如果不存在这样的 $y$ ，输出 $-1$</p><h2 id="解题思路-2">解题思路</h2><p>题目给定了一个定义式：$\lfloor \dfrac{y^2}{10^k} \rfloor = x$<br>可以将其化解为不等式：<br>$$\begin{align}<br>原式<br>&amp;\Rightarrow x \le \dfrac{y^2}{10^k} \lt x+1 \newline<br>&amp;\Rightarrow 10^k x \le y^2 \lt 10^k (x+1) \newline<br>&amp;\Rightarrow \sqrt{10^k x} \le y \lt \sqrt{10^k(x+1)}<br>\end{align}<br>$$<br>其中 $x$ 是确定的，只需遍历 $k$ 对应的 $y=sqrt(10^k x)+1$ ，判断即可</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(t*t==x)&#123;</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        p*=<span class="number">10</span>;<span class="comment">//表示10^k</span></span><br><span class="line">        t=<span class="built_in">sqrt</span>(p*x);</span><br><span class="line">        <span class="keyword">if</span>(t*t&lt;t*n) t++;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;<span class="number">1e9</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((t*t)/p==x)&#123;</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>F.Link with Chess Game</h1><p><strong>二分图博弈</strong></p><h2 id="题意-3">题意</h2><p>在一行长度为 $n$ 的格子上有红绿蓝三种颜色的棋子，他们的坐标构成一个有序三元组 $(r,g,b)$ （坐标可以重复）</p><p>每次可以选择一颗棋子向左或向右移动一步，如果某次移动后的三元组 $(r_i,g_i,b_i)$ 在此前出现过，则执行移动的人失败</p><h2 id="解题思路-3">解题思路</h2><h3 id="赛时想法">赛时想法</h3><p>假设只有一颗棋子的情况<br>选定一个方向，假设棋子当前距离这个方向端点的距离为 $x$ 。不难证明 $x$ 为奇数时胜利； $x$ 为偶数时失败<br>在这种情况下，只要当前位置与两端之一的距离为奇数即可获胜<br>基于这一结论，猜想三颗棋子的条件下，每颗棋子与左、右两端的距离之和 $suml,sumr$ 与必胜态之间的关系，和一颗棋子的情况相似<br>样例满足这一猜想</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,a,b,c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll l,r;</span><br><span class="line">    l=a+b+c<span class="number">-3</span>;</span><br><span class="line">    r=n*<span class="number">3</span>-a-b-c;</span><br><span class="line">    <span class="keyword">if</span>(l&amp;<span class="number">1</span>||r&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赛后补题">赛后补题</h3><p>对于这类无向的博弈，可以考虑是否为二分图博弈<br>把三颗棋子看作是三个维度，显然所有状态组成的图是一个正方体，一定是二分图<br>在 $n$ 为偶数的情况下，最大匹配可以覆盖所有状态，即初始状态一定在某一对匹配上。这种情况下，先手一定落在匹配中的最后一个点，因此是必胜的<br>在 $n$ 为奇数的情况下，对于起始点在较小一部的状态点，一定在某一最大匹配上。这种情况下，先手一定落在匹配中的最后一个点，因此是必胜的<br>对于起始点在较大一部中的状态点的情况，一定存在一个最大匹配不包含起始点。因此在这个最大匹配上，后手一定落在匹配中的最后一个点，因此是必败的<br>赛时的思路虽然不严谨，但误打误撞结论和正解是一致的//</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,a,b,c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>((a+b+c<span class="number">-1</span>)&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>I.Link with Gomoku</h1><p><strong>构造</strong></p><h2 id="题意-4">题意</h2><blockquote><p>“你赢得越多，你的自信就越强。你的自信越强，你就越傲慢。你越傲慢，就越容易犯错误。你犯的错误越多，你就输的越多。所以你赢的越多，你输的就越多。”</p></blockquote><p>在一个 $n\times m$ 大小的棋盘上下五子棋，构造一个平局的棋盘局面。</p><h2 id="解题思路-4">解题思路</h2><p>构造的方法并不难想，这里给出如下两种：</p><ol><li>题目样例所示的：<br>xxxxooooxxxxoooo<br>ooooxxxxooooxxxx<br>xxxxooooxxxxoooo<br>ooooxxxxooooxxxx</li><li>我赛时所写的：<br>ooxooxooxoo<br>xxoxxoxxoxx<br>ooxooxooxoo<br>xxoxxoxxoxx</li></ol><p>易错点在于：只关注了平局的条件，没有在意黑白子之间的数量关系</p><p>如果是偶数行，按上面方案输出；<br>如果是奇数行，最后一行按xoxoxox的顺序输出即可</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> flag=n&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag) n=n<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">3</span>) cout &lt;&lt; <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">3</span>) cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&amp;<span class="number">1</span>) cout &lt;&lt; <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校02</title>
      <link href="/posts/ACM_2023Summer_HDU02.html"/>
      <url>/posts/ACM_2023Summer_HDU02.html</url>
      
        <content type="html"><![CDATA[<h1>1002.Binary Number</h1><p><strong>字符串、贪心</strong></p><h2 id="题意">题意</h2><p>给定一段长度为$n$的01串，首位保证为1<br>任选定其中任意长的一段并将其反转<br>必须执行以上操作$k$次，求操作后得到的01串表示的二进制数最大的状态并输出</p><h2 id="解题思路">解题思路</h2><p>首先考虑<strong>次数不足</strong>的情况。对于一个二进制数，高位的权重大于其所有低位权重之和。因此优先考虑将靠前的字符中的0反转为1。</p><p>接下来比较多次反转<strong>不同方案</strong>的优劣。忽略操作次数限制，考虑这个字符串：1001001001</p><ol><li>最直观的办法是直接选定第2-3,5-6,8-9位反转为1，得到全1串。</li><li>还有一种可选的优质方法:1001001001 $\Rightarrow$ 1110110111 $\Rightarrow$ 11100111 $\Rightarrow$ 1111111111</li></ol><p>上述两种方法对于同样3段的0，次数相同，并且第一种方法更便于考虑，故采取第一种策略，从左往右反转0。</p><p>接下来再考虑已经转化为全1串，<strong>次数溢出</strong>的情况。可以考虑在转换过程中做无效操作浪费次数，避免对最大结果造成影响。</p><ol><li>对于起始01串，如果有0必有前导1(首位保证为1)。因此可以在反转某段0时带上前导1一起，再消耗1次操作单独转回前导1，可以浪费1次数</li><li>对于单个1做2次反转操作，可以浪费2次数</li><li>对于连续的2个1，分两次单独反转这两个1，然后一起翻回，可以浪费3次数</li></ol><p>在以上策略的搭配下，正常情况下可以消耗任意溢出次数，并最终状态为全1</p><p>最后考虑<strong>特殊情况</strong></p><ol><li>当起始01串全为1，且$k=1$，此时只能反转末位1使损失最小</li><li>当01串长度为1，此时起始01串只能是&quot;1&quot;，其状态只由$k$的奇偶决定</li></ol><p>(P.S.)谁赛时程序中把’='写成&quot;==&quot;又不想Remake于是卡签一个半小时我不说</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(n)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,re;</span><br><span class="line">    ll n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    ll flag=<span class="number">0</span>,all1=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>&amp;&amp;k) &#123;k--;flag=<span class="number">1</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) re.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> re.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            all1=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;all1) re[n<span class="number">-1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>((k%<span class="number">2</span>)&amp;&amp;n==<span class="number">1</span>) re[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1004.Card Game</h1><p><strong>思维题</strong></p><h2 id="题意-2">题意</h2><p>游戏规则和汉诺塔类似<br>有 $n$ 根柱子，起始在第1根柱子上从下到上摆放着编号 $k,k-1,\cdots,2,1$ 的卡牌<br>规定：每根柱子只能从下到上放编号<strong>连续且递减</strong>的卡牌<br>每次操作可以将一根柱子上的最顶端的卡牌移动到其他柱子上（且不能违反规定）<br>求对于给定的柱子根数 $n$ ，可以实现将第一根柱子上所有牌移动到第二根柱子上的最大卡牌张数 $k$</p><h2 id="解题思路-2">解题思路</h2><p>这道题可以采用逆向思维。<br>起始态和最终态同构，拆解和合并过程对称，考虑从中间关键步骤分解顺推：</p><ol><li>将最大点数的卡牌从 柱子$1$ 转移到 柱子$2$</li><li>此时有 $1$ 个空位，可以将牌数为 $2$ 的柱子（假设他们恰好是次大的）拆分合并到柱子 $2$ ，并产生一个新的空位……</li><li>每次完全合并一个柱子，就会多一个空位，空位多的状态包含了空位少的状态。考虑状态转移关系：<ol><li>记：利用 $x$ 个空位可以转移到目标柱子的最大牌数为 $f(x)$<br>显然： $f(0)=1$</li><li>假设目前有个 $x$ 空位，对于本轮要转移的柱子，可以先借用一个空位存储上半部分较小卡牌。存储数量为  $f(x-1)$ ，因为存储本身需要占用一个空位</li><li>利用剩余 $x-1$ 个空位，最多可以转移并合并 $f(x-1)$ 张卡牌到柱子 $2$</li><li>再利用剩余 $x-1$ 个空位，将存储的 $f(x-1)$ 张卡牌到柱子 $2$</li><li>综3.1-3.4，可以得到 $f(x)$ 的递推式： $f(x)=2f(x-1)$<br>并求得 $f(x)=2^n$</li></ol></li><li>第一步可以看作：利用 $0$ 个空位，将最大点数的卡牌从 柱子$1$ 转移到 柱子$2$<br>最后一步可以看作：利用 $n-2$ 个空位，将最后一堆卡牌从转移到 柱子$2$<br>中途每一步产生 $1$ 个空位<br>由此得到结果：</li></ol><p>$$\begin{align}<br>k<br>&amp;=\sum\limits_{i=0}^{n-2} f(i) \newline<br>&amp;=1+2+\cdots+2^{n-2} \newline<br>&amp;=2^{n-1}-1<br>\end{align}<br>$$</p><p>快速幂斩了</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Get_Mod</span>(<span class="built_in">qcpow</span>(<span class="number">2</span>,n<span class="number">-1</span>)<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//快速幂代码略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1>1007.foreverlasting and fried-chicken</h1><p><strong>图论、枚举</strong></p><h2 id="题意-3">题意</h2><p>给定一个无权无向图 $G=(V,E),|V|=n,|E|=m$<br>求图中包含以下子图的数量：<br><img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_HDU02_1007.png" alt="Img"></p><h2 id="解题思路-3">解题思路</h2><p>对于这个子图，有一个度为4的点和一个度为6的点，他们有4个公共邻居。借助这个特征，在给定无向图中找点</p><p>构图，在过程中记录每个点的度数 $deg_i$</p><p>对于每个 $deg_1\ge6$ 的点 $v_1$ ，枚举 $deg_2\ge4$ 的点 $v_2$<br>计算公共邻居个数，记为 $nbr$<br>对于 $v_1,v_2$ ，其含有上述子图个数为：$C_{nbr}^4 \cdot C_{deg_1-4}^2$<br>（注意：如果  $v_1,v_2$ 相连，这条边是不允许被构入子图的，计算的度是要减去1）</p><p>计算每一对 $v_1,v_2$ 的个数之和即可</p><h3 id="时间复杂度-2">时间复杂度</h3><p>朴素的做法的时间复杂度是 $O(n^3)$ （会有人T到飞起）<br>考虑用bitset对图进行状态压缩，降低求 $nbr$ 的时间复杂度<br>最终时间复杂度为  $O(\dfrac{n^3}{\omega})$</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ll C[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//在主函数中预处理组合数C，代码略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    bitset&lt;1005&gt; G[<span class="number">1005</span>];</span><br><span class="line">    <span class="type">int</span> deg[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">set</span>(v);</span><br><span class="line">        G[v].<span class="built_in">set</span>(u);</span><br><span class="line">        deg[u]++;deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll re=<span class="number">0</span>,nbr,deg1,deg2;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(deg[i]&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,i+<span class="number">1</span>,n) <span class="keyword">if</span>(j-i&amp;&amp;deg[j]&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">            deg1=deg[i]-G[i][j];</span><br><span class="line">            deg2=deg[j]-G[i][j];</span><br><span class="line">            <span class="comment">//如果vi,vj直接相连，这条边是不能构入的</span></span><br><span class="line">            nbr=(G[i]&amp;G[j]).<span class="built_in">count</span>();</span><br><span class="line">            <span class="keyword">if</span>(nbr&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(deg1&gt;=<span class="number">6</span>) re=<span class="built_in">add</span>(re,<span class="built_in">mul</span>(C[nbr][<span class="number">4</span>],C[deg1<span class="number">-4</span>][<span class="number">2</span>]));</span><br><span class="line">                <span class="keyword">if</span>(deg2&gt;=<span class="number">6</span>) re=<span class="built_in">add</span>(re,<span class="built_in">mul</span>(C[nbr][<span class="number">4</span>],C[deg2<span class="number">-4</span>][<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1009.String Problem</h1><p><strong>字符串、签到</strong></p><h2 id="题意-4">题意</h2><p>给定一个字符串 $S$，仅包含小写字母<br>在其中选择 $S$ 的 $k$ 个回文非空子串，且它们成对不相交，可以得到等同于 所选子串的长度之和减去子串数量 的分数：$\sum\limits_{i=1}^k len(s_i) -k$<br>为了<s>让这道题成为签到题</s>《增加题目难度》，所选子串最多包含一个字符，求对于给定字符串，可以获得的最高分数</p><h2 id="解题思路-4">解题思路</h2><p>在增加难度后，<s>很难想到</s>所选的每一子串就是连续相同字符<br>答案即给定字符串长度减去连续相同字符段数</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    ll len=s.<span class="built_in">size</span>();</span><br><span class="line">    ll cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>]) &#123;cnt++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len-cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期杭电多校01</title>
      <link href="/posts/ACM_2023Summer_HDU01.html"/>
      <url>/posts/ACM_2023Summer_HDU01.html</url>
      
        <content type="html"><![CDATA[<h1>1002.City Upgrading</h1><p><strong>树形DP、支配集</strong></p><h2 id="题意">题意</h2><p>crazyzhk居住在一个树形城市。有一天，这个城市的网络需要升级。为了实现这一目标，需要部署路由器。<br>每个路由器可以覆盖其所在的节点及其相邻节点，在节点 $i$ 上放置一个路由器的成本是 $a_i$<br>确保每个节点都得到覆盖的情况下，成本最低是多少</p><h3 id="前置知识点">前置知识点</h3><ul><li><a href="https://oi-wiki.org/dp/tree/">树形DP</a></li><li><a href="https://baike.baidu.com/item/%E6%94%AF%E9%85%8D%E9%9B%86/3187787">支配集</a>：给定无向图 $G=(V,E)$ ，称 $V$ 的一个子集 $S$ 为支配集，当且仅当对于 $V-S$ 中任何一个点 $v$ ，都有 $S$ 中的某个点 $u$ ，使得 $(u,v) \in E$</li></ul><h2 id="解题思路">解题思路</h2><p>要实现信号全覆盖，所选取的点集必须是一个<strong>支配集</strong><br>题目求的是所有支配集中最小的cost，考虑<strong>树形DP</strong></p><p>构造DP数组<code>dp[N][3]</code>:</p><ol><li><code>dp[i][0]</code>表示点 $i$ 属于支配集合，并且以点 $i$ 为根的子树都被覆盖了的情况下，支配集中所包含最少cost</li><li><code>dp[i][1]</code>表示点 $i$ 不属于支配集合，且以 $i$ 为根的子树都被覆盖，且 $i$ 被其不少于一个子节点覆盖的情况下，支配集所包含最少cost</li><li><code>dp[i][2]</code>表示点 $i$ 不属于支配集合，且以 $i$ 为根的子树都被覆盖，且 $i$ 没被子节点覆盖（将被父节点覆盖）的情况下，支配集中所包含最少cost</li></ol><p>结合最小支配集的贪心思想，按<strong>DFS序的逆序</strong>进行DP，节点 $i$ 的子节点记为 $u$</p><p>对于第一种状态，<code>dp[i][0]</code>含义为点 $i$ 属于支配集合，那么依次取每个儿子节点三种状态中的最小值，再把取得的最小值全部加起来再加1，就是dp<code>[i][0]</code>的值了。即只要每个以 $i$ 的儿子为根的子树都被覆盖，再加上当前点 $i$ ，所需要的最少cost，DP转移方程如下：<br>$$<br>dp[i][0] = 1 + ∑min(dp[u][0], dp[u][1], dp[u][2])<br>$$<br>对于第三种状态，<code>dp[i][2]</code>含义为点 $i$ 不属于支配集合，且 $i$ 被其父节点覆盖。那么说明点 $i$ 和点 $i$ 的儿子节点都不属于支配集合，所以点 $i$ 的第三种状态之和其儿子节点的第二种状态有关，方程为：<br>$$<br>dp[i][2] =∑dp[u][1]<br>$$<br>对于第二种状态，略有些复杂。<br>首先如果点 $i$ 没有子节点那么<code>dp[i][1]</code>应该初始化为INF；否则为了保证它的每个以 $i$ 的儿子为根的子树被覆盖，那么要取每个儿子节点的前两种状态的最小值之和，因为此时点 $i$ 不属于支配集，不能支配其子节点，所以子节点必须已经被支配，与子节点的第三种状态无关。<br>如果当前所选状态中每个儿子都没被选择进入支配集，即在每个儿子的前两种状态中，第一种状态都不是所需点最小的，那么为了满足第二种状态的定义(因为点 $i$ 的第二种状态必须被其子节点覆盖，即其子节点必须有一个属于支配集，如果此时没有，就必须强制使一个子节点的状态为状态一)，需要重新选择点 $i$ 的一个儿子节点为第一种状态，这时取花费最少的一个点，即取<code>min(dp[u][0] - dp[u][1])</code>的儿子节点 $u$ ，强制取其第一种状态，其他的儿子节点取第二种状态，DP转移方程为:<br>$$dp[i][1] = \begin{cases}<br>INF ，i没有子节点 \newline<br>∑min(dp[u][0], dp[u][1]) + inc ，Otherwise \newline<br>\end{cases} \newline<br>$$<br>$$<br>其中，inc = \begin{cases}<br>0 ，上式的Otherwise中至少选择了一次状态一的子节点 \newline<br>min(dp[u][0] - dp[u][1]) ，Otherwise<br>\end{cases} \newline<br>$$</p><p>结果为根节点三个状态中的最小值</p><h3 id="时间复杂度">时间复杂度</h3><p>$O(nlogn)$</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; T;</span><br><span class="line">vector&lt;ll&gt; cost;</span><br><span class="line">vector&lt;ll&gt; DFS_vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ll node)</span></span>&#123;</span><br><span class="line">    DFS_vec.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:T[node]) <span class="built_in">DFS</span>(i);</span><br><span class="line">&#125;<span class="comment">//获取DFS遍历序列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    T.<span class="built_in">clear</span>();T.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    cost.<span class="built_in">clear</span>();cost.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n) cin &gt;&gt; cost[i];</span><br><span class="line">    ll u,v;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        T[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DFS_vec.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">ALL</span>(DFS_vec));<span class="comment">//逆序</span></span><br><span class="line">    <span class="comment">//print_vec(DFS_vec);</span></span><br><span class="line">    </span><br><span class="line">    ll dp[N][<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:DFS_vec)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=cost[i];</span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:T[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]+=<span class="built_in">min</span>(&#123;dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>],dp[j][<span class="number">2</span>]&#125;);</span><br><span class="line">            dp[i][<span class="number">2</span>]+=dp[j][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(T[i].<span class="built_in">empty</span>()) dp[i][<span class="number">1</span>]=INF;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> flag=<span class="number">1</span>;ll inc=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:T[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][<span class="number">0</span>]&lt;=dp[j][<span class="number">1</span>]) &#123;dp[i][<span class="number">1</span>]+=dp[j][<span class="number">0</span>];flag=<span class="number">0</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][<span class="number">1</span>]+=dp[j][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:T[i]) inc=<span class="built_in">min</span>(&#123;inc,dp[u][<span class="number">0</span>]-dp[u][<span class="number">1</span>]&#125;);</span><br><span class="line">                dp[i][<span class="number">1</span>]+=inc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll re=<span class="built_in">min</span>(&#123;dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1005.Cyclically Isomorphic</h1><p><strong>字符串匹配</strong></p><h2 id="题意-2">题意</h2><p>对于两个字符串 $s_1$ , $s_2$ ，如果存在一个整数 $k$ 使得 $s_1$ 循环右移k位与 $s_2$ 相同，则称他们是&quot;cyclically right-shifted&quot;。<br>每组数据给出 $n$ 个长度为 $m$ 的字符串， $Q$ 次询问两个字符串是否&quot;cyclically right-shifted&quot;。</p><h2 id="解题思路-2">解题思路</h2><p>对于每一字符串，找到其字典序最小的状态储存，每次询问时直接比较即可。<br>主要是时间复杂度难以证明</p><h3 id="时间复杂度-2">时间复杂度</h3><p>找最小态储存 $n \times m^2$ ，比较 $Q \times m$<br>$Q \le \dfrac{1}{2} n(n-1) \Rightarrow$ 比较 $m \times n^2$<br>总复杂度： $O(mn \times (m+n))$ ，<br>$mn \le 10^5$ 下<s>数据不变态的话</s>就能卡过去</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s[N],s1,s2;</span><br><span class="line">    <span class="type">char</span> t;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s1;</span><br><span class="line">        s2=s1;</span><br><span class="line">        <span class="built_in">FORLL</span>(j,<span class="number">1</span>,m)</span><br><span class="line">        &#123;</span><br><span class="line">            t=s2.<span class="built_in">front</span>();</span><br><span class="line">            s2.<span class="built_in">erase</span>(s2.<span class="built_in">begin</span>());</span><br><span class="line">            s2.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">if</span>(s1.<span class="built_in">compare</span>(s2)&gt;<span class="number">0</span>) s1=s2;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i]=s1;</span><br><span class="line">    &#125;</span><br><span class="line">    ll Q;cin &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(s[n].<span class="built_in">compare</span>(s[m])==<span class="number">0</span>) cout &lt;&lt; YES;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>1009.Assertion</h1><p><strong>签到题</strong></p><h2 id="题意-3">题意</h2><p>多组数据<br>给定m件物品，分成n组<br>问：是否无论怎么分都至少有一组个数超过d</p><h2 id="解题思路-3">解题思路</h2><p>平均分组，找最大那个组的个数和d比较</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m,n,d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span>((m<span class="number">-1</span>)/n+<span class="number">1</span>&gt;=d) cout &lt;&lt; YES;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; NO;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期杭电多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解|2023暑期牛客多校01</title>
      <link href="/posts/ACM_2023Summer_NCD01.html"/>
      <url>/posts/ACM_2023Summer_NCD01.html</url>
      
        <content type="html"><![CDATA[<h1>D.Chocolate</h1><p><strong>博弈题</strong></p><h2 id="题意">题意</h2><p>有一块大小为n*m的巧克力，起始坐标为(1,1)</p><p>每次操作可以选择一个坐标(a,b)，并吃掉(1,1):(a,b)中的所有巧克力</p><p>每次操作必须吃掉至少一块巧克力，吃掉最后一块巧克力的玩家输</p><h2 id="解题思路">解题思路</h2><p><strong>1*1</strong>：显然先行必输</p><p><strong>其他</strong>：对于总数m*n。若总数为奇数，则先行开局吃偶数个，若总数为偶数，则先行开局吃奇数个。<br>然后剩余个数变为奇数个，后续每一步，先行者都保证吃完后剩余奇数个巧克力且行数/列数多于1,或1*1（可以证明在任何状态下，一定有一种这样的操作）。</p><p>先行必胜</p><h2 id="参考程序">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;Walk Alone&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Kelin&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>H.Matches</h1><p><strong>二分、包络</strong></p><h2 id="题意-2">题意</h2><p>给定两个长度为 $n$ 的序列 $a,b$ ，定义他们之间的距离为对应元素差的绝对值之和，即：<br>$$<br>\sum\limits_{i=1}^n |a_i-b_i|<br>$$<br>可以对其中一个序列交换两个数，问至多操作一次后的最小距离。</p><h2 id="解题思路-2">解题思路</h2><p>绝对值的本质就是数轴上区间的大小，把每一对元素看作一个区间，就能将问题转化。</p><p>对于某一个区间， $a_i,b_i$ 决定它自身的正反序</p><p>对于某两个区间：<br>覆盖区域有 相交、包络、不交 三种相对关系<br>正反序有 正序、反序 两种相对关系<br>组合之下便有6种相对关系</p><p>针对两个区间的相对关系的转换，展开以下分类讨论<br>1.正序相交 $\rightleftarrows$ 正序包络<img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_NCD01_H_1.png" alt="Img"><br>2.正序不交 $\rightleftarrows$ 反序包络<img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_NCD01_H_2.png" alt="Img"><br>3.反序不交 $\rightleftarrows$ 反序相交<img src="https://source.cclmsy.cc/Posts/ACM/2023Summer_NCD01_H_3.png" alt="Img"></p><p>可以看到绝对值减小的情况只有两种：<br>1.反序相交 $\Rightarrow$ 反序不交<br>2.反序包络 $\Rightarrow$ 正序不交<br>它们对距离的减少量都是重叠区间大小的两倍</p><p>综上所述，只需要找出反序相交和反序包络的情况中，重叠区间最大的情况，即可得到答案。</p><p>对于输入数据，可以先按照 $a_i,b_i$ 的相对大小，将正序区间和反序区间分别存入两个容器，记为 $S,T$ ，并算出初始值 $sum$<br>对 $S$ 进行预处理，按照区间起点排序，去除被正序包络的区间（不难证明，被正序包络的区间对答案的贡献一定不大于正序包络它的区间）<br>对于 $T$ 中的每个区间，二分查找 $S$ 中与它有交集的区间，求出重叠区间大小的最大值 $dif$</p><p>最终答案为 $sum-2\times dif$</p><h2 id="参考程序-2">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,sum=<span class="number">0</span>,dif=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; v[i].first;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cin &gt;&gt; v[i].second;</span><br><span class="line">    vector&lt;pll&gt; S,T;</span><br><span class="line">    vector&lt;ll&gt; Sx,Sy,len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [a,b]:v)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=<span class="built_in">abs</span>(a-b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a&lt;b) S.<span class="built_in">emplace_back</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) T.<span class="built_in">emplace_back</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SORT</span>(S);</span><br><span class="line">    ll r=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.second&lt;=r) <span class="keyword">continue</span>;</span><br><span class="line">        r=p.second;</span><br><span class="line">        Sx.<span class="built_in">emplace_back</span>(p.first);</span><br><span class="line">        Sy.<span class="built_in">emplace_back</span>(p.second);</span><br><span class="line">        len.<span class="built_in">emplace_back</span>(p.second-p.first);</span><br><span class="line">    &#125;<span class="comment">//消除S中被正向包络的区间。算法决定Sy递增。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> finddif=[&amp;](ll x,ll y)&#123;<span class="comment">//对于给定的区间</span></span><br><span class="line">        ll m=Sx.<span class="built_in">size</span>(),re=<span class="number">0</span>;</span><br><span class="line">        ll l=<span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(Sx),x)-Sx.<span class="built_in">begin</span>();</span><br><span class="line">        ll r=<span class="built_in">lower_bound</span>(<span class="built_in">ALL</span>(Sy),y)-Sy.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">//查找该区间在S中的位置</span></span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span>) re=<span class="built_in">max</span>(re,<span class="built_in">min</span>(Sy[l<span class="number">-1</span>],y)-x);<span class="comment">//反序相交1</span></span><br><span class="line">        <span class="keyword">if</span>(r&lt;m) re=<span class="built_in">max</span>(re,y-<span class="built_in">max</span>(Sx[r],x));<span class="comment">//反序相交2</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;l) re=<span class="built_in">max</span>(re,*<span class="built_in">max_element</span>(len.<span class="built_in">begin</span>()+l,len.<span class="built_in">begin</span>()+r));<span class="comment">//反序包络</span></span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:T) dif=<span class="built_in">max</span>(dif,<span class="built_in">finddif</span>(x,y));</span><br><span class="line">    cout &lt;&lt; sum-dif*<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1>J.Roulette</h1><p><strong>数学题</strong></p><h2 id="题意-3">题意</h2><p>初始有 $n$ 元钱，目标为赢得 $m$ 元钱（即共 $n+m$ 元钱）<br>每次投注 $x$ 元，有50%的概率输掉，50%的概率赢得 $2x$ 元<br>第一局投注 $1$ 元，接下来的每局按下述策略投注：<br>$$\begin{cases}<br>x_i=1 , \text{ 上一局赢了} \newline<br>x_i=2 \times x_{i−1} ， \text{ 上一局输了}<br>\end{cases}$$<br>如果某局剩下的钱不足以按上述策略投注，则失败退场<br>问达成目标的概率有多大</p><h2 id="解题思路-3">解题思路</h2><p>投注采用的是<strong>倍投法</strong>，考虑每一轮投注为：输若干局直到赢一局</p><ol><li>第一局就赢了，则获得 $1$ 元</li><li>第 $n$ 局赢了，则获得 $2^{n-1} - (2^{n-2}+2^{n-3}+\cdots+2+1)=1$ 元</li></ol><p>综上，<strong>每一轮赢取的钱数固定为 $1$ 元</strong></p><p>根据题意，直到输到无法投注才失败，则对于每轮投注</p><ol><li>失败的概率为： $\dfrac{1}{2^a}$</li><li>成功的概率为： $1-\dfrac{1}{2^a}$</li></ol><p>其中 $a$ 是这轮投注的局数<br>那么对于整个投注过程，成功的概率为：$\prod\limits_{i=n}^{n+m-1} (1-\dfrac{1}{2^{a_i}})$</p><p>考虑本金与可以进行的投注轮数的关系，进行第a轮至少需要的本金为：<br>$1+2+\cdots+2^{a-1}=2^a-1$<br>以此为边界对集合 ${n,n+1,\cdots,m+n-1}$ 做划分（划分内投注轮数相同，成功率相同），分别计算每个划分的成功率，再相乘得到结果</p><h3 id="时间复杂度">时间复杂度</h3><p>划分数 $\log n$，快速幂等操作 $\log n$，总复杂度 $O(\log^2n)$</p><h2 id="参考程序-3">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Get_Mod(x) ((x)%MOD)</span></span><br><span class="line"><span class="function">ll <span class="title">QuickPow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=<span class="built_in">Get_Mod</span>(x*ans);</span><br><span class="line">        x=<span class="built_in">Get_Mod</span>(x*x);</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Get_Inv</span><span class="params">(ll a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QuickPow</span>(a,MOD<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll a,b,c;</span><br><span class="line">    ll base=<span class="number">0</span>,t=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//base存储当前划分的投注轮数</span></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        base++;</span><br><span class="line">        t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll l=n,r=<span class="built_in">pow</span>(<span class="number">2</span>,base+<span class="number">1</span>)<span class="number">-2</span>;</span><br><span class="line">    <span class="comment">//l,r分别记录当前划分的左右边界</span></span><br><span class="line">    ll re=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m+n&lt;=r)<span class="comment">//所有操作数都在一个划分中，则m+n-1作为右边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="built_in">QuickPow</span>(<span class="number">2</span>,base);</span><br><span class="line">        b=<span class="built_in">Get_Mod</span>(<span class="built_in">Get_Mod</span>(a+MOD<span class="number">-1</span>)*<span class="built_in">Get_Inv</span>(a));</span><br><span class="line">        <span class="comment">//b为等比数列求和</span></span><br><span class="line">        c=<span class="built_in">QuickPow</span>(b,m);<span class="comment">//这个划分共m局游戏</span></span><br><span class="line">        re=<span class="built_in">Get_Mod</span>(re*c);</span><br><span class="line">        base++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=m+n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a=<span class="built_in">QuickPow</span>(<span class="number">2</span>,base);</span><br><span class="line">            b=<span class="built_in">Get_Mod</span>(<span class="built_in">Get_Mod</span>(a+MOD<span class="number">-1</span>)*<span class="built_in">Get_Inv</span>(a));</span><br><span class="line">            c=<span class="built_in">QuickPow</span>(b,r-l+<span class="number">1</span>);<span class="comment">//完全的划分共r-l+1局游戏</span></span><br><span class="line">            re=<span class="built_in">Get_Mod</span>(re*c);</span><br><span class="line"></span><br><span class="line">            base++;</span><br><span class="line">            l=<span class="built_in">pow</span>(<span class="number">2</span>,base)<span class="number">-1</span>;</span><br><span class="line">            r=<span class="built_in">pow</span>(<span class="number">2</span>,base+<span class="number">1</span>)<span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;m+n)</span><br><span class="line">        &#123;</span><br><span class="line">            a=<span class="built_in">QuickPow</span>(<span class="number">2</span>,base);</span><br><span class="line">            b=<span class="built_in">Get_Mod</span>(<span class="built_in">Get_Mod</span>(a+MOD<span class="number">-1</span>)*<span class="built_in">Get_Inv</span>(a));</span><br><span class="line">            c=<span class="built_in">QuickPow</span>(b,m+n-l);<span class="comment">//最后一个的划分共m+n-l局游戏</span></span><br><span class="line">            re=<span class="built_in">Get_Mod</span>(re*c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>K.Subdivision</h1><p><strong>图论-BFS最短路</strong></p><h2 id="题意-4">题意</h2><p>给定一个无权无向图 $G=(V,E),|V|=n,|E|=m$</p><p>每次操作可以选定一条边，在其中插入一个点使其分裂成两条边</p><p>问操作任意次数后，与点 $v_1$ 距离不大于 $k$ 的点至多有多少个</p><h2 id="解题思路-4">解题思路</h2><p>对于无向图 $G$ ，以点 $v_1$ 为根，用BFS确定最短路，刻画BFS树</p><p>可以很容易得到以下结论：<br>1.不在BFS树上的边可以无限分裂，对BFS树上点的距离无影响<br>2.分裂操作对答案有贡献的情况是：这条边至少有一个端点的距离 $dist_i$ 小于 $k$ 。从端点的角度，分裂这条边的最大贡献是 $k-dist_i$</p><p>那么可以对BFS树上的点进行分类讨论：<br>1.在图上具有除父节点外的其他邻节点：分裂以它为端点的树边，或导致其它邻节点到根的距离增大，对答案有损失。故只允许它在非树上的有效边上分裂<br>2.在图上没有除父节点外的其他邻节点：允许其在回溯的树边上分裂，对答案没有损失，只有贡献</p><p>我赛时写的程序和标程其实差不多，只是后面想歪了写了个图存储BFS树然后卡死在那了//<br>所以本篇参考程序后半部分<s>照抄</s>借鉴了标程，并加入了对BFS的优化：<br>由于距离 $dist_i$ 大于 $k$ 的点 $v_i$ 上一定没有对答案有贡献的边（这是最短路的特性决定的，不难证明），BFS只需搜索完 $dist_i$ 小于等于 $k$ 的点并加入BFS树即可，在 $k&lt;&lt;n$ 的情况下可以大幅减少BFS时间</p><h2 id="参考程序-4">参考程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">G</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll u,v; pll tpll;</span><br><span class="line">    vector&lt;ll&gt;::iterator it;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dist</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;<span class="comment">//记录最短路长度</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pre</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//记录BFS树上点的前驱</span></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">leaf</span><span class="params">(n + <span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//0表示叶子节点（无子节点）</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BFS最短路</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;dist[q.<span class="built_in">front</span>()]&lt;k)<span class="comment">//优化</span></span><br><span class="line">    &#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: G[u])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[v]!=<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">            dist[v]=dist[u]+<span class="number">1</span>;</span><br><span class="line">            pre[v]=u;</span><br><span class="line">            leaf[u]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll re=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FORLL</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==<span class="number">-1</span>||dist[i]&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:G[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(p==pre[i]||i==pre[p]) <span class="keyword">continue</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;<span class="comment">//对于非叶子节点，在非树上的有效边上分裂</span></span><br><span class="line">        <span class="keyword">if</span> (!leaf[i]) cnt = <span class="built_in">max</span>(cnt, <span class="number">1ll</span>);</span><br><span class="line">        <span class="comment">//对于叶子节点，如果没有其他邻节点(cnt==0)，允许其在回溯的树边上分裂</span></span><br><span class="line">        re+=(k-dist[i])*cnt+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛笔记 </tag>
            
            <tag> 2023暑期牛客多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SYの代码框架</title>
      <link href="/posts/cpp_head.html"/>
      <url>/posts/cpp_head.html</url>
      
        <content type="html"><![CDATA[<h2 id="CPP-Head">CPP-Head</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #pragma GCC optimize(&quot;O3&quot;) //调试时关闭</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------Consts----------*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF=<span class="number">0x3fffffffffffffff</span>;</span><br><span class="line"><span class="comment">/*----------Consts----------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; pll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DEFINITION</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> scanfll(a) scanf(<span class="string">&quot;%lld&quot;</span>,&amp;a)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ALL(A) (A).begin(),(A).end()</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SORT(A) sort(ALL(A))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SORT_REV(A) sort((A).rbegin(),(A).rend())</span></span><br><span class="line">    <span class="comment">//SORT BEFORE UNIQUE!!</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UNIQUE(A) A.erase(unique(ALL(A)),(A).end())</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> Presentation(i,r) <span class="string">&quot; \n&quot;</span>[i==r]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FORLL(i,l,r) for(ll i=(l);i&lt;=(r);i++)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FORLL_rev(i,r,l) for(ll i=(r);i&gt;=(l);i--)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NO cout &lt;&lt; <span class="string">&quot;No\n&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> YES cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span></span></span><br><span class="line">    <span class="comment">// #define x first</span></span><br><span class="line">    <span class="comment">// #define y second</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span> <span class="comment">//交互题不启用！</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CCLIB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> create_vec(v,n) vector<span class="string">&lt;ll&gt;</span> v(n);for(auto &amp;x:v) cin &gt;&gt; x;</span></span><br><span class="line">    ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> pair&lt;ll,ll&gt; &amp;p) &#123;out &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;)&#x27;</span>;<span class="keyword">return</span> out;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩欧返回d=gcd(a,b);x,y对应ax+by=d的解;通解为x=x0+k*b/d,y=y0-k*a/d;</span></span><br><span class="line">    <span class="function">ll <span class="title">Exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;<span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="keyword">if</span>(b==<span class="number">0</span>) &#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125; ll d=<span class="built_in">Exgcd</span>(b,a%b,y,x); y-=a/b*x; <span class="keyword">return</span> d;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">chmax</span><span class="params">(T1 &amp;a,T2 b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b) a=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">chmin</span><span class="params">(T1 &amp;a,T2 b)</span></span>&#123;<span class="keyword">if</span>(a&gt;b) a=b;&#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//iterable</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_vec</span><span class="params">(<span class="type">const</span> T &amp;A)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:A) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;cout &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_float</span><span class="params">(ld value,<span class="type">int</span> digit=<span class="number">10</span>)</span></span>&#123;cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(digit) &lt;&lt; value;&#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;ll&gt; snums;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Get_Nums</span><span class="params">(string s)</span> </span>&#123; snums.<span class="built_in">clear</span>(); ll i=<span class="number">0</span>,cur=<span class="number">0</span>,sgn=<span class="number">1</span>,fl=<span class="number">0</span>; <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>()) &#123; <span class="keyword">if</span>(s[i]==<span class="string">&#x27;-&#x27;</span>) sgn=<span class="number">-1</span>; <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>) &#123; cur=cur*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;fl=<span class="number">1</span>; &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fl) &#123; snums.<span class="built_in">push_back</span>(cur*sgn); cur=<span class="number">0</span>; sgn=<span class="number">1</span>; fl=<span class="number">0</span>; &#125; i++; &#125; <span class="keyword">if</span>(fl) snums.<span class="built_in">push_back</span>(cur*sgn); &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MODULE</span><br><span class="line">&#123;</span><br><span class="line">    ll MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">Get_Mod</span><span class="params">(ll val,ll mod=MOD)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;<span class="number">0</span>) <span class="keyword">return</span> val-val/mod*mod+mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> val-val/mod*mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">qcpow</span><span class="params">(ll a,ll b,ll p=MOD)</span></span>&#123;ll ret=<span class="number">1</span>;a=<span class="built_in">Get_Mod</span>(a);<span class="keyword">for</span> (;b;b&gt;&gt;=<span class="number">1</span>,a=a*a%p) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret=ret*a%p;<span class="keyword">return</span> ret;&#125;</span><br><span class="line">    <span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p=MOD)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">qcpow</span>(a,p<span class="number">-2</span>,p);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Get_Mod</span>(a+b);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">sub</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Get_Mod</span>(a-b);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Get_Mod</span>(a*b);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">frac</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Get_Mod</span>(a*<span class="built_in">inv</span>(b));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addto</span><span class="params">(ll &amp;a,ll b)</span></span>&#123;a=<span class="built_in">Get_Mod</span>(a+b);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subto</span><span class="params">(ll &amp;a,ll b)</span></span>&#123;a=<span class="built_in">Get_Mod</span>(a-b);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">multo</span><span class="params">(ll &amp;a,ll b)</span></span>&#123;a=<span class="built_in">Get_Mod</span>(a*b);&#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;ll&gt; Fac;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Prepare_Factorial</span><span class="params">(ll n)</span></span>&#123;Fac.<span class="built_in">resize</span>(n+<span class="number">1</span>);Fac[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) Fac[i]=<span class="built_in">mul</span>(Fac[i<span class="number">-1</span>],i);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;<span class="keyword">return</span> n&lt;m?<span class="number">0</span>:<span class="built_in">mul</span>(Fac[n],<span class="built_in">inv</span>(<span class="built_in">mul</span>(Fac[m],Fac[n-m])));&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DEFINITION;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> CCLIB;</span><br><span class="line"><span class="comment">// using namespace MODULE;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_IO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUTIPLE_JUDGE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"><span class="type">const</span> ll N = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Prepare_Factorial(5005);</span></span><br><span class="line">    MODULE::MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------Code Area----------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="type">clock_t</span> clk = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;1.in&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;1.out&quot;</span>)</span></span>;</span><br><span class="line">    streambuf *cinbackup;</span><br><span class="line">    cinbackup = cin.<span class="built_in">rdbuf</span>(ifs.<span class="built_in">rdbuf</span>());</span><br><span class="line">    streambuf *coutbackup;</span><br><span class="line">    coutbackup = cout.<span class="built_in">rdbuf</span>(ofs.<span class="built_in">rdbuf</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FAST_IO</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MUTIPLE_JUDGE</span></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">prepare</span>();</span><br><span class="line"><span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    cin.<span class="built_in">rdbuf</span>(cinbackup);</span><br><span class="line">    cout.<span class="built_in">rdbuf</span>(coutbackup);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">clock</span>() - clk &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/markdown_grammar.html"/>
      <url>/posts/markdown_grammar.html</url>
      
        <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
